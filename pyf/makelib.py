import re, os, subprocess
import sys, keyword, builtins
from time import ctime
OUTPUT_FILE="../perllib/__init__.py"

def main():
    """makelib: Used to generate the perllib for the pythonizer
       Takes all of the modules which are in individual source files and
       bundles them together into one file, stripping off the leading "_" in
       the definitions in also in internal calls.
    """

    # get some manifest constants to put at the start of the file
    author=''
    email=''
    with open('../AUTHORS.rst', 'r') as a:
        for line in a:
            if(m:=re.match(r'^\* (.*) <([^>]+)>', line)):
                author = m.group(1)
                email = m.group(2)
                break

    version=''
    with open('../pythonizer', 'r') as p:
        for line in p:
            if(m:=re.match(r"\s*\$VERSION\s*=\s*'(\d+[.]\d+)';", line)):
                version = m.group(1)
                break

    global_defs = eval(subprocess.run("""perl get_globals.pl""", capture_output=True,text=True,check=True, shell=True).stdout)
    files = [file for file in os.listdir() if file.endswith('.py') and file != "makelib.py" and not file.startswith('__')]
    under_functions_list = [file.replace('.py', '') for file in files if file.startswith('_')]
    under_functions_regex = re.compile(r'\b(?:' + '|'.join(under_functions_list) + r')[(,]')

    def under_repl(m):
        """Remove underscores from function names in calls"""
        func = m.group(0)
        result = func[1:-1]
        if keyword.iskeyword(result) or hasattr(builtins, result):
            result += '_'
        return result + func[-1]

    with open(OUTPUT_FILE, 'w') as of:
        print(f'# perllib module for pythonizer, generated by {sys.argv[0]} on {ctime()}', file=of)
        print('#', file=of);
        print("# WARNING: Do not edit this file - to change the functions or add new ones, edit them in the pyf directory,", file=of)
        print("#          then re-run makelib.py", file=of)
        print('#', file=of);
        print(f'__author__ = """{author}"""', file=of)
        print(f"___email__ = '{email}'", file=of)
        print(f"__version__ = '{version}'", file=of)
        print(file=of)
        print('import sys,os,re,fileinput,subprocess,collections.abc,warnings,inspect,itertools,signal,traceback,io,tempfile,calendar,types,random,dataclasses,builtins,codecs,struct,pprint,functools', file=of)
        print('import time as tm_py', file=of)
        print('import stat as st_py', file=of)
        print('_str = lambda s: "" if s is None else str(s)', file=of)
        print('try:', file=of)
        print('    import fcntl as fc_py', file=of)
        print('except Exception:', file=of)
        print('    pass', file=of)
        Die = """
class Die(Exception):
    def __init__(self, *args,suppress_traceback=None):
        super().__init__(*args)
        if TRACEBACK and not suppress_traceback:
            cluck()
"""
        print(Die, file=of)
        for definition, value in global_defs.items():
            if re.match(r'^_[a-z]', definition):    # Remove anything lowercase like _locals_stack
                continue
            value = value.replace("\n", r'\n')
            print(f"{definition} = {value}", file=of)
        print(file=of)

        # Put init_package first so we can call it from other functions at the main level
        files = ["_init_package.py"] + files
        seen = set()

        for file in files:
            if file in seen:
                continue
            seen.add(file)
            under_func = file.replace('.py','')
            func = under_func[1:]
            if keyword.iskeyword(func) or hasattr(builtins, func):     # e.g. import has to remain _import
                func += '_'
            with open(file, 'r') as fh:
                for line in fh:
                    line = re.sub(r'\bstat[.]', r'st_py.', line)        # we have a 'stat' function, so we have to rename the stat class
                    line = re.sub(r'\bfcntl[.]', r'fc_py.', line)        # we have a 'fcntl' function, so we have to rename the fcntl class
                    if under_func.startswith('_') and re.match(r'def _', line):
                        line = line.replace(f'def {under_func}', f'def {func}')
                    line = re.sub(under_functions_regex, under_repl, line)
                    print(line, file=of, end='')

if __name__ == '__main__':
    main()

