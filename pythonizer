#!/usr/bin/perl
## pythonizer -- Translator of the subset of Perl 5 to Python 3.x 
## Copyright Nikolai Bezroukov, 2019-2021.
## Licensed under Perl Artistic license
##
## As most Perl statement are simple over 80% of them usually allow sucessful translation.  That's why we use the term "fuzzy" translation.
## The result will contain some statements that need to be converted by hand or corrected. In some cases that requres change of logic.
## Best works for Perl 4 subset of Perl 5 which typically is used in sysadmin scripts.
## Perl scripts that extensivly use references or OO requre more extensive manual effort
##
## --- INVOCATION:
##
##   pythonizer [options] [file_to_process]
##
##--- OPTIONS:
##    -p -- version of Python for generation, Default 3, if set to 2 generation is into Python 2.7
##    -v -- verbosity 0 -minimal (only serious messages) 3 max verbosity (warning, errors and serious); default -v 3
##    -h -- this help
##    -t -- size of tab ingenerated Python code (emulated with spaces). Default is 4
##    -d    level of debugging  default is 0 -- production mode
##          0 -- Production mode
##          1 -- Testing mode. Program is autosaved in Archive (primitive versioning mechanism)
##          2 -- Stop at the beginning of statement analysys (the statement can be selected via breakpoint option -b )
##          3 -- More debugging output.
##          4 -- Stop at lexical scanner with $DB::single = 1;
##          5 -- output stages of Python line generation
##--- PARAMETERS:
##
##    1st -- name of  file (only one argument accepted)

#--- Development History
#
# Ver      Date        Who        Modification
# =====  ==========  ========  ==============================================================
# 0.010  2019/10/09  BEZROUN   Initial implementation
# 0.020  2019/10/10  BEZROUN   Revised structure of global arrays, Now we have four parallel arrays: TokenStr, ValClass ValPerl, ValPy
# 0.030  2019/10/11  BEZROUN   Recursion is used to expressions, but in certain cases when I need a look-ahead, bracket counting is used instead
# 0.040  2019/10/12  BEZROUN   Better listing for debugging implemented
# 0.050  2019/11/06  BEZROUN   Forgot almost everything after a month; revised code just to refreash memory. Tokenizer slightly improved
# 0.051  2019/11/07  BEZROUN   Assignment within logical expression is not allowed in Python 2.7. It is now translated correctly
# 0.060  2019/11/08  BEZROUN   post assignment conditions like "next if( substr($line,0,1) eq '') " are processed correctly
# 0.070  2019/11/11  BEZROUN   x=(v>0) ? y :z is now translated into ugly Python ternary operator which exists since Python 2.5
# 0.071  2019/11/11  BEZROUN   program now correctly translated 80% codelines of pre_pythonizer.pl
# 0.080  2019/12/27  BEZROUN   Array ValCom is introduced for the preparation of version 0.2 of pre-processor pre_pythonizer.pl
# 0.090  2020/02/03  BEZROUN   #\ means continuation of the statement.
# 0.091  2020/02/03  BEZROUN   Moved sub preprocess_line to Pythonizer
# 0.100  2020/03/16  BEZROUN   Reworked scanner
# 0.200  2020/08/05  BEZROUN   Abandoned hope to make it perfect.
# 0.210  2020/08/07  BEZROUN   Moved gen_output to Perlscan,  removed ValCom  from the exported list.
# 0.220  2020/08/07  BEZROUN   Diamond operator is processed as a special type of identifier.
# 0.230  2020/08/09  BEZROUN   gen_chunk moves to Perlscan module. Pythoncode array made local
# 0.230  2020/08/09  BEZROUN   more functions and statements implemented
# 0.240  2020/08/10  BEZROUN   postfix conditional like return if(rc>0) re-implemented differently via scanner buffer
# 0.250  2020/08/10  BEZROUN   split function is reimplemented and optimized in case there is plain vanilla string and not-regex.
# 0.251  2020/08/12  BEZROUN   Perl_default_var is renames into default_var
# 0.260  2020/08/14  BEZROUN   System variables in double quoted literals are now complied correctly. Perlscan.pm improved.
# 0.261  2020/08/14  BEZROUN   for loop translation corrected
# 0.270  2020/08/15  BEZROUN   getopts is now implemented in Softpano.pm to allow the repetition of option letter to set the value of options ( -ddd)
# 0.300  2020/08/17  BEZROUN   Python 3.8 now is default for generaion. Option -p introduced. -p 2 changes target version of Python to 2.7
# 0.310  2020/08/18  BEZROUN   f-strings are implemented for Python 3 mode instead of decompiling string into chunks
# 0.320  2020/08/20  BEZROUN   open statement and  (condition) && ... statement translation corrected
# 0.400  2020/08/22  BEZROUN   __DATA__ and POD statements are now processed. File filename.data is created for data file.
# 0.410  2020/08/24  BEZROUN   pre_pythonizer now refactors Perl script pushing subroutines to the top and creating main sub.
# 0.420  2020/08/25  BEZROUN   print recognized in constructs like if($debug){ print 'something';}.
# 0.430  2020/08/25  BEZROUN   Variables from other namespaces recognized.
# 0.440  2020/08/26  BEZROUN   FailedTrans flag is replaced with TrStatus flag. Failure now is determined by the negative value of the TrStatus flag.
# 0.450  2020/08/26  BEZROUN   Option - r (refactor) added
# 0.500  2020/08/31  BEZROUN   Regular expression processing competly reworked based on changed in  Perlscan
# 0.510  2020/08/31  BEZROUN   Special subroutine for putting regex in quote created in Perlscan.pm
# 0.520  2020/08/31  BEZROUN   Statement  $line=~/abc/ this is not assignment statement; In no metacharaters it should  be treated as string search.
# 0.530  2020/08/31  BEZROUN   Handling of __DATA and __END__ improved. Now they are not discarded but instead the separate file with extention.data is created.
# 0.540  2020/09/01  BEZROUN   Translation of function substr improved by recognizing several special cases.
# 0.550  2020/09/01  BEZROUN   Matching of groups corrected.
# 0.560  2020/09/02  BEZROUN   Translation of for and while improved.
# 0.570  2020/09/03  BEZROUN   Translation of ++ and --  implemented
# 0.580  2020/09/03  BEZROUN   Translation of function sprintf implemented
# 0.600  2020/09/08  BEZROUN   List on internal functions created. Translation of backquotes and open improved.
# 0.700  2020/09/17  BEZROUN   Basic global varibles detection added. Global statement generated for each local subroutine
# 0.800  2020/10/02  BEZROUN   More correct translation of array assignments. Globals initialiazed after main sub. Installer added
# 0.810  2020/10/05  BEZROUN   Pre-pythonizer by default does not create main subroutine
# 0.820  2020/10/06  BEZROUN   Function parsing rewritten to accomodate some "bracketless" cases which now became a norm in Perl
# 0.830  2020/10/08  BEZROUN   Implementation of postfix conditional is completly rewritten and now uses token buffering
# 0.840  2020/10/09  BEZROUN   state varibles now are prefixed with the name of sub to avoid conflict with globals
# 0.850  2020/10/12  BEZROUN   print translation improved; many fixes in lex analyser
# 0.860  2020/10/14  BEZROUN   Python 2.7 mode eliminated to simplify the code. Option -p removed. "since" test passed
# 0.870  2020/10/21  BEZROUN   Treatment of brackets systematised. The code of subroutine expression revised.
# 0.871  2021/05/10  BEZROUN   Minor corrections in the header. 
# 0.900	 2021/11/06  SNOOPYJC  Updates to handle many more cases.
# 0.901	 2021/11/08  SNOOPYJC  Fix issue 22 and issue with pyf folder
# 0.902	 2021/11/09  SNOOPYJC  Fix issues 13,23,24,25,26 and mismatched parens
# 0.903  2021/11/10  SNOOPYJC  Physically remove ( ) on control statements rather than just skipping the first and removing the second
# 0.904  2021/11/10  SNOOPYJC  Fix issues in for/foreach, including adding range support and proper loop termination if ">=" or "<=" is used. Generate proper code for split on space.
# 0.905  2021/11/11  SNOOPYJC  Fix issues 28, 29, 31
# 0.906  2021/11/14  SNOOPYJC  Fix issue 14, more fixes for issue 9, 13 and 28, issue 35, 36, 37, 38, and most of issue 39 (except interpolation in HereIs)
# 0.907  2021/11/15  SNOOPYJC  Fix issues 43, 44, more issue 37 (my $x=@a)
# 0.908  2021/11/15  SNOOPYJC  Fix issue 48
# 0.909  2021/11/16  SNOOPYJC  Handle more cases of issue 48, issue 49, additional fix for issue 44, issue 54, issue 52 (in assignment only), issue 50, issue 53, issue 45, issue 55, issue 56, issue 57, issue 58, issue 46, issue 59, issue 61, issue 62, issue 61, issue 62, issue 41, issue 45
# 0.910  2021/11/22  SNOOPYJC  Fix issue 63, issue with post-pass refactoring of multi-line strings, issue 64, addl fixes for issue 36 and issue 39, another issue 13 fix (array assignment of function call)
# 0.911  2021/11/23  SNOOPYJC  Another issue 49 fix ($ARGV), another issue 43 fix (${var} not in ...), issue 68, issue 65, issue 69, more issue 32 fixes, some pep8 enhancements to spacing, implement 'abs(...)', issue 74, issue 66, issue 75, issue 76, issue 42, issue 52, another issue 45 fix, isue 42, issue 73, issue 71
# 0.912  2021/11/29  SNOOPYJC  Fix coding error in perl_open (encoding)
# 0.913  2021/11/30  SNOOPYJC  issue 79, addl fix for issue 53, addl fix for foreach, addl fix for ++/--, add constants for open and flock
# 0.914  2021/12/01  SNOOPYJC  Fix missing _time, add _flock, fix references to $!, issue 81
# 0.915  2021/12/02  SNOOPYJC  Additional issue 81 fixes, add -A for autodie and -T for traceback, fix issue with globals on sub's with ()
# 0.916  2021/12/03  SNOOPYJC  issue 60: implement grep and map
# 0.917  2021/12/04  SNOOPYJC  Addl fix for issue 60 - map with user functions, fix ref, generate proper code for $#ARGV, generate no code for labels and warn on label refs, fix .. range if preceded by a digit, use _open for all open calls, implement binmode, fix extra paren on split, add type computation and init variables appropriately, fix state vars, change undef to use type appropriate assignment, issue 82
# 0.918  2021/12/06  SNOOPYJC  addl issue 39 fix, compute types of user subs, add sqrt, fix _flock typo, more type analysis, issue 85, fix undef, fix | open, issue 86, fix get_globals
# 0.919  2021/12/08  SNOOPYJC  Set nest to 0 after pass 1, allow ' in varnames (old perl syntax for ::), fix infinite recursion in expr_type, fix := in assignment in expression by fixing next_same_level_token(s) for parens, issue 88, extra issue 50 fix for $$xxx, addl fix for issue 45 with function call as last statement
# 0.920  2021/12/09  SNOOPYJC  issue 89, issue 90, addl fix for $t-timegm issue 88, add timegm(), issue 91
# 0.921  2021/12/10  SNOOPYJC  Fix if not(open(FH,...)), add rename, fork, implement range (..) operator in slice, issue 84, fix open/opendir in control stmt
# 0.922  2021/12/10  SNOOPYJC  issue 93, fix foreach (%hash), @arr = keys %hash, @arr = values %hash, @arr = %hash, ignore var defs alone, handle modelsss constant open, handle sed/awk style range, implement each
# 0.923  2021/12/12  SNOOPYJC  Add wait() using _wait(), fileparse() using _fileparse(), fix open/opendir with filename expression, issue 94
# 0.924  2021/12/13  SNOOPYJC  issue 95, implement do{...}while/until(...);, PERL5PATH is now automatic, addl fix for issue 93, issue 96, remove double ++/-- fix, remove warning on 1;, issue 99
# 0.925  2021/12/14  SNOOPYJC  Addl fixes for issue 21 (split), issue 45 (was putting orig lines in wrong place), issue 58 on elsif, fix opendir not found error, issue 98, issue 100, remove extra 'r' after regex, issue 101
#!start ===============================================================================================================================

   use v5.10.1;
   use warnings;
   use strict 'subs';
   use feature 'state';
   use Carp 'verbose';	# SNOOPYJC
   use File::Basename;	# SNOOPYJC
   $SIG{ __DIE__ } = sub { Carp::confess( @_ ) };	# SNOOPYJC
   $SIG{ INT } = sub { Carp::confess( @_ ) };		# SNOOPYJC
   # $SIG{ __WARN__ } = sub { Carp::confess( @_ ) };	# SNOOPYJC
   $| = 1;                                              # SNOOPYJC - unbuffer STDOUT

BEGIN {                                                 # SNOOPYJC
    if(!exists $ENV{PERL5PATH}) {
        $ENV{PERL5PATH} = dirname(__FILE__);
        unshift @INC, dirname(__FILE__);
    }
}
   use config;				# issue 32
#
# Modules used ( from the current directory to make debugging more convenient; will change later)
#
   use Softpano qw(autocommit abend banner logme summary out);

   use Perlscan ('gen_statement', 'tokenize', 'gen_chunk', 'append', 'replace',
                 'insert', 'destroy', 'autoincrement_fix', '@ValClass', '@ValPerl', '@ValPy', '@ValCom',
                 'escape_keywords',                     # issue 41
                 '%SPECIAL_FUNCTION_MAPPINGS',          # issue 65
                 'save_code', 'restore_code',           # issue 74
                 '@ValType', '$TokenStr');

   use Pythonizer qw(correct_nest getline prolog output_line %LocalSub %GlobalVar %VarType %InitVar init_val); # SNOOPYJC

   $VERSION='0.925';
   $SCRIPT_NAME='pythonizer';
#
# options
#
   $breakpoint=9999; # line from which to debug code. See Pythonizer user guide
   $debug=0;  # 0 -- production mode
              # 1 -- testing mode
              # 2 -- first pass debugging
              # 3 -- provides tracing during the second pass (useful for users for trableshooing infinite loops)
              # 4 -- stop at Perlscan.pm
              # 5 -- stop at particular error message.
   $traceback=0;                        # SNOOPYJC -T option
   $autodie=0;                          # SNOOPYJC -A option
   $HOME=$ENV{'HOME'}; # the directory used for autobackup (only if debug>0)
   if( $^O eq 'cygwin' ){
      # $^O is built-in Perl Variable that contains OS name
      $HOME="/cygdrive/f/_Scripts";  # CygWin development mode -- the directory used for backups
   }
   #
   # Local dictionaries
   #
   # SNOOPYJC %PyOpen=('<'=>'r', '>'=>'w', '>>'=>'a', '+<'=>'+');
   %PyOpen=('<'=>'r', '>'=>'w', '>>'=>'a', '+<'=>'r+', '+>'=>'w+', '+>>'=>'a+', '->'=>'->', '<-'=>'<-', '-|'=>'-|', '|-'=>'|-', '|'=>'|-', ''=>'r');   # SNOOPYJC

   $LOG_DIR='/tmp/'.ucfirst($SCRIPT_NAME);
   # issue 64    banner($LOG_DIR,$SCRIPT_NAME,"Fuzzy translator of Python to Perl. Version $VERSION",30); # Opens SYSLOG and print STDERRs banner; parameter 4 is log retention period
   # issue 55 prolog(); # sets all options, including breakpoint
   prolog(dirname(__FILE__), $LOG_DIR,$SCRIPT_NAME,"Fuzzy translator of Python to Perl. Version $VERSION",30); # issue 55, issue 64  # sets all options, including breakpoint

   correct_nest(0, 0);                  # SNOOPYJC

   if( $debug > 0 ){
      autocommit("$HOME/Archive",$ENV{'PERL5LIB'},qw(Softpano.pm Perlscan.pm Pythonizer.pm));
   }

   %Pyf=();			# SNOOPYJC: Keeps track of which extra functions we need to include at the end
   $Pyf_dir = dirname(__FILE__)."/pyf";		# SNOOPYJC: Where we keep the extra python functions
   %Constants=();               # issue 13: Keeps track of constants declared in "use constant" and also file handles
   @Constants{keys %CONSTANT_MAP} = values %CONSTANT_MAP;       # SNOOPYJC

#
# Skip initial block of comments
#
   $TrStatus=0;
   chomp($line=<>); # we need to discard the first line with /usr/bin/perl as interpreter
   output_line('','#!/usr/bin/python3 -u'); # put a proper line

   my $user = $ENV{LOGNAME} || $ENV{USERNAME} || $ENV{USER};                            # SNOOPYJC
   $rb_user = " run by $user" if($user);                                                # SNOOPYJC
   my $comment = "# Generated by pythonizer $VERSION$rb_user on ".localtime();         # SNOOPYJC
   output_line('', $comment);                                                           # SNOOPYJC

   if ($line =~ /^\s*#!/){
      $line=getline(); # skip previous interpreter definition and get the first meaningful line + initial block of comments, if present
   }else{
      getline($line); # put the first line in the readline buffer
      $line=getline(); # rescan it to have full proper processing
   }
   # issue flock foreach $l ('import sys,os,re','import fileinput,subprocess,inspect'){
   $Die = "class Die(Exception):
    pass";
   $Die = "class Die(Exception):
    def __init(self, arg):
        traceback.print_stack()" if($traceback);
   # NOTE: This import line gets rewritten in Pythonizer.pm!
   my @headers = ('import sys,os,re,fcntl,math,fileinput,subprocess,inspect,collections.abc,argparse,glob,warnings,inspect,functools,signal,traceback,io,tempfile,atexit,calendar',
	   'import time as tm_py');             # SNOOPYJC
   foreach my $g (keys %GLOBALS) {              # SNOOPYJC
       if($g eq 'TRACEBACK' && $traceback) {
           push @headers, "$g = 1";
       } elsif($g eq 'AUTODIE' && $autodie) {
           push @headers, "$g = 1";
       } else {
           push @headers, "$g = $GLOBALS{$g}";
       }
   }
   my @more_headers = ("$Die", "class $EVAL_RETURN_EXCEPTION(Exception):\n    pass");   # SNOOPYJC
   for my $label (keys %Perlscan::all_labels) {                 # issue 94
       my $ex_name = label_exception_name($label);
       push @more_headers, "class $ex_name(Exception):\n    pass";
   }
   push @headers, @more_headers;                # SNOOPYJC
   #
   # SNOOPYJC: Define any variables that just appear out of nowhere in perl, like $option{key} = 1 creates %options
   #
   if(exists $InitVar{main}) {
       push @headers, $InitVar{main};
   }
   my $last_header = "$PERL_ARG_ARRAY = sys.argv[1:]";      # SNOOPYJC - must be last!!
   push @headers, $last_header;         # SNOOPYJC: Post-processor in Pythonizer.pm relies on this one being last
   foreach $l (@headers) {              # SNOOPYJC
       output_line('',$l); # to block reproducing the first source line
   }





   #while($l=<DATA>){
   #   chomp $l;
   #   output_line($l,'',''); # to block reproducing the first source line; added Sept 3, 2020 just for the future
   #}
   #close DATA;
#
#Main loop
#
   @Perlscan::BufferValClass=@Perlscan::BufferValCom=@Perlscan::BufferValPerl=@Perlscan::BufferValPy=(); # cleaning after the first pass
   @Perlscan::BufferValType=();
my ($start,$token_buffer_active);
   $CurSub='main';
   $token_buffer_active=0;
   $we_are_in_sub_body=0;
   $context_manager_nest = -2;          # issue 66
   @eval_stack = ();                    # issue 42
   $LastLabel = '';                     # SNOOPYJC
   $deferred_statement=0;               # issue 58
   $deferred_statement_nesting=0;       # issue 58
   @DeferredValClass=@DeferredValCom=@DeferredValPerl=@DeferredValPy=@DeferredValType=();        # issue 58
   &Perlscan::initialize();             # issue 94

   while( defined($line) || scalar(@Perlscan::BufferValClass)>0 ){
      $TrStatus=0;
      # issue 68 if( scalar(@ValClass)==0 || ! defined($ValClass[0]) ){
      # issue 68 $line=getline(); # skip lines with no tokens like ';'
      # issue 68 next;
      # issue 68 }

      # issue 13: Attempt to replace bare words in hash definitions and references
      # issue 13 $line =~ s/\{([A-Za-z_][A-Za-z0-9_]*)\}/\{\'$1\'\}/g;	# issue 13
      # We do this a better way now: $line =~ s/(?<!\$)\{([A-Za-z_][A-Za-z0-9_]*)\}/\{\'$1\'\}/g;	# issue 13
      if($debug >= 5) {
        say "Main loop, line=$line, BufferValClass=@Perlscan::BufferValClass, deferred_statement=$deferred_statement";
      }

#
# You need to claw back tokens from buffer for postfix conditionals. This is a pretty brittle and complex code -- Oct 8,2020 NNB
#
      if ( scalar(@Perlscan::BufferValClass)==0 && $deferred_statement < 2) {       # issue 58
         if( $debug>1 ){
            say STDERR "\n\n === Line $. Perl source:".(defined($line)?$line:$ValPerl[0])."===\n";
            if( $.>=$breakpoint ){
                logme('S', "Breakpoint was triggered at line $. in pythonizer.pl");
                # $breakpoint=999999;
                $DB::single = 1;
            }
         }
         tokenize($line);   # I just like to see tokenize call first in debugger  :-)
         if($debug >= 5) {
            say STDERR "deferred_statement_nesting=$deferred_statement_nesting, nesting_level=$Perlscan::nesting_level, TokenStr=$TokenStr, nesting_last->{type}=$Perlscan::nesting_last->{type}" if($deferred_statement == 1);
         }

         if($deferred_statement == 1 && $Perlscan::nesting_level < $deferred_statement_nesting) {       # issue 58
            if($Perlscan::nesting_last->{type} eq 'else') {
                $deferred_statement=0;          # We're all set
            } elsif($TokenStr ne '}' && substr($TokenStr,0,1) ne 'C') {
                gen_statement('else:');         # Insert an 'else:' clause so we have a place to generate the assignment
                correct_nest(1,1);
                my @tmp=@ValClass; @ValClass=@DeferredValClass; @DeferredValClass=@tmp;
                @tmp=@ValCom; @ValCom=@DeferredValCom; @DeferredValCom=@tmp;
                @tmp=@ValPerl; @ValPerl=@DeferredValPerl; @DeferredValPerl=@tmp;
                @tmp=@ValPy; @ValPy=@DeferredValPy; @DeferredValPy=@tmp;
                @tmp=@ValType; @ValType=@DeferredValType; @DeferredValType=@tmp;
                $TokenStr=join('',@ValClass);
                $deferred_statement=3;
            }
        }
      }else{
         if($deferred_statement >= 2) {         # issue 58
            @ValClass=@DeferredValClass;
            $TokenStr=join('',@ValClass);
            @ValCom=@DeferredValCom;
            @ValPerl=@DeferredValPerl;
            @ValPy=@DeferredValPy;
            @ValType=@DeferredValType;
            #@DeferredValClass=@DeferredValCom=@DeferredValPerl=@DeferredValPy=@DeferredValType=();   # issue 58
            if($deferred_statement == 3) {
                correct_nest(-1,-1);            # We inserted an "else:" above
                $deferred_statement = 0;
            } else {
                $deferred_statement = 1;
            }
         } elsif($token_buffer_active==0){
            @ValClass=@ValPerl=('{');
            @ValPy=('if');                      # issue 94
            &Perlscan::enter_block();           # issue 94
            $token_buffer_active=1;
         }elsif($token_buffer_active==1){
            @ValClass=@Perlscan::BufferValClass;
            $TokenStr=join('',@ValClass);
            @ValCom=@Perlscan::BufferValCom;
            @ValPerl=@Perlscan::BufferValPerl;
            @ValPy=@Perlscan::BufferValPy;
            @ValType=@Perlscan::BufferValType;
            $token_buffer_active=2;
         }else{
            @ValClass=@ValPerl=('}');
            &Perlscan::exit_block();           # issue 94
            @Perlscan::BufferValClass=@Perlscan::BufferValCom=@Perlscan::BufferValPerl=@Perlscan::BufferValPy=();
            @Perlscan::BufferValType=();
            $token_buffer_active=0;
         }
      }

      if( scalar(@ValClass)==0 || ! defined($ValClass[0]) ){            # issue 68
          gen_statement('pass');                                        # issue 68
          $line=getline(); # skip lines with no tokens like ';'         # issue 68
          next;                                                         # issue 68
      }                                                                 # issue 68

      #
      # Dealing with problem of state varaible mapping into Python via renaming
      #
      rename_state_var(0,$#ValPy);
      if( index($TokenStr,'s^')>-1){
         # Selected cases of postfix and prefix operator can be translated; other not
         autoincrement_fix() # exported function located in Perlscan
      }

      fix_scalar_context();                             # issue 37
      fix_string_catenation();                          # issue 36
      fix_multi_subscripts();                           # issue 84
      remove_array_or_hash_references();                # issue 50
      fix_expression_issues();                          # SNOOPYJC, issue 74, issue 52

      #
      # Statements
      #
      $RecursionLevel=0;
      # issue 13: Treat my @arr and my %hash as if there was no "my" so the proper code is generated
      if( $ValClass[0] eq 't' && $ValPerl[0] eq 'my' && $ValClass[1] =~ /[ah]/ && scalar(@ValClass) > 2) {	# issue 13
          destroy(0, 1);	# issue 13: remove the "my"
      }				# issue 13
      if( $ValClass[0] eq '^' ) {	# issue 29
         # ++ expr; statement: change to expr++;
	 my $vpl = $ValPerl[0]; my $vpy = $ValPy[0];
	 destroy(0, 1);			# issue 29
	 append('^', $vpl, $vpy);	# issue 29
      }					# issue 29

      if ($ValClass[0] eq 'W' ) {       # issue 66: Context manager
          $context_manager_nest = $Pythonizer::CurNest; # issue 66
          if($debug >= 3) {
              say STDERR "Setting context_manager_nest = $context_manager_nest";
          }
          gen_statement($ValPy[0]);     # issue 66
          correct_nest(1);              # issue 66
          correct_nest();               # issue 66
          destroy(0, 1);                # issue 66
      }
      
      if( $ValClass[0] eq '}' ){
         # we treat curvy bracket as a separate dummy statement
         if($debug >= 5 && $deferred_statement == 1) {
             say STDERR "deferred_statement_nesting=$deferred_statement_nesting, nesting_level=$Perlscan::nesting_level";
             say STDERR "nesting_last->{type}=$Perlscan::nesting_last->{type}";
         }
         if(!$Pythonizer::GeneratedCode) {      # issue 96
             gen_statement('pass');             # issue 96: python doesn't allow empty blocks
         }                                      # issue 96
         if(&Perlscan::loop_needs_try_block(1)) {
             my $ex_name = label_exception_name($Perlscan::nesting_last->{label});
             gen_statement();
             correct_nest(-1,-1);
             gen_statement("except $ex_name as _l:");
             correct_nest(1,1);
             gen_statement("if 'break' in str(_l):");
             correct_nest(1,1);
             gen_statement('break');
             correct_nest(-1,-1);
             gen_statement('continue');
             correct_nest(-1);
         }
         correct_nest(-1); # next line will be de-indented
         if( $we_are_in_sub_body  && $Pythonizer::NextNest ==0  ){
            correct_nest(0,0);
            initialize_globals_for_state_vars();
            %new_state_var_name=(); # hash for own and state variables
            %new_state_var_init=();
            $CurSub='main';
         }
      }elsif( $ValClass[0] eq '{' ){
         if(!$Perlscan::PREV_HAD_COLON) {                 # SNOOPYJC
             # The user opened a brace with nothing before it, so we have to generate some code for
             # the nesting to be correct
             gen_statement('for _ in range(1):');       # SNOOPYJC: Use a loop so you can last/next it
             #finish();
         }
         $Perlscan::PREV_HAD_COLON = 0;                 # issue 94: It's only good once!
         if(&Perlscan::loop_needs_try_block(0)) {                # issue 94
             gen_statement();
             correct_nest(1,1);
             gen_statement('try:');
         }
         $Pythonizer::GeneratedCode = 0;                # issue 96
         correct_nest(1); # next line will be indented
         if($deferred_statement == 1 && $deferred_statement_nesting == $Perlscan::nesting_level) {
            $deferred_statement = 2;  # issue 58
         }
      }elsif( $ValClass[0] eq '(' ){
         $close_br_pos=matching_br(0);
         # issue paren if( $close_br_pos && $ValClass[$close_br_pos+1] eq '=' ){
         if( $close_br_pos >= 0 && $close_br_pos < $#ValClass && $ValClass[$close_br_pos+1] eq '=' ){      # issue paren
            $TrStatus=assignment(0);
         } elsif (index(substr($TokenStr, 0, $close_br_pos), '=') >= 0) {       # issue paren:  assignment, like in ($i = 1) if(...);
            $TrStatus=assignment(1, $close_br_pos-1);                           # issue paren
         }else{
            $TrStatus=-255;
         }
      }elsif(  $ValPy[0] eq 'NoTrans!'  ){
         if($Pythonizer::CurNest) {                             # SNOOPYJC
             output_line('pass','    #SKIPPED: '.$line);        # issue 96
         } else {
             output_line('','#SKIPPED: '.$line);
         }
         $line=getline();
         next;
      }elsif( $ValPerl[0] eq 'sub' ){
         $we_are_in_sub_body=1;
         %new_state_var_name=(); # hash for own and state variables
         %new_state_var_init=();
         # Perl has two types of sub statements -- prototype and actual
         $CurSub=$ValPy[1];

         correct_nest(0,0);
         $escaped = escape_keywords($CurSub);   # issue 41
         if(substr($escaped, 0, 7) eq '__END__') {      # SNOOPYJC: END block
            gen_statement("atexit.register($escaped)"); # SNOOPYJC
            gen_chunk('def',$escaped,"():");            # SNOOPYJC - code shuffler at end will move the def above the ref above
         } else {
            # issue 41 gen_chunk('def',$CurSub,"($PERL_ARG_ARRAY):"); # def name ([list of arguments])        # isssue 32
            gen_chunk('def',$escaped,"($PERL_ARG_ARRAY):"); # def name ([list of arguments])        # issue 32, issue 41
            $LocalSub{$CurSub}=1;
         }
         if (exists($GlobalVar{$CurSub}) ){
            gen_statement();
            correct_nest(1,1);
            output_line($GlobalVar{$CurSub});
            correct_nest(0,0);
         }
         if (exists($InitVar{$CurSub}) ){             # SNOOPYJC: Variable initialization
            gen_statement();
            correct_nest(1,1);
            my @init = split /\n/, $InitVar{$CurSub};
            for $in (@init) {
                output_line($in);
            }
            correct_nest(0,0);
         }
      }elsif( $ValPerl[0] eq 'BEGIN' ){
         correct_nest(0,0);
         gen_chunk($ValPy[0],'    # BEGIN:'); # SNOOPYJC
      }elsif(  $ValPerl[0] eq 'close' ){
         for( my $i=1; $i<@ValPy; $i++ ){
             if( $ValClass[$i] eq 'i' || $ValClass[$i] eq 's' ){        # issue 10
	        # issue close gen_chunk($ValPy[$i].'.f.close;');
                gen_chunk($ValPy[$i].'.close()');	# issue close
             }
         }
      }elsif( $ValPerl[0] =~ /^(?:say|print|printf)$/ ){        # SNOOPYJC
          $TrStatus=print3(0);
      }elsif( $ValPerl[0] =~ /^warn$/ ){                        # SNOOPYJC
          $TrStatus=print3(0,'STDERR'); # in Python3 this is a function
      }elsif( $ValClass[0] eq 's' ){
          if( ($TokenStr=~tr/=//) > 1 && $ValClass[-1] eq 'd' && ($ValPerl[-2] eq '+=' || $ValPerl[-2] eq '-=') ){
             # multiple assignment with the last increment like $K=$i+=1 need to be expanded due to bug in Python parser
             $ValPy[-1]=$ValPy[-3].substr($ValPerl[-2],0,1).$ValPy[-1];
             $ValPy[-2]=$ValPerl[-2]='=';
          }
          if($CurSub eq 'main' || scalar(@ValClass) != 1) {  # issue 45: Ignore scalar alone on a line (may be the return value)
              $TrStatus=assignment(0);
          }                                     # issue 45
      }elsif( $ValClass[0] eq 't' ){
         if( scalar(@ValClass)==2 ){
            #uninitalise single var declaration like my $line
            if( $ValPerl[0] eq 'my' || $ValPerl[0] eq 'our'){
               if(exists $VarType{$ValPy[1]}{$CurSub}) {
                   output_line("$ValPy[1] = ".init_val($VarType{$ValPy[1]}{$CurSub}));
               } else {
                   output_line("$ValPy[1] = None");
               }
            }elsif( $ValPerl[0] eq  'own' ){
               gen_chunk( $ValPy[0], $ValPy[1] );
            }elsif( $ValPerl[0] eq 'state' ){
               $new_name=$CurSub.'_'.$ValPy[1];
               $new_state_var_name{$ValPy[1]}=$new_name;
               gen_chunk($ValPy[0],$new_name);
            }
            finish();
            next;
         }elsif( scalar(@ValClass)==4 && $ValClass[2] eq '='  ){
            if( $ValPerl[0] eq 'my' || $ValPerl[0] eq 'our' ){
	       if($ValClass[3] eq 'f') {	# Issue 8: shift generates bad code
		  gen_chunk("$ValPy[1] = ");	# Issue 8
                  function(3,3);		# Issue 8
               } elsif($ValClass[3] eq 'x') {   # issue 42
		   gen_chunk("$ValPy[1] = ");	# Issue 42
                   expression(3, 3, 0);         # issue 42
	       }elsif($ValClass[3] eq 'i' && $ValPy[3] eq $ValPerl[3]) {	# issue 13
		   gen_chunk("$ValPy[1] = ");					# issue 13
	           if( $LocalSub{$ValPy[3]} ){					# issue 13: local sub call with no parens
	              gen_chunk(escape_keywords($ValPy[3]));    		# issue 13, issue 41
	              gen_chunk('([])');					# issue 13
                    } elsif ($Constants{$ValPy[3]}) {                           # issue 13: constant or file handle
                        gen_chunk($ValPy[3]);   	        		# issue 13
	            } else {							# issue 13: bare word - treat as string
	              gen_chunk("'".$ValPy[3]."'");				# issue 13
	            }
	       } else {				# Issue 8
                  output_line("$ValPy[1]=$ValPy[-1]");
	       }
            }elsif( $ValPerl[0] eq  'own' ){
               gen_chunk( $ValPy[0], $ValPy[1].' = ',$ValPy[-1] );
            }elsif(  $ValPerl[0] eq 'state' ){
               $new_name=$CurSub.'_'.$ValPy[1];
               $new_state_var_name{$ValPy[1]}=$new_name;
               gen_chunk($ValPy[0],$new_name);
               $new_state_var_init{$ValPy[1]}=$ValPy[-1];
            }
            finish();
            next;
         }elsif($ValClass[1] eq '('){
            #this is a more complex case
            my $last=matching_br(1);
            if($#ValClass>$last && $ValClass[$last+1] eq '='){
               if($ValPerl[0] eq 'state' ){
                  rename_state_var(2,$last-1);
               }
               $TrStatus=assignment(1);
            }else{
               my $val = undef;                 # SNOOPYJC
               for($i=2; $i<$last;$i++){        # SNOOPYJC: Run thru them all and see if they all have the same value
                   my $sval = 'None';
                   if(exists $VarType{$ValPy[$i]}{$CurSub}) {
                       $sval = init_val($VarType{$ValPy[$i]}{$CurSub});
                   }
                   if(defined $val && $sval ne $val) {
                       $val = undef;
                       last;
                   }
                   $val = $sval;
               }
               if(defined $val) {               # SNOOPYJC: they are all the same
                   for($i=2; $i<$last;$i++){
                      if ($ValPy[$i] eq ','){
                         gen_chunk(' = ');
                      }elsif($ValPerl[0] eq 'state'){
                         $new_name=$CurSub.'_'.$ValPy[$i];
                         $new_state_var_name{$ValPy[$i]}=$new_name;
                         gen_chunk($new_name);
                      }else{
                          gen_chunk($ValPy[$i]);
                      }
                   }
                   gen_chunk(" = $val");
                } else {                        # We need to do it one by one
                   for($i=2; $i<$last;$i++){
                      next if ($ValPy[$i] eq ',');
                      my $val = 'None';
                      if(exists $VarType{$ValPy[$i]}{$CurSub}) {
                          $val = init_val($VarType{$ValPy[$i]}{$CurSub});
                      }
                      if($ValPerl[0] eq 'state'){
                         $new_name=$CurSub.'_'.$ValPy[$i];
                         $new_state_var_name{$ValPy[$i]}=$new_name;
                         gen_chunk($new_name);
                      }else{
                         gen_chunk($ValPy[$i]);
                      }
                      gen_chunk(" = $val");
                      gen_statement();
                   }
                }
            }
          }elsif( $ValClass[2] eq '=' ){
             $TrStatus=assignment(1);
          }elsif( $ValPerl[0] eq 'local') {
              ;         # SNOOPYJC: ignore things like "local *FH;"
          }else{
            $TrStatus=-255;
          }
       }elsif( $ValClass[0] eq 'h' ){
          # hash to has need method copy          #
          if( $#ValClass >= 2 && $ValClass[1] eq '=' ){
             if( $ValPerl[2] eq '(' ){
                  # Special case hash initialization needs to be converted to dictionary initialization
                  gen_chunk($ValPy[0].' = {');
		  # issue 13: Handle a list of key, value, key, value by converting it to key: value, key: value
                  #for( my $i=4; $i<$#ValPy; $i+=4 ) {				# issue 13
                  #$ValPy[$i] = ":" if $ValPy[$i] eq ",";			# issue 13
                  #}								# issue 13
                  my $comma_flip = 0;                   # issue 13
                  for( my $i=3; $i<$#ValPy; $i++ ){
                     if( $ValClass[$i] eq 'i' ) {                               # issue 13
	                if( $LocalSub{$ValPy[$i]} ){				# issue 13: local sub call with no parens
	                    gen_chunk(escape_keywords($ValPy[$i]));		# issue 13, issue 41
	                    gen_chunk('([])');					# issue 13
                        } elsif ($Constants{$ValPy[$i]}) {                      # issue 13: constant or file handle
                            gen_chunk($ValPy[$i]);     	        		# issue 13
                        } elsif( $ValPerl[$i] eq $ValPy[$i]) {	                # issue 13
		            $ValPy[$i] = "'".$ValPy[$i]."'";			# issue 13 - put in quotes
                            gen_chunk( $ValPy[$i] );                            # issue 13
                        }                                                       # issue 13
                     } elsif($ValPy[$i] eq ',' && $comma_flip == 0) {           # issue 97
                         gen_chunk(': ');                                       # issue 97
                         $comma_flip = 1;                                       # issue 97
		     } else {							# issue 13
                        gen_chunk( $ValPy[$i] );
                        $comma_flip = 1-$comma_flip if($ValPy[$i] eq ',' && $comma_flip != -1); # issue 97
                        $comma_flip = -1 if($ValPy[$i] =~ /^:\s?$/);                 # issue 97
                     }
                  }
                  gen_chunk('}');
                  finish();
                  next;
             # SNOOPYJC }elsif( scalar(@ValClass)==2 && ($ValPerl[2] eq 'h' || $ValPerl[2] eq 'q') ){
             }elsif( scalar(@ValClass)==2 && $ValClass[2] eq 'h') {     # SNOOPYJC
		  # issue 31 gen_chunk("$ValPy[0]=$ValPy[2].copy"); # copy structure not reference
                  gen_chunk("$ValPy[0] = $ValPy[2].copy()"); # copy structure not reference	# issue 31
                  finish();
                  next;
             } elsif($#ValClass==2 && $ValClass[2] eq 'a') {    # SNOOPYJC: %hash = @arr
                  gen_chunk("$ValPy[0] = {$ValPy[2]".'[_]:'.$ValPy[2]."[_+1] for _ in range(0,len(".$ValPy[2]."),2)}");
                  finish();
                  next;
             }
          } elsif($#ValClass == 0) {            # SNOOPYJC: Hash definition (ignore it)
              finish();
              next;
          }
          $TrStatus=assignment(0);
      }elsif($ValClass[0] eq 'a'){
          if($#ValClass == 0) {            # SNOOPYJC: Array definition (ignore it)
              finish();
              next;
          }
          if( $ValClass[1] eq '=' ){
             if( $#ValClass==2 && $ValClass[2] eq 'a'){
                # Special case array to array copy
		# issue 31 gen_chunk("$ValPy[0]=$ValPy[2].copy");
                gen_chunk("$ValPy[0] = $ValPy[2].copy()");	# issue 31
                finish();
                next;
             } elsif($#ValClass==2 && $ValClass[2] eq 'h') {    # SNOOPYJC: @arr = %hash
                gen_chunk("$ValPy[0] = list(functools.reduce(lambda x,y:x+y,$ValPy[2].items()))");
                finish();
                next;
             } elsif($ValClass[2] eq 'f' && ($ValPerl[2] eq 'keys' || $ValPerl[2] eq 'values')) {       # SNOOPYJC
                # python keys() and values() functions return something not subscriptable!
                gen_chunk("$ValPy[0] = list(");
                $TrStatus=expression(2,$#ValClass,0);
                gen_chunk(')');
                finish();
                next;
             }elsif( $ValPerl[2] eq '(' && ($end_pos=matching_br(2)) == $#ValClass){    # SNOOPYJC
                # array initialization
                gen_chunk($ValPy[0],' = [');
                $end_pos=matching_br(2);
                for (my $i=3; $i<$end_pos; $i++){
		    if( $ValClass[$i] eq 'i' && $ValPerl[$i] eq $ValPy[$i]) {	# issue 13
	      		if( $LocalSub{$ValPy[$i]} ){				# issue 13: local sub call with no parens
	        	    gen_chunk(escape_keywords($ValPy[$i]));		# issue 13, issue 41
	        	    gen_chunk('([])');  				# issue 13
              		} elsif ($Constants{$ValPy[$i]}) {                      # issue 13: constant or file handle
                	    gen_chunk($ValPy[$i]);           		        # issue 13
			} else {
			    $ValPy[$i] = "'".$ValPy[$i]."'";		        # issue 13 - put in quotes
                            gen_chunk($ValPy[$i]);
			}
		    } else {							# issue 13
                        gen_chunk($ValPy[$i]);
                    }
                }
                gen_chunk(']');
                finish();
                next;
             }elsif( $ValPerl[2] =~ /<\w*>/ ){
               # Special case of array initialization via slurping
	       # issue 31 gen_chunk("$ValPy[0]=$ValPy[2].copy");
               gen_chunk("$ValPy[0] = $ValPy[2].copy()");		# issue 31
               finish();
               next;
             }elsif(  $ValClass[2] eq 'a' && $ValPerl[3] eq '=' ){
               my $last_eq=rindex($TokenStr,'=');
               if( $ValPerl[$last_eq+1] eq '(' ){
                   #  list assignment @x=(1,2,3);
                   $ValPy[$last_eq+1]='[';
                   if( $ValPerl[-1] eq ')' ){
                      $ValPy[-1]=']';
                   }else{
                      $TrStatus=-255;
                      finish();
                      next;
                   }
               }
               for( $i=0; $i<$last_eq; $i+=2 ){
                  # cascade assignent processing @x=@y=@z
                  if ($ValClass[$i+1] ne '='){
                     logme('S',"Token $ValPerl[$i+1] was found insted of '=' in what is expected to be array assignment");
                     $TrStatus=-255;
                     last;
                  }
                  if( $last_eq+1==@ValClass ){
		     # issue 31 gen_statement("$ValPy[$i]=$ValPy[-1].copy"); # last array is the source
                     gen_statement("$ValPy[$i] = $ValPy[-1].copy()"); # last array is the source	# issue 31
                  }elsif( $ValPerl[$last_eq+1] eq '(' ){
                     #left side is the list $a=@b=(1,2,3)
                     gen_chunk("$ValPy[$i] = ");
                     expression($last_eq+1,$#ValClass); # processing (1,2,3) -- you need brackets here.  Recursion level should be 0
                     gen_statement();
                  }
               }
               finish();
               next;
             }
          }
          $TrStatus=assignment(0);
      }elsif( $ValClass[0] eq 'c' ){
          #normal control statement: if/while/for, etc -- next line is always nested.
          # in foreach loop "(" is absent ) do in perl you can's distibush between postfix for and foreach loop without parens
	  # issue 19 if( defined($ValType[0]) && $ValType[0] eq 'P' && $ValClass[1] ne '(' && $ValPy[0] ne 'for' ){
          if( defined($ValType[0]) && $ValType[0] eq 'P' && $ValPerl[0] ne 'for' && $ValPerl[0] ne 'foreach'){	# issue 19
	      # issue 19: If this control statement is not surrounded by parens, then add them in
	      # We were fooled by "if (this or that) and options{debug}" as we assumed the first ( and the last } were
	      # matching parens, which they are obviously not!
	      $add_parens = 1;				# issue 19
	      if($#ValClass >= 1 && $ValClass[1] eq '(') {			# issue 19
	         $end_pos = matching_br(1);		# issue 19
		 if($end_pos == $#ValClass) { $add_parens = 0; }		# issue 19
	      }						# issue 19
	      if($add_parens == 1) {			# issue 19
                 if($#ValClass >= 1) {
                     insert(1,'(','(','(');
                 } else {
                     append('(','(','(');
                 }
                 append(')',')',')');
	      }						# issue 19
          }

          if ($TokenStr=~/^c\(\!f\(?/ && $ValPerl[3] eq 'open' ){
            $TrStatus=open_fun(3,matching_br(1)-1,'c');   # SNOOPYJC: add extra param
          }elsif ($TokenStr=~/^c\(\!f\(?/ && $ValPerl[3] eq 'opendir' ){
              $TrStatus=open_dir(3,matching_br(1)-1,'c'); # SNOOPYJC: add extra param
          }else{
            $TrStatus=control(0); # control now itself destroy the last ) Oct 14, 2020 --NNB
          }
      }elsif( $ValClass[0] eq 'C' ){
         #next last continue
         if( $ValPerl[0] eq 'elsif' ){
            $end_pos=matching_br(1);
            $k=0;
            if(($k=next_same_level_token('=', 2, $end_pos-1))>-1 && 
                ($ValClass[$k-1] !~ /[ahs]/ || $ValPy[$k-1] !~ /[A-Za-z0-9_]+/)) {      # issue 58: complex assignment
               $deferred_statement = 1;                 # In the elif body we will generate the "complex_stuff=_e" assignment
               $deferred_statement_nesting = $Perlscan::nesting_level;
               @DeferredValClass=@ValClass[2..$k]; 
               @DeferredValCom=@ValCom[2..$k]; 
               @DeferredValPerl=@ValPerl[2..$k]; 
               @DeferredValPy=@ValPy[2..$k];
	       @DeferredValType=@ValType[2..$k];
               push @DeferredValClass, 'a';
               push @DeferredValCom, '';
               push @DeferredValPerl, $ELSIF_TEMP;
               push @DeferredValPy, $ELSIF_TEMP;
               push @DeferredValType, '';
               replace(2, 'a', $ELSIF_TEMP, $ELSIF_TEMP);       # Change it to _e:=expression
               destroy(3,$k-3) if($k >= 3);
               $end_pos -= ($k-3);
            }
            gen_chunk('elif ');
            if($k>0) {                          # issue 58: We have a := in there
                $TrStatus=expression(1,$end_pos,0);     # Keep the parens
            } else {
                $TrStatus=expression(2,$end_pos-1,0);
            }
            gen_chunk(':');
            gen_statement();
         }elsif( $ValPerl[0] eq 'else' ){
               gen_chunk('else:');
               gen_statement();
         }elsif( $ValPerl[0] eq 'eval' ) {              # issue 42
             gen_eval(0, 0);                            # issue 42
         }elsif( $ValPerl[0] eq 'do' ) {                # SNOOPYJC
             gen_statement("$DO_CONTROL$. = True");     # SNOOPYJC
             gen_chunk("while $DO_CONTROL$.:");         # SNOOPYJC
         }
     }elsif( $ValClass[0] eq 'f' ){
         #this is a left hand function like is substr($line,0,1)='' or open or chomp;
	 
         if( $ValPerl[0] eq 'substr' ){
            $TrStatus=left_hand_substr(0);
         }elsif( $ValPerl[0] eq 'chomp' ){
            if( $#ValPerl==0) {
               gen_chunk(qq[$DEFAULT_VAR=$DEFAULT_VAR.rstrip("\\n")]); # chomp with no argumnets # issue 32
            }else{
               function(0,$#ValClass);
            }
         }elsif( $ValPerl[0] eq 'chop' ){
             # SNOOPYJC if( $ValPerl[1] eq '(' ){
             # SNOOPYJC   if( $ValClass[2] eq 's' ){
             # SNOOPYJC      gen_chunk($ValPy[2].'='.$ValPy[2].'[0:-1]');
             # SNOOPYJC   } else{
             # SNOOPYJC      $TrStatus=-1;
             # SNOOPYJC   }
             # SNOOPYJC }else{
             if($#ValPerl==0) {                 # SNOOPYJC
               gen_chunk("$DEFAULT_VAR = ${DEFAULT_VAR}[0:-1]");          # issue 32
             } else {                           # SNOOPYJC
               function(0,$#ValClass);          # SNOOPYJC
             }                                  # SNOOPYJC
         }elsif( $ValPerl[0] eq 'open' ){
            $rc=open_fun(0,$#ValClass,'s');     # SNOOPYJC: Add extra param
	 }elsif( $ValPerl[0] eq 'opendir' ){	# SNOOPYJC
	    $rc=open_dir(0,$#ValClass,'s');
         }else{
            $TrStatus=function(0);

         }
      }elsif( $ValClass[0] eq 'x' ){
         # this is backquotes
         gen_chunk(qq{$DEFAULT_VAR=subprocess.run($ValPy[0],capture_output=True,text=True,shell=True)});
         gen_statement();
         gen_chunk(qq[$SUBPROCESS_RC=${DEFAULT_VAR}.returncode]);
         if($autodie) {
             gen_statement();
             gen_statement("if $SUBPROCESS_RC:");
             correct_nest(1,1);
             gen_statement("raise Die(f'run($ValPy[0]): failed with {$SUBPROCESS_RC}')");
             correct_nest(-1,-1);
         }
      }elsif( $ValClass[0] eq 'd' ){
         if( length($TokenStr)==1 ){
             # SNOOPYJC: just ignore it!  if($CurSub eq 'main' && scalar(@eval_stack) == 0) {  # issue 45: could be the return value of a sub # issue 42 or eval
             # SNOOPYJC: just ignore it!  logme('W','line starts with digit');
             # SNOOPYJC: just ignore it!  }                                          # issue 45
         # issue 45 }else{
         }elsif($CurSub eq 'main' && scalar(@eval_stack) == 0) {     # issue 45: could be the return value of a sub # issue 42 or eval
            $TrStatus=-1;
         }
      }elsif( $ValClass[0] eq '(' ){
         # (/abc/) && a=b; (a<b) || a=7
         $right_br=matching_br(0);
         if( $ValClass[$right_br+1] eq '0' ){
            gen_chunk('if ');
            $RecursionLevel=-1;
            $TrStatus=expression(0); # this will scan till ')'
         }elsif( $ValClass[$right_br+1] eq '1' ){
            gen_token('if ! ');
            $RecursionLevel=-1;
            $TrStatus=expression(0); # this will scan till ')'
         }elsif( $ValClass[$right_br+1] eq '=' ){
            #this is a list assignment like ($i,$k)=@_  or ($i,$k)=split(//,$text)
            $RecursionLevel=-1;
            $TrStatus=expression(0,$right_br);
            gen_chunk($ValPy[$right_br+1]);
            $RecursionLevel=-1;
            $TrStatus=expression($right_br+1,$#ValClass,0);
         }
      }elsif( $ValClass[0] eq 'k' ){
         # keywords next, last, return and all other for which we have no special treatment
         if ( $ValPy[0] eq 'return' && scalar(@eval_stack) != 0 ) {     # issue 42
             if($#ValClass != 0) {              # not a plain 'return'
                my $lno = $eval_stack[-1]->{lno};
                gen_chunk("$EVAL_RESULT$lno = ");
                $TrStatus = expression(1,$#ValClass,-1);        # -1 means to eat any surrounding ()
            }
            gen_statement();
            gen_statement("raise $EVAL_RETURN_EXCEPTION");
            $eval_stack[-1]->{had_return} = 1;
         } elsif($ValPy[0] eq 'return' && $CurSub eq 'main') {          # SNOOPYJC
             gen_statement('raise Die("Can\'t return outside a function")');  # SNOOPYJC
             logme('W',"Attempt to return outside a subroutine will die if executed");    # SNOOPYJC
         } else {
            if( $#ValClass == 0 ){
                #say STDOUT "$ValPy[0], we_are_in_sub_body=$we_are_in_sub_body, CurNest=$Pythonizer::CurNest, NextNest=$Pythonizer::NextNest";
                if(($ValPerl[0] eq 'next' || $ValPerl[0] eq 'last') && &Perlscan::next_last_needs_raise()) {
                    my $ex_name = label_exception_name(undef);
                    gen_chunk("raise $ex_name('$ValPy[0]')");
                } else {
                    gen_chunk($ValPy[0]);
                }
            }elsif( $ValClass[1] eq '(' ){
                $TrStatus=expression(0,$#ValClass,0); # Can be this will scan till ')'
            }elsif($ValClass[1] eq 'i' && ($ValPerl[0] eq 'next' || $ValPerl[0] eq 'last')) {   # issue 94
                if($ValPerl[1] eq $LastLabel) {
                    gen_chunk($ValPy[0]);
                } else {
                    # next LABEL or last LABEL, with LABEL not the last one we saw
                    my $ex_name = label_exception_name($ValPerl[1]);
                    gen_chunk("raise $ex_name('$ValPy[0]')");
                }
            }else{
                # last 2
                gen_chunk($ValPy[0]);
                $TrStatus=expression(1,$#ValClass); # this will scan till ')'
            }
         }
      }elsif( $ValClass[0] eq 'i' ){
         # user defined functon
         if( $#ValClass>0 && $ValClass[1] eq '(' ){
            $right_br=matching_br(1);
            if( $ValClass[2] eq ')' ){
               # function with zero arguments
               if( $ValPy[0] eq 'main' && $Pythonizer::CurNest==0 ){
                   my $globals=substr($GlobalVar{$CurSub},length('global'));
                   $globals=~tr/,/=/;
                   gen_statement($globals.'=None');
               }
               gen_chunk(escape_keywords($ValPy[0]).'([])');            # issue 13
            }elsif( $ValClass[2] eq 'f' && ( $ValClass[3] ne '(' || ($ValClass[3] eq '(' && matching_br(3) == $right_br-1)) ){
               # bracketless call of built-in function as a single argument: get_config(split / /,$line)
               # or bracketed call to built-in function call that return list. We do not need sqare brackets
               gen_chunk($ValPy[0],'(');
               function(2,$right_br-1); # we assume that evethying in brackets is the function call
               gen_chunk(')');
            }else{
               # In all other cases we will put sqare bracket, even if they are redundant: they can be manually deleted.
               gen_chunk(escape_keywords($ValPy[0]));           # issue 13
               gen_chunk('([');
               $TrStatus=expression(2,$#ValClass-1,-1); # this will scan till ')' and should eliminate ')' due to -1 as 3-d arg
               gen_chunk('])');
            }
         }elsif($#ValClass == 1 && $ValClass[1] eq ':') {       # SNOOPYJC: Label
             $LastLabel = $ValPerl[0];                          # SNOOPYJC
             output_line('',"# $LastLabel:");                   # issue 94
             $Perlscan::PREV_HAD_COLON = 0;                     # SNOOPYJC
         }else{
           $RecursionLevel=-1;
           $TrStatus=expression(0,$#ValClass); # this will scan till ')'
         }
      }elsif( ($split=index($TokenStr,'~'))>-1) {       # issue 73
         $k=regex_and_translate(0,0,$split,0);          # issue 73
         if($k < 0) {                                   # issue 73
             $TrStatus=-1;                              # issue 73
         }                                              # issue 73
      }else{
         if($debug >= 1) {
             say STDERR "Main loop: Unknown statement (@ValClass)";
         }
         if($CurSub eq 'main' && scalar(@eval_stack) == 0) {  # issue 45: ignore string as statement in sub - may be changed to "return 'string'" # issue 42 or eval
            $TrStatus=-1;
         }                                      # issue 45
      }
      finish();
    } # while

    initialize_globals_for_state_vars();
    while (($key, $value) = each (%Pyf)) {	# SNOOPYJC
        if($value == 1) {
	    open(my $fh, '<', "$Pyf_dir/$key.py");
            while($l=<$fh>){
                chomp $l;
	        $l=~ s/[\r]//g;
                say Pythonizer::SYSOUT $l;       # Quietly output line
            }
            close $fh;
	}
    }
#
# Epilog -- close  output file and  if you are in debugging mode display the content  on the screen
#
   if (scalar(@NoTrans)>0) {
      say STDERR "\nATTENTION!\nThe following lines were probably translated incorrectly:\n";
      say STDERR join("\n",@NoTrans);
   }
   Pythonizer::move_defs_before_refs();                 # SNOOPYJC
   $rc=summary(); # print diagnostic messages summary
   exit $rc;

sub apply_scalar_context                        # issue 37
{
    $pos = shift;
    return if($pos < 0 || $pos > $#ValClass);
    if($ValClass[$pos] eq 'a' && substr($ValPy[$pos],0,4) ne 'len(') {
        $ValPy[$pos] = 'len('.$ValPy[$pos].')';
        return 1;
    } elsif($ValClass[$pos] eq 'f' && exists $SPECIAL_FUNCTION_MAPPINGS{$ValPerl[$pos]}) {      # issue 65
        $scalar_ValPy = $SPECIAL_FUNCTION_MAPPINGS{$ValPerl[$pos]}->{scalar};
        if($ValPy[$pos] ne $scalar_ValPy) {
            $ValPy[$pos] = $scalar_ValPy;
            return 1;
        }
    }
    return 0;
}

sub fix_scalar_context                          # issue 37
{
    # Run over the statement and fix scalar context issues
    if($TokenStr eq 's=a' || $TokenStr =~ /^s=f/) {                     # issue 65
        apply_scalar_context(2);
    } elsif($TokenStr eq 'ts=a' || $TokenStr =~ /^ts=f/) {               # issue 65
        apply_scalar_context(3);
    } elsif($#ValClass > 5 && $ValClass[1] eq '(' && $ValClass[0] eq 's') {    # Array subscript or hashref
        $j=matching_br(1);
        if($j+2 <= $#ValClass && $ValClass[$j+1] eq '=' && $ValClass[$j+2] =~ /[af]/) {
            apply_scalar_context($j+2);
        }
    }

    for(my $i=0; $i<=$#ValClass; $i++) {
        if(index("+-*/.>",$ValClass[$i]) >= 0) {        # Scalar operator
            if($i-1 == 0 || $ValClass[$i-2] ne 'f') {   # function (like shift/pop) on an array - don't apply scalar context to the array
                apply_scalar_context($i-1);
            }
            apply_scalar_context($i+1);
        } elsif($ValClass[$i] eq 'f' and $ValPerl[$i] eq 'scalar') {
            # The 'scalar' function gets changed to 'len' which works unless it's applied to 'localtime'
            # or other functions that have different scalar interpretation, like 'reverse',
            # so we handle that here by fixing the function and removing the 'len' call.
            if(apply_scalar_context($i+1) == 1) {
                destroy($i,1);
                $i--;
            }
        }
    }
}

sub fix_string_catenation                       # issue 36
{
    # Run over the statement and fix string catenation issues
    for(my $i=0; $i<=$#ValClass; $i++) {
        if($ValClass[$i] eq '.' and $ValPy[$i] eq ' + ') {
            my $j = $i-1;
            while($j >= 0) {
                if($ValClass[$j] eq ')') {
                    $j=reverse_matching_br($j);
                } else {
                    last if(index(".>0=,()!cfi", $ValClass[$j]) >= 0);
                }
                $j--;
            }
            $j-- if($ValClass[$j] eq 'f' && $ValPerl[$j] ne 'print' && $ValPerl[$j] ne 'printf' && $ValPerl[$j] ne 'say');
            $j-- if($ValClass[$j] eq 'i' && $LocalSub{$ValPy[$j]});
            if(!($ValClass[$j+1] eq '"' || ($ValClass[$j+1] eq 'f' && ($ValPerl[$j+1] eq 'str' || $ValPerl[$j+1] eq 'substr')))) {
                if($debug > 3) {
                   say STDERR "fix_string_catentation1 i=$i, j=$j\n";
                }
	        insert($i,')',')',')');
                insert($j+1,'(','(','(');
                insert($j+1,'f','str','str');
                $i += 3;
            }
            $j = $i+1;
            while($j <= $#ValClass) {
                if($ValClass[$j] eq '(') {
                    $j=matching_br($j);
                } else {
                    last if(index(".>0=,()!c", $ValClass[$j]) >= 0);
                }
                $j++;
            }
            if($i+1 <= $#ValClass && !($ValClass[$i+1] eq '"' || ($ValClass[$i+1] eq 'f' && ($ValPerl[$i+1] eq 'str' || $ValPerl[$i+1] eq 'substr')))) {
                if($debug > 3) {
                   say STDERR "fix_string_catentation2 i=$i, j=$j\n";
                }
                if($j >= scalar(@ValClass)) {
	            append(')',')',')');
                } else {
	            insert($j,')',')',')');
                }
                insert($i+1,'(','(','(');
                insert($i+1,'f','str','str');
                $i += 2;
            }
        }
    }
}
sub fix_multi_subscripts                                # issue 84
{
    # Replace code that pulls multiple subscripts from an array or expression
    # e.g. @arr[0,1,4]  @{$hash{$key}}[0,1,4]  (array_func())[0,1,4]
    # Generate: [arr[_] for _ in [0,1,4]]
    for(my $i = 0; $i <= $#ValClass; $i++) {
        if(index('a@(', $ValClass[$i]) >= 0) {
            my $sub_start = $i+1;
            if($ValClass[$i] eq '@') {
                $sub_start = matching_br($i+1) + 1;
                next if($sub_start == 0);
            } elsif($ValClass[$i] eq '(' && $ValPerl[$i] eq '(') {
                $sub_start = matching_br($i) + 1;
                next if($sub_start == 0);
            } elsif($ValClass[$i] ne 'a') {
                next;                   # { or [
            }
            last if($sub_start > $#ValClass);
            next if($ValPerl[$sub_start] ne '[');
            my $sub_end = matching_br($sub_start);
            my $commas = 0;
            for(my $j = $sub_start+1; $j < $sub_end; $j++) {
                $commas++ if($ValClass[$j] eq ',');
            }
            if($commas >= 2) {          # We have a winner!
                insert($sub_end+1,')',']',']');         # Add the ending ']'
                insert($sub_start, 'y', 'multi', '[_] for _ in ');      # 'y' is a special token type for "extra python code"
                insert($i, '(', '[', '[');              # Add the opening '['
                $i = $sub_end+3;
                if($debug > 3) {
                    say STDERR "fix_multi_subscripts: found $commas commas, updated code: =|$TokenStr|=";
                }
            }
        }
    }
}

sub remove_array_or_hash_references                     # issue 50
{
    # Run over the statement removing array or hash dereferences of the form @{...} or %{...}
    # because python doesn't need them.  Also fix up hashref initialization.

    for(my $i = 0; $i <= $#ValClass; $i++) {
        if($ValClass[$i] eq '@' || $ValClass[$i] eq '%') {
            if($i < $#ValClass && $ValClass[$i+1] eq '(' && $ValPerl[$i+1] eq '{') {
                my $to=matching_br($i+1);
                next if($to < 0);
                destroy($to,1);                 # Delete the '}'
                destroy($i,2);                  # Delete the '@{'
                $i--;
            }
        } elsif($ValClass[$i] eq '(' && $ValPerl[$i] eq '{') {
            # This case happens in like $hash_ref = {this=>'that', these=>'those}
            # as by default all '{' are changed to '[', but in this case
            # they need to be restored to '{' and '}'.
            my $to = matching_br($i);
            next if($to < 0);
            my $j;
            if(($j = index($TokenStr,':',$i+1)) > 0 && $j < $to) {   # $TokenStr is a string representation of @ValClass
                $ValPy[$i] = '{';
                $ValPy[$to] = '}';
            }
        }
    }
}

sub fix_expression_issues
{
   my $start = 0;
   my $limit = $#ValClass;
   my $end_pos = $limit;
   my $pos;

   # issue 74: Handle ++ and --
   while(($pos = next_matching_token('^', $start, $limit)) >= 0) {  # issue 74
       my $adjust = handle_incr_decr($start, $pos, $limit); # issue 74
       last if(!$adjust);                               # issue 74
       $end_pos += $adjust;                             # issue 74
       $limit += $adjust;                               # issue 74
   }                                                    # issue 74
   # SNOOPYJC: Handle cmp and <=>
   my $st = $start;
   while(($pos = next_matching_token('>', $st, $limit)) >= 0) {
       if($ValPerl[$pos] eq 'cmp' || $ValPerl[$pos] eq '<=>') {
           my $adjust = handle_cmp_spaceship($st, $pos, $limit);
           $end_pos += $adjust;
           $limit += $adjust;
       } else {
           $st = $pos+1;
       }
   }
   # issue 52: handle ? : operator
   while(($pos = next_matching_token('?', $start, $limit)) >= 0) {  # issue 52
       my $adjust = handle_question_mark_colon($start, $pos, $limit); # issue 52
       $end_pos += $adjust;                             # issue 52
       $limit += $adjust;                               # issue 52
   }                                                    # issue 52

   # issue 88: handle -bareword
   # We have to do it here and not in the lexer because of things like: t -timelocal(...)
   # was converting timelocal to "-timelocal"!!
   $st = $start;
   while(($pos = next_matching_token('-', $st, $limit)) >= 0) {
       if($pos+1 <= $#ValClass && $ValClass[$pos+1] eq 'i' && !$LocalSub{$ValPy[$pos+1]} && !$Constants{$ValPy[$pos+1]} &&
          ($pos == 0 || $ValClass[$pos-1] !~ /[s)]/)) {
           my $adjust = handle_negative_bareword($pos);
           $end_pos += $adjust;
           $limit += $adjust;
        } else {
            $st = $pos+1;
        }
   }

   # 

   # issue 81: Handle anonymous sub in expression
   goto SKIPITFORNOW;
   $st = $start;
   while(($pos = next_matching_token('k', $st, $limit)) >= 0) {
       if($ValPerl[$pos] eq 'sub' && $pos != 0) {
           my $adjust = handle_anonymous_sub_in_expression($start, $pos, $limit);
           $end_pos += $adjust;
           $limit += $adjust;
        } else {
            $st = $pos+1;
        }
    }
    SKIPITFORNOW: ;
}

sub finish
# imitation of continue statement.
{
    if( defined($TrStatus) && $TrStatus < 0 ){
       push(@NoTrans,"[$.]: $line");
    }
    $generated_code = scalar(@Perlscan::PythonCode);            # issue 45
    # issue 45 gen_statement();
    my $prev_line = $line;                                      # issue 45
    $line=getline(0) if($deferred_statement < 2); # get new line # issue 58, issue 45
    #say STDERR "finish $CurSub generated_code=$generated_code, line=(($line)), prev_line=(($prev_line)), ValPerl=@ValPerl, CurNest=$Pythonizer::CurNest";
    if(($CurSub ne 'main' || scalar(@eval_stack) != 0) &&       # issue 42
        defined $line &&                                        # issue 42
        ($line eq '}' || $line =~ /^}\s*#/ || $line eq '};') && # issue 42
        $ValPerl[0] ne 'return' && $Pythonizer::CurNest==1) {      # issue 45
        if($debug >= 5) {                                       # issue 45
            say STDERR "finish: prev_line=$prev_line, PythonCode=@Perlscan::PythonCode";               # issue 45
        }                                                       # issue 45
        if($generated_code == 0 && index('fds"(-', $ValClass[0]) >= 0) {   # issue 45
            $prev_line =~ s/\s+#.*$//;                          # issue 45: remove comments
            $last_c = substr($prev_line,-1,1);                  # issue 45
            if($last_c eq '}' && $ValClass[-1] ne ')') {        # issue 45
                chop $prev_line;                                # issue 45
                $prev_line =~ s/\s+$//;                         # issue 45
                $last_c = substr($prev_line,-1,1);              # issue 45
            }                                                   # issue 45
            if($last_c eq ';') {                                # issue 45
                $line = "return ".$prev_line;                   # issue 45
            } else {                                            # issue 45
                $line = "return ".$prev_line.';';               # issue 45
            }                                                   # issue 45
            getline('}');                                       # issue 45
        } elsif($ValClass[0] eq 'f') {                          # issue 45
            # In this case, we generated the code for a function call - sneak the 'return' in just before it
            my $return = 'return';                              # issue 45
            if(scalar(@eval_stack) != 0) {                      # issue 45
               $return = undef;                                 # issue 45
               if(exists $eval_stack[-1]->{assignment}) {       # issue 45
                  my $lno = $eval_stack[-1]->{lno};             # issue 45
                  $return = "$EVAL_RESULT$lno = ";              # issue 45: for an a = eval {...};, we set the EVAL_RESULT instead of returning
               }                                                # issue 45
            } elsif($Perlscan::PythonCode[0] =~ /^(?:(?:raise )|(?:return ))/) {    # issue 45 
                $return = undef;                                # issue 45
            }                                                   # issue 45
            unshift @Perlscan::PythonCode,$return if($return);  # issue 45
        } elsif(index($TokenStr,'=') > 0) {                     # issue 45
            $prev_line =~ s/^\s*my\s+//;                        # issue 45
            $prev_line =~ s/^\s*own\s+//;                       # issue 45
            $line = "return ".substr($prev_line, 0, index($prev_line,'='));     # issue 45
            $line =~ s/\s*[.+*\/\|\&-]$//;                      # issue 45: remove char prior to '=', like in '+='
            $line .=';';                                        # issue 45
            getline('}');                                       # issue 45
        }                                                       # issue 45
        if($debug >= 5) {                                       # issue 45
            say STDERR "finish: Resetting line to $line";       # issue 45
        }                                                       # issue 45
    }                                                           # issue 45
    gen_statement();                                            # issue 45
    getline(1);                                                 # issue 45

    $eval_nest = ((scalar(@eval_stack) == 0) ? -2 : $eval_stack[-1]->{eval_nest});        # issue 42
    if($debug >= 3 && scalar(@eval_stack)) {
        say STDERR "eval_stack=@eval_stack, eval_nest=$eval_nest";
    }
    if($eval_nest == $Pythonizer::CurNest && !$Perlscan::PREV_HAD_COLON) {  # issue 42
        gen_statement();                                        # issue 42
        correct_nest(1,1);                                      # issue 42
        gen_statement('EVAL_ERROR = None');                     # issue 42
        correct_nest(-1,-1);                                    # issue 42
        if(exists $eval_stack[-1]->{had_return}) {              # issue 42: there was a "return" statement
            gen_statement("except $EVAL_RETURN_EXCEPTION:");    # issue 42
            correct_nest(1,1);                                  # issue 42
            gen_statement('EVAL_ERROR = None');                 # issue 42
            correct_nest(-1,-1);                                # issue 42
        }                                                       # issue 42
        gen_statement('except Exception as _e:');               # issue 42
        correct_nest(1,1);                                      # issue 42
        gen_statement('EVAL_ERROR = _exc(_e)');                 # issue 42
        output_line('traceback.print_exc()') if($traceback);    # SNOOPYJC
        $Pyf{"_exc"} = 1;                       		# issue 42
        correct_nest(-1,-1);                                    # issue 42
        if(exists $eval_stack[-1]->{assignment}) {              # issue 42
            unpackage_code($eval_stack[-1]->{assignment});      # issue 42
            assignment($ValClass[0] eq 't' ? 1 : 0);            # issue 42 - generate the code for the assignment we packaged up
            gen_statement();                                    # issue 42
        }                                                       # issue 42
        pop @eval_stack;                                        # issue 42
    }
    if($context_manager_nest == $Pythonizer::CurNest-1 && $ValClass[0] ne 'c') {    # issue 66
        if($debug >= 3) {                                       # issue 66
            say STDERR "Resetting context manager nest";        # issue 66
        }
        correct_nest(-1);                                       # issue 66
        $context_manager_nest = -2;                             # issue 66
    }                                                           # issue 66
    correct_nest();
} # finish

sub rename_state_var
{
($from,$to)=@_;
   for( $i=$from; $i<=$to; $i++ ){
      if( defined($ValClass[$i]) &&  $ValClass[$i]=~/[sah]/ && exists($new_state_var_name{$ValPy[$i]}) ){
          $ValPy[$i]=$CurSub.'_'.$ValPy[$i];
      }
   }
}
sub initialize_globals_for_state_vars
{
    my @state_var = keys %new_state_var_name;           # SNOOPYJC
    # SNOOPYJC my  @renamed_state_var=values(%new_state_var_name);
    if($debug >= 3) {           # SNOOPYJC
        say STDERR "initialize_globals_for_state_vars: @state_var";
    }
   return unless( defined($state_var[0]) ); # nothing to do     # SNOOPYJC
   # First generate varibles for which we have inialization
   foreach $sv (@state_var) {        # SNOOPYJC
      my $renamed_sv = $new_state_var_name{$sv};
      my $val = 'None';                         # SNOOPYJC
      $renamed_sv =~ /^(.*)_$sv$/;
      my $sv_sub = $1;                          # SNOOPYJC: Get the sub name from the renamed sv name
      #say STDERR "sv_sub = $sv_sub";
      if( exists($new_state_var_init{$sv}) ){
          $val = $new_state_var_init{$sv};
      } elsif(exists($VarType{$sv}{$sv_sub})) {         # SNOOPYJC
          $val = init_val($VarType{$sv}{$sv_sub});      # SNOOPYJC: Use our computed type for the init
      }
      gen_statement($renamed_sv.' = '.$val);
   }
# SNOOPYJC    # Now initialize the rest to None
# SNOOPYJC my $first=0;
# SNOOPYJC    for( $i=0; $i<@renamed_state_var; $i++){
# SNOOPYJC       unless( exists($new_state_var_init{$renamed_state_var[$i]}) ){
# SNOOPYJC          if( $first==0 ){
# SNOOPYJC             gen_chunk($renamed_state_var[$i]);
# SNOOPYJC             $first++;
# SNOOPYJC          }else{
# SNOOPYJC             gen_chunk(' = ',$renamed_state_var[$i]);
# SNOOPYJC          }
# SNOOPYJC       }
# SNOOPYJC    }
# SNOOPYJC    ($first) && gen_chunk(' = None');
# SNOOPYJC    gen_statement;
}
#
# Print statement for Python 3
#
sub print3
{
my $begin=$start=$_[0];
my ($k,$handle);
my $end_pos=$#ValClass;                                            # issue 10
# end="") instead of trailing comma in Python 2
   if($start == 0) {                    # issue 77
       gen_chunk($ValPy[$start],'(');
   } else {                             # issue 77
       $Pyf{"_perl_print"} = 1;		# issue 77
       gen_chunk('_perl_print(');        # issue 77 - this print returns 1 on success
   }                                    # issue 77
   if($start+1 <= $#ValClass && $ValClass[$start+1] eq '(') {     # issue printf: handle bracketed
       $end_pos = matching_br($start+1) - 1;
       $start++;
   }
   if( $start+1 <= $#ValClass && $ValClass[$start+1] =~ /[is]/ ){ # issue 32
      $handle=$ValPy[$start+1];
      $k=$start+2;
      if($k <= $#ValClass && ($ValClass[$k] eq ',' || $ValClass[$k] eq '.')) {    # issue 32; handle print $session->elapsed_time(...)
          $handle='';
          $k = $start+1;
      }elsif($ValClass[$start+1] eq 's' && ($#ValClass == $start+1 || $ValClass[$start+2] eq '(')) { # issue 32
          $handle='';
          $k = $start+1;
      }
   }else{
      $handle='';
      $k=$start+1;
      $handle=$_[1] if(scalar(@_) >= 2);        # SNOOPYJC: warn
   }
   # issue 10 if( $#ValClass>$k ){
   if($debug >= 3) {
      say STDERR "print3($begin) start=$start, handle=$handle, k=$k, end_pos=$end_pos\n";
   }
   if($begin != 0 && $ValClass[$begin-1] eq '(' && $ValClass[-1] eq ')') {	# issue 10: Surrounded by ( )
       $end_pos--;
       if($debug >= 3) {
          say STDERR "setting end_pos = $end_pos\n";
       }
   }
   if( $end_pos>=$k ){	# issue 10
      # issue 10 $TrStatus=expression($k,$#ValClass,0);
      if($ValPerl[$begin] eq 'printf') {                # issue printf
          my $comma=next_same_level_token(',',$k,$end_pos);
          $comma = $end_pos+1 if($comma < 0);
          $TrStatus=expression($k,$comma-1,0);    # format
          return -1 if ($TrStatus<0);
          if($ValClass[$k] eq 'a' && $comma == $end_pos+1) {    # format is first element of the array
              gen_chunk('[0] % (', $ValPy[$k], '[1:])');
          } else {
            gen_chunk(' % (');
            $TrStatus=expression($comma+1,$end_pos,0) if($comma+1 <= $end_pos);   # list
            gen_chunk(')');
          }
      } else {
          $TrStatus=expression($k,$end_pos,0);		# issue 10
      }
      return -1 if ($TrStatus<0);
   }else{
      $end = ($ValPerl[$begin] eq 'print' || $ValPerl[$begin] eq 'printf') ? ', end=""' : '';      # issue 59
      $def = $DEFAULT_VAR;              # issue printf
      if($ValPerl[$begin] eq 'printf') {
          $def .= ' % ()';
      }
      if(length($handle)>0){
          # issue 59 gen_chunk("file=$handle)");
         gen_chunk("$def, file=$handle$end)");      # issue 59
      }else{
          # issue 59 gen_chunk(')');
          gen_chunk("$def$end)");           # issue 59
      }
      return 0;
   }
   if (($ValPerl[$begin] eq 'print' || $ValPerl[$begin] eq 'printf') && $ValClass[-1] eq '"' ){
      if( $Perlscan::PythonCode[-1]=~qr[\\n["']$] ){
         substr($Perlscan::PythonCode[-1],-3,2)=''; # Perl print was actually say
      }else{
         gen_chunk(',end=""');
      }
   } elsif($ValPerl[$begin] eq 'print' || $ValPerl[$begin] eq 'printf') {               # issue 59
       gen_chunk(',end=""');
   }
   if( $handle){
      #printing to file handle
       gen_chunk(',file=',$handle); #  Python   3.x:   print('hello world', file=file_object)
   }

   #say
   gen_chunk(')');
   #if($end_pos != $#ValClass) {	# issue 10
   #gen_chunk(')');		# issue 10
   #}				# issue 10
   return scalar(@ValClass);
} # print3

sub assignment
#
# Analyse and generate code for Perl assignment statement
#
{
my $start=$_[0]; # start of analysys of assignment statement
   if( $start<0 || $TrStatus<0  ){
      return -255;
   }
my $limit=(scalar(@_)>1) ? $_[1] : $#ValClass; # Nov 11, 2019  accept not only the index of the first token, but also index of the last.
   if($debug >= 3) {
	   say STDERR "assignment($start, $limit) =|$TokenStr|= @ValPerl\n"
   }
my ($k,$split,$post_processing,$comma_pos,$colon_pos,$from,$to);
#
# Assignment with post condition need to be transformed into regular control structure in Python
#
   $k=$start;

#
# C-style ++ and --
#
   if( $ValClass[$#ValClass] eq '^' ){
       if ($#ValClass-$start==1){
	 if($ValPy[$k] =~ /^\(len\((.*)\)-1\)$/) { # issue 14 - increment or decrement array length
            $arrName = $1;			# issue 14
	    if($ValPerl[$#ValClass] eq '++') {	# issue 14: add one element to array
	       gen_chunk("$arrName.append(None)");	# issue 14
	    } else {				# issue 14
	       gen_chunk("del $arrName".'[len('.$arrName.')-1:]');	# issue 14
	    }
	 } else {				# issue 14
            gen_chunk($ValPy[$k],$ValPy[$k+1]);
	 }
         return $#ValClass+1;
       }else{
         replace($#ValClass,'=','=',substr($ValPy[-1],0,2));
         append('d','1','1');
         $limit+=1;
         if($debug >= 3) {
	   say STDERR "assignment_updated($start, $limit) =|$TokenStr|= @ValPerl\n"
         }
       }
    }
#
# We assume this is a regular assignment with "=". Let's analyse the left  side.
#
   $add_right_paren = 0;			# issue 14
   $number_of_elements = 0;                     # issue 56
   if( ($split=index($TokenStr,'=',$k))>-1 ){
       if($split+1 <= $#ValClass && $ValClass[$split+1] eq 'C') {         # issue 42
           if(handle_assign_eval($split+1)) {   # issue 42
               return $#ValClass;               # issue 42
           }                                    # issue 42
           $limit = $#ValClass;                 # issue 42 - we deleted the (...)
       }                                        # issue 42
       if( $split-$k==1 ){
         if($ValPy[$k] =~ /^\(len\((.*)\)-1\)$/) { # issue 14 - assign array last element index
             if($ValPy[$split] ne '=') {	# issue 14 - handle +=, -=, etc
	        $ValPy[$split] = '=';		# issue 14
	        insert($split+1,$ValClass[$k],$ValPerl[$k],$ValPy[$k]);	# issue 14
		$op = substr($ValPerl[$split],0,1); # issue 14
	        insert($split+2,$op,$op,$op);	# issue 14
		$limit += 2;			# issue 14
	     }					# issue 14
	     gen_chunk("_set_last_ndx($1,");	# issue 14
     	     $Pyf{"_set_last_ndx"} = 1;		# issue 14
	     $add_right_paren = 1;		# issue 14
	 } else {				# issue 14
            # single token on the left side -- regular assignment;
            gen_chunk($ValPy[$k]); # simple scalar assignment -- varible of left side
	  }					# issue 14
       }elsif( $ValPerl[$k] eq '(' ){
          # brackets on the right side -- we assume that this is the list on the left side
	  #
	  # Issue 56: perl allows the length of the list on the lhs and rhs to be different.  Handle this
	  # by inserting a function surrounding the rhs which returns the proper number of elements
	  # corresponding to the lhs.  Pass that # to the function.
	  #
          gen_chunk('[');
          $k++;
          if($ValClass[$k] eq 'f' && $ValPerl[$k] eq 'undef') { # issue 63
              gen_chunk('_');        # issue 63
          } else {
              gen_chunk($ValPy[$k]); # first in the cascading assignement
          }
          $number_of_elements++;                # issue 56
          $k++;
          while($k<$split ){
             # this was we skip delimiters
             # issue 63 if( substr($TokenStr,$k,1)=~/^[sha]/ ){
             if( substr($TokenStr,$k,1)=~/^[shaf]/ ){   # issue 63: handle multiple undef in lhs list
                if($ValClass[$k] eq 'f' && $ValPerl[$k] eq 'undef') {   # issue 63
                    gen_chunk(',_');                                    # issue 63
                } else {
                    gen_chunk(','.$ValPy[$k]);
                }
                $number_of_elements++;          # issue 56
             }
             $k++;
          }
          gen_chunk(']');
          $k++;
      }else{
         # possibly  array with complex subscripts or complex hash key expression
	 if(substr($TokenStr,$k) =~ /^s\([si"]\)=\(\)$/ &&
	    $ValPerl[$k+1] eq '{' && $ValPy[$k+5] eq '(') {	# issue 36
	    # Assigning an empty tuple to a hash value is never what you want
	    $ValPy[$k+5] = '{';					# issue 36
	    $ValPy[$k+6] = '}';					# issue 36
	 }
         
         $k=expression($k,$split-1,0); # on the left side it can be array index or something more complex
         return -255 if ($k<0);
      }
      # issue 14 gen_chunk($ValPy[$split]); # generate appropriate operation hidden under generic token '=' (  +=, -=, etc)
      gen_chunk($ValPy[$split]) unless $add_right_paren == 1; # generate appropriate operation hidden under generic token '=' (  +=, -=, etc)

      if($number_of_elements) {         # issue 56
        gen_chunk('_list_of_n(');       # issue 56
        $Pyf{"_list_of_n"} = 1;		# issue 56
      }                                 # issue 56

      if( $limit - $split == 1 ){
         # only one token after '='
	 if($debug >= 3) {
	 	say STDERR "assign, ValClass[limit] = $ValClass[$limit], ValPy=$ValPy[$limit], ValPerl=$ValPerl[$limit]\n";
         }
         if ($ValClass[$limit] eq 'x' ) {
            gen_chunk(qq{subprocess.run($ValPy[$split+1],capture_output=True,text=True,shell=True)});
            gen_statement();
            gen_statement(qq{$SUBPROCESS_RC=$ValPy[$split-1].returncode});
            gen_chunk($ValPy[$k]);
            gen_chunk($ValPy[$split]);
            gen_chunk($ValPy[$k].'.stdout');
            if($autodie) {                              # SNOOPYJC
                gen_statement();
                gen_statement("if $SUBPROCESS_RC:");
                correct_nest(1,1);
                gen_statement("raise Die(f'run($ValPy[$split+1]): failed with {$SUBPROCESS_RC}')");
                correct_nest(-1,-1);
            }
	 }elsif($ValClass[$limit] eq 'f') {	# Issue 8: this is a function like shift with no args
            function($limit,$limit);		# Issue 8
	 }elsif($ValClass[$limit] eq 'i' && $ValPy[$limit] eq $ValPerl[$limit]) {	# issue 13
	      if( $LocalSub{$ValPy[$limit]} ){						# issue 13: local sub call with no parens
	        gen_chunk(escape_keywords($ValPy[$limit]));				# issue 13, issue 41
	        gen_chunk('([])');							# issue 13
              } elsif ($Constants{$ValPy[$limit]}) {                                    # issue 13: constant or file handle
                gen_chunk($ValPy[$limit]);                 	        		# issue 13
	      } else {									# issue 13: bare word - treat as string
	        gen_chunk("'".$ValPy[$limit]."'");					# issue 13
	      }
         }else{
            gen_chunk($ValPy[$limit]); # that includes diamond operator <> and <HANDLE> Aug 10,2020
            #$is_numeric{$ValPerl[$k]}='d'; # capture the type of variable.
         }
         gen_chunk(", $number_of_elements)") if($number_of_elements);    # issue 56
	 gen_chunk(')') if($add_right_paren);		# issue 14
         return($#ValClass);
      }elsif($limit - $split == 2 && $ValClass[$split+1] eq '(' && $ValClass[$split+2] eq ')') {        # issue paren
          # We have some sort of empty parens on the RHS.  Generate the correct type of code depending on
          # what type of parens the user entered.
          $k = $split+1;
          if($ValPerl[$k] eq '{') {             # {} = Empty hashref
              gen_chunk("dict()");
          } else {                              # [] = Empty arrayref, () = Empty array
              gen_chunk("[]");
          }
	  gen_chunk(')') if($add_right_paren);		# issue 14
          return($#ValClass);
      }else{
          # we have some kind of expression on  the right side
          # issue 52 if( (substr($TokenStr,$split,2) eq '=(')>-1 &&  (index($TokenStr,')?',$split))>-1 ){
         if( index($TokenStr,'?',$split) >-1 ){         # issue 52
            # this is C-style conditional assigment   x=(v>0)?y:z;  -or- x=v>0?y:z;
            # Step one analyse the expression in blackets
            my $bracketed = 0;                          # issue 52
            if($ValClass[$split+1] eq '(') {            # issue 52
                $to=matching_br($split+1);
                ($to<0) && return -255;
                $bracketed = 1;                         # issue 52
            } else {                                    # issue 52
                $to = index($TokenStr,'?',$split+1)-1;    # issue 52
            }

            # Fist we need to generate then part of ternary if expression

            $colon_pos=index($TokenStr,':',$to+2);
            #say "to=$to, colon_pos=$colon_pos, bracketed=$bracketed";
            if( $colon_pos>-1 ){
               $k=expression($to+2,$colon_pos-1,0);
               return -255 if( $k<0 );

            }else{
               $k=expression($to+2,$#ValClass,0);
               return -255 if( $k<0 );
            }
            gen_chunk(' if ');
            $k=$split+1;
            if($bracketed) {                            # issue 52
               if( $to==$k+2){
                  $k++;
                  gen_chunk($ValPy[$k]); # expression consist of one token
                  $k+=3; # the next symbol after ')?'
               }else{
                  $k=expression($k+1,$to-1,0); # generate conditon without brackets
                  return -255 if ($k<0);
               }
            } else {
                  $k=expression($k,$to,0); # generate conditon
                  return -255 if ($k<0);
            }
            if ($colon_pos>-1){
               gen_chunk(' else ');
               $k=expression($colon_pos+1,$#ValPerl,0); # up to the very end
               return -255 if( $k<0 );
            }
            gen_chunk(", $number_of_elements)") if($number_of_elements);    # issue 56
	    gen_chunk(')') if($add_right_paren);		# issue 14
            gen_statement(); # output if line
            return $#ValClass;
         }else{
            $k=expression($split+1,$limit,0); # process expression without brackets -- last param is 0
            return -255 if( $k<0 );
            gen_chunk(", $number_of_elements)") if($number_of_elements);    # issue 56
	    gen_chunk(')') if($add_right_paren);		# issue 14
         }
      }
   }elsif( ($split=index($TokenStr,'~',$k))>-1) {
      $k=regex_and_translate($start,$k,$split,0);
      return $k+1;
   }elsif($#ValClass >= 3 && $ValClass[$start+1] eq '.' && $ValClass[$start+2] eq 'i') {        # SNOOPYJC $obj->method or $obj->method(args)
       $k = expression($start,$#ValClass,0);            # SNOOPYJC
       return -255 if( $k<0 );                          # SNOOPYJC
       return $k+1;                                     # SNOOPYJC
   }elsif($CurSub ne 'main') {  # issue 45
       ;                # issue 45: could be a return from a sub - just ignore it and don't give a warning
   }else{
      if($debug >= 1) {
          say STDERR "assignment - returns -255";
      }
      return -255;
   }
   return($#ValClass);
} # assignment

sub handle_assign_eval             # issue 42
#
# handle $var = eval {...} or $var = eval(...)
# arg1 = pointer to the eval
# returns 1 if we should not generate any code for the assignment
#
{
    my $exp = shift;            # pointer to the eval or x

    $was_block = gen_eval($exp, 1);
    $result = "$EVAL_RESULT$.";
    replace($exp, 's', $result, $result);
    if($exp != $#ValClass) {
        destroy($exp+1, $#ValClass-$exp);
    }
    if($was_block) {
        $eval_stack[-1]->{assignment} = package_code();
    }
    return $was_block;

} # handle_assign_eval

sub gen_eval                    # issue 42
{
    my $ep = shift;             # pointer to the eval start in @ValClass
    my $need_result = shift;

    if($need_result) {
        gen_statement("$EVAL_RESULT$. = None");
    }
    gen_statement('try:');                     # issue 42
    push @eval_stack,{eval_nest => $Pythonizer::CurNest, lno => $.};  # issue 42
    if(($ep < $#ValClass && $ValClass[$ep+1] eq '(') ||         # we have (...)
       ($ep == $#ValClass && $line =~ /eval;/)) {              # we have $val = eval; -or just- eval;
        correct_nest(1, 1);
        gen_statement('EVAL_ERROR = None');                     # issue 42
        #gen_chunk('subprocess.run(');
        if($need_result) {
            gen_chunk("$EVAL_RESULT$. = ");
        }
        gen_chunk("subprocess.run(['perl','-e',");
        if($ep == $#ValClass) {
            gen_chunk(q{"print +" + }, $DEFAULT_VAR);
        } else {
            insert($ep+2, '.', '.', ' + ');
            insert($ep+2, '"', '', qq{'print +'});
            my $end_pos = matching_br($ep+1);
            $k = expression($ep+2, $end_pos-1, 0);
        }
        gen_chunk('],capture_output=True,text=True,check=True).stdout');
        gen_statement();
        correct_nest(-1, -1);
        gen_statement('except Exception as _e:');               # issue 42
        correct_nest(1,1);                                      # issue 42
        gen_statement('EVAL_ERROR = _exc(_e)');                 # issue 42
        output_line('traceback.print_exc()') if($traceback);    # SNOOPYJC
        $Pyf{"_exc"} = 1;                       		# issue 42
        correct_nest(-1,-1);                                    # issue 42
        pop @eval_stack;                                        # issue 42
        return 0;
    }
    return 1;
}

sub package_code                 # issue 42
# Package up all the code in a cute little ref so we can generate it later
{
    my @_ValClass = @ValClass;
    my @_ValPerl = @ValPerl;
    my @_ValPy = @ValPy;
    my @_ValCom = @ValCom;
    my @_ValType = @ValType;
    return {class=>\@_ValClass, perl=>\@_ValPerl, py=>\@_ValPy, com=>\@_ValCom, type=>\@_ValType};
}

sub unpackage_code              # issue 42
# Restore the code from the cute little ref we created with package_code
{
    my $coderef = shift;

    @ValClass = @{$coderef->{class}};
    @ValPerl = @{$coderef->{perl}};
    @ValPy = @{$coderef->{py}};
    @ValCom = @{$coderef->{com}};
    @ValType = @{$coderef->{type}};
    $TokenStr=join('',@ValClass);
}

sub regex_and_translate
#
# process very tricky regex and tranlate function
#
{
my($start,$k,$split)=@_;
   say STDERR "regex_and_translate($start,$k,$split)" if($debug >= 3);  # SNOOPYJC
   if( $ValClass[$split+1] eq 'f' && $ValPerl[$split+1] eq 'tr'){
      # tr is a special case -- this is not regular expression
      if( $split-$k==1 ){
         gen_chunk($ValPy[$split-1],'=',$ValPy[$split-1],'.translate(',$ValPy[$split-1],$ValPy[$split+1],')'); # a=a.trasnlate(a)
      }else{
         $k=expression($start,$split-1,0); # can be array index or something  more problemtic ;-)
         return -255 if( $k<0 );
         gen_chunk('=');
         $k=expression($start,$split-1,0); # replicate the left part of the assignment
         gen_chunk('.translate(');
         $k=expression($start,$split-1,0); # replicate the left part of the assignment
         gen_chunk($ValPy[$split+1],')');
      }
      # next token
      $k=$split+1;
   }elsif( ($split=index($TokenStr,'~',$k))>-1 ){
      #regular expression $string =~ /cat/ or $string =~m/cat/
      # re.search(r'cat', string): ...
      if($ValClass[$split+1] eq 'q') {
         # match only; There is no variable to assign results
         if( substr($ValPy[$split+1],0,1) eq '.' ){
            $k=expression($start,$split-1,0); # generate left side of the regular expression
            return -255 if( $k<0 );
            gen_chunk($ValPy[$split+1],')'); # add dot part generated by scanner
         }else{
             gen_chunk($ValPy[$split+1]);
             $k=expression($start,$split-1,0); # generate left side of the regular expression, it can be array index or something even more problemtic ;-)
             return -255 if( $k<0 );
             if (index($ValPy[$split+1],':=')>-1){
                # issue 57: Generate proper code for when we're in list context or scalar context
                my $eq = index($TokenStr,'=');                          # issue 57
                if($eq > 0 && $eq < $split && ($ValClass[$eq-1] eq ')' || $ValClass[$eq-1] eq 'a')) {   # issue 57: list context
                    gen_chunk("),${DEFAULT_MATCH}.groups() if $DEFAULT_MATCH else [])[1]");         # issue 57, 32
                }elsif($eq > 0 && $eq < $split && $ValClass[$eq-1] eq 's') {                    # issue 57: scalar context
                    gen_chunk("),len(${DEFAULT_MATCH}.groups()) if $DEFAULT_MATCH else 0)[1]");         # issue 57, 32
                } else {                                                                        # issue 57
                    gen_chunk('))'); # close function bracket and expression
                }                                                                               # issue 57
             }else{
                gen_chunk(')'); # close function bracket and expression
             }
         }
         $k=$split+1;
      }elsif( $ValClass[$split+1] eq 'f' && $ValPerl[$split+1] eq 're' ){
         # this  is case of substirution
	 # issue 11: Handle the re.G flag which doesn't actually exist
	 $re_count = 1;				# issue 11
	 if($ValPy[$split+1] =~ /re\.G/) {	# issue 11
	     $re_count = 0;			# issue 11
	     $ValPy[$split+1] =~ s/.re\.G//;    # issue 11
	 }
         if( $split-$k==1 ){
            gen_chunk($ValPy[$split-1]); # a
            gen_chunk('=');              # a=
            if( substr($ValPy[$split+1],0,1) eq '.' ){
               gen_chunk($ValPy[$split-1].$ValPy[$split+1]); # a=a.find(string)
            }else{
	       # issue 11 gen_chunk("$ValPy[$split+1]$ValPy[$split-1])"); # a=re.sub(rexex,replacement,variable)
               gen_chunk("$ValPy[$split+1]$ValPy[$split-1],count=$re_count)"); # a=re.sub(rexex,replacement,variable,count=N)	# issue 11
            }
         }else{
            $k=expression($start,$split-1,0); # can be array index or something  more problemtic ;-)
            return -255 if( $k<0 );
            gen_chunk('=');
            if( substr($ValPy[$split+1],0,1) eq '.' ){
               $k=expression($start,$split-1,0); # replicate the left part of the assignment
               return -255 if( $k<0 );
               gen_chunk($ValPy[$split+1]);
            }else{
	       gen_chunk($ValPy[$split+1]);	# issue 11
               $k=expression($start,$split-1,0); # replicate the left part of the assignment
               return -255 if( $k<0 );
	       # issue 11 gen_chunk(')');
               gen_chunk(",count=$re_count)");	# issue 11
            }
         }
         # next token
         $k=$split+1;
      }else{
        return -255;
      }
   }
   return $k+1;
}

sub matching_br
# Find matching bracket, arase closeing braket, if found.
# Arg1 - starting position for scan
# Arg2 - (optional) -- balance from whichto start (allows to skip opening brace)
{
my $scan_start=$_[0];
my $balance=(scalar(@_)>1) ? $_[1] : 0; # case where opening bracket is missing for some reason or was skipped.
   for( my $k=$scan_start; $k<length($TokenStr); $k++ ){
     $s=substr($TokenStr,$k,1);
     if( $s eq '(' ){
        $balance++;
     }elsif( $s eq ')' ){
        $balance--;
        if( $balance==0  ){
           return $k;
        }
     }
  } # for
  return $#TokenStr;
} # matching_br

sub reverse_matching_br
# Find matching bracket, opening braket, if found.
# Arg1 - starting position for scan
# Arg2 - (optional) -- balance from whichto start (allows to skip closing brace)
{
my $scan_start=$_[0];
my $balance=(scalar(@_)>1) ? $_[1] : 0; # case where opening bracket is missing for some reason or was skipped.
   for( my $k=$scan_start; $k>=0; $k-- ){
     $s=substr($TokenStr,$k,1);
     if( $s eq ')' ){
        $balance++;
     }elsif( $s eq '(' ){
        $balance--;
        if( $balance==0  ){
           return $k;
        }
     }
  } # for
  return 0;
} # reverse_matching_br

#
# Extration of assignment statement from conditions and other places where Python prohibits them
# Added Nov 11, 2019
#
# SNOOPYJC: allow 2nd arg which means to leave lists intact
sub pre_assign
{
my  $assign_start=$_[0];
my  $assign_end=matching_br($assign_start);
   if($debug >= 3) {
	   say STDERR "pre_assign($assign_start, $_[1]), assign_end=$assign_end, =|$TokenStr|= @ValPerl\n"
   }
   ($assign_end<0) && return -255;
   if($ValClass[$assign_start+1] eq '!') {              # issue 58 - skip any "not" clause
       if($ValClass[$assign_start+2] eq '(') {
           $assign_start += 2;
           $assign_end = matching_br($assign_start);
        }
   }
   my $from=index($TokenStr,'=',$assign_start+2); # issue 58
   if($ValPy[$from] eq ':=') {                    # issue 58: generate a regular '=', not a walrus operator
       $ValPy[$from] = '=';                       # issue 58
   }                                              # issue 58
   assignment($assign_start+1,$assign_end-1);
   gen_statement();
#
# remove everytnogh but variable name. we need to shink arrrays
#
# issue 58 my $from=index($TokenStr,'=',$assign_start+2); # "=" now is next to identifier; should be
#issue 58 my $howmany=$assign_end-$from+1; # closed interval

   my $use_default_match = 0;
   for(my $i = $from+1; $i <= $#ValClass; $i++) {
       if($ValClass[$i] eq 'q' && ($ValPy[$i] =~ /$DEFAULT_MATCH:=/)) {
           $use_default_match = 1;
           last;
       }
   }
   my $howmany=$assign_end-$from;          # issue 58 - keep the ')'
   #say STDERR $TokenStr;
   if( $howmany>0 ){
       destroy($from,$howmany);
   }
   #say STDERR $TokenStr;
   # issue 58 # Remove opening bracket -- it is no longer needed
   # issue 58 destroy($assign_start,1);
   #
   # issue 58: Replace ($this, $that) with $this, and ($this) with $this
   return if(scalar(@_) >=2);           # SNOOPYJC
   if($ValClass[$assign_start+1] eq '(') {
       my $end = matching_br($assign_start+1);
       my $comma = index($TokenStr,',',$assign_start+2);
       if($end > 0) {
           if($comma > $assign_start && $comma < $end) {
               destroy($comma,$end-$comma+1);         # remove from ',' to ')'
               #say STDERR $TokenStr;
           } else {
               destroy($end,1);
               #say STDERR $TokenStr;
           }
           destroy($assign_start+1,1);
           if($use_default_match) {
               replace($assign_start+1, 's', '$'.$DEFAULT_MATCH, $DEFAULT_MATCH);
           } else {
               insert($assign_start+1, 'f', 'defined', 'defined');
           }
           #say STDERR $TokenStr;
       }
    }
}

#
# Process all control statements
#
sub control
{
my $begin=$_[0];
   if($debug >= 3) {
	   say STDERR "control($begin) =|$TokenStr|= @ValPerl\n"
   }
   if( $begin<0 || $TrStatus<0  ){
      return -255;
   }
my $limit;
my ($hashpos,$end_pos,$end_br_pos,$k,$increment,$tempvar);
   $start=$begin+1;
   # issue paren   if( $ValPerl[$start] eq '(' ){
   # issue paren    $start++;
   # issue paren   }
   # issue paren   if($ValClass[-1] eq ')' ){
   if(index(substr($TokenStr,$start),')=') >= 0) {      # issue 58: complicated assignment in expression
       pre_assign($start);                              # issue 58
   }                                                    # issue 58
   $limit = $#ValClass;         # issue paren
   $hadparens = 0;		# issue paren
   if( $ValPerl[$start] eq '(' && $ValClass[-1] eq ')' && ($ValPerl[$begin] eq 'for' || $ValPerl[$begin] eq 'foreach' || $TokenStr !~ /=/)) {	# issue paren, issue 32 (walrus op has to be in parens - but skip the '=' in a 'for' loop)
      $hadparens = 1;		# issue paren
      Perlscan::destroy(-1); # eliminate last bracket  -- Perl does not enclose controlstatements in bralckts.
      Perlscan::destroy($start,1);				# issue paren
      $limit=$#ValClass; # exclude it from count
      if($debug >= 3) {
	   say STDERR "control-parens removed, begin=$begin start=$start =|$TokenStr|= @ValPerl\n"
      }
   }
   $limit = $_[1] if (scalar(@_) >= 2);         # issue 81


   if( $ValPerl[$begin] eq 'if'  || $ValPerl[$begin] eq 'unless' ){
	  # issue 18 if( $TokenStr eq 'c(i)') {
      if( $TokenStr eq 'ci' && !$LocalSub{$ValPy[$start]}) {	# issue 18, issue paren: at this point the '()' are gone
          # while(<SYSIN>)
          gen_chunk("$ValPy[$start] $DEFAULT_VAR = $ValPy[$start+2]:"); # gen initial keyword     # issue 32
          return($#ValClass);
      } elsif($TokenStr eq 'cqrq' || $TokenStr eq 'cdrq') {             # SNOOPYJC: issue range
          $Pyf{'_range'} = 1;
          my $key = substr($Pythonizer::fname,0,length($Pythonizer::fname)-3).':'.$.;    # filename and line # as key - each range gets it's own storage
          my $pat1;
          my $flags1 = 0;
          if($ValClass[1] eq 'd') {
             $pat1 = $ValPy[1];
          } else {
             $ValPy[1] =~ /^re\.search\((.*),.*(?:,\s?flags=(.*))?\)/;
             $pat1 = $1;
             return -255 if(!$pat1);
             $flags1 = $2 if($2);
          }
          $ValPy[3] =~ /re\.search\((.*),(.*)(?:,\s?flags=(.*))?\)/;
          my $pat2 = $1;
          return -255 if(!$pat2);
          my $var = $2;
          return -255 if(!$var);
          $flags2 = 0;
          $flags2 = $3 if($3);
          gen_chunk("$ValPy[$begin] _range($var, $pat1, $flags1, $pat2, $flags2, '$key'):");
          return($#ValClass);
      }
      gen_chunk($ValPy[$begin]); # gen initial keyword
      if( $ValPerl[$begin] eq 'unless' ) { gen_chunk('('); }	# issue 20
      $k=expression($start,$limit,0); # last bracket was erased.
      return -255 if ($k<0);
      if( $ValPerl[$begin] eq 'unless' ) { gen_chunk(')'); }	# issue 20
      gen_chunk(':');
      return($#ValClass);
   }elsif( $ValPerl[$begin] eq 'while' || $ValPerl[$begin] eq 'until' ){
      # SNOOPYJC: Implement 'do':
      my $in_do = 0;
      if(defined $Perlscan::nesting_last && $Perlscan::nesting_last->{type} eq 'do') {
          my $lno = $Perlscan::nesting_last->{lno};
          $ValPy[0] =~ s/^while\s*/$DO_CONTROL$lno = (/;
          $in_do = 1;
          correct_nest(1,1);
          $Perlscan::nesting_last = undef;
      }
      # issue 18 if( $TokenStr eq 'c(s=i)' && substr($ValPerl[4],0,1) eq '<' ) {
      if( $TokenStr eq 'cs=i' && substr($ValPerl[4],0,1) eq '<' ) {	# issue 18, issue paren
         gen_chunk("$ValPy[0] $ValPy[2] in $ValPy[4]" );
      # issue 18}elsif( substr($TokenStr,$start) eq 'c(d)' && $ValPy[$start+2]==1  ){
      }elsif( substr($TokenStr,$start) eq 'd' && $ValPy[$start] eq '1' ){	# issue 18
          gen_chunk("$ValPy[0] True" ); # while(1) Perl idiom
      # issue 18}elsif( substr($TokenStr,$start) eq 'c(i)' ){
      }elsif( substr($TokenStr,$start) eq 'i' ){	# issue 18
	 # issue 18 gen_chunk("$ValPy[0] default_var in $ValPy[2]" ); # while(<stdin>)
         gen_chunk("$ValPy[0] ($DEFAULT_VAR:=$ValPy[1])" ); # while(<stdin>)	# issue 18, issue paren, issue 32
      }elsif( substr($TokenStr,$start) eq 'g' ){	# issue 66 - glob
	 save_code();                                   # issue 66
         gen_statement("$GLOB_LIST = $ValPy[$start]");  # issue 66
         restore_code();                                # issue 66
         gen_chunk("for $DEFAULT_VAR in $GLOB_LIST" );  # issue 66
      }else{
           gen_chunk($ValPy[$begin]); #while
           if ($ValClass[$start] eq '('){
              $TrStatus=expression($start,$limit,1); # gen expression
           }else{
              $TrStatus=expression($start,$limit,0); # gen expression
           }
      }
      if($in_do) {                      # SNOOPYJC
          gen_chunk(')');
          gen_statement();
          correct_nest(-1,-1);
      } else {
          gen_chunk(':');
      }
      return($#ValClass);
   # issue paren }elsif( $ValPerl[$begin] eq 'for' && $ValPerl[$begin+1] eq '('  && $ValClass[$begin+2] !~ /[ahf]/ ){
   }elsif( ($ValPerl[$begin] eq 'for' || $ValPerl[$begin] eq 'foreach') && $hadparens == 1 && $ValClass[$begin+1] !~ /[ahf]/ ){	# issue paren, issue foreach
      # regular for loop but can be foreach loop too
      if( $ValPerl[-1] eq '++'){
         $increment='';
      }elsif( $ValPerl[-1] eq '--'){
         $increment='-1';
      } elsif(index($TokenStr, ';((s=s+d)-d)') > 0) {   # issue 74 - replacement code for ++
         $increment='';                                 # issue 74
      } elsif(index($TokenStr, ';((s=s-d)+d)') > 0) {   # issue 74 - replacement code for --
         $increment='-1';                               # issue 74
      }elsif( index($TokenStr,';',$begin+1) < 0 ) {	# issue foreach: Expression returning an iterable
         gen_chunk($ValPy[$begin]);			# issue foreach
	 gen_chunk("$DEFAULT_VAR in ");			# issue foreach, issue 32
         if( ($range=index($TokenStr,'r',$begin+1)) != -1) {	# issue range
            gen_chunk('range(');				# issue range
	    $k=expression($begin+1,$range-1,0);			# issue range
            return -255 if ($k<0);				# issue range
	    gen_chunk(',');					# issue range
	    $k=expression($range+1,$limit,0);			# issue range
            return -255 if ($k<0);				# issue range
	    gen_chunk('+1)');					# issue range
         } else {						# issue range
            gen_chunk('(');				# issue foreach
            $k=expression($begin+1,$limit,0);		# issue foreach
            return -255 if ($k<0);			# issue foreach
            gen_chunk(')');				# issue foreach
         }							# issue range
         gen_chunk(':');				# issue foreach
         return $#ValClass;				# issue foreach
      }else{
         logme('S', "In the current version more complex increment than ++ or -- requires manual translation");
         $TrStatus=-1;
         return -255;
      }
      $start=$begin;
      gen_chunk($ValPy[$start]);
      # issue parens if ($ValClass[$start+2] eq ';'){
      # issue parens gen_chunk($ValPy[$start+3],' in range(',$ValPy[$start+3]);
      # issue parens $end_pos=$start+2;
      if ($ValClass[$start+1] eq ';'){		# issue parens
         gen_chunk($ValPy[$start+2],' in range(',$ValPy[$start+2]);		# issue parens
         $end_pos=$start+1;		# issue parens
      }else{
	 # issue parens gen_chunk($ValPy[$start+2]); # index var
         gen_chunk($ValPy[$start+1]); # index var
         gen_chunk('in range(');
         $start=index($TokenStr,'=',$start); # find initialization. BTW it can be expression
         if( $start == -1 ){$TrStatus=-1; return -255;}
         $start++;

         # find end of initialization
         $end_pos=next_same_level_token(';',$start,$limit); # end of expression

         if( $end_pos-$start==1 ){
             gen_chunk($ValPy[$start]);
         }else{
            $TrStatus=expression($start,$end_pos-1,0); # gen expression
            if( $TrStatus < -1 ){return -255;}
         }
      }
      gen_chunk(',');
      #
      # Analize loop exit condition
      #
      $start=index($TokenStr,'>',$end_pos); # fron last ;
      if( $start == -1 ){$TrStatus=-1; return -255; }
      $inc = '';			# issue foreach
      if($ValPerl[$start] eq '<=') {	# issue foreach
         $inc = '+1';			# issue foreach
      }elsif($ValPerl[$start] eq '>=') { # issue foreach
         $inc = '-1';			# issue foreach
      }					# issue foreach
      $start++;
      # find end of loopexit condition
      $end_pos=next_same_level_token(';',$start,$limit);
      if( $end_pos == -1 ){$TrStatus=-1; return -255; }
      if( $end_pos-$start==1 ){
          if($ValClass[$start] eq 'a'){
             gen_chunk($ValPy[$start]); # array as limit of the range
          }else{
             gen_chunk($ValPy[$start]); # all other cases of single limit of the range
          }
      }else{
         $TrStatus=expression($start,$end_pos-1); # gen expression for the limit of the range
         return -255 if ($TrStatus<0);
      }
      if( $inc ) {		# issue foreach
	 gen_chunk($inc);	# issue foreach
      }				# issue foreach
      # we already got increamnt at the begining
      if( $increment) {
         gen_chunk(",$increment):");
      }else{
        gen_chunk('):');
      }
      return($#ValClass);
   }elsif( $ValPerl[$begin] eq 'for' || $ValPerl[$begin] eq 'foreach' ){
      gen_chunk($ValPy[$begin]);
      if ($ValClass[$start] eq 's'){
         gen_chunk($ValPy[$start].' in ');
      }else{
         gen_chunk("$DEFAULT_VAR in ");         # issue 32
	 $start--;	# issue foreach
      }
      if( $hadparens == 1 ) {		# issue parens, foreach - we removed the parens, but in this case we need them!
	 insert($start+1,'(','(','(');	# issue parens
	 append(')',')',')');		# issue parens
      }
      $start=index($TokenStr,'(',$start);
      if( substr($TokenStr,$start) eq '(a)') {
         # loop over an array
           gen_chunk($ValPy[$start+1]);
      }elsif( substr($TokenStr,$start) eq '(h)') {              # SNOOPYJC: Looping over a hash in perl gives the keys and the values
         # loop over a hash
           gen_chunk('functools.reduce(lambda x,y:x+y,'.$ValPy[$start+1].'.items())');
      }elsif( substr($TokenStr,$start)=~/^\(f\(?h\)/ ){
         # foreach loop over a hash
         $start++; # skip '('
         if( $ValPerl[$start] eq 'keys' || $ValPerl[$start] eq 'values'  ){
             $hashpos=index($TokenStr,'h',$start);
	     # issue foreach gen_chunk("$ValPy[$hashpos]q$ValPy[$start]()"); # translate keys function into postfix notation
             gen_chunk("$ValPy[$hashpos]$ValPy[$start]"); # translate keys function into postfix notation # issue foreach
         } elsif($ValPerl[$start] eq 'sort') {          # SNOOPYJC: Sort the keys and values
             $hashpos=index($TokenStr,'h',$start);      # SNOOPYJC
             gen_chunk('sorted(list(functools.reduce(lambda x,y:x+y,'.$ValPy[$hashpos].'.items())))');  # SNOOPYJC
         }else{
	    say STDERR "FIXME: Can't handle 'for' with $ValPerl[$start]\n";	# SNOOPYJC
            $TrStatus=-1; return -255;
         }
      }elsif( substr($TokenStr,$start)=~/^\((['"qds](,['"qds])*)\)/ ){
         # loop over explisit list
         $tempvar='[';
         for(my $i=$start+1;$i<$#ValClass;$i++){
           $tempvar.=$ValPy[$i];
         }
         gen_chunk($tempvar,']');
      }elsif( ($range=index($TokenStr,'r',$start)) != -1) {	# issue range
         gen_chunk('range(');					# issue range
	 $k=expression($start+1,$range-1,0);			# issue range
         return -255 if ($k<0);					# issue range
	 gen_chunk(',');					# issue range
	 $k=expression($range+1,$#ValClass-1,0);		# issue range
         return -255 if ($k<0);					# issue range
	 gen_chunk('+1)');					# issue range
      }else{
         #$end_pos = matching_br($start);	# issue foreach
	 if( $ValPerl[$start] ne '(' || $ValPerl[-1] ne ')' || index(substr($TokenStr,$start), ',') >= 0) {	# issue foreach: This is a list - keep the parens
            $k=expression($start,$#ValClass,0); # issue foreach
	 } else {				# issue foreach
            destroy($#ValClass, 1);		# issue foreach - eat the right paren
            $k=expression($start+1,$#ValClass,0); # issue foreach: No list - no parens
	 }					# issue foreach
         return -255 if ($k<0);
	 # issue foreach $TrStatus=-1; return -255;
      }
      gen_chunk(':');
      return $#ValClass;
   }elsif( $ValPerl[$begin] eq 'assert' ) {             # SNOOPYJC
       gen_chunk('assert');
       $k=expression($start,$#ValClass,0);
       return -255 if ($k<0);
   }else{
      $TrStatus=-1; return -255;
   }
} # control

sub next_matching_token                 # SNOOPYJC
# get the next matching token
{
my $t=$_[0];
my $scan_start=$_[1];
my $scan_end=$_[2];
    $k = index(substr($TokenStr, $scan_start, $scan_end-$scan_start+1), $t);
    return $k if($k < 0);
    return $k + $scan_start;
} # next_matching_token

sub next_same_level_token
# get the next token on the same nesting level.
{
my $t=$_[0];
my $scan_start=$_[1];
my $scan_end=$_[2];
my $balance=0;
    # issue 74 for( my $k=$scan_start; $k<$scan_end; $k++ ){      # issue 74
    for( my $k=$scan_start; $k<=$scan_end; $k++ ){      # issue 74
      my $s=substr($TokenStr,$k,1);
      if( $s eq '(' ){
         $balance++;
      }elsif( $s eq ')' ){
         $balance--;
      }
      if($t eq ')') {            # SNOOPYJC: if we're looking for a ')', the balance needs to be -1
          return $k if($s eq $t && $balance < 0);
      } elsif( $s eq $t && $balance<=0  ){
          return $k;
      }
   } # for
   return -1; # not found
} # next_same_level_token

sub next_same_level_tokens
# get the next token on the same nesting level matching any given by first arg.
{
my $toks=$_[0];
my $scan_start=$_[1];
my $scan_end=$_[2];
my $balance=0;
    # issue 74 for( my $k=$scan_start; $k<$scan_end; $k++ ){      # issue 74
    for( my $k=$scan_start; $k<=$scan_end; $k++ ){      # issue 74
      my $s=substr($TokenStr,$k,1);
      if( $s eq '(' ){
         $balance++;
      }elsif( $s eq ')' ){
         $balance--;
      }
      my $p = index($toks, $s);
      if($p >= 0) {
          if($s eq ')') {       # SNOOPYJC: if we're looking for a ')', the balance needs to be -1
              return $k if($balance < 0);
          } elsif( $balance<=0  ){
              return $k;
          }
      }
   } # for
   return -1; # not found
} # next_same_level_tokens

sub function
# Built-in  functions processing
{
my $begin=$_[0];
my ($limit,$start );  # $limit is the position of closing bracket, if any
                      # start is the position of the first symbol after the opening bracket
  $start=$begin+1; # default start for parentheiss less function;
  my $end_pos=$limit=$#ValClass;           # SNOOPYJC
  if( scalar(@_)>1 ){
    $end_pos=$limit=$_[1];
  }
   if($debug >= 3) {
	   say STDERR "function($begin, $limit) =|$TokenStr|= @ValPerl\n"
   }
my $bracketed=0;  # nessesary for the proper call of expression.
  if( $begin==$#ValClass || (scalar(@_)>1 && $begin==$limit) ){
     $bracketed=-1; # serves as zero arg flag;
  }elsif( $begin<$#ValClass && $ValClass[$begin+1] eq '(' ){
    $bracketed=1;
    $limit=matching_br($begin+1);
    $start=$begin+2;  # function call with normal pathethis
    if( $ValClass[$limit] eq ')' ){ $end_pos=$limit-1; }
  # issue 16 }elsif( ($k=index($TokenStr,'0'))>=1 ){
  }elsif( ($k=index($TokenStr,'0',$begin+1))>=1 ){	# issue 16
      $end_pos=$limit=$k-1 if($k-1 < $end_pos); # if we have && that function should end before it
      $bracketed=-1 if($end_pos < $start);              # issue 59
  }elsif( ($k=index($TokenStr,'>',$begin+1))>=1 ){	# issue 16
      $end_pos=$limit=$k-1 if($k-1 < $end_pos); # if we have <,==,<=,>,>= that function should end before it
      $bracketed=-1 if($end_pos < $start);              # issue 59
  }elsif( ($k=index($TokenStr,'?',$begin+1))>=1 ){	# issue 16
      $end_pos=$limit=$k-1 if($k-1 < $end_pos); # if we have ? that function should end before it
      $bracketed=-1 if($end_pos < $start);              # issue 59
  }elsif( ($k=index($TokenStr,':',$begin+1))>=1 ){	# issue 16
      $end_pos=$limit=$k-1 if($k-1 < $end_pos); # if we have : that function should end before it
      $bracketed=-1 if($end_pos < $start);              # issue 59
  }elsif(scalar(@_)<2 && $begin != 0 && $ValClass[$begin-1] eq '(') {	# issue paren, issue 81
    # if the entire function call w/parameters is parenthesized, then the function ends
    # at the next right paren
    $end_pos=$limit=matching_br($begin-1)-1;		# issue paren
    if ($end_pos < $begin) {				# issue paren
       $end_pos=$limit=$#ValClass;			# issue paren
    }							# issue paren
  }elsif(scalar(@_)<2) {                                # issue 81
    $end_pos=$limit=$#ValClass;                         # issue paren: if we have (...f",") - then the ending paren isn't ours!
    if($ValClass[$end_pos] eq ')') {                    # issue paren
        $mb = reverse_matching_br($end_pos);            # issue paren
        if($mb < $begin) {                              # issue paren
            $end_pos=$limit-1;                          # issue paren
        }                                               # issue paren
    }                                                   # issue paren
  }
   if($debug >= 3) {
	   say STDERR "function start=$start, end_pos=$end_pos, bracketed=$bracketed";
   }
my ($k, $split, $split2, $delta, $dict, $incr, $arg1, $arg2, $perl_name, $py_name);
   if( $begin<0 || $TrStatus<0 ){
      $TrStatus=-255;  return -255;
   }
   $perl_name=$ValPerl[$begin];
   $py_name=$ValPy[$begin];
   #SNOOPYJC: See if this function has a special code module we need to include at the end
   if( !exists $Pyf{$py_name} ) {
     if( -e "$Pyf_dir/$py_name.py" ) {
	 $Pyf{$py_name} = 1;		#Include the module
     } else {
	 $Pyf{$py_name} = 0;		#No module to include
     }
   }
#
# At this point
#   $start is the first token after prath (if presnet)
#   $end_pos is the sybol befor closing paren, if present
#   $limit -- the last symbol that belongs to this function, Scanning will start from $limit+1
   if( $perl_name eq 'substr' ){
      # substr($line,$from, To )
      #        0    1 2   3 4  5
      if( substr($TokenStr,$start,$end_pos-$start+1) =~ /^s,([-]?d),([-]?d)/ ){
         # the simplest case when start and length of the substring are constants: substr($test,-1,1);
         $arg1=$ValPy[index($TokenStr,'d',$start)];
         $arg2=$ValPy[$end_pos];
         if( length($1) == 2 && substr($1,0,1) eq '-' ){ $arg1=-$arg1; }
         if( length($2) == 2 && substr($2,0,1) eq '-' ){ $arg2=-$arg2; }
         # issue 76 if( length($arg2)==1){
         if( $arg2==1){         # issue 76
            gen_chunk("$ValPy[$start]\[$arg1\]"); # single symbol
         }elsif( $arg1<0 && -$arg1>=$arg2 ){
             gen_chunk("$ValPy[$start]\[$arg1:\]"); # last symbol
         }elsif( $arg2>0 ){
             $arg2+=$arg1;
             gen_chunk("$ValPy[$start]\[$arg1:$arg2\]"); # positive length added to the first index
         }elsif($arg2<0) {
             gen_chunk("$ValPy[$start]\[$arg1:$arg2\]"); # negative value is not length but the position from the last
         }else{
             $TrStatus=-1;  return -255;
         }
         return $limit+1; # $limit is the position of closing bracket, if any
      }
      # more complex case with varibles or expression in iether second or the third arguments
      #step1 -- generate varible from which substing is extracted (can be an expression)
      if( substr($TokenStr,$start+1,1) eq ',' ){
         # Simplest case -- scalar varaible or constant is used
         gen_chunk($ValPy[$start]); # a simple first arg -- the name of the variable or a string
         $split=$start+1;
      }else{
         $split=next_same_level_token(',',$start,$end_pos);
         if( $split==-1 ){
            $TrStatus=-1;  return -255
         }
         $k=expression($start,$split-1,0);
         return -255 if ($k<0);
      }
      #
      # Processing of thesecond arg -- starting position. Can beconstant or expression
      #
      gen_chunk('['); # opening  bracket
      if( substr($TokenStr,$split,3) =~ /,(\-?)d[),]/){
         $arg1=( length($1)==1) ? -$ValPy[$split+1] : $ValPy[$split+1];
         $arg1=$ValPy[$split+1];
      }
      #determine if there are two or three argument
      $split2=next_same_level_token(',',$split+1,$end_pos);
      if( $split2>-1 ){
          # substr($line,$start,$lenth) -- the third argumant is present
          $k=expression($split+1,$split2-1,0); # generate the secong arg
          return -255 if ($k<0);
          if( $end_pos-$split2==1 && $ValClass[$end_pos] eq 'd'){
               #positive length
               $arg2=$ValPy[$end_pos];
               if ( $ValPy[$split2+1] == 1 ){
                  gen_chunk(']'); # substr($line,$a,1) -- the third arg is 1
                  return $limit+1;
               }
               gen_chunk(':');
               if( defined($arg1) ){
                  # rescn first arg and add the second
                  if ($arg1==0){
                     gen_chunk($arg2);
                  }else{
                     $arg2=$arg1+$arg2;
                     gen_chunk($arg2);
                  }
               }else{
                  $k=expression($split2+1,$end_pos,0);
                   gen_chunk("+$arg2");
               }
               gen_chunk("]");
          }elsif( $end_pos-$split2==2 && substr($TokenStr,$split2,3) eq ',-d' ){
              # third arg is negative constant. Can be used directly.
              gen_chunk(':');
              $arg2=-$ValPy[$end_pos];
              gen_chunk("$arg2]");
          }else{
             # general case of the third argument -- need to rescan the first and add the second
              gen_chunk(':');
             if (defined($arg1)){
               gen_chunk("$arg1+");
               $k=expression($split2+1,$end_pos,0);
               gen_chunk(']');
             }else{
                $k=expression($split+1,$split2-1,0); # generate secong argument again
                return -255 if ($k<0);
                gen_chunk("+");
                $k=expression($split2+1,$end_pos,0);
                return -255 if ($k<0);
                gen_chunk(']');
             }
          }
      }else{
         # substr($line,$start)
         $k=expression($split+1,$end_pos,0);
         return -255 if ($k<0);
         gen_chunk(':]');
      }
   }elsif( $perl_name eq 'index' || $perl_name eq 'rindex' ){
      # index(text,'search',from)
      #       0   1 2      3 4
      # string.find(text, substr, start)
      if( $ValClass[$start+1] eq ',' ){
         # Simplest case -- scalar varaible is used
         gen_chunk("$ValPy[$start]$py_name("); # line.find -- .find is now in scannet table Nov 15, 2019 --NNB
         $split=$start+2;
      }else{
         $split=next_same_level_token(',',$start,$end_pos); # next comma on the same nesting level
         $k=expression($start+2,$split-1,0);
         return -255 if ($k<0);
         gen_chunk("$ValPy[$start]("); # .find and opening  bracket
      }
      $split2=next_same_level_token(',',$split+1,$end_pos);
      # processing string to find
      if( $split2>-1 ){
          # index($line,$string,$start)
          if( $split+2==$split2 ){
             gen_chunk($ValPy[$split+1]);
          }else{
             $k=expression($split+1,$split2-1,0);
             return -255 if ($k<0);
          }
          gen_chunk(',');
          $k=expression($split2+1,$end_pos,0);
          return -255 if ($k<0);
          gen_chunk(')');
      }else{
         # index($line,'xxx') -> line.find('xxx')
         $k=expression($split,$end_pos,0);
         return -255 if ($k<0);
         gen_chunk(')');
      }
   }elsif( $perl_name eq 'join' ){
      # issue 40 $args=join(' ',@ARGS) => args=ARGS.join(' ');
      # $args=join(' ',@ARGS) => args=' '.join(ARGS)    # issue 40
      $split=next_same_level_token(',',$start,$end_pos);
      # issue 40 if($end_pos-$split==1 ){
      if($split < 0) {                  # issue 40 - no ",list" is present
         # the second argument is not expression or function
         # issue 40 gen_chunk($ValPy[$end_pos],$py_name); # gen array.join('');
         gen_chunk("''");       # issue 40 - join with no expr is an empty string
      }else{                    # issue 40
          # issue 40 $TrStatus=expression($split+1,$end_pos);
          # issue 40 return $TrStatus if ($TrStatus<0);
          # issue 40 gen_chunk($py_name); # gen .join
          # issue 40 }
         if( $split-$start==1 ){
             # issue 40 gen_chunk($ValPy[$start].')'); # gen delimiter
            gen_chunk($ValPy[$start]); # issue 40: gen delimiter
         }else{
            $TrStatus=expression($start,$split-1);
            return $TrStatus if ($TrStatus<0);
         }
         gen_chunk($py_name);           # issue 40: gen .join(
         if($end_pos-$split==1) {       # issue 40: one thing (a list)
             gen_chunk($ValPy[$end_pos]);       # issue 40: arr
         } else {                       # issue 40: Multiple things: make them into a tuple by adding an extra set of parens
            gen_chunk('(');             # issue 40
            $TrStatus=expression($split+1,$end_pos);       # issue 40
            return $TrStatus if ($TrStatus<0);             # issue 40
            gen_chunk(')');             # issue 40
         }
         gen_chunk(')');                                # issue 40
      }                         # issue 40
   }elsif( $perl_name eq 'open' ){
      $TrStatus=open_fun($begin,$end_pos,'f'); # open like function, for example in if
      return -255 if( $TrStatus < 0 );
   }elsif( $perl_name eq 'opendir' ){	# SNOOPYJC:
      $TrStatus=open_dir($begin,$end_pos,'f'); # open like function, for example in if
      return -255 if( $TrStatus < 0 );
   }elsif( $perl_name eq 'exists' ){
      # applicable to the elemnt of hash only
      $k=$start;
      if( $ValClass[$k] eq 's') {
         # issue 91 $dict=$ValPy[$k];
         # issue 91 $k+=2;
         return -255 if($ValClass[$end_pos] ne ')');
         my $key_start = reverse_matching_br($end_pos);
	 if ( $debug > 4 ) {
	    say STDERR "exists k=$k, key_start=$key_start, length(ValPerl)=$#ValPerl, end_pos=$end_pos, limit=$limit\n";
	 }
         # issue 91 if( $k+1<=$#ValPerl && $k+1==$end_pos ) {
         # issue 91    #single token between {}
         # issue 91    if( $ValClass[$k] eq 's' || $ValClass[$k] eq '"' || $ValClass[$k] eq "'"){
         # issue 91       gen_chunk("$ValPy[$k] in $dict");
         # issue 91       # issue parens return $k+3; # you need to skip two closing brackets: })
         # issue 91       return (($bracketed == 1) ? $k+3 : $k+2); # you need to skip one or two closing brackets: })    # issue parens
         # issue 91    }
         # issue 91    return -255;
         # issue 91 }else{
         # issue 91 $k=expression($k-1,$limit,1); #preserve brackets
         $k=expression($key_start+1,$end_pos-1,0);     # issue 91
         return -255 if ($k<0);
         gen_chunk('in');                       # issue 91
         $k=expression($start,$key_start-1,0);  # issue 91
         return -255 if ($k<0);
         # issue 91}
      }else{
        return -255
      }
   }elsif(substr($perl_name,0,1) eq '-') {
      #file predicate, always one agument
       gen_chunk($py_name.'('.$ValPy[$start].')');
       return $start+1;		# issue 19
   }elsif( $perl_name eq 'split' ){
      $k=$start; # pos of the first arg
      if ($k > $#ValClass || ($bracketed==1 && $ValPerl[$k] eq ')')){   # SNOOPYJC: handle ... = split;
         # special case of splitting default varible on white space
	 # issue split gen_chunk("default_var.split(' ')");
         gen_chunk("${DEFAULT_VAR}.split()");	# issue split - split on white space, issue 32
         # SNOOPYJC return $end_pos+1;
         return $limit+1;                       # SNOOPYJC
      }
      $arg1=$ValPy[$k];  # first argument is present
      $arg1type=$ValClass[$k];
      $flags = '';                      # issue 21
      if($arg1type ne '"' && $k+1 <= $#ValClass && $ValClass[$k+1] eq 'i') {    # issue 21: we have FLAGS!
          $k++;
          foreach my $flag (split(//,$ValPerl[$k])) {
              next if($flag eq 'g');            # 'g' flag is meaningless here
              $flags .= '|re.'.uc($flag);     
          }
          $flags =~ s/^\|/, flags=/;
      }
      if(($k+1) > $#ValClass || $ValPerl[$k+1] ne ','){	# SNOOPYJC
         # special case of splitting degaqult varible on white space
         # issue 21 if( $arg1 eq ' ' || $arg1type eq '"' ){
         if( $arg1type eq '"' ){                        # issue 21: string
            $arg1 ='' if($arg1 eq "' '");               # issue 21: string of ' ' is a special case
            gen_chunk("${DEFAULT_VAR}.split($arg1)");           # issue 32
         }else{
	    # issue 21 gen_chunk($py_name,"($arg1,default_var"); # this is a regex function
            gen_chunk($py_name,"($arg1, $DEFAULT_VAR$flags)"); # this is a regex function	# issue 21, issue 32
         }
         # SNOOPYJC return $end_pos+1;
         return $limit+1;                     # SNOOPYJC
      }
      $k+=2; # $k now points to the start of the second argument
      if( $k==$end_pos ){
         $arg2=$ValPy[$k];
         $k+=1;
         # issue 21 if( $arg1 eq ' ' || $arg1type eq '"' ){
	 # issue 21    gen_chunk("$arg2.lstrip($arg1");
         if( $arg1type eq '"' ){        # issue 21
            $arg1 ='' if($arg1 eq "' '");       # issue 21: string of ' ' is a special case
            gen_chunk("$arg2.split($arg1");	# issue 21
         }else{
            gen_chunk($py_name,"($arg1,$arg2$flags"); # issue 21: this is a regex function
         }
      }elsif( ($split=next_same_level_token(',',$k+1,$end_pos))>-1 ){
         #we have third argument to split
         if($arg1type eq '"') {                 # issue 21
            $k=expression($k,$split-1);         # issue 21
            if($arg1 eq "' '") {       # issue 21: string of ' ' is a special case
                gen_chunk(".split(maxsplit=");       # issue 21
            } else {
                gen_chunk(".split($arg1,");          # issue 21
            }
         } else {
            gen_chunk($py_name,"($arg1,");
            $k=expression($k,$split-1);
            return -255 if($k<0);
            gen_chunk(',');
         }
         $k=expression($split+1,$end_pos,0);
         return -255 if($k<0);
	 gen_chunk("-1");	        # issue 21: # of times to split is different in python
         gen_chunk($flags) if($flags);  # issue 21
      }elsif($arg1type eq '"') {        # issue 21: Expression with string pattern and 2 args
         $k=expression($k,$end_pos);	# issue 21
         $arg1 ='' if($arg1 eq "' '");       # issue 21: string of ' ' is a special case
         gen_chunk(".split($arg1");     # issue 21
      }else{			# issue 21: Expression with regex pattern and 2 args
         gen_chunk($py_name,"($arg1,");	# issue 21
         $k=expression($k,$end_pos);	# issue 21
         gen_chunk($flags) if($flags);  # issue 21
      }
      gen_chunk(')');
   }elsif($perl_name eq 'print' || $perl_name eq 'printf') {
      $TrStatus=print3($begin); # in Python3 this is a function
      if ($TrStatus<0) { return -255; }
   }elsif($perl_name eq 'defined' ) {
      # open used without parantethisi. always has one argument
      $k=$start;
      # issue 25 gen_chunk("$ValPy[$k] != none");
      if($k+1 <= $#ValClass && $ValClass[$k+1] eq '(') {        # issue 25 - array element or hash value
          $e = matching_br($k+1);                               # issue 25
          $k = expression($k, $e, 0);                           # issue 25
      } else {                                                  # issue 25
        gen_chunk("$ValPy[$k] is not None");		        # issue 25
      }                                                         # issue 25
      $k=($k+1<=$#ValPerl && $ValPerl[$k+1] eq ')') ? $k+2 : $k+1;
   }elsif($perl_name eq 'unshift' ){
      # unshift ARRAY,LIST
      # arrayOrList.insert(0 , element)
      $k=$start;
      # issue 38 gen_chunk($ValPy[$k],$py_name,$ValPy[$k+2],')');
      # issue 38 $k=($k+3<=$#ValPerl && $ValPerl[$k+3] eq ')') ? $k+4 : $k+3;
      my $comma = next_same_level_token(',',$start,$end_pos);      # issue 38
      return -255 if $comma<0;                                     # issue 38
      if ($debug > 4) {
         say STDERR "unshift $ValClass[$comma+1]\n";
      }
      $slice = '[0:0]';                         # issue 66
      # issue 66: fix unshift into @ARGV for the test
      if($k == $comma-1 && substr($ValPy[$k],-4,4) eq '[1:]') {     # issue 66 like sys.argv[1:]
          substr($ValPy[$k],-2,2) = ':0]';      # issue 66
          $slice = '';                          # issue 66
      }                                         # issue 66
      my $t=expression($k,$comma-1,0);          # issue 38 Gen the LHS
      return -255 if $t<0;                      # issue 38
      if( $ValClass[$comma+1] eq 'a' ){         # issue 38
         gen_chunk("$slice = ",$ValPy[$comma+1]); # unshift(@x,@y)
      }elsif($ValClass[$comma+1] eq '(' ){
          gen_chunk("$slice = [");
          $k=expression($comma+2,$end_pos-1,0);	# issue 38
          gen_chunk(']');                       # issue 38
      }elsif(index("sd-\"", $ValClass[$comma+1]) >= 0 || ($ValClass[$comma+1] eq 'i' && $comma+1 == $#ValClass)) {   # issue 38: scalar
	  gen_chunk("$slice = [");	        # issue 38
          $k=expression($comma+1,$end_pos,0);	# issue 38
	  gen_chunk(']');			# issue 38
      }else{
	  gen_chunk("$slice = ");	        # issue 38
     	  $Pyf{"_make_list"} = 1;		# issue 38
          gen_chunk("_make_list(");             # issue 38
          $k=expression($comma+1,$end_pos,0);	# issue 38
	  gen_chunk(')');			# issue 38
      }
      # issue 28 }elsif($perl_name eq 'shift' ){
   }elsif($perl_name eq 'shift' || $perl_name eq 'pop'){        # issue 28
      # assent only a single arg -- array; if no argument then it uses @_ array
      $bracketed=-1 if($bracketed!=-1 && index('>0+-*/',$ValClass[$start]) >= 0); # issue 28: pop has no arg if the next thing is an operator
      if( $bracketed==-1 ){
	  # issue 28 gen_chunk("perl_arg_array$py_name");
          gen_chunk("($PERL_ARG_ARRAY$py_name if $PERL_ARG_ARRAY else None)");	# issue 28, issue 32
          return $start;                       # issue 28
      # issue 28 }elsif( $end_pos==$start ){
      } else {          # issue 28
	 # issue 28 gen_chunk($ValPy[$start],$py_name);
         gen_chunk('(',$ValPy[$start],$py_name,"if",$ValPy[$start],"else", "None)");	# issue 28
         return $start+1;                       # issue 28
      # issue 28 }else{
      # issue 28    return -255;
      }
   }elsif($perl_name eq 'ord' || $perl_name eq 'chr') { # issue 59
      if( $bracketed==-1 ){
          gen_chunk("$py_name($DEFAULT_VAR)");
          return $start;                       # issue 28
      } 
      gen_chunk("$py_name(");
      $k=expression($start,$end_pos,0);
      return -255 if $k<0;
      gen_chunk(')');
      return $limit+1;
   }elsif($perl_name eq 'grep' || $perl_name eq 'map') {        # issue 60
       # grep expr, @arr
       # grep /pat/, @arr
       # grep(expr, @arr)
       # grep(/pat/, @arr)
       # map f, @arr 
       # map(f, @arr)
       # map{block} @arr (or list)
       # grep{block} @arr (or list)
       $k=$start;
       gen_chunk('list(');             # filter or map, convert to list so we can use len and subscript
       gen_chunk($py_name);
       $need_lambda = 1;
       if($perl_name eq 'map') {
           # See if we have an equiv python function that's like "chr", and not like ".lower()".
           if(($bracketed == 0 || $ValPerl[$begin+1] eq '(') && $ValClass[$start] eq 'f' && substr($ValPy[$start],0,1) ne '.') {
               gen_chunk('(', $ValPy[$start]);
               $need_lambda = 0;
            }
       }
       $comma = $end_pos+1;
       if($need_lambda) {
            gen_chunk("(lambda $DEFAULT_VAR:");
            $comma = next_same_level_token(',', $start, $end_pos);
            $comma = $end_pos+1 if $comma<0;
            if($start == $comma-1 && $perl_name eq 'grep') {    # singleton
                if(index('sd"', $ValClass[$start]) >= 0) {   # scalar, digits, or string
                    gen_chunk($DEFAULT_VAR,'==', $ValPy[$start]);
                } elsif($ValClass[$start] eq 'q') {      # pattern
                    if(substr($ValPy[$start],0,3) eq 're.') {
                        gen_chunk($ValPy[$start]);      # it's ready to go!
                    } else {
                        gen_chunk('re.search(', $ValPy[$start], ',', $DEFAULT_VAR, ')');
                    }
                } else {
                    return -255;
                }
            } elsif($start == $comma-1 && $ValClass[$start] eq 'f' && substr($ValPy[$start],0,1) eq '.') {      # function like ".lower()"
                  gen_chunk($DEFAULT_VAR, $ValPy[$start]);
            } elsif($start == $comma-1 && $ValClass[$start] eq 'i' && $LocalSub{$ValPy[$start]} && $perl_name eq 'map') {
     	          $Pyf{"_mapf"} = 1;		# Need extra function because perl uses global $_ instead of passing an arg
                  gen_chunk('_mapf('.escape_keywords($ValPy[$k]).", $DEFAULT_VAR)");
            } else {
                $k = expression($start, $comma-1, 0);
                return -255 if $k<0;
            }
       } elsif($bracketed == 1 && $ValPerl[$begin+1] eq '(') {
            $comma = next_same_level_token(',', $start, $end_pos);
       }
       gen_chunk(',');
       if($bracketed == 1 && $ValPerl[$begin+1] eq '{') {
           # We chopped our limit to the matching '}', so put it back!
           $limit = $#ValClass;
           $limit = $_[1] if(scalar(@_)>1);
           $k = expression($end_pos+2, $limit, 0);
       } else {
           $k = expression($comma+1, $limit, 0);
       }
       gen_chunk(')') if($ValPerl[$limit] ne ')');
       gen_chunk(')');   # close list(...)
   }elsif($perl_name eq 'sort') {                       # SNOOPYJC
       # sort @arr (or list)
       # sort f @arr
       # sort{block} @arr (or list)
       #
       # Gen call to sorted(list, key=..., reverse=...) - this returns a list
       #
       $k=$start;
       gen_chunk($py_name);
       if(!($bracketed == 1 && $ValPerl[$begin+1] eq '{') && 
           ($ValClass[$k] ne 'i' || ($k+1 < $#ValClass && $ValClass[$k+1] eq '('))) {        # sub but not sub()
         # Simple case of sort @arr -or- sort (list)
         gen_chunk('(');
         $TrStatus=expression($start,$end_pos,0);
         return -255 if ($TrStatus<0);
         gen_chunk(')');
         return $limit+1;
       }
       gen_chunk('(');
       # Generate the list as the first argument to python's sorted()
       if($bracketed == 1 && $ValPerl[$begin+1] eq '{') {
           # We chopped our limit to the matching '}', so put it back!
           $limit = $#ValClass;
           $limit = $_[1] if(scalar(@_)>1);
           # If bracketed == 1, then end_pos points just before the '}'
           if($end_pos+2 == $limit && $ValClass[$limit] eq 'h') {       # sort a hash sorts the keys and values in perl
               gen_chunk('functools.reduce(lambda x,y:x+y,'.$ValPy[$limit].'.items())')
           } else {
               $k = expression($end_pos+2, $limit, 0);
           }
       } elsif($start+1 == $limit && $ValClass[$limit] eq 'h') {        # sort a hash sorts the keys and values in perl
           gen_chunk('functools.reduce(lambda x,y:x+y,'.$ValPy[$limit].'.items())')
       } else {
           $k = expression($start+1, $limit, 0);
       }
       gen_chunk(', key=functools.cmp_to_key(lambda a,b:');
       if($bracketed == 0 && $ValClass[$start] eq 'i' && $LocalSub{$ValPy[$start]}) {
          $Pyf{"_sortf"} = 1;		# Need extra function because perl uses global $_ instead of passing an arg
          gen_chunk('_sortf('.escape_keywords($ValPy[$start]).", a, b)");
       } else {
           $k = expression($start, $end_pos, 0);
           return -255 if $k<0;
       }
       gen_chunk(')');   # Close the functools.cmp_to_key(...
       gen_chunk(')') if($ValPerl[$limit] ne ')');

   }elsif( $perl_name eq 'push' ){
      # push LHS, RSH => LSH.append(RSH) -or- LHS.extend(RHS)
      $k=$start;
      # issue 9 if( $ValClass[$k+2] =~ /[a"]/ ){
      # issue 9 }elsif( $ValClass[$k+2] eq 'a' ){
      my $comma = next_same_level_token(',',$start,$end_pos);      # issue 9
      return -255 if $comma<0;                                  # issue 9
      if ($debug > 4) {
         say STDERR "push $ValClass[$comma+1]\n";
      }
      my $t=expression($k,$comma-1,0);          # issue 9: Gen the LHS
      return -255 if $t<0;                                  # issue 9
      if( $ValClass[$comma+1] eq 'a' ){
         gen_chunk($py_name,$ValPy[$comma+1],')'); # issue 9: push(@x,@y)
      }elsif($ValClass[$comma+1] eq '(' ){      # issue 9
          gen_chunk($py_name.'[');              # issue 9
          $k=expression($comma+2,$end_pos-1,0);	# issue 9
          gen_chunk('])');
      }elsif(index("sd-\"", $ValClass[$comma+1]) >= 0 || ($ValClass[$comma+1] eq 'i' && $comma+1 == $#ValClass)) {   # issue 9: scalar
	  $py_name = '.append(';		# issue 9
	  gen_chunk($py_name);	                # issue 9
          $k=expression($comma+1,$end_pos,0);	# issue 9
	  gen_chunk(')');			# issue 9
      }else{
	  gen_chunk($py_name);	                # issue 9: .extend(
	  # issue 9 $k=expression($k+3,$end_pos,0);
     	  $Pyf{"_make_list"} = 1;		# issue 9
          gen_chunk("_make_list(");             # issue 9
          $k=expression($comma+1,$end_pos,0);	# issue 9
	  gen_chunk('))');			# issue 9
      }
   }elsif($perl_name eq 'delete' ){
      # open used without parantethisi. always has one argument
      # issue delete $k=($ValPerl[$start+1] eq '(') ? $start+2 : $start+1;
      $k=$start;              # issue delete
      if($ValClass[$k] eq 'a') {                # issue delete - handle delete @options{list of keys}
          gen_chunk("for _ in ");
          $e = matching_br($k+1);
          # special case for delete @options{keys %options);, as the default code will give an error
          # about modifying the dict in the loop.
          $gen_close = 0;
          if($ValClass[$k+2] eq 'f' && $ValPerl[$k+2] eq 'keys' &&
             $ValClass[$k+3] eq 'h' && $ValPerl[$k]) {
             gen_chunk("list(");
             $gen_close = 1;
          }
          my $kk=expression($k+2, $e-1, 0);
          return -255 if $kk<0;
          gen_chunk(')') if($gen_close);
          gen_chunk(':');
          gen_statement();
          correct_nest(1,1);
          gen_chunk($ValPy[$k],$py_name,'_,None)'); # delete($hash{$key}) => hash.pop($key)
          gen_statement();
          correct_nest(-1,-1);
      } else {
        gen_chunk($ValPy[$k],$py_name,$ValPy[$k+2],',None)'); # delete($hash{$key}) => hash.pop($key)
      }
   }elsif($perl_name eq 'sprintf' ){
      #$ValPy[$start] -- format string
      gen_chunk($ValPy[$start],' % ( '); # format string
      $k=expression($start+2,$end_pos,0); # skip initial',' and scan all variables
      return -255 if $k<0;
      gen_chunk(')'); #
   }elsif($perl_name eq 'undef'  ){
      # undef in Perl accepts list of arguments
      if( $bracketed==-1){
          if($begin != 0) {     # SNOOPYJC: don't gen code for "undef;", since it may be turned into a "return undef;"
            gen_chunk('None');
          }
      }else{
         if(index('?:,)', $ValClass[$start]) >= 0) {           # SNOOPYJC - undef by itself, followed by a ? : , or )
             gen_chunk('None');
             return $start;
         }
         # SNOOPYJC: If we know the type of the var, then init it to that value instead
         # If the var is used in a "defined" function, then the type is set to 'm' for mixed so
         # we init it to None.
         my @undefs = ($ValPy[$start]);                 # SNOOPYJC: new code
         for(my $i=$start+1; $i<$end_pos; $i+=2 ){
            last if ($ValClass[$i] ne ','); # check if the list endeded
            push @undefs, $ValPy[$i+1];
         }
         my $val = undef;
         foreach my $u (@undefs) {
             my $sval = 'None';
             if(exists $VarType{$u}{$CurSub}) {
                   $sval = init_val($VarType{$u}{$CurSub});
             }
             if(defined $val && $sval ne $val) {
                 $val = undef;
                 last;
             }
             $val = $sval;
         }
         if(defined $val) {     # they are all the same
            gen_chunk(join(' = ', @undefs));
            gen_chunk(" = $val"); # final assignment
         } else {               # do it one by one
            foreach my $u (@undefs) {
                gen_chunk("$u = ");
                my $val = 'None';
                if(exists $VarType{$u}{$CurSub}) {
                    $val = init_val($VarType{$u}{$CurSub});
                }
                gen_chunk($val);
                gen_statement();
            }
         }
     }
   }elsif($perl_name eq 'chomp' || $perl_name eq 'chop' ){      # SNOOPYJC
      if(index($TokenStr,'=') > 0) {            # SNOOPYJC chomp(my @a = <FH>);
          pre_assign($begin+1,1);
          $end_pos = $#ValClass-1;
          if($debug >= 3) {
	     say STDERR "after pre_assign: start=$start, end_pos=$end_pos, =|$TokenStr|= @ValPerl\n"
          }
      }
      if ($bracketed==-1){
          gen_chunk($ValPy[1].' = '.$DEFAULT_VAR.$py_name);         # issue 32: Be careful because $py_name contains '\n'
      }elsif ($start==$end_pos){
         if($ValClass[$start] eq 'a' || $ValClass[$start] eq 'h') {  # SNOOPYJC: Handle array or hash chomp
             if($ValClass[$start] eq 'a') {
                gen_statement("for _ in range(len($ValPy[$start])):");  # SNOOPYJC
             } else {
                gen_statement("for _ in $ValPy[$start]:");  # SNOOPYJC
             }
             correct_nest(1,1);                         # SNOOPYJC
             gen_chunk($ValPy[$start].'[_] = '.$ValPy[$start].'[_]'.$py_name);    # SNOOPYJC
             gen_statement();
             correct_nest(-1,-1);                       # SNOOPYJC
         } else {                                       # SNOOPYJC
             gen_chunk($ValPy[$start].' = '.$ValPy[$start].$py_name);
         }
      }elsif(index($TokenStr,',') > 0) {                      # SNOOPYJC
         for(my $i=$start; $i<=$end_pos; $i+=2 ){             # SNOOPYJC
            # SNOOPYJC last if ($ValClass[$i] ne ','); # check if the list endeded
            # SNOOPYJC gen_chunk($ValPy[$i],'=',$ValPy[$i],$ValPy[0],';');
            gen_chunk($ValPy[$i],' = ',$ValPy[$i],$ValPy[0]); # SNOOPYJC
            gen_statement();                                    # SNOOPYJC
         }
      } else {
          # What else??
      }
   }elsif($perl_name eq 'reverse') {            # issue 65 - implement 'reverse'
       if(substr($py_name,0,1) eq '_') {            # _reverse_scalar - scalar context
           # Optimize some special cases
           if($bracketed==-1) {
                gen_chunk($DEFAULT_VAR.'[::-1]');
           } elsif($start == $end_pos && $ValClass[$start] =~ /([as])/) {        # a single thing
               if($1 eq 'a') {  # a (array)
                   gen_chunk("''.join($ValPy[$start])[::-1]");
               } elsif($1 eq 's') {     # s (scalar)
                   gen_chunk("$ValPy[$start]".'[::-1]');
               } else {         # h (hash)
                   gen_chunk("{_v: _k for _k, _v in $ValPy[$start].items()}");
               }
           } else {
               gen_chunk($py_name);
               $Pyf{$py_name} = 1;
               gen_chunk('(');
               $make_tuple = 0;
               if($ValClass[$start] ne '(' && next_same_level_token(',',$start,$end_pos) >= 0) {
                  gen_chunk('(');
                  $make_tuple = 1;
               }
               $TrStatus=expression($start,$end_pos,0);
               return -255 if ($TrStatus<0);
               gen_chunk(')') if($make_tuple);
               gen_chunk(')');
           }
       } else {
           if($bracketed==-1) {
               gen_chunk($DEFAULT_VAR);        # reversing a list of 1 element = identity
           } elsif($start == $end_pos && $ValClass[$start] eq 'h') {        # a single hash
               gen_chunk("{_v: _k for _k, _v in $ValPy[$start].items()}");
           } else {
               gen_chunk('(');
               $TrStatus=expression($start,$end_pos,0);
               return -255 if ($TrStatus<0);
               gen_chunk(')');
               gen_chunk($py_name);
           }
        }
   # SNOOPYJC }elsif($perl_name eq 'chop'){
   # SNOOPYJC gen_chunk("$ValPy[$start]=$ValPy[$start]".'[0,-1]');
   }elsif($perl_name eq 'GetOptions' && $bracketed==1 && (my $type = GetOptionsHandled($start, $end_pos))) { # issue 48
      GetOptions_fun($type, $start, $end_pos);                  # issue 48
   }elsif($perl_name eq 'binmode') {            # SNOOPYJC
       # binmode FH -or- binmode FH, "LAYER"
       my $fh = $start;
       my $ly = (($fh+2 <= $#ValClass) ? $fh+2 : undef);
       if(!defined $ly || $ValClass[$ly] ne '"') {
           $layer = ':raw';
       } else {
           $layer = $ValPerl[$ly];
       }
       my $mode = 'None';
       $mode = "'b'" if($layer eq ':raw' || $layer eq ':bytes');
       my $encoding = 'None';
       my $errors = 'None';
       $encoding = $1 if($layer =~ /:encoding=\((.*)\)/);
       if($layer eq ':utf8') {
           $encoding = 'UTF-8';
           $errors = "'ignore'";
       }
       $Pyf{'_binmode'} = 1;
       gen_statement("$ValPy[$fh] = _binmode($ValPy[$fh], mode=$mode, encoding=$encoding, errors=$errors)");
   }elsif($perl_name eq 'caller') {                     # SNOOPYJC
       if($bracketed == -1) {                  # no args
           gen_chunk(q(['main',__file__,sys._getframe(1).f_lineno]));
       } else {
           # definition here: https://perldoc.perl.org/functions/caller
           # note we leave some stuff out!
           gen_chunk("['main',__file__,(_f:=sys._getframe(");
           $TrStatus=expression($start,$end_pos,0);
           return -255 if ($TrStatus<0);
           gen_chunk(")).f_lineno,_f.f_code.co_name,_f.f_code.co_argcount,0,'',0,0,0,0]");
        }
   }elsif($py_name eq '.read') {                        # issue 10 - read or sysread
       my $fh = $start;
       my $sc = $fh+2;
       my $ln = $sc+2;
       my $of = $ln+2;
       if($begin == 0) {                # We don't care about the result
           if($of < $#ValClass && $ValClass[$of-1] eq ',') {
               gen_chunk("$ValPy[$sc]"."[$ValPy[$of]:] = $ValPy[$fh]$py_name($ValPy[$ln])");
           } else {
               gen_chunk("$ValPy[$sc] = $ValPy[$fh]$py_name($ValPy[$ln])");
           }
       } else {
           gen_chunk("(($ValPy[$sc]:=$ValPy[$fh]$py_name($ValPy[$ln])), len($ValPy[$sc]))[1]");
           if($of < $#ValClass && $ValClass[$of-1] eq ',') {
               logme('W',"Offset is not supported when the 'read' is in an expression. Translation is incorrect");
           }
       }

   }elsif( substr($py_name,0,1) eq '.' ){
      #Generic Perl built-in function which is a method in Python
      $ValPy[$limit]='' if $bracketed==1; # in this case we do not need to process closing bracket.
      $TrStatus=expression($start,$end_pos,0);
      return -255 if ($TrStatus<0);
      gen_chunk($py_name); # add method
   }else{
      gen_chunk($py_name);
      if ( $bracketed==-1 || $end_pos < $start){        # issue paren
         # zero arguments -- special case
         gen_chunk('()');
      # issue 13 }elsif( $end_pos==$start ){
      # issue 13   # single argument                            # issue 13: int(PI) needs to call PI([])!!
      # issue 13   gen_chunk('('.$ValPy[$start].')')
      }elsif( $bracketed==1 ){
         gen_chunk('(');		# Issue time
         $TrStatus=expression($start,$end_pos,0);
         return -255 if ($TrStatus<0);
         gen_chunk(')');		# Issue time
      }else{
         gen_chunk('(');
         $TrStatus=expression($start,$end_pos,0);
         return -255 if ($TrStatus<0);
         gen_chunk(')');
      }
   }
   return $#ValClass+1 if(!defined $limit);             # SNOOPYJC
   return $limit+1; # limit_1 always represnt the fist not scanned symbol for this function.
} #function

sub GetOptionsHandled           # issue 48: Can we handle this GetOptions call?
{
    # We handle 2 types of GetOptions calls.  
    # Type 1:  GetOption(\%hash, str, str, str, str, ...);
    # Type 2:  GetOptions(str => \$var, str => \$var, ...);
    my $start = shift;
    my $end_pos = shift;
    #
    # First we check for Type 1:
    #
    if($ValClass[$start] eq '\\' && $ValClass[$start+1] eq 'h') {
        for(my $i = $start+2; ($i+1) <= $end_pos; $i+=2) {
            return 0 if($ValClass[$i] ne ',');
            return 0 if($ValClass[$i+1] ne '"');
        }
        return 1;
    } else {            # Check for Type 2:
        for(my $i = $start; ($i+4) <= $end_pos; $i += 5) {
            return 0 if($ValClass[$i] ne '"');
            return 0 if($ValClass[$i+1] ne ':');
            return 0 if($ValClass[$i+2] ne '\\');
            return 0 if($ValClass[$i+3] ne 's' && $ValClass[$i+3] ne 'a');
            return 0 if($ValClass[$i+4] ne ',' && $ValClass[$i+4] ne ')');
        }
        return 2;
    }
}

sub GetOptions_split            # issue 48: Split the string GetOptions argument and return the pieces as a 3-array
{
    my $str = shift;
    my ($key, $op, $typ, $arr) = $str =~ /([A-Za-z0-9_-|]+)([:=!+]?)([a-z0-9]*)([\$\@\{\d,\}]*)/;
    my @keys = split /[|]/, $key;
    #say STDERR "GetOptions_split($str): keys = @keys\n";
    for(my $i=0; $i<scalar(@keys); $i++) {
        if(length($keys[$i]) == 1) {
            $keys[$i] = '-' . $keys[$i];
        } else {
            $keys[$i] = '--' . $keys[$i];
        }
    }
    $op = '' if(!defined($op));
    $typ = '' if(!defined($typ));
    $arr = '' if(!defined($arr));
    my %TypeMap = (s=>'str', i=>'int', f=>'float');
    $typ = $TypeMap{$typ} if(exists $TypeMap{$typ});
    #say STDERR "GetOptions_split($str) = (@keys, $op, $typ, $arr)\n";
    return (\@keys, $op, $typ, $arr);
}

sub GetOptions_fun              # issue 48: Generate code for GetOptions
{
    my $type = shift;           # 1 or 2
    my $start = shift;
    my $end_pos = shift;

    #gen_statement("import argparse");
    gen_statement("$ARG_PARSER = argparse.ArgumentParser(argument_default=argparse.SUPPRESS)");
    if($type == 1) {            # Type 1: GetOptions(\%hash, str, str, str...);
        for(my $i = $start+2; $i <= $end_pos; $i+=2) {
            my ($keys, $op, $typ, $arr) = GetOptions_split($ValPerl[$i+1]);
            gen_chunk("$ARG_PARSER.add_argument(");
            foreach my $key (@$keys) {
                gen_chunk("\"$key\", ");
            }
            $const = '""';
            $const = '0' if($typ eq 'int' || $typ eq 'float');
            if($typ =~ /\d+/) {
                gen_chunk("type=int, ");
                $const = $typ;
                $typ = 'int';
            } elsif($typ) {
                gen_chunk("type=$typ, ")
            }
            if($arr eq '%') {
                logme('S', "Sorry, GetOptions(...'$ValPerl[$i+1]'...) -  '%' hash option is not supported!");
                $TrStatus=-1;
            }
            $nargs = '';
            if($op eq ':') {
                $nargs = "'*'";
            } elsif($op eq '=') {
                $nargs = "'+'";
            }
            if($nargs) {
                if($arr eq '@') {
                    gen_chunk("action='append', ");
                } elsif($arr =~ /{(\d+)}/) {
                    gen_chunk("nargs=$1, ");
                } elsif($arr =~ /{,\d+}/ || $arr =~ /{,}/) {
                    gen_chunk("nargs=$nargs, ");
                } elsif($arr =~ /{0,\d+}/) {
                    gen_chunk("nargs='*', ");
                } elsif($arr =~ /{(\d+),(\d+)}/) {
                    if($1 eq $2) {
                        gen_chunk("nargs=$1, ");
                    } else {
                        gen_chunk("nargs='+', ");
                    }
                } elsif($op eq ':') {
                    gen_chunk("nargs='?', const=$const, ");
                }
            }
            if($op eq '+') {
                gen_chunk("action='count', default=0, ");
            }
            if($op eq '!' || $op eq '') {
                gen_chunk("action='store_true')");
                gen_statement();
            }
            if($op eq '!') {
                gen_chunk("$ARG_PARSER.add_argument(");
                foreach my $key (@$keys) {
                    next if(length($key) == 2);         # skip single flags
                    gen_chunk('"--no'.substr($key,2)."\", action='store_false', dest=\"".substr($key,2).'")');
                }
            } elsif($op ne '') {
                $Perlscan::PythonCode[-1] =~ s/, $/)/;           # Change the trailing ', ' to a ')'
            }
            gen_statement();
        }
        gen_statement("(${ARG_PARSER}_res, ${ARG_PARSER}_rem) = $ARG_PARSER.parse_known_args()");
        gen_statement("$ValPy[$start+1].update(vars(${ARG_PARSER}_res))");
        gen_statement("sys.argv[1:] = $PERL_ARG_ARRAY = ${ARG_PARSER}_rem");
    } else {                    # Type 2:  GetOptions(str => \$var, str => \$var, ...);
        for(my $i = $start; $i <= $end_pos; $i+=5) {
            my ($keys, $op, $typ, $arr) = GetOptions_split($ValPerl[$i]);
            gen_chunk("$ARG_PARSER.add_argument(");
            foreach my $key (@$keys) {
                gen_chunk("\"$key\", ");
            }
            $const = '""';
            $const = '0' if($typ eq 'int' || $typ eq 'float');
            if($typ =~ /\d+/) {
                gen_chunk("type=int, ");
                $const = $typ;
                $typ = 'int';
            } elsif($typ) {
                gen_chunk("type=$typ, ")
            }
            #say STDERR "typ=$typ\n";
            $dest = $ValPy[$i+3];
            if($arr eq '%' || $ValClass[$i+3] eq 'h') {
                logme('S', "Sorry, GetOptions(...'$ValPerl[$i]'=>\\\%$ValPerl[$i+3]...) -  '%' hash option is not supported!");
                $TrStatus=-1;
            }
            $nargs = '';
            if($op eq ':') {
                $nargs = "'*'";
            } elsif($op eq '=') {
                $nargs = "'+'";
            }
            if($nargs) {
                if($arr eq '@') {
                    gen_chunk("action='append', ");
                } elsif($arr =~ /{(\d+)}/) {
                    gen_chunk("nargs=$1, ");
                } elsif($arr =~ /{,\d+}/ || $arr =~ /{,}/) {
                    gen_chunk("nargs=$nargs, ");
                } elsif($arr =~ /{0,\d+}/) {
                    gen_chunk("nargs='*', ");
                } elsif($arr =~ /{(\d+),(\d+)}/) {
                    if($1 eq $2) {
                        gen_chunk("nargs=$1, ");
                    } else {
                        gen_chunk("nargs='+', ");
                    }
                } elsif($ValClass[$i+3] eq 'a') {
                    gen_chunk("action='append', ");
                } elsif($op eq ':') {
                    gen_chunk("nargs='?', const=$const, default=$dest, ");
                }
            }
            if($op eq '+') {
                gen_chunk("action='count', default=0)");
            }
            if($op eq '!' || $op eq '') {
                gen_chunk("action='store_true', default=bool($dest))");
                gen_statement();
            }
            if($op eq '!') {
                gen_chunk("$ARG_PARSER.add_argument(");
                foreach my $key (@$keys) {
                    next if(length($key) == 2);         # skip single flags
                    gen_chunk('"--no'.substr($key,2)."\", action='store_false', dest=\"".substr($key,2).'")');
                }
            } elsif($op ne '') {
                $Perlscan::PythonCode[-1] =~ s/, $/)/;           # Change the trailing ', ' to a ')'
            #} elsif($op ne '' && $op ne '+') {
                #gen_chunk("default=bool($dest))");
            }
            gen_statement();
        }
        gen_statement("(${ARG_PARSER}_res, ${ARG_PARSER}_rem) = $ARG_PARSER.parse_known_args()");
        gen_statement("${ARG_PARSER}_opts=vars(${ARG_PARSER}_res)");
        for(my $i = $start; $i <= $end_pos; $i+=5) {
            $dest = $ValPy[$i+3];
            my ($keys, $op, $typ, $arr) = GetOptions_split($ValPerl[$i]);
            my $key = @$keys[0];
            $key =~ s/^[-]+//;
            gen_statement("$dest = ${ARG_PARSER}_opts.get(\"$key\", $dest)");
        }
        gen_statement("sys.argv[1:] = $PERL_ARG_ARRAY = ${ARG_PARSER}_rem");
    }
}


sub open_fun
#
# Process Perl open statement
# assents three parameters
#   start --  Starting postion
#   limit --  End position
#   mode  -- 's' or 'f' statement or invocation in expression, or 'c' if it's an "if not open"
{
my ($start,$limit,$mode)=@_;
my $end_pos=($ValPerl[$start+1] eq '(') ? matching_br($start+1)-1 : $limit;
my($k,$myline, $target,$open_mode,$handle);
    #  open (SYSFORM,'>',$output_file ) || abend(__LINE__,"Cannot open file $output_file for");
   $k=($ValPerl[$start+1] eq '(') ? $start+2: $start+1;
   $handle=$ValPy[$k];
   unless( $ValClass[$k] =~ /[is]/ ){
      logme('W',"In open statement handle $ValPerl[$k] is not identifier or scalar variable. Translation might be incorrect");
   }
   $Constants{$handle} = 1 if $ValClass[$k] eq 'i';             # issue 13
   my $encoding = '';                   # SNOOPYJC
   my $errors = '';                     # SNOOPYJC
   my $dup = '';                        # SNOOPYJC
   my $variable_mode = '';
   $k+=2 if(  $ValPerl[$k+1] eq ',');
   # SNOOPYJC if( $ValClass[$k] eq '"' && ($k+1) <= $#ValClass && $ValClass[$k+1] eq ',' ){
   if( ($k+1) <= $#ValClass && $ValClass[$k+1] eq ',' ){
      if($ValClass[$k] eq '"') {
        # this is the second argument like in open(FILE,'>',$path);
        $open_mode=$ValPerl[$k]; # constant without quotes
        if(substr($open_mode,-1,1) eq '&') {    # SNOOPYJC: dup
            $dup = '&';                         # SNOOPYJC: dup
            substr($open_mode,-1,1) = '';       # SNOOPYJC: dup
        }
      } elsif($ValClass[$k] eq 's') {           # SNOOPYJC: Variable
        $open_mode = undef;                     # SNOOPYJC
        $variable_mode=$ValPy[$k];              # SNOOPYJC
      } else {                                  # SNOOPYJC
          return -1;                            # SNOOPYJC
      }                                         # SNOOPYJC
      $k+=2;
      if( $ValClass[$k] eq '"' || $ValClass[$k] eq 's' ){
          $target=$ValPy[$k];
      } elsif($ValClass[$k] eq 'i' && $LocalSub{$ValPy[$k]}) {
          $target=escape_keywords($ValPy[$k]).'([])';
      }
   }elsif( $ValClass[$k] eq '"'  ){
      # ValPerl does not preserve quotes
      # SNOOPYJC if( $ValPy[$k]=~/^(f?['"])([<->])+/ ){
      if( $ValPy[$k]=~/^(f?['"]+)\s*([<>+|-]*)([&]?)\s*(.*?)\s*([|]?)\s*(['"]+)$/) {        # SNOOPYJC
         $str_open=$1;          # SNOOPYJC
         $open_mode=$2;         # SNOOPYJC
         $dup=$3;               # SNOOPYJC
         $file=$4;              # SNOOPYJC
         $pipe=$5;              # SNOOPYJC
         $str_close=$6;         # SNOOPYJC
         if($open_mode eq '<-') {               # SNOOPYJC
             $target = "sys.stdin";
             $open_mode = undef;
         } elsif($open_mode eq '->') {
             $target = "sys.stdout";
             $open_mode = undef;
         } else {
             $target = $str_open.$file.$str_close;
         }
         if($pipe) {
             $open_mode = '-|';
         }
         # SNOOPYJC substr($ValPy[$k],length($1),1)='';
         # SNOOPYJC $target=$ValPy[$k];
      }
      if(defined $open_mode && $open_mode eq '' && $ValPy[$k] =~ /^['"]/) {   # SNOOPYJC: Not an 'f' string
         # implicit filemode
         $open_mode='<';
         $target=$ValPy[$k];
      }
   }elsif( $ValClass[$k] eq 's' ){
      # implicit filemode
      # issue 26 $open_mode='>';
      $open_mode=undef;		# issue 26
      if($k == $end_pos) {      # SNOOPYJC: Simple variable
          $target=$ValPy[$k];
      } else {                  # SNOOPYJC: Expression for target
          $target = undef;
      }
   }elsif( $ValClass[$k] eq 'i' && $LocalSub{$ValPy[$k]}) {
      $open_mode=undef;		# issue 26
      $target=escape_keywords($ValPy[$k]).'([])';
   }
   # SNOOPYJC if ($target eq '-' ) {
   # SNOOPYJC    $target='sys.argv[1]';
   # SNOOPYJC }
   if (defined $open_mode) {              # SNOOPYJC
       if(index($open_mode, ':') >= 0) {
           ($open_mode, $ext) = split /:/, $open_mode;
           $open_mode .= 'b' if($ext eq 'raw' || $ext eq 'bytes');
           if($ext =~ /encoding\((.*)\)/) {
               $encoding = ", encoding='$1'";
           } elsif($ext eq 'utf8') {
               $encoding = ", encoding='UTF-8'";
               $errors = ", errors='ignore'";
           }
       }
       if (exists($PyOpen{$open_mode}) ){     # SNOOPYJC
          $open_mode=$PyOpen{$open_mode}
       }else{
          logme('E',"The mode '$open_mode' in open statement needs to be manually translated to Python");
          $open_mode = '?';
       }
   }
   my $function = '_open';              # SNOOPYJC
   if(!defined $open_mode) {
      $function = '_open_dynamic';
      $Pyf{'_open'} = 1;
      $Pyf{'_dup'} = 1;
      $open_mode = '';
      $open_mode = ", $variable_mode" if($variable_mode);
   } else {
       $open_mode = ", '$open_mode'";
       if($dup) {
           $function = '_dup';
       }
   }
   $Pyf{$function} = 1;	# SNOOPYJC

   my $orig_mode = $mode;               # SNOOPYJC: Handle complex handle
   if($mode ne 's' && $handle !~ /^[A-Za-z0-9_]+$/) {
       $mode = 's';
       save_code();
   }
   if( $mode eq 'f' ){
     # SNOOPYJC logme('E',"In case of error open function in Python raises the FileNotFoundError exception. The code should be revised");
     # SNOOPYJC gen_chunk("($handle:=open($target,'$open_mode'))");
     if(defined $target) {                              # SNOOPYJC
        gen_chunk("($handle:=$function($target$open_mode$encoding$errors))");	# SNOOPYJC
     } else {                                           # SNOOPYJC
        gen_chunk("($handle:=$function(");              # SNOOPYJC
        expression($k,$end_pos,0);                      # SNOOPYJC
        gen_chunk("$open_mode$encoding$errors))");	# SNOOPYJC
     }
     # issue paren return $k+1 if ($ValClass[$k+1] eq ')');
     return $k+1 if ($ValPerl[$start+1] eq '(');
     # issue paren return $k+1;
     return $k;			# issue paren
   }elsif( $mode eq 's' ){
      $k+=2;
      if(defined $target) {                             # SNOOPYJC
         output_line("$handle = $function($target$open_mode$encoding$errors)");
      } else {
         gen_chunk("$handle = $function(");
         expression($k,$end_pos,0);                      # SNOOPYJC
         gen_chunk("$open_mode$encoding$errors)");
       }
   }elsif( $mode eq 'c' ){                      # Control statement, like if
      if(defined $target) {                     # SNOOPYJC
         output_line("if not ($handle:=$function($target$open_mode$encoding$errors)):");
      } else {
         gen_chunk("if not ($handle:=$function(");
         expression($k,$end_pos,0);                      # SNOOPYJC
         gen_chunk("$open_mode$encoding$errors)):");
      }
      $Perlscan::PREV_HAD_COLON = 1;
   } #if mode
   if($mode ne $orig_mode) {                    # SNOOPYJC: Handle complex handle like sys.stderr that can't appear in a :=
       restore_code();
       if($orig_mode eq 'f') {
           gen_chunk($handle);
       } else {
           output_line("if not $handle:");
           $Perlscan::PREV_HAD_COLON = 1;
       }
    }
   return $#ValClass;
} # open_fun

sub open_dir
#
# Process Perl opendir statement
# assents thrww parameters
#   start --  Starting postion
#   limit --  End position
#   mode  -- 's' or 'f' statement or invocation in expression, or 'c' for if not opendir
{
my ($start,$limit,$mode)=@_;
my $end_pos=($ValPerl[$start+1] eq '(') ? matching_br($start+1)-1 : $limit;
my($k,$myline, $target,$open_mode,$handle);
    #  open (SYSFORM,'>',$output_file ) || abend(__LINE__,"Cannot open file $output_file for");
   $k=($ValPerl[$start+1] eq '(') ? $start+2: $start+1;
   $handle=$ValPy[$k];
   unless( $ValClass[$k] =~ /[is]/ ){
      logme('W',"In opendir statement handle $ValPerl[$k] is not identifier or scalar variable. Translation might be incorrect");
   }
   $Constants{$handle} = 1 if $ValClass[$k] eq 'i';             # issue 13
   $k+=2 if(  $ValPerl[$k+1] eq ',');
   if( $ValClass[$k] eq 's' ){
      if($k == $end_pos) {      # SNOOPYJC: Simple variable
         $target=$ValPy[$k];
      } else {                  # expression
         $target = undef;
      }
   }elsif( $ValClass[$k] eq 'i' && $LocalSub{$ValPy[$k]}) {
      $target=escape_keywords($ValPy[$k]).'([])';
   }
   $Pyf{'opendir'} = 1;

   if( $mode eq 'f' ){
     #logme('E',"In case of error open function in Python raises the FileNotFoundError exception. The code should be revised");
     if(defined $target) {
        gen_chunk("($handle:=opendir($target))");
     } else {
        gen_chunk("($handle:=opendir(");
        expression($k,$end_pos,0);                      # SNOOPYJC
        gen_chunk("))");
     }
     return $k+1 if ($ValClass[$k+1] eq ')');
     return $k;
   }elsif( $mode eq 's' ){
      $k+=2;
      if($autodie) {
         if(defined $target) {
            output_line("$handle=opendir($target)");
         } else {
            gen_chunk("$handle=opendir(");
            expression($k,$end_pos,0);                      # SNOOPYJC
            gen_chunk(')');
         }
      } else {
        output_line('try:');
        correct_nest(1,1);
        if(defined $target) {
            output_line("$handle=opendir($target)");
        } else {
            gen_chunk("$handle=opendir(");
            expression($k,$end_pos,0);                      # SNOOPYJC
            gen_chunk(')');
            gen_statement();
        }
        correct_nest(-1,-1);
        output_line('except OSError as _e:');
        correct_nest(1,1);
        output_line('pass');
        correct_nest(-1,-1);
      }
   }elsif( $mode eq 'c' ){
      if($autodie) {
        if(defined $target) {
            output_line("if not($handle:=opendir($target)):");
        } else {
            gen_chunk("if not($handle:=opendir(");
            expression($k,$end_pos,0);                      # SNOOPYJC
            gen_chunk(")):");
        }
      } else {
        output_line('try:');
        correct_nest(1,1);
        output_line("$handle=None");
        if(defined $target) {
            output_line("$handle=opendir($target)"); # Opendir statement generation from collected info -- $handle and $target
        } else {
            gen_chunk("$handle=opendir(");
            expression($k,$end_pos,0);                      # SNOOPYJC
            gen_chunk(')');
            gen_statement();
        }
        correct_nest(-1,-1);
        output_line('except OSError as _e:');
        correct_nest(1,1);
        output_line('pass');
        correct_nest(-1,-1);
        output_line("if not $handle:");
        $Perlscan::PREV_HAD_COLON = 1;
      }
   } #if ValPerl
   return $#ValClass;
} # open_dir


sub expression
#
# Anything in round brackets, including the list
# Arg1 == (obligatory) starting point
# Arg2 -- limit  -- the last token to scan.
# Arg3 -- mode of operation
#         -1 - Put '' in ValPy for external brackets
#         0 - do not intefere with external blackets
#         1 -preserve round brackets
# Arg 4 -- if given set recursion level to 0
{
my $begin=$_[0];
   unless(defined($begin) ){
      logme('S',"Internal error is expression call -- starting position is not defined while processlike $.: $line" );
      return -255;
   }

my ($bracketed,$cur_pos,$limit,$mode,$split,$start,$prev_k,$end_pos,$pos);
   if( $begin<0 || $TrStatus<0 ){
       $TrStatus=-1; return -255;
   }elsif( $begin>$#ValClass ){
      $cur_pos=$#ValClass;
   }else{
      $cur_pos=$begin;
   }
   $start=$cur_pos;  # starting point possibly from && or ||  -- we need that for regular expressions.
   $mode=(scalar(@_)>2) ? $_[2] : 0; # $mode allows brackets to be supressed but only on recursion level 0
                                     # $mode 1 injects ( and ) if they are not present
   $limit=$#ValClass;
   $bracketed=0;
   if( scalar(@_)>1 ){
      $limit=$_[1];
   }elsif( $ValClass[$begin] eq '(' ){
         $limit=matching_br($begin);
   # issue 70 }else{
   # issue 70    $limit=$_[1];
   }
   # issue 90 $bracketed=1 if $ValClass[$begin] eq '(';
   $bracketed=1 if $ValClass[$begin] eq '(' && matching_br($begin) == $limit;   # issue 90
   $RecursionLevel++; # we are starting from 0
   if($debug >= 3) {
	   say STDERR "expression($begin, $limit, $mode) =|$TokenStr|= @ValPerl\n"
   }

   # issue 53: Change hash references to use ".get(...)" instead of "[...]"
   for(my $i = $begin; $i <= $limit; $i++) {    # issue 53
       if($ValClass[$i] eq '(' && $ValPy[$i] eq '[' && $ValPerl[$i] eq '{') {  # issue 53
           $l = matching_br($i);                        # issue 53
           next if($l < 0);                             # issue 53
           next if(index($TokenStr, '=') > $l);         # issue 53: skip if on lhs of assignment
           if(substr($TokenStr,$i,($l+1)-$i) !~ /[,:]/) {   # issue 53: don't change list or hash constant
               $ValPy[$i] = '.get(';                        # issue 53
               $ValPy[$l] = ')';                            # issue 53
           }
           $i = $l;
       }
   }


   #
   # we need tocoorect end_pos in case there is a closing bracket to $limit-1
   #
   $end_pos=$limit;
   if( $mode==1 && $bracketed==0 ){
       gen_chunk('('); # generate opening bracket, as requested
   }elsif( $mode==-1  && $ValClass[$begin]  eq '(' && $ValClass[$limit] eq ')'){
      # eliminate closing bracket
      $ValPy[$limit]='';
      $end_pos=$limit-1;
   }

   $prev_k=-1; # starting position of infinite loop preventor.
   while($cur_pos<=$limit ){
      if( $cur_pos < 0 || $TrStatus<0 ){
         $TrStatus=-1; return -255;
       }
       unless( defined($ValClass[$cur_pos]) ){
         say "Undefined ValClass at pos $cur_pos. Attempting to switch to debug  mode ";
         $DB::single = 1;
      }
      #
      $pos = next_same_level_tokens('0~', $cur_pos, $limit);    # issue 101
      if($pos != -1 && $ValClass[$pos] eq '~') {                # issue 101
         $cur_pos=regex_and_translate($cur_pos,$cur_pos,$pos); # issue 101
         next;                                                  # issue 101
      }                                                         # issue 101
      if( $ValClass[$cur_pos] eq '(' ){
         # generate bracket if mode=1 or recursion level is above zero
         gen_chunk($ValPy[$cur_pos]);
	 # issue 15 $cur_pos=expression($cur_pos+1,$end_pos,0); # preserve brackets
         my $match = matching_br($cur_pos);             # issue paren
         # SNOOPYJC: Handle [k=>v, ...] and (k=>v, ...) - needs to generate a list, not a hash (note not {...} brackets)
         if($ValPy[$cur_pos] ne '{') {
             for(my $i=$cur_pos+1; $i<$match; $i++) {
                 if($ValClass[$i] eq ':' && $ValPerl[$i] eq '=>') {
                     $ValPy[$i] = ',';
                 }
             }
         }
         $cur_pos=expression($cur_pos+1,$match-1,0); # preserve brackets	# issue 15, paren
         ($cur_pos<0) && return -255;
      }elsif(  $ValClass[$cur_pos] eq '<' ){
         gen_chunk('readline()');
         $cur_pos++;
      }elsif( $ValClass[$cur_pos] eq ')' ){
         $RecursionLevel--;
         gen_chunk($ValPy[$cur_pos]);
         # issue paren return $cur_pos+1;
         $cur_pos++;                    # issue paren
      }elsif( $ValClass[$cur_pos] eq '0' ){
         gen_chunk($ValPy[$cur_pos]);
         $start=$cur_pos=$cur_pos+1; # change starting point -- we need that for regular expressions.
       }elsif( $ValClass[$cur_pos] eq 'x' ){
         # execution of Unix uility via shell
          gen_chunk(qq{subprocess.run($ValPy[$cur_pos],capture_output=True,text=True,shell=True).stdout});
         $cur_pos++;
      }elsif( $ValClass[$cur_pos]=~ /[sf]/ ){
         # match in Puthon is library re.match
         # As the argument to =~ can be complex. currently we can transtalte only two simple case: a scalar and an element of array/hash
         $pos=next_same_level_token('0',$cur_pos,$limit); # limit  of search for '~' below
         $end_pos=( $pos>-1 )? $pos : (($bracketed ==1) ? $limit-1 : $limit); # limit scan to next && or ||
         #say STDERR "found s/f at $cur_pos, pos=$pos, end_pos=$end_pos, limit=$limit, bracketed=$bracketed";
         if( $end_pos-$cur_pos>=2 && $ValClass[$cur_pos] eq 's'
             && $ValClass[$cur_pos+1] eq '='  &&  $ValClass[$cur_pos+2] eq 'f' ){
            # can be method like while( $line=shift )
            gen_chunk($ValPy[$cur_pos],$ValPy[$cur_pos+1]);
            $cur_pos=function($cur_pos+2,$end_pos);
         # issue 90 }elsif( $end_pos-$cur_pos>1 && ($split=index(substr($TokenStr,$cur_pos,$end_pos-$cur_pos+1),'~'))>-1 ){
         }elsif( $end_pos-$cur_pos>1 && ($split=next_same_level_token('~',$cur_pos,$end_pos))>-1 && $split <= $end_pos) {     # issue 90, issue 99
            # REGEX processing $line=~/abc/
            # issue 90 $cur_pos=regex_and_translate($start,$cur_pos,$cur_pos+$split); # split is index from $cur_pos not abs index
            # issue 99 $cur_pos=regex_and_translate($start,$cur_pos,$split); # issue 90
            $cur_pos=regex_and_translate($cur_pos,$cur_pos,$split); # issue 90, issue 99
         }elsif( $ValClass[$cur_pos] eq 'f'){
            $cur_pos=function($cur_pos,$end_pos);
            ($cur_pos<0) && return -255;
         }else{
            gen_chunk($ValPy[$cur_pos]);
            $cur_pos++;
         }
      # issue uninit value }elsif( $cur_pos<$#ValClass && $ValClass[$cur_pos] eq 'i' && $ValClass[$cur_pos+1] eq '(' ){ 
      }elsif( $cur_pos<$#ValClass && $ValClass[$cur_pos] eq 'i' && $ValClass[$cur_pos+1] eq '(' ){ # issue uninit
         $end_pos=matching_br($cur_pos+1); # find balanced bracket for the current bracket
         if($end_pos+1<=$limit && $ValClass[$end_pos+1] eq '~') {            # issue 99
            $cur_pos=regex_and_translate($cur_pos,$cur_pos,$end_pos+1);         # issue 99
         } else {
             # issue 41 gen_chunk($ValPy[$cur_pos]);
             gen_chunk(escape_keywords($ValPy[$cur_pos]));
             if( $LocalSub{$ValPy[$cur_pos]} ){
                # Perl user defined function -- need to pass an array
                gen_chunk('([');
                # issue parens expression($cur_pos+2,$end_pos-1,0); # call without brackets
                expression($cur_pos+2,$end_pos-1,0) if($cur_pos+2 <= $end_pos-1); # call without brackets   # issue paren
                gen_chunk('])');
                $cur_pos=$end_pos+1;
             }elsif( $ValClass[$cur_pos+2] eq 'f' ){
                #built-in function
                gen_chunk('(');
                # issue paren function($cur_pos+2,$end_pos-1);
                function($cur_pos+2,$end_pos-1) if($cur_pos+2 <= $end_pos-1);       # issue paren
                gen_chunk(')');
             }else{
                #function of unknown origin
                logme("W","Function $ValPy[$cur_pos] is neither internal not built-in function. Please check the correspondence of arguments");
                expression($cur_pos+1,$end_pos,1); # preseve brackets
             }
             $cur_pos=$end_pos+1;
         }                                                                      # issue 99
      }elsif($ValClass[$cur_pos] eq 'i' && $ValPy[$cur_pos] eq $ValPerl[$cur_pos] && !inDotOp($cur_pos)) {	# issue 13
         $pos=next_same_level_tokens('0>~)',$cur_pos,$limit);           # issue 13, issue 99
         $end_pos=( $pos>-1 )? $pos-1 : (($bracketed ==1) ? $limit-1 : $limit);      # issue 13: limit scan to next && or ||, issue 99
         if($pos>-1 && $ValClass[$pos] eq '~') {                                   # issue 99
            $cur_pos=regex_and_translate($cur_pos,$cur_pos,$pos)-1;       # issue 99 (-1 is because we add 1 to it below)
         } elsif( $LocalSub{$ValPy[$cur_pos]} && ($cur_pos+1 > $#ValClass || $ValPerl[$cur_pos+1] ne '=>')){		# issue 13: local sub call with no parens
            if($cur_pos+1 <= $end_pos && $ValClass[$cur_pos+1] eq 'i' && 
               !$LocalSub{$ValPy[$cur_pos+1]} && !$Constants{$ValPy[$cur_pos+1]}) {    # SNOOPYJC: like new Package()
                gen_chunk($ValPy[$cur_pos+1], '.');
                gen_chunk(escape_keywords($ValPy[$cur_pos]));				# issue 13, issue 41
                $cur_pos++;
                if($cur_pos+1 <= $end_pos && $ValClass[$cur_pos+1] eq '(') {              # SNOOPYJC: eat the parens
                    $bracketed = 1;
                    $limit = matching_br($cur_pos+1);
                    $end_pos = $limit-1;
                    $cur_pos++;
                }
            } else {
                gen_chunk(escape_keywords($ValPy[$cur_pos]));				# issue 13, issue 41
            }
            gen_chunk('([');                                                            # issue 13
            $k = 0;                                                                     # issue 13
            $k=expression($cur_pos+1, $end_pos, 0) if($cur_pos+1 <= $end_pos);          # issue 13
            if($k < 0) { $TrStatus=-1; return -255; }                                   # issue 13
            gen_chunk('])');								# issue 13
            $cur_pos = $end_pos;                                                        # issue 13: we add one to it below
            $cur_pos++ if($bracketed == 1);                                             # issue 13
          } elsif ($Constants{$ValPy[$cur_pos]}) {                                      # issue 13: constant or file handle
            gen_chunk($ValPy[$cur_pos]);						# issue 13
          } elsif($cur_pos+1 <= $#ValClass && $ValClass[$cur_pos+1] eq 'i') {           # SNOOPYJC: Like new XXXX
              my $last_i;
              for($last_i = $cur_pos+1; $last_i <= $#ValClass; $last_i++) {
                  last if($ValClass[$last_i] ne 'i' && $ValClass[$last_i] ne '.');
              }
              $last_i--;
              #say STDERR "last_i = $last_i";
              if($last_i <= $#ValClass && $ValClass[$last_i] eq 'i') {
                  $ValPy[$last_i] .= ".$ValPy[$cur_pos]";                               # SNOOPYJC: Change new XXXX to XXXX.new
              } else {
                  gen_chunk($ValPy[$cur_pos]);
              }
	  } else {									# issue 13: bare word - treat as string
            gen_chunk("'".$ValPy[$cur_pos]."'");					# issue 13
	  }										# issue 13
	  $cur_pos++;									# issue 13
      }elsif($ValClass[$cur_pos] eq 'r') {		# issue range
         # See if this looks like a slice, then we can implement it
         if(inSubscript($cur_pos)) {                    # issue range/slice
             gen_chunk(':');                            # issue range/slice
         } else {
            logme('E',"'..' range operator not implemented outside of for loop");		# issue range
            gen_chunk($ValPy[$cur_pos]);							# issue range
         }
         $cur_pos++;									# issue range
      }elsif($ValClass[$cur_pos] eq '+' && ($cur_pos == 0 || $ValClass[$cur_pos-1] eq '(' ||
              ($ValClass[$cur_pos-1] eq 'f' && $ValPy[$cur_pos-1] eq 'print'))) {       # issue unary +
          $cur_pos++;                           # skip it
      }elsif($ValClass[$cur_pos] eq 'k' && $ValPerl[$cur_pos] eq 'sub') {               # issue 81: sub in expression
          gen_chunk('lambda s,f:');             # issue 81 - assume it's a signal handler
          my $walrus = 0;
          for(my $i = $cur_pos+1; $i <= $limit; $i++) {
              if($ValClass[$i] eq 'f' && $ValPerl[$i] eq 'die') {
                  $ValPy[$i] = '_die';                                  # Can't use "raise" in a lambda
                  $Pyf{'_die'} = 1;
              } elsif($ValClass[$i] eq '=') {
                  $ValPy[$i] = ':=';
                  $walrus = 1;
              }
          }
          my $s = $cur_pos+1;
          my $end_pos = matching_br($s);
          my $e = $end_pos-1;
          $e-- if($ValClass[$e] eq ';');
          gen_chunk('(') if($walrus);
          $k = expression($s+1, $e, 0);
          gen_chunk(')') if($walrus);
          if($k < 0) { $TrStatus=-1; return -255; }
          $cur_pos = $end_pos+1;
      }elsif($ValClass[$cur_pos] eq '=' && $ValPy[$cur_pos] eq '=' && inParens($cur_pos)) {           # issue assign in expr
          gen_chunk(':=');
          $cur_pos++;
      }elsif($ValClass[$cur_pos] eq ',' && $cur_pos == $#ValClass) {    # issue trailing ',' - ignore it!
          $cur_pos++;
      }else{
         gen_chunk($ValPy[$cur_pos]);
         $cur_pos++;
      }
      if( $cur_pos eq $prev_k ){
         logme("S","Internal error -- no progress in scanning expression from position $cur_pos");
         $TrStatus=-1;
         return -255;
      }
      $prev_k=$cur_pos
   }
   # issue 90 if( $mode==1 && $ValClass[$begin] ne '(' ){
   if( $mode==1 && $bracketed == 0){    # issue 90
      #we generated opening bracket, so let's geneerate closing
      gen_chunk(')');
   }
   $RecursionLevel--;
   if($cur_pos > $limit) {              # issue paren
       $cur_pos = $limit;               # issue paren
   }                                    # issue paren
   if($debug >= 3) {
       say STDERR 'expression returns ' . ($cur_pos+1);
   }
   return $cur_pos+1;
} #expression

sub inDotOp				# issue 13 - check to see if this bare word is involved in a "->" operation
{
    my $pos = shift;
    if($pos != 0) {
	return 1 if($ValClass[$pos-1] eq '.');
    }
    if($pos != $#ValClass) {
	return 1 if($ValClass[$pos+1] eq '.');
    }
    return 0;
}

sub inSubscript                            # is this '::' operator in an array subscript?
{
    my $pos = shift;

    my $close_p = next_same_level_token(')', $pos+1, $#ValClass);
    return 0 if($close_p < 0);
    return 0 if($ValPy[$close_p] ne ']');
    my $open_p = reverse_matching_br($close_p);
    return 0 if($open_p < 0);
    return 1 if($open_p < $pos);
    return 0;
}

sub inParens                            # is this '=' operator in a parenthesized expression?
{
    my $pos = shift;

    my $close_p = next_same_level_token(')', $pos+1, $#ValClass);
    return 0 if($close_p < 0);
    my $open_p = reverse_matching_br($close_p);
    return 0 if($open_p < 0);
    return 1 if($open_p < $pos);
    return 0;
}

sub handle_incr_decr                    # issue 74: handle ++ and -- in expressions
{
    my $start = shift;
    my $op_pos = shift;
    my $limit = shift;

    # determine if this is a ++$t or a $t++
    my $op = $ValPerl[$op_pos] eq '++' ? '+' : '-';
    my $rop = $ValPerl[$op_pos] eq '++' ? '-' : '+';
    my $pre_op = 0;
    my $lvalue_start;
    my $lvalue_end;
    if($debug >= 3) {
        print STDERR "handle_incr_decr($start, $op_pos, $limit) with $ValPerl[$op_pos]";
    }
    if($op_pos == 0) {
        return 0;               # we handle this case natively
    }
    if($op_pos+1 <= $#ValClass && $ValClass[$op_pos+1] eq 's') {
        $pre_op = 1;
        $lvalue_end = $lvalue_start = $op_pos+1;
        while($lvalue_end+1 <= $#ValClass && $ValClass[$lvalue_end+1] eq '(') {  # array sub or hash key
            $lvalue_end = matching_br($lvalue_end+1);
        }
    } elsif($op_pos == 0) {
        replace($op_pos, $op, $op, $op);
        if($debug >= 3) {
            say STDERR "- can't figure it out!";
        }
        return 0;               # Not sure what this is so ignore it
    } else {            # post op
        $lvalue_start = $lvalue_end = $op_pos-1;
        while($ValClass[$lvalue_start] eq ')') {        # Handle $num{$key}{$hour}++;
            $lvalue_start = reverse_matching_br($lvalue_start) - 1;
        }
        if($lvalue_start == 0 && $lvalue_end == 0) {
            return 0;                   # we handle this case natively
        }
    }
    if($debug >= 3) {
        print STDERR ", pre_op=$pre_op, lvalue_start=$lvalue_start, lvalue_end=$lvalue_end";
    }
    $inc = 0;
    if($lvalue_start != 0 && $ValClass[$lvalue_start-1] eq 'i' && $ValClass[$lvalue_start] ne '(' && $LocalSub{$ValPy[$lvalue_start-1]}) {
        # We have a sub call w/o parens here - since we may insert parens after the function reference,
        # we have to surround the entire set of args with parens to make sure we process it right
        $pos=next_same_level_tokens('0~',$lvalue_start,$limit); 
        $end_pos=( $pos>-1 )? $pos-1 : $limit;
        insert($end_pos+1, ')', ')', ')');
        insert($lvalue_start, '(', '(', '(');
        $inc = 2;
        $limit += 2;
        $op_pos++;
        $lvalue_start++;
        $lvalue_end++;
    }
    if($lvalue_start == $lvalue_end) {          # simple scalar - handle using the walrus operator
	 if($ValPy[$lvalue_start] =~ /^\(len\((.*)\)-1\)$/) { # issue 14 - increment or decrement array length
            $arrName = $1;			# issue 14
            save_code();
	    if($op eq '+') {	                # issue 14: add one element to array
	       gen_chunk("$arrName.append(None)");	# issue 14
	    } else {				# issue 14
	       gen_chunk("del $arrName".'[len('.$arrName.')-1:]');	# issue 14
	    }
            gen_statement();
            restore_code();
            destroy($op_pos, 1);            # remove the ++ or --
            if(!$pre_op) {      # post - need to adjust the value
                $ValPy[$lvalue_start] =~ s/-1\)$/-2\)/;
            }
            if($debug >= 3) {
                say STDERR " = ".(-1+$inc);
            }
            return -1+$inc;
        }
        if($pre_op) {                       # generate ($val:=$val+1) replacing ++$val
            destroy($op_pos, 1);            # remove the ++ or --
            $lvalue_start--;
            insert($lvalue_start+1, ')', ')', ')');
            insert($lvalue_start+1, 'd', '1', '1');
            insert($lvalue_start+1, $op, $op, $op);
            insert($lvalue_start+1, 's', $ValPerl[$lvalue_start], $ValPy[$lvalue_start]);
            insert($lvalue_start+1, '=', '=', ':=');
            insert($lvalue_start, '(', '(', '(');
            if($debug >= 3) {
                say STDERR " = ".(5+$inc);
            }
            return 5+$inc;           # how many we inserted
        } else {        # post op: generate (($val:=$val+1)-1) replacing $val++
            destroy($op_pos, 1);            # remove the ++ or --
            insert($lvalue_start+1, ')', ')', ')');
            insert($lvalue_start+1, 'd', '1', '1');
            insert($lvalue_start+1, $rop, $rop, $rop);
            insert($lvalue_start+1, ')', ')', ')');
            insert($lvalue_start+1, 'd', '1', '1');
            insert($lvalue_start+1, $op, $op, $op);
            insert($lvalue_start+1, 's', $ValPerl[$lvalue_start], $ValPy[$lvalue_start]);
            insert($lvalue_start+1, '=', '=', ':=');
            insert($lvalue_start, '(', '(', '(');
            insert($lvalue_start, '(', '(', '(');
            if($debug >= 3) {
                say STDERR " = ".(9+$inc);
            }
            return 9+$inc;           # how many we inserted
        }
    } else {            # array index or hashref - split it out
        # for pre:
        #   $arr[$ndx] += 1
        #   (... $arr[$ndx] ...)
        # for post:
        #   $arr[$ndx] += 1
        #   (... ($arr[$ndx]-1) ...)
       
        #
        # If we're replacing the entire statement, then just remove all the code since we are generating it
        #
        if($pre_op && $op_pos == 0 && $lvalue_end == $#ValClass) {      # entire line
            destroy($op_pos, 1);            # remove the ++ or --
            append('=', '+=', '+=');
            append('d', '1', '1');
            if($debug >= 3) {
                say STDERR " = ".(2+$inc);
            }
            return 2+$inc;
        } elsif(!$pre_op && $lvalue_start == 0 && $op_pos == $#ValClass) {      # entire line
            replace($op_pos, '=', "$op=", "$op=");
            append('d', '1', '1');
            if($debug >= 3) {
                say STDERR " = ".(1+$inc);
            }
            return 1+$inc;
        }
        save_code();
        if($pre_op) {
            insert($lvalue_end+1, '=', "$op= 1", "$op= 1");   # Not actually used but it tells expression() that we're on the LHS
        } else {
            replace($op_pos, '=', "$op= 1", "$op= 1");      # Not actually used but it tells expression() that we're on the LHS
        }
        $k = expression($lvalue_start, $lvalue_end, 0);
        if($pre_op) {
            destroy($lvalue_end+1, 1);      # remove the extra '=' we put in
        }
        gen_chunk(" $op= 1");            # += 1 or -= 1
        gen_statement();
        restore_code();
        if($debug >= 3) {
            print STDERR " =|$TokenStr|=, op_pos=$op_pos, ";
        }
        destroy($op_pos, 1);            # remove the ++ or --
        if($pre_op) {
            if($debug >= 3) {
                say STDERR " = ". (-1+$inc)." (arr/hash)";
            }
            return -1+$inc;
        } else {                # post op
            insert($lvalue_end+1, ')', ')', ')');
            insert($lvalue_end+1, 'd', '1', '1');
            insert($lvalue_end+1, $rop, $rop, $rop);
            insert($lvalue_start, '(', '(', '(');
            if($debug >= 3) {
                say STDERR " = ".(3+$inc);
            }
            return 3+$inc;
        }
    }
}

sub handle_cmp_spaceship                    # SNOOPYJC: Handle cmp and <=> operators
{
    my $start = shift;
    my $op_pos = shift;
    my $limit = shift;

    # Replace a cmp b with _cmp(a,b)
    # Replace a <=> b with _spaceship(a,b)
    # We determine where to stop by looking at the operator precidence chart here: https://perldoc.perl.org/perlop

    my ($a_start, $a_end, $b_start, $b_end);
    $a_end = $op_pos-1;
    for($a_start=$a_end; $a_start >= $start; $a_start--) {
        if($ValClass[$a_start] eq ')') {
            $a_start = reverse_matching_br($a_start);
        } elsif(index('&|^0r:?=,!(', $ValClass[$a_start]) >= 0) {
            next if($ValPerl[$a_start] eq '!');         # Distinguish ! from 'not', as ! is higher precidence than 'not'
            last;
        }
    }
    $a_start++;
    $b_start = $op_pos+1;
    for($b_end=$b_start; $b_end <= $limit; $b_end++) {
        if($ValClass[$b_end] eq '(') {
            $b_end = matching_br($b_end);
        } elsif(index('&|^0r:?=,!)', $ValClass[$b_end]) >= 0) {
            next if($ValPerl[$b_end] eq '!');         # Distinguish ! from 'not'
            last;
        }
    }
    $b_end--;
    insert($b_end+1, ')', ')', ')');
    my $pl = $ValPerl[$op_pos];
    my $py = $ValPy[$op_pos];
    replace($op_pos, ',', ',', ',');
    insert($a_start, '(', '(', '(');
    insert($a_start, 'f', $pl, $py);
    $Pyf{$py} = 1;      # Causes it to load the function from our library into the generated code
    if($debug >= 3) {
        say STDERR "handle_cmp_spaceship($start, $op_pos, $limit): a[$a_start:$a_end], b[$b_start:$b_end] = 3 (=|$TokenStr|=)";
    }
    return 3;           # How many things we added
}

sub handle_question_mark_colon                    # issue 52 handle ? : in expressions
{
    my $start = shift;
    my $q_pos = shift;
    my $limit = shift;
    # cond ? tval : fval
    my $c_pos = next_same_level_token(':', $q_pos+1, $limit);
    my $fval_start = $c_pos+1;
    #my $fval_end = next_same_level_tokens(',:!)', $fval_start+1, $limit)-1;
    my $tval_start = $q_pos+1;
    my $tval_end = $c_pos-1;
    my $cond_start = $start;
    my $cond_end = $q_pos-1;
    
    for($cond_start = $cond_end; $cond_start >= $start; $cond_start--) {
        if($ValClass[$cond_start] eq ')') {
            $cond_start = reverse_matching_br($cond_start);
        } elsif(index("(=,:kc", $ValClass[$cond_start]) >= 0) {
            last;
        }
    }
    $cond_start++;
    if($debug >= 3) {
        say STDERR "handle_question_mark_colon($start, $q_pos, $limit) cond=[$cond_start:$cond_end], fval=[$fval_start:], tval=[$tval_start:$tval_end]";
    }

    # we need to generate this code:
    #
    # tval if cond else fval
    replace($c_pos, ':', ':', 'else');
    for(my $i = $cond_end; $i >= $cond_start; $i--) {
        insert($c_pos, $ValClass[$i], $ValPerl[$i], $ValPy[$i]);
    }
    # now we have: cond ? tval cond else fval
    insert($tval_end+1, ':', '?', 'if');        # Needs to be an op with the same precedence, but not '?'
    # now we have: cond ? tval if cond else fval
    destroy($cond_start, $cond_end-$cond_start+2);
    # now we have: tval if cond else fval
    if($debug >= 3) {
        say STDERR "after handle_question_mark_colon: =|$TokenStr|=";
    }
    return 0;           # we have the same number of tokens as before
}

sub handle_negative_bareword                    # issue 88
{
    # given a -bareword, remove the - and put it in the bareword
    # arg = position of the '-'
    my $pos = shift;

    $ValPerl[$pos+1] = '-'.$ValPerl[$pos+1];
    $ValPy[$pos+1] = '-'.$ValPy[$pos+1];
    destroy($pos, 1);
    return -1;
}

sub handle_anonymous_sub_in_expression          # issue 81
{
    # given a "sub { ... }" in an expression, bust it out and replace it with an anonymous sub ref
    # arg1 = starting position
    # arg2 = position of "sub"
    # arg3 = end of line
    my $start = shift;
    my $pos = shift;
    my $limit = shift;
    state $anon_counter = 1;

    return if($pos == $limit || $ValClass[$pos+1] ne '(');
    my $close_br = matching_br($pos+1);
    my $fname = "$ANONYMOUS_SUB$anon_counter";
    $anon_counter++;
    insert($pos+1, 'i', $fname, $fname);
    $close_br++;
    control($pos, $close_br);
    $adjust = ($close_br - ($pos+2))+1;
    destroy($pos+2, $adjust);
    destroy($pos, 1);
    $adjust++;
    return -$adjust;
}

sub left_hand_substr
#
# Perl
#    substr(text, start, length)=replacement
# can be translated into Python:
#    text = text[:start] + replacement + text[start+length:]
# or
#    text = replacement.join(text[0:start],text[start+length:])
{
my  $equal_pos=index($TokenStr,'=');
# issue 70 my $comma_no=0;
# issue 70 state $temp_var=0;
# issue 70 my $var='';
my ($replacement,$k);

      if( $equal_pos == -1 ){
         return 255;
      }
      #
      # issue 70: recode it from scratch
      #
      # Potential issue with this code: if text or start contains an expression with
      # a function call or side effect, it will be run more than once!
      #
      $comma1 = next_same_level_token(',', 2, $equal_pos-1);
      $comma2 = next_same_level_token(',', $comma1+1, $equal_pos-1);
      $close_paren = matching_br(1);
      $k=expression(2, $comma1-1,0);      # text
      return -255 if($k<0);
      gen_chunk('=');
      $k=expression(2, $comma1-1,0);      # text
      gen_chunk('[:');
      $k=expression($comma1+1, $comma2-1,0);   # start
      return -255 if($k<0);
      gen_chunk("] + ");
      $k=expression($equal_pos+1);        # parse to the tail of the line  first starting from '='
      return -255 if ($k<0);
      gen_chunk(" + ");
      $k=expression(2, $comma1-1,0);      # text
      gen_chunk('[');
      $k=expression($comma1+1, $comma2-1,0);   # start
      gen_chunk('+');
      $k=expression($comma2+1, $close_paren-1,0);   # length
      gen_chunk(':]');
      return $close_paren+1;
      
      # issue 70 if( index(q(s'"qd),$ValClass[$equal_pos+1])>=1 && $#ValClass==$equal_pos+1 ){
      # issue 70 # $#ValClass==$equal_pos+1 means that we deal with =$str variant
      # issue 70 # substr($str,$from,$len)=$str2; -- no expression on the right part
      # issue 70 $replacement=$ValPy[$equal_pos+1]; # we can translate such subst in a single line
      # issue 70 }else{
      # issue 70 # we need a temp Variable to storethe replacement string
      # issue 70 $replacement="$REPLACEMENT$.";         # issue 32
      # issue 70 gen_chunk("$replacement.=");
      # issue 70 $k=expression($equal_pos+1); # parse the tail of te line  first starting from '='
      # issue 70 return -255 if ($k<0);
      # issue 70 gen_statement() # out the generated line
      # issue 70 }
      #
      # issue 70      if( $ValClass[1] eq '(' && $ValClass[2] eq 's' ){
      # issue 70         # the first argument should be scalar
      # issue 70        $var=$ValPy[2];
      # issue 70        gen_chunk("$var=$var".'[:');
      # issue 70      }else{
      # issue 70         return -255;
      # issue 70      }
      # issue 70       for( $k=4; $k<@ValClass; $k++ ){          # 4 is the position of "start"
      # issue 70          if( $ValClass[$k] eq ')' ){
      # issue 70            last;
      # issue 70          }elsif( $ValClass[$k] eq ',' ){
      # issue 70            $comma_no++;
      # issue 70            if( $comma_no==1 ){
      # issue 70               gen_chunk("] + $replacement + $var".'[('.$ValPy[$k-1]);
      # issue 70            }elsif( $comma_no==2 ){
      # issue 70               gen_chunk("+$ValPy[$k-1]:]");
      # issue 70            }
      # issue 70          }elsif( $ValClass[$k] eq 'f' ){
      # issue 70             $k=function($k);
      # issue 70             return -255 if ($k<0);
      # issue 70           }elsif( $ValClass[$k] eq '(' ){
      # issue 70             $k=expression($k+1);
      # issue 70             return -255 if ($k<0);
      # issue 70          }else{
      # issue 70            gen_chunk($ValPy[$k]);
      # issue 70            $k++;
      # issue 70          }
      # issue 70       } #for
      # issue 70       return $k;
} #left_hand_substr

__DATA__
def PostIncr(name, local={}):
    #Equivalent to name++
    if name in local:
        local[name]+=1
        return local[name]-1
    globals()[name]+=1
    return globals()[name]-1
def PostDecr(name, local={}):
    #Equivalent to name--
    if name in local:
        local[name]-=1
        return local[name]-1
    globals()[name]-=1
    return globals()[name]-1
