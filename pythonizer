#!/usr/bin/perl
## pythonizer -- Translator of the subset of Perl 5 to Python 3.8+
## Copyright Nikolai Bezroukov, 2019-2022.  Significant updates by Joe Cool (http://github.com/snoopyjc).
## Licensed under Perl Artistic license
##
## Automatic translation of most perl scripts to python 3.8+.
## Best works for Perl 4 subset of Perl 5 which typically is used in sysadmin scripts.
## Perl scripts that extensivly use references or OO require more extensive manual effort
##
## --- INVOCATION:
##
##   pythonizer [options] [file_to_process]
##
##--- OPTIONS:
##    -v -- verbosity 0 -minimal (only serious messages) 3 max verbosity (warning, errors and serious); default -v 1
##    -h -- this help
##    -t -- size of tab in the generated Python code (emulated with spaces). Default is 4
##    -m -- Make global variables into "my" filescope variables, else they use a separate global namespace
##    -M -- Turn off -m
##    NOTE: If neither -m nor -M are passed, the pythonizer uses heuristics to make a best guess here.
##    -s -- Attempt to run standard library functions thru pythonizer for use/require - not recommended!
##    -S -- Turn off -s
##    -p -- "import perllib" library instead of including functions inline to emulate perl built-in functions (default)
##    -P -- Turn off -p
##    -A -- Imply "use autodie;"
##    -T -- Perform a traceback in the generated code on errors
##    -V -- Imply "no autovivification qw(fetch delete exists store strict);"
##    -d    level of debugging  default is 0 -- production mode
##          0 -- Production mode
##          1 -- Testing mode. Program is autosaved in Archive (primitive versioning mechanism)
##          2 -- Stop at the beginning of statement analysys (the statement can be selected via breakpoint option -b )
##          3 -- More debugging output.
##          4 -- Stop at lexical scanner with $DB::single = 1;
##          5 -- output stages of Python line generation
##    -B N  -- for internal debugging - set breakpoint when processing input line N in the first pass
##    -b N  -- for internal debugging - set breakpoint when processing input line N in the second pass
##
##    If -m and -M are both NOT present, you may set these options and all other options in the
##    perl source file using a special comment of the form "# pragma pythonizer -flags".  You can also
##    spell the options out optionally prefixed by "no", like "# pragma pythonizer no implicit global my, traceback".
##--- PARAMETERS:
##
##    1st -- full pathname of file (only one argument accepted)
##
##--- OUTPUT:
##    filename.py will be generated in the same folder as the input file

#--- Development History
#
# Ver      Date        Who        Modification
# =====  ==========  ========  ==============================================================
# 0.010  2019/10/09  BEZROUN   Initial implementation
# 0.020  2019/10/10  BEZROUN   Revised structure of global arrays, Now we have four parallel arrays: TokenStr, ValClass ValPerl, ValPy
# 0.030  2019/10/11  BEZROUN   Recursion is used to expressions, but in certain cases when I need a look-ahead, bracket counting is used instead
# 0.040  2019/10/12  BEZROUN   Better listing for debugging implemented
# 0.050  2019/11/06  BEZROUN   Forgot almost everything after a month; revised code just to refreash memory. Tokenizer slightly improved
# 0.051  2019/11/07  BEZROUN   Assignment within logical expression is not allowed in Python 2.7. It is now translated correctly
# 0.060  2019/11/08  BEZROUN   post assignment conditions like "next if( substr($line,0,1) eq '') " are processed correctly
# 0.070  2019/11/11  BEZROUN   x=(v>0) ? y :z is now translated into ugly Python ternary operator which exists since Python 2.5
# 0.071  2019/11/11  BEZROUN   program now correctly translated 80% codelines of pre_pythonizer.pl
# 0.080  2019/12/27  BEZROUN   Array ValCom is introduced for the preparation of version 0.2 of pre-processor pre_pythonizer.pl
# 0.090  2020/02/03  BEZROUN   #\ means continuation of the statement.
# 0.091  2020/02/03  BEZROUN   Moved sub preprocess_line to Pythonizer
# 0.100  2020/03/16  BEZROUN   Reworked scanner
# 0.200  2020/08/05  BEZROUN   Abandoned hope to make it perfect.
# 0.210  2020/08/07  BEZROUN   Moved gen_output to Perlscan,  removed ValCom  from the exported list.
# 0.220  2020/08/07  BEZROUN   Diamond operator is processed as a special type of identifier.
# 0.230  2020/08/09  BEZROUN   gen_chunk moves to Perlscan module. Pythoncode array made local
# 0.230  2020/08/09  BEZROUN   more functions and statements implemented
# 0.240  2020/08/10  BEZROUN   postfix conditional like return if(rc>0) re-implemented differently via scanner buffer
# 0.250  2020/08/10  BEZROUN   split function is reimplemented and optimized in case there is plain vanilla string and not-regex.
# 0.251  2020/08/12  BEZROUN   Perl_default_var is renames into default_var
# 0.260  2020/08/14  BEZROUN   System variables in double quoted literals are now complied correctly. Perlscan.pm improved.
# 0.261  2020/08/14  BEZROUN   for loop translation corrected
# 0.270  2020/08/15  BEZROUN   getopts is now implemented in Softpano.pm to allow the repetition of option letter to set the value of options ( -ddd)
# 0.300  2020/08/17  BEZROUN   Python 3.8 now is default for generaion. Option -p introduced. -p 2 changes target version of Python to 2.7
# 0.310  2020/08/18  BEZROUN   f-strings are implemented for Python 3 mode instead of decompiling string into chunks
# 0.320  2020/08/20  BEZROUN   open statement and  (condition) && ... statement translation corrected
# 0.400  2020/08/22  BEZROUN   __DATA__ and POD statements are now processed. File filename.data is created for data file.
# 0.410  2020/08/24  BEZROUN   pre_pythonizer now refactors Perl script pushing subroutines to the top and creating main sub.
# 0.420  2020/08/25  BEZROUN   print recognized in constructs like if($debug){ print 'something';}.
# 0.430  2020/08/25  BEZROUN   Variables from other namespaces recognized.
# 0.440  2020/08/26  BEZROUN   FailedTrans flag is replaced with TrStatus flag. Failure now is determined by the negative value of the TrStatus flag.
# 0.450  2020/08/26  BEZROUN   Option - r (refactor) added
# 0.500  2020/08/31  BEZROUN   Regular expression processing competly reworked based on changed in  Perlscan
# 0.510  2020/08/31  BEZROUN   Special subroutine for putting regex in quote created in Perlscan.pm
# 0.520  2020/08/31  BEZROUN   Statement  $line=~/abc/ this is not assignment statement; In no metacharaters it should  be treated as string search.
# 0.530  2020/08/31  BEZROUN   Handling of __DATA and __END__ improved. Now they are not discarded but instead the separate file with extention.data is created.
# 0.540  2020/09/01  BEZROUN   Translation of function substr improved by recognizing several special cases.
# 0.550  2020/09/01  BEZROUN   Matching of groups corrected.
# 0.560  2020/09/02  BEZROUN   Translation of for and while improved.
# 0.570  2020/09/03  BEZROUN   Translation of ++ and --  implemented
# 0.580  2020/09/03  BEZROUN   Translation of function sprintf implemented
# 0.600  2020/09/08  BEZROUN   List on internal functions created. Translation of backquotes and open improved.
# 0.700  2020/09/17  BEZROUN   Basic global varibles detection added. Global statement generated for each local subroutine
# 0.800  2020/10/02  BEZROUN   More correct translation of array assignments. Globals initialiazed after main sub. Installer added
# 0.810  2020/10/05  BEZROUN   Pre-pythonizer by default does not create main subroutine
# 0.820  2020/10/06  BEZROUN   Function parsing rewritten to accomodate some "bracketless" cases which now became a norm in Perl
# 0.830  2020/10/08  BEZROUN   Implementation of postfix conditional is completly rewritten and now uses token buffering
# 0.840  2020/10/09  BEZROUN   state varibles now are prefixed with the name of sub to avoid conflict with globals
# 0.850  2020/10/12  BEZROUN   print translation improved; many fixes in lex analyser
# 0.860  2020/10/14  BEZROUN   Python 2.7 mode eliminated to simplify the code. Option -p removed. "since" test passed
# 0.870  2020/10/21  BEZROUN   Treatment of brackets systematised. The code of subroutine expression revised.
# 0.871  2021/05/10  BEZROUN   Minor corrections in the header. 
# 0.900	 2021/11/06  SNOOPYJC  Updates to handle many more cases.
# 0.901	 2021/11/08  SNOOPYJC  Fix issue 22 and issue with pyf folder
# 0.902	 2021/11/09  SNOOPYJC  Fix issues 13,23,24,25,26 and mismatched parens
# 0.903  2021/11/10  SNOOPYJC  Physically remove ( ) on control statements rather than just skipping the first and removing the second
# 0.904  2021/11/10  SNOOPYJC  Fix issues in for/foreach, including adding range support and proper loop termination if ">=" or "<=" is used. Generate proper code for split on space.
# 0.905  2021/11/11  SNOOPYJC  Fix issues 28, 29, 31
# 0.906  2021/11/14  SNOOPYJC  Fix issue 14, more fixes for issue 9, 13 and 28, issue 35, 36, 37, 38, and most of issue 39 (except interpolation in HereIs)
# 0.907  2021/11/15  SNOOPYJC  Fix issues 43, 44, more issue 37 (my $x=@a)
# 0.908  2021/11/15  SNOOPYJC  Fix issue 48
# 0.909  2021/11/16  SNOOPYJC  Handle more cases of issue 48, issue 49, additional fix for issue 44, issue 54, issue 52 (in assignment only), issue 50, issue 53, issue 45, issue 55, issue 56, issue 57, issue 58, issue 46, issue 59, issue 61, issue 62, issue 61, issue 62, issue 41, issue 45
# 0.910  2021/11/22  SNOOPYJC  Fix issue 63, issue with post-pass refactoring of multi-line strings, issue 64, addl fixes for issue 36 and issue 39, another issue 13 fix (array assignment of function call)
# 0.911  2021/11/23  SNOOPYJC  Another issue 49 fix ($ARGV), another issue 43 fix (${var} not in ...), issue 68, issue 65, issue 69, more issue 32 fixes, some pep8 enhancements to spacing, implement 'abs(...)', issue 74, issue 66, issue 75, issue 76, issue 42, issue 52, another issue 45 fix, isue 42, issue 73, issue 71
# 0.912  2021/11/29  SNOOPYJC  Fix coding error in perl_open (encoding)
# 0.913  2021/11/30  SNOOPYJC  issue 79, addl fix for issue 53, addl fix for foreach, addl fix for ++/--, add constants for open and flock
# 0.914  2021/12/01  SNOOPYJC  Fix missing _time, add _flock, fix references to $!, issue 81
# 0.915  2021/12/02  SNOOPYJC  Additional issue 81 fixes, add -A for autodie and -T for traceback, fix issue with globals on sub's with ()
# 0.916  2021/12/03  SNOOPYJC  issue 60: implement grep and map
# 0.917  2021/12/04  SNOOPYJC  Addl fix for issue 60 - map with user functions, fix ref, generate proper code for $#ARGV, generate no code for labels and warn on label refs, fix .. range if preceded by a digit, use _open for all open calls, implement binmode, fix extra paren on split, add type computation and init variables appropriately, fix state vars, change undef to use type appropriate assignment, issue 82
# 0.918  2021/12/06  SNOOPYJC  addl issue 39 fix, compute types of user subs, add sqrt, fix _flock typo, more type analysis, issue 85, fix undef, fix | open, issue 86, fix get_globals
# 0.919  2021/12/08  SNOOPYJC  Set nest to 0 after pass 1, allow ' in varnames (old perl syntax for ::), fix infinite recursion in expr_type, fix := in assignment in expression by fixing next_same_level_token(s) for parens, issue 88, extra issue 50 fix for $$xxx, addl fix for issue 45 with function call as last statement
# 0.920  2021/12/09  SNOOPYJC  issue 89, issue 90, addl fix for $t-timegm issue 88, add timegm(), issue 91
# 0.921  2021/12/10  SNOOPYJC  Fix if not(open(FH,...)), add rename, fork, implement range (..) operator in slice, issue 84, fix open/opendir in control stmt
# 0.922  2021/12/10  SNOOPYJC  issue 93, fix foreach (%hash), @arr = keys %hash, @arr = values %hash, @arr = %hash, ignore var defs alone, handle modelsss constant open, handle sed/awk style range, implement each
# 0.923  2021/12/12  SNOOPYJC  Add wait() using _wait(), fileparse() using _fileparse(), fix open/opendir with filename expression, issue 94
# 0.924  2021/12/13  SNOOPYJC  issue 95, implement do{...}while/until(...);, PERL5PATH is now automatic, addl fix for issue 93, issue 96, remove double ++/-- fix, remove warning on 1;, issue 99
# 0.925  2021/12/14  SNOOPYJC  Addl fixes for issue 21 (split), issue 45 (was putting orig lines in wrong place), issue 58 on elsif, fix opendir not found error, issue 98, issue 100, remove extra 'r' after regex, issue 101
# 0.926  2021/12/15  SNOOPYJC  Addl fix for issue 93, uniquely map tokens to get precedence, issue 102, update to ending fix in double_quoted string
# 0.927  2021/12/16  SNOOPYJC  Revamp the time functions, use *arr for passing arrays, use map(str,...) for join of int array
# 0.928  2021/12/19  SNOOPYJC  Rename vars that clash with built-in functions like len, etc., fix _each, issue 103, issue 104, implement automatic type conversion, issue 105, issue 106
# 0.929  2021/12/20  SNOOPYJC  issue 107, fix _open if result is checked, implement $| and FD->autoflush(), fix problem with vartypes for globals vars, use _i as temp loop index instead of _
# 0.930  2021/12/21  SNOOPYJC  Check var references in interpolated strings for auto-init
# 0.931  2021/12/22  SNOOPYJC  Interpolate in HERE strings, issue 92
# 0.932  2021/12/23  SNOOPYJC  Fix foreach loop with array range, fix range index to include last, addl fix for issue 92, issue 109, remove blank lines at start of output, change not X is not None => X is None
# 0.933  2021/12/23  SNOOPYJC  Additional fix for issue 106, issue 110, addl fix for issue 45, handle $/, $. with issue 66
# 0.934  2021/12/25  SNOOPYJC  One more fix for issue 106, issue 108 (implement local), addl fix for issue 43 with @ and %, use a simpler _readline if the program does not use $. or $/, suppress generation of EVAL_ERROR if $@ is not used
# 0.935  2021/12/26  SNOOPYJC  Chg type of optional second arg to mkdir to int, chg type of ENV and os.environ so _str() is called, remove [] on args and only copy to a list if used in shift or pop, only die on return outside a function in main.
# 0.936  2021/12/29  SNOOPYJC  Fix issue 84 with 2 subscripts, fix caller to return None if in main, allow E in float exponent, shift(@arr) caused extra ), fix @_ in assignment where it's still a tuple, proper code generation for sub call statement with array arg, implement rand
# 0.937  2021/12/30  SNOOPYJC  issue 111, issue 112, issue 113, default to -v 2, print code on stdout only if -v 3, print warnings at -v 2
# 0.938  2022/01/10  SNOOPYJC  Fix STMT for LIST and do{...} if/unless EXPR; fix _list_of_n() with short tuple as arg, implement dirname(), filepath(), replace basename(), splat out map() if used as arg, implement use and require, handle $. on LHS assignment, implement more special vars, handle goatse, set v5.034, implement use constant, handle names with multiple sets of ::, implement carp, $| needs to autoflush STDERR too, add seek, tell, reimplement stat and lstat, use full topological sort on sub placement, implement remaining -X operators, fix function return insertion if line has a comment, fix issue with order of comments being reversed, fix variable variables, fix assignment to ARGV[i], handle vNN version strings, handle ~ operator, handle default with no arg, exit takes an optional int - not a str, handle GLOB assignment and subrefs.  Add -s flag. Fix tr with [...][...].
# 0.939  2022/01/18  SNOOPYJC  Implement package X and cross-file global vars, implement -m option.  Do a better job at handling various assignment operators in expressions, handle $arr_ref->[...] and $hash_ref->{...} in double quoted strings, fixes for use/require + look at the perl if we don't have the python, implement goto &sub, remove -u option to python as we have autoflush implemented, spit out the args to pythonizer in the py file, rewrite read to handle expressions and package names, handle s/.../.../ and tr/.../.../ without =~ and with complex arguments
# 0.940  2022/01/18  SNOOPYJC  Fix issue where _num(...) is missing on for loop upper bound, make filehandles global unless declared otherwise
# 0.941  2022/01/24  SNOOPYJC  Addl fix for issue 42: eval in expression, handle goatse in expression, addl fix for issue 57, reimplement read using helper function to mimic perl results and handle offset in expression, type convert sprintf/printf args to match format using a helper function, support use utf8 and handle special chars in strings and regexs, return was not being recognized as a keyword, generate a warning if the loop counter is modified in the loop
# 0.942  2022/01/26  SNOOPYJC  Add autovivification of arrays and hashes and -V option to turn it off and support no autovifification in the source code too, fixup incorrect code from defined arr[i][j], make sure hash and array values are always typed properly so they get initialized, fix conversions from hash to array so they don't give an error on empty hashes, change package name to main and change user sub main to main_, generate proper code to merge hashes, when tokenizing strings in the first pass, make sure we generate balanced brackets else the scanner won't stop on the ending ;, generate proper code for sub main, addl fix for issue 41 where the name is main, issue 115 multi-assignment of %hash vars
# 0.943  2022/01/28  SNOOPYJC  Create makelib.py and get_globals.pl to build perllib, fix binmode, make -p the default, give warning on require stmt if using -m
# 0.944  2022/01/30  SNOOPYJC  Addl fixes for issue 108: handle local with array elem or hash key, handle array elem and hash keys in paren list LHS expressions, fix issue 78 - s/regex/expr/e flag, handle g flag on regex, warn on wantarray use, handle 'no warnings' and assignments to $^W.
# 0.945  2022/02/04  SNOOPYJC  Fix __LINE__, implement __FILE__, __PACKAGE__, fix missing _init_package('main') if the file has other packages but still uses main, handle dotted package name in _init_package, fixup wrong ++/-- code in trailing if, use proper {} brackets for hashref in expr, add File::Temp functions POSIX::tmpnam, and IO::File->new, fix UTF-8 in binmode and binmode in an expression, handle i=>x in func/sub calls, change opendir etc to _opendir and fix readdir(), do not try to write in perllib folders even if writable, use python package name - not the perl name, handle open as last line of sub producing the return value, addl fix for issue 13 - scalar context with comma operator, revamp stat now that all OO references are methods and not properties
# 0.946  2022/02/06  SNOOPYJC  Implement redo and continue, fix push with scalar expression in parens, remove more oddities in the generated code like perllib.Array([]) and ((...)), add a couple dozen additional tests, fix issue 24, add UNITCHECK, CHECK, and INIT blocks, give warning if $? is set in an END block (not supported), issue 26, issue 30, issue 54, issue 76, handle for(;;), implement every type of for loop using while e.g. if the loop counter is modified or the increment can't be handled by range(...)
# 0.947  2022/02/08  SNOOPYJC  Use a heuristic to determine -m/-M option by adding Pass0.pm, implement # pragma pythonizer to set options, issue 72 - wait for subprocess to complete on close, fix fcntl, ioctl, and flock with clash on the module name
# 0.948  2022/02/09  SNOOPYJC  Implement splice, fix push with a list of multiple values, fix issue with assigning less values to Array slice, fix passing qw(...) to sub, fix passing array as non-first argument to sub, fix some issues in stmt modifiers, fix mkdir not returning the proper return code, remove blank line generated if the perl line has trailing whitespace
# 0.949  2022/02/10  SNOOPYJC  Handle ${\(expr)} and @{[expr]} in strings, fix while in stmt modifier with global pattern, fix AUTODIE, uniform handling of TRACEBACK using cluck, fix system, fix empty signal function, implement hex and oct
# 0.950  2022/02/12  SNOOPYJC  Fix pythonizer hang on unless eval, fix error on func($_) foreach @arr, allow sigils to have whitespace after them including newlines, use -M if all lines in main are global inits, generate proper code for ($v1,$v2...) = ();, add the package name to a non-local sub call if it's referenced with an &, implement FileHandle and new_from_fd() also for IO::File, fix if/else with comment before the {, issue 117 - pass thru the arguments on &mySub;, remove sub dereferences, implement pack and unpack
# 0.951  2022/02/13  SNOOPYJC  Remove extra () on if not (...), issue 116 - bash and/or with stmt modifier, issue 114 - substr with replacement, implement elipsis ..., redo test run script to operate like pytest
#!start ===============================================================================================================================

   use v5.10.1;
   use warnings;
   use strict 'subs';
   use feature 'state';
   use Carp 'verbose';	# SNOOPYJC
   use File::Basename;	# SNOOPYJC
   use File::Spec::Functions qw(file_name_is_absolute catfile);   # SNOOPYJC
   use Data::Dumper;    # SNOOPYJC
   $SIG{ __DIE__ } = sub { Carp::confess( @_ ) };	# SNOOPYJC
   $SIG{ INT } = sub { Carp::confess( @_ ) };		# SNOOPYJC
   # $SIG{ __WARN__ } = sub { Carp::confess( @_ ) };	# SNOOPYJC
   $| = 1;                                              # SNOOPYJC - unbuffer STDOUT

BEGIN {                                                 # SNOOPYJC
    use Config;
    unshift @INC, dirname(__FILE__);
    if(exists $ENV{PERL5PATH}) {
        my $sep = $Config{path_sep};
        $ENV{PERL5PATH} .= $sep . dirname(__FILE__);
    } else {
        $ENV{PERL5PATH} = dirname(__FILE__);
    }
}
   use Pyconfig;				# issue 32
#
# Modules used ( from the current directory to make debugging more convenient; will change later)
#
   use Softpano qw(autocommit abend banner logme summary out);

   use Perlscan ('gen_statement', 'tokenize', 'gen_chunk', 'append', 'replace',
                 'insert', 'destroy', 'autoincrement_fix', '@ValClass', '@ValPerl', '@ValPy', '@ValCom',
                 'escape_keywords',                     # issue 41
                 'save_code', 'restore_code',           # issue 74
                 '%SpecialVarsUsed',                    # SNOOPYJC
                 '%SpecialVarR2L',                      # SNOOPYJC
                 '@EndBlocks',                          # SNOOPYJC
                 'get_sub_vars_with_class',             # issue 78
                 '%FileHandles',                        # SNOOPYJC
                 '@ValType', '$TokenStr');

   use Pythonizer qw(correct_nest getline prolog output_line %LocalSub %PotentialSub %GlobalVar %VarType %InitVar init_val matching_br reverse_matching_br next_matching_token next_matching_tokens next_same_level_token next_same_level_tokens next_lower_or_equal_precedent_token fix_scalar_context %SubAttributes %Packages @Packages arg_type_from_pos in_sub_call); # SNOOPYJC

   $VERSION='0.951';
   $SCRIPT_NAME='pythonizer';
#
# options
#
   $breakpoint=9999; # line from which to debug code. See Pythonizer user guide
   $debug=0;  # 0 -- production mode
              # 1 -- testing mode
              # 2 -- first pass debugging
              # 3 -- provides tracing during the second pass (useful for users for trableshooing infinite loops)
              # 4 -- stop at Perlscan.pm
              # 5 -- stop at particular error message.
   $traceback=0;                        # SNOOPYJC -T option
   $autodie=0;                          # SNOOPYJC -A option
   $implicit_global_my=0;               # SNOOPYJC -m option
   $pythonize_standard_library=0;       # SNOOPYJC -s option
   $import_perllib=1;                   # SNOOPYJC -p option, -P turns it off
   $autovivification=1;                 # SNOOPYJC -V turns this option off
   $HOME=$ENV{'HOME'}; # the directory used for autobackup (only if debug>0)
   if( $^O eq 'cygwin' ){
      # $^O is built-in Perl Variable that contains OS name
      $HOME="/cygdrive/f/_Scripts";  # CygWin development mode -- the directory used for backups
   }
   #
   # Local dictionaries
   #
   # SNOOPYJC %PyOpen=('<'=>'r', '>'=>'w', '>>'=>'a', '+<'=>'+');
   %PyOpen=('<'=>'r', '>'=>'w', '>>'=>'a', '+<'=>'r+', '+>'=>'w+', '+>>'=>'a+', '->'=>'->', '<-'=>'<-', '-|'=>'-|', '|-'=>'|-', '|'=>'|-', ''=>'r');   # SNOOPYJC
   @UseLib=();                  # SNOOPYJC: Paths added using "use lib"
   %Pyf=();			# SNOOPYJC: Keeps track of which extra functions we need to include at the end
   $Pyf_dir = dirname(__FILE__)."/pyf";		# SNOOPYJC: Where we keep the extra python functions

   $saved_eval_tokens = undef;                  # issue 42
   @saved_eval_buffer = ();                     # issue 42
   $saved_eval_lno = undef;                     # issue 42
   %nested_subs = ();                           # issue 78: map from nested sub name to arglist
   $nested_sub_at_level = -1;                   # issue 78
   $saved_sub_tokens = undef;

   $LOG_DIR='/tmp/'.ucfirst($SCRIPT_NAME);
   # issue 64    banner($LOG_DIR,$SCRIPT_NAME,"Fuzzy translator of Python to Perl. Version $VERSION",30); # Opens SYSLOG and print STDERRs banner; parameter 4 is log retention period
   # issue 55 prolog(); # sets all options, including breakpoint
   prolog(dirname(__FILE__), $LOG_DIR,$SCRIPT_NAME,"Translator of Python to Perl. Version $VERSION",30); # issue 55, issue 64  # sets all options, including breakpoint

   push @UseLib, dirname($Pythonizer::fname);   # SNOOPYJC: Always good to look here!
   correct_nest(0, 0);                  # SNOOPYJC

   if( $debug > 0 ){
      autocommit("$HOME/Archive",$ENV{'PERL5LIB'},qw(Softpano.pm Perlscan.pm Pythonizer.pm));
   }

   %Constants=();               # issue 13: Keeps track of constants declared in "use constant" and also file handles
   #@Constants{keys %CONSTANT_MAP} = values %CONSTANT_MAP;       # SNOOPYJC
   @Constants{values %CONSTANT_MAP} = values %CONSTANT_MAP;       # SNOOPYJC
   $modules_path_added = 0;                     # SNOOPYJC
   $uses_file_stat = 0;                         # SNOOPYJC
   $set_initial_package = 0;                    # SNOOPYJC
   if(!%Packages) {                             # SNOOPYJC
       $Packages{$DEFAULT_PACKAGE} = 1 unless($implicit_global_my);
   }
   $saved_eval_tokens = undef;                  # issue 42
   @saved_eval_buffer = ();                     # issue 42
   $saved_eval_lno = undef;                     # issue 42
   $saved_sub_tokens = undef;
   $nested_sub_at_level = -1;                   # issue 78
   $saved_sub_tokens = undef;

   $split_multiple_assignment = undef;          # issue 115
   $gen_open_data = 0;                          # SNOOPYJC
   $continue_needed_try_block = 0;              # issue continue

#
# Skip initial block of comments
#
   $TrStatus=0;
   chomp($line=<>); # we need to discard the first line with /usr/bin/perl as interpreter
   # SNOOPYJC: We don't need '-u' anymore: output_line('','#!/usr/bin/python3 -u'); # put a proper line
   output_line('','#!/usr/bin/python3'); # SNOOPYJC: We implemented autoflush, so we don't need '-u': put a proper line

   my $user = $ENV{LOGNAME} || $ENV{USERNAME} || $ENV{USER};                            # SNOOPYJC
   $rb_user = " run by $user" if($user);                                                # SNOOPYJC
   my $us = basename($0);                                                               # SNOOPYJC
   my $comment = "# Generated by \"$us @Pythonizer::orig_ARGV\" v$VERSION$rb_user on ".localtime();         # SNOOPYJC
   output_line('', $comment);                                                           # SNOOPYJC
   if(@Pass0::implied_options) {
       output_line('', "# Implied $us options: " . join(' ', @Pass0::implied_options));
   }

   if ($line =~ /^\s*#!/){
      $line=getline(); # skip previous interpreter definition and get the first meaningful line + initial block of comments, if present
   }else{
      getline($line); # put the first line in the readline buffer
      $line=getline(); # rescan it to have full proper processing
   }
   # issue flock foreach $l ('import sys,os,re','import fileinput,subprocess,inspect'){
   $Die = "class Die(Exception):
    pass";
   if($traceback) {             # Note: The code in &Pythonizer::cleanup_imports needs to know how many lines we have in this definition (see $dif_def_lno)
       $Die = "class Die(Exception):
    def __init__(self, *args,suppress_traceback=None):
        super().__init__(*args)
        if TRACEBACK and not suppress_traceback:
            _cluck()";
        $Pyf{_cluck} = 1;
        $Pyf{_longmess} = 1;
   }
   $Die = "from $PERLLIB import Die" if($import_perllib);
   # NOTE: This import line gets rewritten in Pythonizer.pm!
   my @headers = ("import sys,os,re,fcntl,math,fileinput,subprocess,collections.abc,argparse,glob,warnings,inspect,functools,itertools,signal,traceback,io,tempfile,atexit,calendar,types,pdb,random,stat,dataclasses,builtins,codecs,struct,$PERLLIB",
	   'import time as tm_py',                              # SNOOPYJC
           "_str = lambda s: '' if s is None else str(s)",      # SNOOPYJC
                 );
   foreach my $g (keys %GLOBALS) {              # SNOOPYJC
       if($import_perllib) {
           if($g eq 'TRACEBACK' && $traceback) {
               push @headers, "$PERLLIB.$g = 1";
           } elsif($g eq 'AUTODIE' && $autodie) {
               push @headers, "$PERLLIB.$g = 1";
           } elsif($g =~ /^_[a-z]/) {           # e.g. _locals_stack
               push @headers, "$g = $GLOBALS{$g}";
           }
       } else {
           if($g eq 'TRACEBACK' && $traceback) {
               push @headers, "$g = 1";
           } elsif($g eq 'AUTODIE' && $autodie) {
               push @headers, "$g = 1";
           } else {
               push @headers, "$g = $GLOBALS{$g}";
           }
       }
   }
   my @more_headers = ("$Die", "class $EVAL_RETURN_EXCEPTION(Exception):\n    pass");   # SNOOPYJC
   if($Perlscan::uses_function_return_exception) {
       push @more_headers, "class $FUNCTION_RETURN_EXCEPTION(Exception):\n    pass";   # SNOOPYJC
   }
   for my $label (keys %Perlscan::all_labels) {                 # issue 94
       my $ex_name = label_exception_name($label);
       push @more_headers, "class $ex_name(Exception):\n    pass";
   }

   push @headers, @more_headers;                # SNOOPYJC
   #
   # SNOOPYJC: Define any variables that just appear out of nowhere in perl, like $option{key} = 1 creates %options
   #
   #if(exists $InitVar{main}) {
   #   push @headers, $InitVar{main};
   #}
   # issue 24 my $last_header = "$PERL_ARG_ARRAY = sys.argv[1:]";      # SNOOPYJC - must be last!!
   my $last_header = "pass # LAST_HEADER";      # issue 24 - must be last!!
   push @headers, $last_header;         # SNOOPYJC: Post-processor in Pythonizer.pm relies on this one being last
   foreach $l (@headers) {              # SNOOPYJC
       output_line('',$l); # to block reproducing the first source line
   }

   for my $package (keys %Packages) {           # SNOOPYJC
       $Pyf{_init_package} = 1;
       if($import_perllib) {
          output_line('', "$PERLLIB.init_package('$package')");
       } else {
          output_line('', "_init_package('$package')");
       }

   }
   if(exists $InitVar{__main__}) {                  # SNOOPYJC, issue 41
       output_line('', $InitVar{__main__});             # issue 41
   }

   foreach my $end (@EndBlocks) {                               # SNOOPYJC
        output_line('', "atexit.register($end)");               # SNOOPYJC
   }                                                            # SNOOPYJC

   if(exists $SpecialVarsUsed{'$|'}) {      # SNOOPYJC: This is also set by the scanner if we ever call autoflush
       $Pyf{_autoflush} = 1;
       if($import_perllib) {
           output_line('', "$Perlscan::keyword_tr{STDOUT}.autoflush = types.MethodType($PERLLIB.autoflush, $Perlscan::keyword_tr{STDOUT})");
           output_line('', "$Perlscan::keyword_tr{STDERR}.autoflush = types.MethodType($PERLLIB.autoflush, $Perlscan::keyword_tr{STDERR})");
       } else {
           output_line('', "$Perlscan::keyword_tr{STDOUT}.autoflush = types.MethodType(_autoflush, $Perlscan::keyword_tr{STDOUT})");
           output_line('', "$Perlscan::keyword_tr{STDERR}.autoflush = types.MethodType(_autoflush, $Perlscan::keyword_tr{STDERR})");
       }
   }

   #while($l=<DATA>){
   #   chomp $l;
   #   output_line($l,'',''); # to block reproducing the first source line; added Sept 3, 2020 just for the future
   #}
   #close DATA;
#
#Main loop
#
   @Perlscan::BufferValClass=@Perlscan::BufferValCom=@Perlscan::BufferValPerl=@Perlscan::BufferValPy=(); # cleaning after the first pass
   @Perlscan::BufferValType=();
my ($start,$token_buffer_active);
# issue 41 $CurSub='main';
   $CurSub='__main__';          # issue 41
   $CurPackage = $DEFAULT_PACKAGE;      # SNOOPYJC
   $token_buffer_active=0;
   $we_are_in_sub_body=0;
   $context_manager_nest = -2;          # issue 66
   @eval_stack = ();                    # issue 42
   $deferred_statement=0;               # issue 58
   $deferred_statement_nesting=0;       # issue 58
   @DeferredValClass=@DeferredValCom=@DeferredValPerl=@DeferredValPy=@DeferredValType=();        # issue 58
   &Perlscan::initialize();             # issue 94

   while( defined($line) || scalar(@Perlscan::BufferValClass)>0 || $saved_eval_tokens || $split_multiple_assignment){ # issue 42, isue 115
      $TrStatus=0;
      # issue 68 if( scalar(@ValClass)==0 || ! defined($ValClass[0]) ){
      # issue 68 $line=getline(); # skip lines with no tokens like ';'
      # issue 68 next;
      # issue 68 }

      # issue 13: Attempt to replace bare words in hash definitions and references
      # issue 13 $line =~ s/\{([A-Za-z_][A-Za-z0-9_]*)\}/\{\'$1\'\}/g;	# issue 13
      # We do this a better way now: $line =~ s/(?<!\$)\{([A-Za-z_][A-Za-z0-9_]*)\}/\{\'$1\'\}/g;	# issue 13
      if($debug >= 5) {
        say "Main loop, line=$line, BufferValClass=@Perlscan::BufferValClass, deferred_statement=$deferred_statement, saved_eval_tokens=" . (defined $saved_eval_tokens ? "@{$saved_eval_tokens->{perl}}" : "undef");
      }

#
# You need to claw back tokens from buffer for postfix conditionals. This is a pretty brittle and complex code -- Oct 8,2020 NNB
#
      if ( scalar(@Perlscan::BufferValClass)==0 && $deferred_statement < 2) {       # issue 58
         if( $debug>1 ){
            say STDERR "\n\n === Line $. Perl source:".(defined($line)?$line:$ValPerl[0])."===\n";
            if( $.>=$breakpoint ){
                logme('S', "Breakpoint was triggered at line $. in pythonizer.pl");
                # $breakpoint=999999;
                $DB::single = 1;
            }
         }
         if(!defined $line && $saved_eval_tokens) {             # issue 42
             unpackage_code($saved_eval_tokens);
             $saved_eval_tokens = undef;
             for my $t (@saved_eval_buffer) {
                 getline($t);
             }
             @saved_eval_buffer = ();
             $. = $saved_eval_lno;
         } elsif(defined $split_multiple_assignment) {          # issue 115
             unpackage_code($split_multiple_assignment);
             $split_multiple_assignment = undef;
         } elsif(defined $saved_sub_tokens && $nested_sub_at_level < 0) {       # SNOOPYJC
             unpackage_code($saved_sub_tokens);
             $saved_sub_tokens = undef;
             tokenize($line, 1);        # Continue where we left off
         } else {
             tokenize($line);   # I just like to see tokenize call first in debugger  :-)
         }
         if($debug >= 5) {
            say STDERR "deferred_statement_nesting=$deferred_statement_nesting, nesting_level=$Perlscan::nesting_level, TokenStr=$TokenStr, nesting_last->{type}=$Perlscan::nesting_last->{type}" if($deferred_statement == 1);
         }

         if($deferred_statement == 1 && $Perlscan::nesting_level < $deferred_statement_nesting) {       # issue 58
            if($Perlscan::nesting_last->{type} eq 'else') {
                $deferred_statement=0;          # We're all set
            } elsif(($TokenStr ne '}' && substr($TokenStr,0,1) ne 'C') ||
                    $Perlscan::nesting_level < $deferred_statement_nesting-1) {         # issue 103
                gen_statement('else:');         # Insert an 'else:' clause so we have a place to generate the assignment
                correct_nest(1,1);
                my @tmp=@ValClass; @ValClass=@DeferredValClass; @DeferredValClass=@tmp;
                @tmp=@ValCom; @ValCom=@DeferredValCom; @DeferredValCom=@tmp;
                @tmp=@ValPerl; @ValPerl=@DeferredValPerl; @DeferredValPerl=@tmp;
                @tmp=@ValPy; @ValPy=@DeferredValPy; @DeferredValPy=@tmp;
                @tmp=@ValType; @ValType=@DeferredValType; @DeferredValType=@tmp;
                $TokenStr=join('',@ValClass);
                $deferred_statement=3;
            }
        }
      }else{
         if($deferred_statement >= 2) {         # issue 58
            @ValClass=@DeferredValClass;
            $TokenStr=join('',@ValClass);
            @ValCom=@DeferredValCom;
            @ValPerl=@DeferredValPerl;
            @ValPy=@DeferredValPy;
            @ValType=@DeferredValType;
            #@DeferredValClass=@DeferredValCom=@DeferredValPerl=@DeferredValPy=@DeferredValType=();   # issue 58
            if($deferred_statement == 3) {
                correct_nest(-1,-1);            # We inserted an "else:" above
                $deferred_statement = 0;
            } else {
                $deferred_statement = 1;
            }
         } elsif($token_buffer_active==0){
            @ValClass=@ValPerl=('{');
            $TokenStr=join('',@ValClass);       # SNOOPYJC
            @ValPy=('if');                      # issue 94
            &Perlscan::enter_block();           # issue 94
            $token_buffer_active=1;
         }elsif($token_buffer_active==1){
            @ValClass=@Perlscan::BufferValClass;
            $TokenStr=join('',@ValClass);
            @ValCom=@Perlscan::BufferValCom;
            @ValPerl=@Perlscan::BufferValPerl;
            @ValPy=@Perlscan::BufferValPy;
            @ValType=@Perlscan::BufferValType;
            $token_buffer_active=2;
         }else{
            @ValClass=@ValPerl=('}');
            $TokenStr=join('',@ValClass);       # SNOOPYJC
            &Perlscan::exit_block();            # issue 94
            @Perlscan::BufferValClass=@Perlscan::BufferValCom=@Perlscan::BufferValPerl=@Perlscan::BufferValPy=();
            @Perlscan::BufferValType=();
            $token_buffer_active=0;
         }
      }

      if( scalar(@ValClass)==0 || ! defined($ValClass[0]) ){            # issue 68
          gen_statement('pass');                                        # issue 68
          $line=getline(); # skip lines with no tokens like ';'         # issue 68
          next;                                                         # issue 68
      }                                                                 # issue 68

      #
      # Dealing with problem of state varaible mapping into Python via renaming
      #
      rename_state_var(0,$#ValPy);
      if( index($TokenStr,'s^')>-1){
         # Selected cases of postfix and prefix operator can be translated; other not
         autoincrement_fix() # exported function located in Perlscan
      }

      if($TokenStr =~ /^f\("\)="$/ && $ValPerl[0] eq '%SIG') {     # SNOOPYJC: Fix a signal assignment with a sub
          replace(2, 'i', $ValPerl[2], unquote_string($ValPy[2]));
          replace(3,',',',',',');
          replace(4,$ValClass[5],$ValPerl[5],$ValPy[5]);
          replace(5,')',')',')');
      }
      fix_scalar_context();                             # issue 37
      #fix_string_catenation();                          # issue 36
      fix_multi_subscripts();                           # issue 84
      remove_dereferences();                            # issue 50
      replace_incr_decr_stmt();                         # SNOOPYJC
      fix_expression_issues();                          # SNOOPYJC, issue 74, issue 52
      fix_type_issues(0, $#ValClass, undef);            # SNOOPYJC
      fix_undef();                                      # SNOOPYJC
      $split_multiple_assignment = split_up_multiple_assignment();      # issue 115
      if($split_multiple_assignment) {                  # issue 115
          fix_expression_issues();                      # issue 115: We skip handling assignment in expression on multi-assignment
      }
      fix_global_and_eval_regex();                      # SNOOPYJC

      #
      # Statements
      #
      $RecursionLevel=0;
      if(!$set_initial_package && ($ValClass[0] ne 'c' || $ValPerl[0] ne 'package')) {   # SNOOPYJC
          gen_statement("builtins.__PACKAGE__ = '$CurPackage'");
          $set_initial_package = 1;
      } elsif(exists $FileHandles{DATA} && $FileHandles{DATA} == $. && !$gen_open_data) {
          my $data = 'DATA';
          $data = "$CurPackage.DATA" unless($implicit_global_my);
          $Pyf{_open} = 1;
          gen_chunk($data,'=','_open',"(re.sub(r'\\.py\$',r'.data',sys.argv[0])", ',', "'r'", ',', 'checked=False', ')');
          gen_statement();
          $gen_open_data = 1;
      }

      # issue 13: Treat my @arr and my %hash as if there was no "my" so the proper code is generated
      if( $ValClass[0] eq 't' &&  $ValClass[1] =~ /[ah]/ && 
          (($ValPerl[0] eq 'my' && scalar(@ValClass) > 2) ||                            # issue 13
           ($ValPerl[0] eq 'our' && next_same_level_token('=', 2, $#ValClass) > 0))) {	# SNOOPYJC
          destroy(0, 1);	# issue 13: remove the "my"/"our"
      } elsif($ValClass[0] eq 't' && $ValPerl[0] eq 'local' && $ValClass[1] eq 'f') {   # Handle local signal
          destroy(0, 1);	# issue 13: remove the "my"/"our"
      }
      if( $ValClass[0] eq '^' ) {	# issue 29
         # ++ expr; statement: change to expr++;
	 my $vpl = $ValPerl[0]; my $vpy = $ValPy[0];
	 destroy(0, 1);			# issue 29
	 append('^', $vpl, $vpy);	# issue 29
      }					# issue 29

      if ($ValClass[0] eq 'W' ) {       # issue 66: Context manager
          $context_manager_nest = $Pythonizer::CurNest; # issue 66
          if($debug >= 3) {
              say STDERR "Setting context_manager_nest = $context_manager_nest";
          }
          gen_statement($ValPy[0]);     # issue 66
          correct_nest(1);              # issue 66
          correct_nest();               # issue 66
          destroy(0, 1);                # issue 66
      }
      
      if( $ValClass[0] eq '}' ){
         # we treat curvy bracket as a separate dummy statement
         if($debug >= 5 && $deferred_statement == 1) {
             say STDERR "deferred_statement_nesting=$deferred_statement_nesting, nesting_level=$Perlscan::nesting_level";
             say STDERR "nesting_last->{type}=$Perlscan::nesting_last->{type}";
         }
         if(!$Pythonizer::GeneratedCode) {      # issue 96
             gen_statement('pass');             # issue 96: python doesn't allow empty blocks
         }                                      # issue 96
         gen_statement();
         if(&Perlscan::is_continue_block(1)) {
             correct_nest(-1,-1);
         }

         if(&Perlscan::needs_redo_loop(1)) {    # SNOOPYJC
             gen_statement('break');
             correct_nest(-1,-1);
         }
         if(&Perlscan::needs_try_block(1)) {    # issue 94
             my $ex_name = &Perlscan::try_block_exception_name();
             if(defined $ex_name) {               # issue 108
                correct_nest(-1,-1);
                if($ex_name eq $FUNCTION_RETURN_EXCEPTION) {    # SNOOPYJC
                    gen_statement("except $ex_name as _r:");
                    correct_nest(1,1);
                    gen_statement("return _r.args[0]");
                } else {
                    my $continue = 0;
                    if(&Perlscan::has_continue(1)) {       # SNOOPYJC
                        $continue = 1;
                        correct_nest(1,1);
                        gen_statement("raise $ex_name('continue')");
                        correct_nest(-1,-1);
                        $continue_needed_try_block = 1;
                    }
                    gen_statement("except $ex_name as _l:");
                    correct_nest(1,1);
                    #gen_statement("if 'break' in str(_l):");
                    gen_statement("if _l.args[0] == 'break':");
                    correct_nest(1,1);
                    gen_statement('break');
                    correct_nest(-1,-1);
                    gen_statement('continue') if(!$continue);
                    gen_implicit_continue();
                }
             }
             &Perlscan::gen_try_block_finally();
             correct_nest(-1);
         } elsif(!&Perlscan::is_continue_block(1)) {
             $continue_needed_try_block = 0;
             gen_implicit_continue();
         }
         correct_nest(-1); # next line will be de-indented
         if( $we_are_in_sub_body  && $Pythonizer::NextNest ==0  ){
            correct_nest(0,0);
            if(!$implicit_global_my && $CurSub ne '__main__') {        # SNOOPYJC, issue 41
                my $escaped = escape_keywords($CurSub);
                my $p_escaped = escape_keywords($CurPackage, 1);
                gen_statement("$p_escaped.$escaped = $escaped");
            }
            initialize_globals_for_state_vars();
            %new_state_var_name=(); # hash for own and state variables
            %new_state_var_init=();
            $CurSub='__main__';         # issue 41
         }
         #if($nested_sub_at_level >= 0) {
             #say STDERR "Got } on line $., nested_sub_at_level=$nested_sub_at_level, nesting_level=$Perlscan::nesting_level";
         #}
      }elsif( $ValClass[0] eq '{' ){
         if(&Perlscan::is_continue_block(0)) {
             correct_nest(1,1) if($continue_needed_try_block);
         } elsif(!$Perlscan::PREV_HAD_COLON) {                 # SNOOPYJC
             # The user opened a brace with nothing before it, so we have to generate some code for
             # the nesting to be correct
             gen_statement('for _ in range(1):');       # SNOOPYJC: Use a loop so you can last/next it
             #finish();
         }
         $Perlscan::PREV_HAD_COLON = 0;                 # issue 94: It's only good once!
         if(&Perlscan::needs_try_block(0)) {                # issue 94
             gen_statement();
             correct_nest(1,1);
             gen_statement('try:');
         }
         if(&Perlscan::needs_redo_loop(0)) {                # SNOOPYJC
             gen_statement();
             correct_nest(1,1);
             gen_statement('while True:');
         }
         $Pythonizer::GeneratedCode = 0;                # issue 96
         correct_nest(1); # next line will be indented
         if(&Perlscan::needs_try_block(0)) {            # issue 108
             &Perlscan::push_locals($CurSub);
         }
         if($deferred_statement == 1 && $deferred_statement_nesting == $Perlscan::nesting_level) {
            $deferred_statement = 2;  # issue 58
         }
      }elsif( $ValClass[0] eq '(' ){
         $close_br_pos=matching_br(0);
         # issue paren if( $close_br_pos && $ValClass[$close_br_pos+1] eq '=' ){
         if( $close_br_pos >= 0 && $close_br_pos < $#ValClass && $ValClass[$close_br_pos+1] eq '='){      # issue paren
            $TrStatus=assignment(0);
         } elsif($close_br_pos >= 0 && $close_br_pos < $#ValClass && $ValClass[$close_br_pos+1] eq '~' && $ValPerl[$close_br_pos+1] ne '~') {      # Regex
            $TrStatus=expression(0, $#ValClass, 0);
         } elsif (index(substr($TokenStr, 0, $close_br_pos), '=') >= 0) {       # issue paren:  assignment, like in ($i = 1) if(...);
            if($close_br_pos == $#ValClass && next_same_level_token(',', 1, $close_br_pos-1) == -1) {
                $TrStatus=assignment(1, $close_br_pos-1);                           # issue paren
            } else {
                $TrStatus=expression(0, $close_br_pos, 1);
                $TrStatus=expression($close_br_pos+1, $#ValClass, 0) if($close_br_pos+1 <= $#ValClass);
            }
         }else{
            $TrStatus=expression(0, $close_br_pos, 1);          # SNOOPYJC
            $TrStatus=expression($close_br_pos+1, $#ValClass, 0) if($close_br_pos+1 <= $#ValClass);
         }
      }elsif(  $ValPy[0] eq 'NoTrans!'  ){
         if($Pythonizer::CurNest) {                             # SNOOPYJC
             output_line('pass','    #SKIPPED: '.$line);        # issue 96
         } else {
             output_line('','#SKIPPED: '.$line);
         }
         $line=getline();
         next;
      }elsif($ValPerl[0] eq 'sub' && exists $nested_subs{$ValPerl[1]}) {        # issue 78
         gen_chunk('def',$ValPy[1],"($nested_subs{$ValPerl[1]}):"); # def name (special list of arguments)
         gen_statement();
         $LocalSub{$ValPy[1]} = 1;
         $nested_sub_at_level = $Perlscan::nesting_level;
         say STDERR "Generating $ValPy[1], nested_sub_at_level=$nested_sub_at_level" if($debug>=3);
         correct_nest(1,1);
         for my $class (qw(global nonlocal)) {
             my @vars = get_sub_vars_with_class($ValPy[1], $class);
             if(@vars) {
                output_line("$class " . join(', ', @vars));
             }
         }
         correct_nest(-1,-1);
      }elsif( $ValPerl[0] eq 'sub' ){
         $we_are_in_sub_body=1;
         %new_state_var_name=(); # hash for own and state variables
         %new_state_var_init=();
         # Perl has two types of sub statements -- prototype and actual
         $CurSub=$ValPy[1];

         correct_nest(0,0);
         my $escaped = escape_keywords($CurSub);   # issue 41
         if(substr($escaped, 0, 7) eq '__END__') {      # SNOOPYJC: END block
            gen_chunk('def',$escaped,"():");            # SNOOPYJC
         } else {
            # issue 41 gen_chunk('def',$CurSub,"($PERL_ARG_ARRAY):"); # def name ([list of arguments])        # isssue 32
            gen_chunk('def',$escaped,"(*$PERL_ARG_ARRAY):"); # def name (list of arguments)        # issue 32, issue 41, SNOOPYJC
            $LocalSub{$CurSub}=1;
            if(exists $SubAttributes{$CurSub}{modifies_arglist}) {     # SNOOPYJC
                # This sub uses a shift or pop of the arguments, so we have to copy it
                # from a tuple to a list.
                gen_statement();
                correct_nest(1,1);
                output_line("$PERL_ARG_ARRAY = list($PERL_ARG_ARRAY)");
                correct_nest(-1,-1);
            }
         }
         if (exists($GlobalVar{$CurSub}) ){
            gen_statement();
            correct_nest(1,1);
            output_line($GlobalVar{$CurSub});
            correct_nest(0,0);
         }
         if (exists($InitVar{$CurSub}) ){             # SNOOPYJC: Variable initialization
            gen_statement();
            correct_nest(1,1);
            my @init = split /\n/, $InitVar{$CurSub};
            for $in (@init) {
                output_line($in);
            }
            correct_nest(0,0);
         }
      }elsif( $ValPerl[0] =~ /BEGIN|UNITCHECK|CHECK|INIT/ ){    # SNOOPYJC
         correct_nest(0,0);
         gen_chunk($ValPy[0],"    # $ValPerl[0]:"); # SNOOPYJC
      }elsif(  $ValPerl[0] eq 'close' ){
         for( my $i=1; $i<@ValPy; $i++ ){
             if( $ValClass[$i] eq 'i' || $ValClass[$i] eq 's' ){        # issue 10
	        # issue close gen_chunk($ValPy[$i].'.f.close;');
                # issue 72 gen_chunk($ValPy[$i].'.close()');	# issue close
                $Pyf{_close} = 1;
                gen_chunk('_close', '(', $ValPy[$i], ')');	# issue close, issue 72
                gen_statement();
             }
         }
      }elsif( $ValPerl[0] =~ /^(?:say|print|printf)$/ ){        # SNOOPYJC
          $TrStatus=print3(0);
      }elsif( $ValPerl[0] =~ /^warn$/ ){                        # SNOOPYJC
          $TrStatus=print3(0,'STDERR'); # in Python3 this is a function
      }elsif( $ValClass[0] eq 's' ){
          if( ($TokenStr=~tr/=//) > 1 && $ValClass[-1] eq 'd' && ($ValPerl[-2] eq '+=' || $ValPerl[-2] eq '-=') ){
             # multiple assignment with the last increment like $K=$i+=1 need to be expanded due to bug in Python parser
             $ValPy[-1]=$ValPy[-3].substr($ValPerl[-2],0,1).$ValPy[-1];
             $ValPy[-2]=$ValPerl[-2]='=';
          }
          my $reg = next_same_level_token('~', 0, $#ValClass);          # SNOOPYJC
          if($reg != -1 && $ValPerl[$reg] ne '~' && $reg+1 <= $#ValClass && $ValPerl[$reg+1] =~ /re|tr/) {    # SNOOPYJC
              $TrStatus=expression(0, $#ValClass, 0);                   # SNOOPYJC
          } elsif($CurSub eq '__main__' || scalar(@ValClass) != 1) {  # issue 45: Ignore scalar alone on a line (may be the return value), issue 41
              $TrStatus=assignment(0);
          }                                     # issue 45
      }elsif( $ValClass[0] eq 't' ){
         &Perlscan::init_local_typeglobs($CurSub) if($ValPerl[0] eq 'local');          # issue 108
         if( scalar(@ValClass)==2 ){
            #uninitalise single var declaration like my $line
            if( $ValPerl[0] eq 'my' || $ValPerl[0] eq 'local'){ # issue 108, SNOOPYJC: don't init 'our' variables
               my $LHS = $ValPy[1];                        # SNOOPYJC
               if(exists $SpecialVarR2L{$ValPy[1]}) {      # SNOOPYJC: Change _nr() to INPUT_LINE_NUMBER etc
                  $LHS = $SpecialVarR2L{$ValPy[1]};
               }
               if(substr($ValPerl[1],0,1) eq '*') {                             # issue 108: Don't init a typeglob
                   ;
               } elsif(exists $VarType{$ValPy[1]} && exists $VarType{$ValPy[1]}{$CurSub}) {
                   output_line("$LHS = ".init_val($VarType{$ValPy[1]}{$CurSub}));
               } else {
                   output_line("$LHS = None");
               }
            }elsif( $ValPerl[0] eq  'own' ){
               gen_chunk( $ValPy[0], $ValPy[1] );
            }elsif( $ValPerl[0] eq 'state' ){
               $new_name=$CurSub.'_'.$ValPy[1];
               $new_state_var_name{$ValPy[1]}=$new_name;
               gen_chunk($ValPy[0],$new_name);
            }
            finish();
            next;
         }elsif( scalar(@ValClass)==4 && $ValClass[2] eq '='  ){
            if( $ValPerl[0] eq 'my' || $ValPerl[0] eq 'our' || $ValPerl[0] eq 'local' ){        # issue 108
               if($ValClass[1] eq 'G') {         # issue 108: typeglob
                  $ValPy[1] = &Perlscan::choose_glob($ValPerl[1], $ValPy[1])
               }
	       if($ValClass[3] eq 'f') {	# Issue 8: shift generates bad code
		  gen_chunk("$ValPy[1] = ");	# Issue 8
                  function(3,3);		# Issue 8
               } elsif($ValClass[3] eq 'x') {   # issue 42
		   gen_chunk("$ValPy[1] = ");	# Issue 42
                   expression(3, 3, 0);         # issue 42
               # SNOOPYJC }elsif($ValClass[3] eq 'i' && $ValPy[3] eq $ValPerl[3]) {	# issue 13
	       }elsif($ValClass[3] eq 'i') {	# issue 13, SNOOPYJC
		   gen_chunk("$ValPy[1] = ");					# issue 13
	           if( $LocalSub{$ValPy[3]} ){					# issue 13: local sub call with no parens
	              gen_chunk(escape_keywords($ValPy[3]));    		# issue 13, issue 41
	              gen_chunk('()');					        # issue 13
                    } elsif ($Constants{$ValPy[3]}) {                           # issue 13: constant or file handle
                        gen_chunk($ValPy[3]);   	        		# issue 13
	            } else {							# issue 13: bare word - treat as string
	              gen_chunk("'".$ValPy[3]."'");				# issue 13
	            }
               }elsif($ValClass[3] eq 'C' && $ValPerl[3] eq 'eval') {    # issue 42: my $var = eval {...}
                   $TrStatus=assignment(1);
	       } else {				# Issue 8
                  output_line("$ValPy[1] = $ValPy[-1]");
	       }
            }elsif( $ValPerl[0] eq  'own' ){
               gen_chunk( $ValPy[0], $ValPy[1].' = ',$ValPy[-1] );
            }elsif(  $ValPerl[0] eq 'state' ){
               $new_name=$CurSub.'_'.$ValPy[1];
               $new_state_var_name{$ValPy[1]}=$new_name;
               gen_chunk($ValPy[0],$new_name);
               $new_state_var_init{$ValPy[1]}=$ValPy[-1];
            }
            finish();
            next;
         }elsif($ValClass[1] eq '('){
            #this is a more complex case
            my $last=matching_br(1);
            if($#ValClass>$last && $ValClass[$last+1] eq '='){
               if($ValPerl[0] eq 'state' ){
                  rename_state_var(2,$last-1);
               } elsif($ValPerl[0] eq 'local') {
                  copy_partially_initialized_locals(2, $last-1);
               }
               $TrStatus=assignment(1);
            # SNOOPYJC }else{
            }elsif($ValPerl[0] ne 'our') {      # SNOOPYJC: Don't init 'our' variable
               my $val = undef;                 # SNOOPYJC
               for($i=2; $i<$last;$i++){        # SNOOPYJC: Run thru them all and see if they all have the same value
                   my $sval = 'None';
                   if(exists $VarType{$ValPy[$i]} && exists $VarType{$ValPy[$i]}{$CurSub}) {
                       $sval = init_val($VarType{$ValPy[$i]}{$CurSub});
                   }
                   if(defined $val && $sval ne $val) {
                       $val = undef;
                       last;
                   }
                   $val = $sval;
               }
               if(defined $val) {               # SNOOPYJC: they are all the same
                   for($i=2; $i<$last;$i++){
                      if ($ValPy[$i] eq ','){
                         gen_chunk(' = ');
                      }elsif($ValPerl[0] eq 'state'){
                         $new_name=$CurSub.'_'.$ValPy[$i];
                         $new_state_var_name{$ValPy[$i]}=$new_name;
                         gen_chunk($new_name);
                      }else{
                          gen_chunk($ValPy[$i]);
                      }
                   }
                   gen_chunk(" = $val");
                } else {                        # We need to do it one by one
                   for($i=2; $i<$last;$i++){
                      next if ($ValPy[$i] eq ',');
                      my $val = 'None';
                      if(exists $VarType{$ValPy[$i]} && exists $VarType{$ValPy[$i]}{$CurSub}) {
                          $val = init_val($VarType{$ValPy[$i]}{$CurSub});
                      }
                      if($ValPerl[0] eq 'state'){
                         $new_name=$CurSub.'_'.$ValPy[$i];
                         $new_state_var_name{$ValPy[$i]}=$new_name;
                         gen_chunk($new_name);
                      }else{
                         gen_chunk($ValPy[$i]);
                      }
                      gen_chunk(" = $val");
                      gen_statement();
                   }
                }
            }
          }elsif( $ValClass[2] eq '=' ){
             my $reg = next_same_level_token('~', 3, $#ValClass);          # SNOOPYJC
             if($reg != -1 && $ValPerl[$reg] ne '~' && $reg+1 <= $#ValClass && $ValPerl[$reg+1] =~ /re|tr/) { # SNOOPYJC
                $TrStatus=expression(1, $#ValClass, 0);                    # SNOOPYJC
             } else {
                $TrStatus=assignment(1);
             }
          }elsif(scalar(@ValClass) > 6 && $ValPerl[0] eq 'local' && $ValClass[1] eq 's' && $ValClass[2] eq '(' &&
                 next_same_level_token('=', 1, $#ValClass) > 2) {               # issue 108
              # local arr[NDX] = VAL;
              # local hsh{key] = VAL;
              gen_statement("$ValPy[1] = $ValPy[1].copy()");
              $TrStatus=assignment(1);
          }elsif( $ValPerl[0] eq 'local') {
              ;         # issue 108 ignore any local we didn't already handle
          }else{
            $TrStatus=-255;
          }
       }elsif( $ValClass[0] eq 'h' ){
          # hash to has need method copy          #
          if( $#ValClass >= 2 && $ValClass[1] eq '=' ){
             if( $ValPerl[2] eq '(' ){
                  # Special case hash initialization needs to be converted to dictionary initialization
                  if($autovivification) {         # SNOOPYJC
                     $Pyf{Hash} = 1;
                     gen_chunk($ValPy[0],'=','Hash','({');
                  } else {
                     gen_chunk($ValPy[0].' = {');
                  }
		  # issue 13: Handle a list of key, value, key, value by converting it to key: value, key: value
                  #for( my $i=4; $i<$#ValPy; $i+=4 ) {				# issue 13
                  #$ValPy[$i] = ":" if $ValPy[$i] eq ",";			# issue 13
                  #}								# issue 13
                  my $comma_flip = 0;                   # issue 13
                  my $last_was_colon = 0;               # SNOOPYJC
                  for( my $i=3; $i<$#ValPy; $i++ ){
                     if( $ValClass[$i] eq 'i' ) {                               # issue 13
	                if( $LocalSub{$ValPy[$i]} ){				# issue 13: local sub call with no parens
	                    gen_chunk(escape_keywords($ValPy[$i]));		# issue 13, issue 41
	                    gen_chunk('()');					# issue 13
                        } elsif ($Constants{$ValPy[$i]}) {                      # issue 13: constant or file handle
                            gen_chunk($ValPy[$i]);     	        		# issue 13
                        } elsif( $ValPerl[$i] eq $ValPy[$i]) {	                # issue 13
		            $ValPy[$i] = "'".$ValPy[$i]."'";			# issue 13 - put in quotes
                            gen_chunk( $ValPy[$i] );                            # issue 13
                        } else {                        # SNOOPYJC
                            gen_chunk( $ValPy[$i] );    # SNOOPYJC
                        }                                                       # issue 13
                     } elsif($ValPy[$i] eq ',' && $comma_flip == 0) {           # issue 97
                         gen_chunk(': ');                                       # issue 97
                         $last_was_colon = 1;
                         $comma_flip = 1;                                       # issue 97
                     } elsif($ValClass[$i] eq 'a' && !$last_was_colon) {    # SNOOPYJC: We hit an array (not after a ':')
                         gen_chunk("**{$ValPy[$i]"."[$INDEX_TEMP]:".$ValPy[$i]."[$INDEX_TEMP+1] for $INDEX_TEMP in range(0,len(".$ValPy[$i]."),2)}");   # SNOOPYJC
                         $comma_flip = -1;               # SNOOPYJC: Don't gen a colon
                         $last_was_colon = 0;                                    # SNOOPYJC
                     } elsif($ValClass[$i] eq 'h' && !$last_was_colon) {    # SNOOPYJC: We got a hash (not after a ':')
                         gen_chunk('**', $ValPy[$i] );  # SNOOPYJC: Double-splat it out
                         $comma_flip = -1;               # SNOOPYJC: Don't gen a colon
                         $last_was_colon = 0;                                    # SNOOPYJC
		     } else {							# issue 13
                        gen_chunk( $ValPy[$i] );
                        $comma_flip = 1-$comma_flip if($ValPy[$i] eq ',' && $comma_flip != -1); # issue 97
                        $comma_flip = -1 if($ValPy[$i] =~ /^:\s?$/);                 # issue 97
                        if($ValPy[$i] eq ':' || $ValPy[$i] eq ': ') {
                            $last_was_colon = 1;
                        } elsif($ValPy[$i] ne '') {
                            $last_was_colon = 0;                                    # SNOOPYJC
                        }
                     }
                  }
                  gen_chunk('}');
                  if($autovivification) {         # SNOOPYJC
                      gen_chunk(')');
                  }
                  finish();
                  next;
             # SNOOPYJC }elsif( scalar(@ValClass)==2 && ($ValPerl[2] eq 'h' || $ValPerl[2] eq 'q') ){
             }elsif( scalar(@ValClass)==3 && $ValClass[2] eq 'h') {     # SNOOPYJC
		  # issue 31 gen_chunk("$ValPy[0]=$ValPy[2].copy"); # copy structure not reference
                  if($autovivification) {         # SNOOPYJC
                     $Pyf{Hash} = 1;
                     gen_chunk("$ValPy[0] = ", 'Hash', "($ValPy[2])"); # SNOOPYJC copy structure not reference	# issue 31
                  } else {
                     gen_chunk("$ValPy[0] = $ValPy[2].copy()"); # copy structure not reference	# issue 31
                  }
                  finish();
                  next;
             } elsif($#ValClass==2 && $ValClass[2] eq 'a') {    # SNOOPYJC: %hash = @arr
                  if($autovivification) {         # SNOOPYJC
                     $Pyf{Hash} = 1;
                     gen_chunk("$ValPy[0] = ", 'Hash', "({$ValPy[2]"."[$INDEX_TEMP]:".$ValPy[2]."[$INDEX_TEMP+1] for $INDEX_TEMP in range(0,len(".$ValPy[2]."),2)})");
                  } else {
                     gen_chunk("$ValPy[0] = {$ValPy[2]"."[$INDEX_TEMP]:".$ValPy[2]."[$INDEX_TEMP+1] for $INDEX_TEMP in range(0,len(".$ValPy[2]."),2)}");
                  }
                  finish();
                  next;
             }
          } elsif($#ValClass == 0) {            # SNOOPYJC: Hash definition (ignore it)
              finish();
              next;
          }
          $TrStatus=assignment(0);
      }elsif($ValClass[0] eq 'a'){
          if($#ValClass == 0) {            # SNOOPYJC: Array definition (ignore it)
              finish();
              next;
          }
          if( $ValClass[1] eq '=' ){
             my $need_flatten = 0;                                                  # issue 102
             if( $ValPerl[2] eq '(' && ($end_pos=matching_br(2)) == $#ValClass){    # issue 102
                # array initialization
                # issue 102: need to smarten this code up.  First see if what we have needs to be flattened,
                # if so and it's just one thing, we can avoid doing that.
                my $elements = 0;
                for(my $i=3; $i<$end_pos; $i++) {
                    $elements++;
                    if($ValClass[$i] =~ /[ah]/) {
                        $need_flatten = 1;
                        last if($elements>1);
                    } elsif($ValClass[$i] eq 'f' && substr(&Pythonizer::func_type($ValPerl[$i], $ValPy[$i]),0,1) eq 'a') {
                        $need_flatten = 1;
                        last if($elements>1);
                    } elsif($i+2 <= $end_pos && $ValClass[$i] eq 's' && $ValClass[$i+1] eq '~' && $ValClass[$i+2] eq 'q' && substr($ValPy[$i+1],0,1) ne '.') { # see test_regex
                        $need_flatten = 1;
                        last if($elements>1);
                    }
                    my $pos = next_same_level_token(',', $i, $end_pos-1);
                    $pos = $end_pos if($pos == -1);
                    $i = $pos;
                }
                #say STDERR "need_flatten=$need_flatten, elements=$elements";
                if($need_flatten && $elements==1) {
                    destroy($end_pos, 1);
                    destroy(2,1);
                    $need_flatten = 0;
                }
             }
             if( $#ValClass==2 && $ValClass[2] eq 'a'){
                # Special case array to array copy
		# issue 31 gen_chunk("$ValPy[0]=$ValPy[2].copy");
                if($ValPerl[2] eq '@_' && $CurSub ne '__main__' && !exists $SubAttributes{$CurSub}{modifies_arglist}) {  # SNOOPYJC, issue 41
                    # In this case our args are still a tuple, which has no ".copy()" operation
                    gen_chunk("$ValPy[0] = list($ValPy[2])");
                } else {
                    gen_chunk("$ValPy[0] = $ValPy[2].copy()");	# issue 31
                }
                finish();
                next;
             } elsif($#ValClass==2 && $ValClass[2] eq 'h') {    # SNOOPYJC: @arr = %hash
                 # SNOOPYJC gen_chunk("$ValPy[0] = list(functools.reduce(lambda x,y:x+y,$ValPy[2].items()))");
                if($autovivification) {         # SNOOPYJC
                    $Pyf{Array} = 1;
                    gen_chunk("$ValPy[0] = ", 'Array', "(itertools.chain.from_iterable($ValPy[2].items()))");        # SNOOPYJC
                } else {
                    gen_chunk("$ValPy[0] = list(itertools.chain.from_iterable($ValPy[2].items()))");        # SNOOPYJC
                }
                finish();
                next;
             } elsif($ValClass[2] eq 'f' && ($ValPerl[2] eq 'keys' || $ValPerl[2] eq 'values')) {       # SNOOPYJC
                # python keys() and values() functions return something not subscriptable!
                if($autovivification) {         # SNOOPYJC
                    $Pyf{Array} = 1;
                    gen_chunk("$ValPy[0] = ", 'Array', '(');
                } else {
                    gen_chunk("$ValPy[0] = list(");
                }
                $TrStatus=expression(2,$#ValClass,0);
                gen_chunk(')');
                finish();
                next;
             }elsif( $ValPerl[2] eq '(' && ($end_pos=matching_br(2)) == $#ValClass){    # SNOOPYJC
                # array initialization

                my $flatten = '';
                my $flatten_end = '';
                if($need_flatten) {
                    $Pyf{'_flatten'} = 1;
                    $flatten = '_flatten(';
                    $flatten = "$PERLLIB.flatten(" if($import_perllib);
                    $flatten_end = ')';
                }
                if($autovivification) {         # SNOOPYJC
                    $Pyf{Array} = 1;
                    if($import_perllib) {
                        $flatten = "$PERLLIB.Array(" . $flatten;
                    } else {
                        $flatten = 'Array(' . $flatten;
                    }
                    $flatten_end = ')' . $flatten_end;
                }
                gen_chunk($ValPy[0]," = $flatten",'[');
                for (my $i=3; $i<$end_pos; $i++){
                    my $pos = next_same_level_token(',', $i, $end_pos-1);       # issue 102
                    $pos = $end_pos if($pos == -1);                             # issue 102
                    $TrStatus = expression($i, $pos-1, 0);                      # issue 102
                    $i = $pos;
                    gen_chunk(',') if($ValClass[$i] eq ',');
                }
                gen_chunk("]$flatten_end");
                finish();
                next;
             }elsif( $ValPerl[2] =~ /<\w*>/ ){
               # Special case of array initialization via slurping
	       # issue 31 gen_chunk("$ValPy[0]=$ValPy[2].copy");
                if($autovivification) {         # SNOOPYJC
                    $Pyf{Array} = 1;
                    gen_chunk("$ValPy[0] = ", 'Array', "($ValPy[2])");		# issue 31
                } else {
                    gen_chunk("$ValPy[0] = $ValPy[2].copy()");		# issue 31
                }
               finish();
               next;
             }elsif(  $ValClass[2] eq 'a' && $ValPerl[3] eq '=' ){
               my $last_eq=rindex($TokenStr,'=');
               if( $ValPerl[$last_eq+1] eq '(' ){
                   #  list assignment @x=(1,2,3);
                   $ValPy[$last_eq+1]='[';
                   if( $ValPerl[-1] eq ')' ){
                      $ValPy[-1]=']';
                   }else{
                      $TrStatus=-255;
                      finish();
                      next;
                   }
               }
               for( $i=0; $i<$last_eq; $i+=2 ){
                  # cascade assignent processing @x=@y=@z
                  if ($ValClass[$i+1] ne '='){
                     logme('S',"Token $ValPerl[$i+1] was found insted of '=' in what is expected to be array assignment");
                     $TrStatus=-255;
                     last;
                  }
                  if( $last_eq+1==@ValClass ){
		     # issue 31 gen_statement("$ValPy[$i]=$ValPy[-1].copy"); # last array is the source
                    if($ValPerl[-1] eq '@_' && $CurSub ne '__main__' && !exists $SubAttributes{$CurSub}{modifies_arglist}) {  # SNOOPYJC, issue 41
                        # In this case our args are still a tuple, which has no ".copy()" operation
                        gen_statement("$ValPy[$i] = list($ValPy[-1])");
                    } elsif ($autovivification) {         # SNOOPYJC
                        $Pyf{Array} = 1;
                        gen_statement("$ValPy[$i] = ", 'Array', "($ValPy[-1])"); # SNOOPYJC last array is the source	# issue 31
                    } else {
                        gen_statement("$ValPy[$i] = $ValPy[-1].copy()"); # last array is the source	# issue 31
                    }
                  }elsif( $ValPerl[$last_eq+1] eq '(' ){
                     #left side is the list $a=@b=(1,2,3)
                     gen_chunk("$ValPy[$i] = ");
                     if($autovivification) {         # SNOOPYJC
                         $Pyf{Array} = 1;
                         gen_chunk('Array', '(');
                     }
                     expression($last_eq+1,$#ValClass); # processing (1,2,3) -- you need brackets here.  Recursion level should be 0
                     if($autovivification) {         # SNOOPYJC
                         gen_chunk(')');
                     }
                     gen_statement();
                  }
               }
               finish();
               next;
             }
          }
          $TrStatus=assignment(0);
      }elsif($ValClass[0] eq 'G' && $ValClass[1] eq '=') {      # SNOOPYJC: Handle glob assignment
          $TrStatus=assignment(0);
      }elsif( $ValClass[0] eq 'c' ){
          #normal control statement: if/while/for, etc -- next line is always nested.
          # in foreach loop "(" is absent ) do in perl you can's distibush between postfix for and foreach loop without parens
	  # issue 19 if( defined($ValType[0]) && $ValType[0] eq 'P' && $ValClass[1] ne '(' && $ValPy[0] ne 'for' ){
          if( defined($ValType[0]) && $ValType[0] eq 'P' && $ValPerl[0] ne 'for' && $ValPerl[0] ne 'foreach'){	# issue 19
	      # issue 19: If this control statement is not surrounded by parens, then add them in
	      # We were fooled by "if (this or that) and options{debug}" as we assumed the first ( and the last } were
	      # matching parens, which they are obviously not!
	      $add_parens = 1;				# issue 19
	      if($#ValClass >= 1 && $ValClass[1] eq '(') {			# issue 19
	         $end_pos = matching_br(1);		# issue 19
		 if($end_pos == $#ValClass) { $add_parens = 0; }		# issue 19
	      }						# issue 19
	      if($add_parens == 1) {			# issue 19
                 if($#ValClass >= 1) {
                     insert(1,'(','(','(');
                 } else {
                     append('(','(','(');
                 }
                 append(')',')',')');
	      }						# issue 19
          }

          if ($TokenStr=~/^c\([!n]f\(?/ && $ValPerl[3] eq 'open' ){
            $TrStatus=open_fun(3,matching_br(1)-1,'c');   # SNOOPYJC: add extra param
          }elsif ($TokenStr=~/^c\([!n]f\(?/ && $ValPerl[3] eq 'opendir' ){
              $TrStatus=open_dir(3,matching_br(1)-1,'c'); # SNOOPYJC: add extra param
          }else{
            $TrStatus=control(0); # control now itself destroy the last ) Oct 14, 2020 --NNB
          }
      }elsif( $ValClass[0] eq 'C' ){
         #next last continue eval elsif else do
         if( $ValPerl[0] eq 'elsif' ){
            if($ValClass[1] ne '(') {   # SNOOPYJC: We could have inserted an array sub expr in before the '('
                append(')',')',')');
                insert(1,'(','(','(');
            }
            $end_pos=matching_br(1);
            my $adjust = fixup_complex_assignment_in_control(2, $end_pos-1);            # issue 58, 103
            $adjust = 0 if($adjust == -1);
            $end_pos -= $adjust;
            gen_chunk('elif ');
            if($adjust) {                          # issue 58: We have a := in there
                $TrStatus=expression(1,$end_pos,0);     # Keep the parens
            } else {
                $TrStatus=expression(2,$end_pos-1,0);
            }
            gen_chunk(':');
            gen_statement();
         }elsif( $ValPerl[0] eq 'else' ){
               gen_chunk('else:');
               gen_statement();
         }elsif( $ValPerl[0] eq 'eval' ) {              # issue 42
             gen_eval(0, 0);                            # issue 42
         }elsif( $ValPerl[0] eq 'do' ) {                # SNOOPYJC
             gen_statement("$DO_CONTROL$. = True");     # SNOOPYJC
             gen_chunk("while $DO_CONTROL$.:");         # SNOOPYJC
         }
     }elsif( $ValClass[0] eq 'f' ){
         #this is a left hand function like is substr($line,0,1)='' or open or chomp;
	 
         if( $ValPerl[0] eq 'substr' ){
            $TrStatus=left_hand_substr(0);
         }elsif( $ValPerl[0] eq 'chomp' ){
            if( $#ValPerl==0) {
               gen_chunk(qq[$DEFAULT_VAR=$DEFAULT_VAR.rstrip("\\n")]); # chomp with no argumnets # issue 32
            }else{
               function(0,$#ValClass);
            }
         }elsif( $ValPerl[0] eq 'chop' ){
             # SNOOPYJC if( $ValPerl[1] eq '(' ){
             # SNOOPYJC   if( $ValClass[2] eq 's' ){
             # SNOOPYJC      gen_chunk($ValPy[2].'='.$ValPy[2].'[0:-1]');
             # SNOOPYJC   } else{
             # SNOOPYJC      $TrStatus=-1;
             # SNOOPYJC   }
             # SNOOPYJC }else{
             if($#ValPerl==0) {                 # SNOOPYJC
               gen_chunk("$DEFAULT_VAR = ${DEFAULT_VAR}[0:-1]");          # issue 32
             } else {                           # SNOOPYJC
               function(0,$#ValClass);          # SNOOPYJC
             }                                  # SNOOPYJC
         }elsif( $ValPerl[0] eq 'open' ){
            $rc=open_fun(0,$#ValClass,'s');     # SNOOPYJC: Add extra param
	 }elsif( $ValPerl[0] eq 'opendir' ){	# SNOOPYJC
	    $rc=open_dir(0,$#ValClass,'s');
         }elsif($ValPerl[0] eq 'pos') {         # SNOOPYJC: Not supported
            logme('S',"Sorry, pos assignment is not supported");    # SNOOPYJC
            $TrStatus=expression(0,$#ValClass,0);          # SNOOPYJC: They could have f(s)+f(s)
         }else{
             # $TrStatus=function(0);
            $TrStatus=expression(0,$#ValClass,0);          # SNOOPYJC: They could have f(s)+f(s)

         }
      }elsif( $ValClass[0] eq 'x' ){
         # this is backquotes
         if($traceback) {               # issue traceback
             $Pyf{_run} = 1;
             gen_chunk(qq{$DEFAULT_VAR = }, '_run', '(', $ValPy[0], ')');
             gen_statement();
         } else {
             gen_chunk(qq{$DEFAULT_VAR = subprocess.run($ValPy[0],capture_output=True,text=True,shell=True)});
             gen_statement();
             if($autodie || exists $SpecialVarsUsed{'$?'}) {        # SNOOPYJC
                gen_chunk(qq[$SUBPROCESS_RC = ${DEFAULT_VAR}.returncode]);
             }
             if($autodie) {
                 gen_statement();
                 gen_statement("if $SUBPROCESS_RC:");
                 correct_nest(1,1);
                 gen_statement("raise Die(f'run(${\(escape_string(unquote_string($ValPy[0]), '\''))}): failed with {$SUBPROCESS_RC}')");
                 correct_nest(-1,-1);
             }
         }
      }elsif( $ValClass[0] eq 'd' ){
         if( length($TokenStr)==1 ){
             # SNOOPYJC: just ignore it!  if($CurSub eq 'main' && scalar(@eval_stack) == 0) {  # issue 45: could be the return value of a sub # issue 42 or eval
             # SNOOPYJC: just ignore it!  logme('W','line starts with digit');
             # SNOOPYJC: just ignore it!  }                                          # issue 45
         # issue 45 }else{
         }elsif($CurSub eq '__main__' && scalar(@eval_stack) == 0) {     # issue 45: could be the return value of a sub # issue 42 or eval, issue 41
            $TrStatus=-1;
         }
      }elsif( $ValClass[0] eq '(' ){
         # (/abc/) && a=b; (a<b) || a=7
         $right_br=matching_br(0);
         if( $ValClass[$right_br+1] =~ /[0o]/ ){        # issue 93
            gen_chunk('if ');
            $RecursionLevel=-1;
            $TrStatus=expression(0); # this will scan till ')'
         # SNOOPYJC }elsif( $ValClass[$right_br+1] eq '1' ){
            # SNOOPYJC gen_token('if ! ');
            # SNOOPYJC $RecursionLevel=-1;
            # SNOOPYJC $TrStatus=expression(0); # this will scan till ')'
         }elsif( $ValClass[$right_br+1] eq '=' ){
            #this is a list assignment like ($i,$k)=@_  or ($i,$k)=split(//,$text)
            $RecursionLevel=-1;
            $TrStatus=expression(0,$right_br);
            gen_chunk($ValPy[$right_br+1]);
            $RecursionLevel=-1;
            $TrStatus=expression($right_br+1,$#ValClass,0);
         }
      }elsif( $ValClass[0] eq 'k' ){
         # keywords next, last, return and all other for which we may have no special treatment
         if ( $ValPy[0] eq 'return' && scalar(@eval_stack) != 0 ) {     # issue 42
             if($#ValClass != 0) {              # not a plain 'return'
                my $lno = $eval_stack[-1]->{lno};
                gen_chunk("$EVAL_RESULT$lno = ");
                $TrStatus = expression(1,$#ValClass,-1);        # -1 means to eat any surrounding ()
            }
            gen_statement();
            gen_statement("raise $EVAL_RETURN_EXCEPTION");
            $eval_stack[-1]->{had_return} = 1;
         } elsif($ValPy[0] eq 'return' && $CurSub eq '__main__' && $nested_sub_at_level < 0) {   # SNOOPYJC, issue 41, issue 78
             gen_statement("if __name__ == '__main__':");
             correct_nest(1,1);
             gen_statement('raise Die("Can\'t return outside a function")');  # SNOOPYJC
             correct_nest(-1,-1);
             logme('W',"Attempt to return outside a subroutine will die if executed from main");    # SNOOPYJC
         } elsif($ValPerl[0] eq 'use' || $ValPerl[0] eq 'require' || $ValPerl[0] eq 'no') {            # SNOOPYJC
            do_use_require(0);                   # SNOOPYJC
         } elsif($ValPerl[0] eq 'goto') {               # SNOOPYJC
             if($ValClass[1] eq 'i' && $LocalSub{$ValPy[1]} && $CurSub ne '__main__') { # issue 41
                gen_chunk('return');
                gen_chunk(escape_keywords($ValPy[1]),"(*$PERL_ARG_ARRAY)");
            } elsif($ValClass[1] eq '\\' && $ValClass[2] eq 'i' && $LocalSub{$ValPy[2]} && $CurSub ne '__main__') { # issue 41
                gen_chunk('return');
                gen_chunk(escape_keywords($ValPy[2]),"(*$PERL_ARG_ARRAY)");
             } elsif($ValClass[1] eq '&' && $ValClass[2] eq 's' && $CurSub ne '__main__') {      # SNOOPYJC goto &$func_ref;
                gen_chunk('return');
                gen_chunk($ValPy[2],"(*$PERL_ARG_ARRAY)");
             } else {
                logme('S', "goto $ValPerl[1] is not supported!");
                if($Pythonizer::CurNest) {                             # SNOOPYJC
                    output_line('pass','    #SKIPPED: '.$line);        # issue 96
                } else {
                    output_line('','#SKIPPED: '.$line);
                }
                $line=getline();
                next;
             }
         } else {
            if( $#ValClass == 0 ){
                #say STDOUT "$ValPy[0], we_are_in_sub_body=$we_are_in_sub_body, CurNest=$Pythonizer::CurNest, NextNest=$Pythonizer::NextNest";
                if(($ValPerl[0] eq 'next' || $ValPerl[0] eq 'last') && &Perlscan::next_last_needs_raise(0)) {
                    my $ex_name = label_exception_name(undef);
                    gen_chunk("raise $ex_name('$ValPy[0]')");
                } else {
                    gen_chunk($ValPy[0]);
                }
            }elsif( $ValClass[1] eq '(' ){
                $TrStatus=expression(0,$#ValClass,0); # Can be this will scan till ')'
            }elsif($ValClass[1] eq 'i' && ($ValPerl[0] eq 'next' || $ValPerl[0] eq 'last' || $ValPerl[0] eq 'redo')) {   # issue 94
                if($ValPerl[1] eq &Perlscan::cur_loop_label() && ($ValPerl[0] eq 'redo' || !&Perlscan::next_last_needs_raise(0))) {
                    gen_chunk($ValPy[0]);
                } else {
                    # next LABEL or last LABEL, with LABEL not the last one we saw
                    # NOTE: This "last one we saw" business had to be turned off since
                    # not all blocks have to be labeled!!
                    my $ex_name = label_exception_name($ValPerl[1]);
                    gen_chunk("raise $ex_name('$ValPy[0]')");
                }
            }else{
                # last 2
                gen_chunk($ValPy[0]);
                $TrStatus=expression(1,$#ValClass); # this will scan till ')'
            }
         }
      }elsif( $ValClass[0] eq 'i' ){
         # user defined functon
         if( $#ValClass>0 && $ValClass[1] eq '(' ){
            $right_br=matching_br(1);
            if( $ValClass[2] eq ')' ){
               # function with zero arguments
               if( $ValPy[0] eq 'main' && $Pythonizer::CurNest==0 ){
                   my $globals=substr($GlobalVar{$CurSub},length('global'));
                   $globals=~tr/,/=/;
                   gen_statement($globals.'=None');
               }
	       &Perlscan::add_package_name_sub(0);	              # SNOOPYJC
               gen_chunk(escape_keywords($ValPy[0]).'()');            # issue 13
	       gen_extra($right_br+1, $#ValClass);		# issue 116
            }elsif( $ValClass[2] eq 'f' && ( $ValClass[3] ne '(' || ($ValClass[3] eq '(' && matching_br(3) == $right_br-1)) ){
               # bracketless call of built-in function as a single argument: get_config(split / /,$line)
               # or bracketed call to built-in function call that return list. We do not need sqare brackets
	       &Perlscan::add_package_name_sub(0);	              # SNOOPYJC
               gen_chunk($ValPy[0],'(');
               function(2,$right_br-1); # we assume that evethying in brackets is the function call
               gen_chunk(')');
	       gen_extra($right_br+1, $#ValClass);		# issue 116
            }else{
               # In all other cases we will put sqare bracket, even if they are redundant: they can be manually deleted.
               # SNOOPYJC gen_chunk(escape_keywords($ValPy[0]));           # issue 13
               # SNOOPYJC gen_chunk('(');
               # SNOOPYJC $TrStatus=expression(2,$#ValClass-1,-1); # this will scan till ')' and should eliminate ')' due to -1 as 3-d arg
               # SNOOPYJC gen_chunk(')');
               $TrStatus=expression(0,$#ValClass,0);            # Generate the entire function call in expression so *arr can be handled
            }
         }elsif($#ValClass == 1 && $ValClass[1] eq ':') {       # SNOOPYJC: Label
             output_line('',"# $ValPerl[0]");                   # issue 94
             $Perlscan::PREV_HAD_COLON = 0;                     # SNOOPYJC
         }else{
           $RecursionLevel=-1;
           $TrStatus=expression(0,$#ValClass); # this will scan till ')'
         }
      }elsif( ($split=index($TokenStr,'~'))>-1 && $ValPerl[$split] ne '~') {       # issue 73, SNOOPYJC: Handle the '~' operator properly
         $k=regex_and_translate(0,0,$split,$#ValClass); # issue 73, issue 106
         if($k < 0) {                                   # issue 73
             $TrStatus=-1;                              # issue 73
         }                                              # issue 73
      }elsif(index($TokenStr,'D')>-1) {         # SNOOPYJC: Some sort of OO construct such as $fh->autoflush(1);
           $RecursionLevel=-1;
           $TrStatus=expression(0,$#ValClass); # this will scan till ')'
      }else{
         if($debug >= 1) {
             say STDERR "Main loop: Unknown statement (@ValClass)";
         }
         if($CurSub eq '__main__' && scalar(@eval_stack) == 0 && $nested_sub_at_level < 0) {  # issue 45: ignore string as statement in sub - may be changed to "return 'string'" # issue 42 or eval, issue 41
            $TrStatus=-1;
         }                                      # issue 45
      }
      finish();
    } # while

    initialize_globals_for_state_vars();
    my ($key, $value);
    my @keys = keys %Pyf;
    for $key (@keys) {
        if($import_perllib) {
            if(substr($key,0,2) ne '__') {      # Only inline __mapf() and __sortf() - everything else comes from the import perllib
                $Pyf{$key} = 0;
            }
        } elsif(exists $PYF_CALLS{$key}) {      # If this module calls another one, include that too
             my @fcns = split(/,/, $PYF_CALLS{$key});
             for my $f (@fcns) {
                $Pyf{$f} = 1;
             }
        }
    }
    while (($key, $value) = each (%Pyf)) {	# SNOOPYJC
        if($value == 1) {
	    open(my $fh, '<', "$Pyf_dir/$key.py");
            while($l=<$fh>){
                chomp $l;
	        $l=~ s/[\r]//g;
                say Pythonizer::SYSOUT $l;       # Quietly output line
            }
            close $fh;
	}
    }
#
# Epilog -- close  output file and  if you are in debugging mode display the content  on the screen
#
   if (scalar(@NoTrans)>0) {
      say STDERR "\nATTENTION!\nThe following lines were probably translated incorrectly:\n";
      say STDERR join("\n",@NoTrans);
   }
   Pythonizer::move_defs_before_refs();                 # SNOOPYJC
   $rc=summary(); # print diagnostic messages summary
   exit $rc;

sub fixup_complex_assignment_in_control         # issue 58, 103
# See if we have a complex assignment in a control statement like for, foreach, while, elsif
# and if so, fix it up to use a simple variable that python allows in a := operation.  We play
# lots of games to get the actual assignment generated inside the control statement, and also
# in an else clause that we generate if there isn't one already.
# Returns the # of tokens we removed if it does a replacement, or -1 if we didn't do anything
{
    my $start = shift;          # Point after the '('
    my $end_pos = shift;        # Point before the ')'

    if(($k=next_same_level_token('=', $start, $end_pos))>-1 && 
        ($ValClass[$k-1] !~ /[ahs]/ || $ValPy[$k-1] !~ /[A-Za-z0-9_]+/)) {      # issue 58: complex assignment
       $deferred_statement = 1;                 # In the elif/while/for body we will generate the "complex_stuff=_e" assignment
       $deferred_statement_nesting = $Perlscan::nesting_level;
       @DeferredValClass=@ValClass[$start..$k]; 
       @DeferredValCom=@ValCom[$start..$k]; 
       @DeferredValPerl=@ValPerl[$start..$k]; 
       @DeferredValPy=@ValPy[$start..$k];
       @DeferredValType=@ValType[$start..$k];
       @DeferredValPy[$k-$start] = '=';                 # Replace := with =
       push @DeferredValClass, 'a';
       push @DeferredValCom, '';
       push @DeferredValPerl, $ELSIF_TEMP;
       push @DeferredValPy, $ELSIF_TEMP;
       push @DeferredValType, '';
       replace(2, 'a', $ELSIF_TEMP, $ELSIF_TEMP);       # Change it to _e:=expression
       destroy(3,$k-3) if($k >= 3);
       return ($k-3);
    }
    return -1;           # didn't do anything
}

sub replace_incr_decr_stmt                      # SNOOPYJC
# Replace ++x --x x++ and x-- if on the statement level with x+-1 or x-=1
# This is what we have to produce anyway and it simplifies the checking
# in fix_type_issues.
{
    return if(scalar(@ValClass) < 2);
    $pop = '+=';
    if($ValClass[0] eq '^') {
        $pop = '-=' if($ValPerl[0] eq '--');
        destroy(0, 1);
    } elsif($ValClass[$#ValClass] eq '^' && $ValClass[0] eq 's') {
        $pop = '-=' if($ValPerl[$#ValClass] eq '--');
        destroy($#ValClass, 1);
    } else {
        return;
    }
    # At this point all we have left is the operand
    append('=', $pop, $pop);
    append('d', '1', '1');
    say STDERR "replace_incr_decr_stmt: now =|$TokenStr|=" if($debug >= 1);
}

sub end_of_variable
# Given a 's' scalar variable reference, return the end_pos of the reference,
# e.g. if it's $s, then return the same pos, but if it's $s[4]{'k'} then return
# the end of those tokens.
# Also works if you give it a parenthesized expression, function, or sub ref
{
    my $pos = shift;

    my $k;
    my $result;
    if($ValClass[$pos] eq '(') {
        $result = matching_br($pos);
        return ($result==-1 ? $pos : $result);
    }
    if($ValClass[$pos] =~ /[if]/ && $pos+1 <= $#ValClass && $ValClass[$pos+1] eq '(') {
        $result = matching_br($pos+1);
        return ($result==-1 ? $pos : $result);
    }
    return $pos if($ValClass[$pos] ne 's');
    if($pos+1 <= $#ValClass && $ValClass[$pos+1] eq 'D') {      # '->'
        if($pos+2 <= $#ValClass && $ValClass[$pos+2] eq 'i') {  # $obj->field
            if($pos+3 <= $#ValClass && $ValClass[$pos+3] eq '(') {    # Method call
                $result = matching_br($pos+3);
                return ($result==-1 ? $pos+2 : $result);
            }
            return $pos+2;
        }
        $pos += 1;      # Could be $href->{...} or $aref->[...]
    }
    while($pos+1 <= $#ValClass && $ValClass[$pos+1] eq '(' &&
        ($ValPerl[$pos+1] eq '{' || $ValPerl[$pos+1] eq '[') && ($k = matching_br($pos+1)) != -1) {
        $pos = $k;
    }
    return $pos;
}

sub operator_type
# If this is an operator, what type is needed?  If not an operator, return undef
{
    my $p = shift;
    my $left = shift;           # 1 if we want the left operand type, else 0 (if it matters)

    $cl = $ValClass[$p];
    return 'S' if($cl eq '.');
    if($cl eq '~') {
        return 'N' if($ValPerl[$p] eq '~');     # real int '~' operator, not a match
        return 'S' 
    }
    if(index('HI^>=+*/%-', $cl) >= 0) {
        return 'S' if($left && $cl eq '*' && $ValPerl[$p] eq 'x');       # x operator is string x number
        return 'S' if($cl eq '>' && $ValPerl[$p] =~ /^[a-z]/);  # e.g. ne, eq, le, cmp, ...
        return 'S' if($cl eq '=' && $ValPerl[$p] eq '.=');
        return undef if($cl eq '=' && $ValPerl[$p] eq '=');   # Regular assignment
        return 'N';
    } elsif($cl eq 'f' && exists $Perlscan::FuncType{$ValPerl[$p]}) {
        return substr($Perlscan::FuncType{$ValPerl[$p]}, 0, 1);
    }
    return undef;
}

sub insert_converter
# If we need a converter, insert it and return the # of elements inserted, else return 0
{
    my $start = shift;          # Start of expr
    my $limit = shift;          # End of expr
    my $i = shift;              # Start of item
    my $k = shift;              # End of item
    my $type = shift;           # Type we need

    return 0 if($k < $i);
    $t_left = $t_right = undef;
    #no warnings 'uninitialized';
    if($i-1 >= $start) {
        $t_left = operator_type($i-1, 0);
        #say STDERR "operator_type($i-1) = $t";
    }
    if($k+1 <= $limit) {
        $t_right = operator_type($k+1, 1);
        return 0 if($ValClass[$k+1] eq '~' && $i == $start);    # $var =~ s/a/b/; or something like that
        #say STDERR "operator_type($k+1) = $t";
    }
    my $t = (defined $t_left) ? $t_left: $t_right;
    if(defined $t_left && defined $t_right) {
        my $p_left = $Perlscan::token_precedence{$ValClass[$i-1]};
        my $p_right = $Perlscan::token_precedence{$ValClass[$k+1]};
        $t = $t_right if($p_right > $p_left);
    }
    $t = $type if(!defined $t);
    $t = $type if(defined $type && index('IF', $type) >= 0 && defined $t && $t ne 'I');
    my $converter = get_converter($i, $k, $t);
    if($debug >= 3 && defined $converter) {
        no warnings 'uninitialized';
        say STDERR "insert_converter($start, $limit, $i, $k, $type): for =|$TokenStr|=, $ValPerl[$i], t=$t, converter=$converter";
    }

    return 0 if(!defined $converter);
    my $adjust = 0;

    my $j;
    if($k+1 <= $#ValClass && $ValClass[$k+1] eq '=') {
        if($ValPerl[$k+1] ne '=') {
            say STDERR "insert_converter($start, $limit, $i, $k, $type): for =|$TokenStr|=, $ValPerl[$i], t=$t, converter=$converter - calling expand_augmented_assignment" if($debug >= 3);
            my $adj;
            ($i, $k, $adj) = expand_augmented_assignment($i, $k+1);
            $limit += $adj;
            $adjust += $adj;
        } else {
            return 0;               # Don't put the function directly on the LHS of an assignment!
        }
    } elsif(($j = next_same_level_token('=', $i, $k))!= -1) {  # If this is an assignment, point to the RHS
        if($ValPerl[$j] eq '=') {       # Regular '='
            $i = $j+1;
        } else {
            say STDERR "insert_converter($start, $limit, $i, $k, $type): for =|$TokenStr|=, $ValPerl[$i], t=$t, converter=$converter, j=$j - calling expand_augmented_assignment" if($debug >= 3);
            my $adj;
            ($i, $k, $adj) = expand_augmented_assignment($i, $j);
            $limit += $adj;
            $adjust += $adj;
        }
    }
    insert($k+1, ')', ')', ')');
    while($i-2 >= 0 && $ValClass[$i-1] eq 'D' && $ValClass[$i-2] eq 'i') {      # Handle FH->autoflush(1)
        $i -= 2;
    }
    insert($i, '(', '(', '(');
    insert($i, 'f', $converter, $converter);
    if($debug >= 3) {
        no warnings 'uninitialized';
        say STDERR "insert_converter($start, $limit, $i, $k, $type): new =|$TokenStr|=, $ValPerl[$i], result = 3+$adjust";
    }
    return 3 + $adjust;
}

sub expand_augmented_assignment
# Take an augumented assignment, like $i += 2, and change it to $i = $i + 2 so we can do a type conversion on $i.
# Of course this is the simplest case.  We need to handle the hard cases like $arr[$i+=1]+=1 too!
# Returns the new start and end of the expression we moved to the RHS and the adjustment factor of how many tokens
# we added or removed.
{
    my $start = shift;
    my $equals = shift;

    my $total_adjust = 0;             # How many tokens we added

    # Determine the token, perl, and python versions of the operation
    my $pl = $op = substr($ValPerl[$equals], 0, length($ValPerl[$equals])-1);
    my $py = substr($ValPy[$equals], 0, length($ValPy[$equals])-1);
    $op = 'H' if($op eq '<<');
    $op = 'I' if($op eq '>>');
    $op = '*' if($op eq '**');
    replace($equals, '=', '=', '=');            # Change to plain '='
    insert($equals+1, $op, $pl, $py);           # Insert the +,-,* or whatever operator it is
    $total_adjust++;

    my $i;
    for($i = $equals-1; $i >= $start; $i--) {        # Insert a full copy of the LHS
        insert($equals+1, $ValClass[$i], $ValPerl[$i], $ValPy[$i]);
        $total_adjust++;
    }

    my $new_start = $equals+1;
    my $new_end = $new_start+$total_adjust-2;
    if(is_expression_simple($start, $equals-1)) {
        say STDERR "expand_augmented_assignment($start, $equals) simple: gives =|$TokenStr|=, ValPy=@ValPy, new_start=$new_start, new_end=$new_end, adjust=$total_adjust" if($debug>=1);
        return ($new_start, $new_end, $total_adjust);
    }

    # Now the fun begins!  Walk thru looking for subscripts that we can grab the value of in
    # a temp variable (using the := operator in python) and replace the corresponding LHS with
    # a reference to that temp variable.

    my $copy = $equals+1;               # Where our copy starts
    $i = $start;
    my $suffix = 0;
    my $adjust = 0;
    my $eq = $equals;
    #$DB::single = 1;
    for($i = index($TokenStr, '(', $i); $i >= 0 && $i < $eq; $i = index($TokenStr, '(', $i+1)) {
        my $sub_start = $i+1;
        my $sub_end = matching_br($i)-1;
        $i = $sub_end+1;
        next if($ValPerl[$sub_start-1] ne '{' && $ValPerl[$sub_start-1] ne '[');
        last if($sub_end < 0);
        if(is_expression_simple($sub_start, $sub_end)) {
            say STDERR "expand_augmented_assignment: Leaving $sub_start..$sub_end alone - simple expression" if($debug >= 3);
            next;
        }
        # We found something to do, start by creating our temp var and then finding the corresponding spot in the RHS
        $temp = $SUBSCRIPT_TEMP . $suffix;
        $suffix++;
        my $rhs_start = $sub_start + $copy - $start;
        my $rhs_end = $sub_end + $copy - $start;
        insert($rhs_end+1, ')', ')', ')');
        insert($rhs_start, '=', '=', ':=');
        insert($rhs_start, 's', $temp, $temp);
        insert($rhs_start, '(', '(', '(');
        replace($sub_start, 's', $temp, $temp);
        destroy($sub_start+1, $sub_end-$sub_start);
        $adjust = 4 - ($sub_end-$sub_start);
        $i = $sub_start+1;              # Point back to the ']'
        $eq -= ($sub_end-$sub_start);   # Point back to '='
        $new_start -= ($sub_end-$sub_start);   # Point back to the start of our expression on the RHS
        $new_end += $adjust;
        $copy += 4;                     # Adjust by the # we inserted
        $total_adjust += $adjust;
        say STDERR "expand_augmented_assignment($start, $equals) did   =|$TokenStr|= i=$i, eq=$eq, new_start=$new_start, new_end=$new_end, copy=$copy, adjust=$adjust, total_adjust=$total_adjust, ValPy=@ValPy" if($debug >= 5);
    }
    say STDERR "expand_augmented_assignment($start, $equals) gives =|$TokenStr|=, new_start=$new_start, new_end=$new_end, adjust=$total_adjust, ValPy=@ValPy" if($debug>=1);
    return ($new_start, $new_end, $total_adjust);
}

sub get_converter
# Get the right converter for this variable to the specified type.  Returns undef if no conversion is needed.
{
    my $var_start = shift;
    my $var_end = shift;
    my $type = shift;

    return undef if(!defined $type);
    return undef if(!exists $CONVERTER_MAP{$type});
    return undef if($ValClass[$var_start] eq 'y');      # special python code
    $v_type = &Pythonizer::expr_type($var_start, $var_end, $CurSub);
    return undef if($type eq $v_type);
    return undef if($type eq 'N' && $v_type =~ /[IF]/);
    return $CONVERTER_MAP{$type};
}

sub fix_type_issues
# Fixup issues with variable types and how perl automatically converts things to the proper type e.g.
# strings used in numeric contexts.  This is a recursive function, and returns the adjustment factor
# of how many tokens we added.  It uses the functions _num(), _str(), and _int() to make the conversions.
# _int() is used in subscripts.  We make use of the type information we gathered in pass 1 to see
# if we can eliminate as many of these conversions as possible.  FIXME: As a desired enhancement, we
# should "peephole optimize" the code, which means keeping track of the exact type of each variable
# in assignment statements in each basic block of code, so that if you say "$j = 1", we know that
# "$j" is an int in the same block even if it gets set to a string elsewhere. Once we hit a merge 
# point, e.g. a "}", then all bets are off!
{
    my $start = shift;
    my $limit = shift;
    my $type = shift;

    if($debug >= 3) {
        no warnings 'uninitialized';
        say STDERR "fix_type_issues($start, $limit, $type)";
    }
    my $total_adjust = 0;
    my $k;
    my $ot;
    my $adjust;
    my $opt;
    return if(scalar(@ValClass) == 0 || ($ValClass[0] eq 'k' && $ValPerl[0] eq 'sub'));
    return 0 if($start > $limit);
    return fix_type_issues($start+1, $limit, $type) if($ValClass[$start] eq 'f' && $ValPy[$start] eq 'print');
    for(my $i=$start; $i<=$limit; $i++) {
        $k = $i;
        no warnings 'uninitialized';
        say STDERR "fix_type_issues($start, $limit, $type): checking $ValPerl[$i] at $i, limit=$limit" if($debug >= 5);
        if($ValClass[$i] eq 'f') {
            next if(!exists $Perlscan::FuncType{$ValPerl[$i]});
            my $f_type = $Perlscan::FuncType{$ValPerl[$i]};
            my $t_pos = 0;
            if($i+1 <= $#ValClass && $ValClass[$i+1] eq '(') {
                my $endbr = matching_br($i+1);
                return if($endbr < 0);
                for(my $j = $i+2; $j < $endbr; $j++) {
                    my $comma = next_same_level_token(',', $j, $endbr);
                    my $ep = (($comma==-1) ? $endbr-1 : $comma-1);
                    my $t = substr($f_type, $t_pos, 1);
                    $t = substr($f_type, ++$t_pos, 1) if($t eq '?');
                    $t = substr($f_type, --$t_pos, 1) if($t eq ':');
                    $t = substr($f_type, --$t_pos, 1) if($t eq '?');
                    $t_pos++;
                    if($t eq 'H' && $ValClass[$j] =~ /[isf]/) {      # e.g. print(H a,b);
                        $j = end_of_variable($j);
                        $j++ if($j+1 == $comma);
                        next;
                    } elsif($ValClass[$j] =~ /[ah]/) {     # We will * an array, and iterate a hash, so just skip this
                        last;
                    } elsif($t eq 'S' && $ValPerl[$i] eq 'grep' && $ValPerl[$i+1] eq '{') {
                        last;                              # Don't convert the function result on a grep {...} @arr
                    } else {
                        if($ValClass[$j] eq 'q' && $ValClass[$ep] eq 'i' && $j+1 == $ep) {      # ignore flags on regex
                            $adjust = fix_type_issues($j, $j, $t);
                        } else {
                            $adjust = fix_type_issues($j, $ep, $t);
                        }
                        $ep += $adjust;
                        $endbr += $adjust;
                        $limit += $adjust;
                        $total_adjust += $adjust;
                    }
                    $j = $ep+1;
                }
                $k = $endbr;
            } else {                    # Unbracketed function call
                my $end_pos = $limit;
                if($i != 0 && $ValClass[$i-1] eq '(') {         # If the whole thing is in brackets, we know where to stop
                    $end_pos = matching_br($i-1) - 1;
                }
                my $j;
                for($j = $i+1; $j <= $end_pos; $j++) {
                    my $comma = next_lower_or_equal_precedent_token('F', $j, $end_pos);
                    my $close = next_same_level_token(')', $j, $end_pos);
                    my $ep = (($comma==-1) ? $end_pos : $comma-1);
                    $ep = $close-1 if($close!=-1 && $close-1 < $ep);
                    my $optional = 0;
                    my $t = substr($f_type, $t_pos, 1);
                    $optional = 1 if(substr($f_type, $t_pos+1, 1) eq '?');
                    $t = substr($f_type, ++$t_pos, 1) if($t eq '?');
                    if($t eq ':') {
                        $t = substr($f_type, --$t_pos, 1);
                        $t = substr($f_type, --$t_pos, 1) if($t eq '?');
                        last if($t ne 'a');
                    }
                    $t_pos++;
                    if($t eq 'H' && $ValClass[$j] =~ /[isf]/) {      # e.g. print H a,b;
                        $j = end_of_variable($j);
                        $j++ if($j+1 == $comma);
                        next;
                    } elsif($ValClass[$j] =~ /[ah]/) {     # We will * an array, and iterate a hash, so just skip this
                        last;
                    } elsif($optional && index("^*~/%+-.HI>&|0or?:=,A", $ValClass[$j]) >= 0) {
                        $j--;
                        last;
                    } else {
                        if($ValClass[$j] eq 'q' && $ValClass[$ep] eq 'i' && $j+1 == $ep) {      # ignore flags on regex
                            $adjust = fix_type_issues($j, $j, $t);
                        } else {
                            $adjust = fix_type_issues($j, $ep, $t);
                        }
                        $comma += $adjust;
                        $ep += $adjust;
                        $end_pos += $adjust;
                        $limit += $adjust;
                        $total_adjust += $adjust;
                    }
                    if($comma >= 0 && $ValClass[$comma] ne ',') {
                        $j = $ep;
                        last;
                    }
                    $j = $ep+1;
                }
                $k = $j;
                $k = $end_pos if($k > $end_pos);
            }
        } elsif($ValClass[$i] eq 'i' && ($LocalSub{$ValPy[$i]} || $i+1 <= $#ValClass && $ValClass[$i+1] eq '(')) {
            # Known local sub call or unknown sub call
            if($i+1 <= $#ValClass && $ValClass[$i+1] eq '(') {          # sub(...)
                my $endbr = matching_br($i+1);
                return if($endbr < 0);
                for(my $j = $i+2; $j < $endbr; $j++) {
                    my $comma = next_same_level_token(',', $j, $endbr);
                    my $ep = (($comma==-1) ? $endbr-1 : $comma-1);
                    if($ValClass[$j] eq 'a') {     # We will * an array, so just skip this
                        last;
                    }
                    $adjust = fix_type_issues($j, $ep, undef);
                    $ep += $adjust;
                    $endbr += $adjust;
                    $limit += $adjust;
                    $total_adjust += $adjust;
                    $j = $ep+1;
                }
                $k = $endbr;
            } else {                    # Unbracketed function call
                my $end_pos = $limit;
                if($i != 0 && $ValClass[$i-1] eq '(') {         # If the whole thing is in brackets, we know where to stop
                    $end_pos = matching_br($i-1) - 1;
                }
                my $j;
                for($j = $i+1; $j <= $end_pos; $j++) {
                    my $comma = next_lower_or_equal_precedent_token(',', $j, $end_pos);
                    my $ep = (($comma==-1) ? $end_pos : $comma-1);
                    if($ValClass[$j] eq 'a') {     # We will * an array, so just skip this
                        last;
                    } elsif(index("^*~/%+-.HI>&|0or?:=,A", $ValClass[$j]) >= 0) {       # Operator is next - that's it!
                        last;
                    }
                    $adjust = fix_type_issues($j, $ep, undef);
                    $ep += $adjust;
                    $comma += $adjust;
                    $limit += $adjust;
                    $end_pos += $adjust;
                    $total_adjust += $adjust;
                    if($comma >= 0 && $ValClass[$comma] ne ',') {
                        $j = $ep;
                        last;
                    }
                    $j = $ep+1;
                }
                $k = $j;
                $k = $end_pos if($k > $end_pos);
            }
        } elsif($ValClass[$i] =~ /[sd"]/) {             # Scalar, digits, or string
            $k = end_of_variable($i);
            #say STDERR "end_of_variable $ValPerl[$i] at $i = $k";
            my $t = undef;
            if($k != $i) {      # Process subscripts
                my $firstsub = next_same_level_token('(', $i, $k);
                if($firstsub != -1) {
                    for(my $j = $firstsub; $j < $k; $j++) {
                        $t = 'S';
                        if($ValPerl[$j] eq '[') {   # Array subscript
                            $t = 'I';
                        } elsif($ValPerl[$j] eq '(') {  # This is like s->i(...) - not a subscript!
                            last;
                        }
                        my $m = matching_br($j);
                        $adjust = fix_type_issues($j+1, $m-1, $t);
                        $m += $adjust;
                        $limit += $adjust;
                        $k += $adjust;
                        $total_adjust += $adjust;
                        $j = $m;
                    }
                }
            }
        } elsif($ValClass[$i] =~ /[ah]/ && $ValPy[$i] =~ /^len\(/) {    # Scalar context
            $k = $i;
        # Not good to look backwards because we may have a function with non-parenthesised arguments
        #} elsif(defined ($ot = operator_type($i))) {
        #if($ValClass[$i-1] eq ')' && $ValPerl[$i-1] eq ')') {
        #my $j=reverse_matching_br($i-1);
        #while($j-1 >= 0 && $ValClass[$j-1] =~ /[if]/) {
        #$j--;
        #}
        #$adjust = insert_converter($start, $limit, $j, $i-1, $ot);
        #$total_adjust += $adjust;
        #$i += $adjust;
        #$limit += $adjust;
        #}
            # Not good to look forward since our $adjust will only pertain to SOME of the pointers
            #if($i+1 <= $#ValClass && $ValClass[$i+1] eq '(') {
            #$k = matching_br($i+1);
            #$adjust = insert_converter($start, $limit, $i+1, $k, $ot);
            #$total_adjust += $adjust;
            #$limit += $adjust;
            #}
            #next;
        } elsif($ValClass[$i] eq '(' && $ValPerl[$i] eq '(') {
            $k = matching_br($i);
            if($k+1 < $limit && defined($ot = operator_type($k+1, 1))) {
                $adjust = fix_type_issues($i, $k, $ot);
                $k += $adjust;
                $limit += $adjust;
                $total_adjust += $adjust;
                $i = $k;
            }
            next;
        } elsif($ValClass[$i] eq ')' && $ValPerl[$i] eq ')') {
            $k = reverse_matching_br($i);
            if($k > 0 && defined($ot = operator_type($k-1, 0))) {
                $adjust = insert_converter($start, $limit, $k, $i, $ot);
                $total_adjust += $adjust;
                $i += $adjust;
                $limit += $adjust;
            }
            next;
        #} elsif($opt = operator_type($i) && $opt ne $type) {
            #$adjust = insert_converter($start, $limit, $start, $i-1, $opt);
            #$total_adjust += $adjust;
            #$i += $adjust;
            #$k += $adjust;
            #$limit += $adjust;
        } elsif($ValClass[$i] eq ';' && $ValPy[0] ne 'for') {         # See it inside a anon sub
            return $total_adjust + fix_type_issues($i+1, $k, $type) if($i+1 >= $k);
            return $total_adjust;
        } elsif($ValClass[$i] eq ':' && $ValPy[$i] eq 'if') {   # issue 90: Converted ? : operator - first part - next is bool expr
            my $colon = next_same_level_token(':', $i+1, $limit);
            if($colon != -1) {
                $adjust = fix_type_issues($i+1, $colon-1, undef);
                $colon += $adjust;
                $limit += $adjust;
                $total_adjust += $adjust;
                $i = $colon;
                next;
            }
        } else {
            next;
        }
        $adjust = insert_converter($start, $limit, $i, $k, $type);
        $total_adjust += $adjust;
        $i = $k + $adjust;
        $limit += $adjust;
    }
    # Do one last check to make sure the whole expression is of the desired type
    $adjust = insert_converter($start, $limit, $start, $limit, $type);
    $total_adjust += $adjust;
    if($total_adjust && $debug >= 3) {
        say STDERR "After fix_type_issues: =|$TokenStr|=, \@ValPy: @ValPy";
    }
    return $total_adjust;
}

sub fix_multi_subscripts                                # issue 84
{
    # Replace code that pulls multiple subscripts from an array or expression
    # e.g. @arr[0,1,4]  @{$hash{$key}}[0,1,4]  (array_func())[0,1,4]
    # Generate: [arr[_i] for _i in [0,1,4]]
    for(my $i = 0; $i <= $#ValClass; $i++) {
        if(index('a@(', $ValClass[$i]) >= 0) {
            my $sub_start = $i+1;
            if($ValClass[$i] eq '@') {
                $sub_start = matching_br($i+1) + 1;
                next if($sub_start == 0);
            } elsif($ValClass[$i] eq '(' && $ValPerl[$i] eq '(') {
                $sub_start = matching_br($i) + 1;
                next if($sub_start == 0);
            } elsif($ValClass[$i] ne 'a') {
                next;                   # { or [
            }
            last if($sub_start > $#ValClass);
            next if($ValPerl[$sub_start] ne '[');
            my $sub_end = matching_br($sub_start);
            my $commas = 0;
            for(my $j = $sub_start+1; $j < $sub_end; $j++) {
                $commas++ if($ValClass[$j] eq ',');
            }
            if($commas >= 1) {          # We have a winner! - updated!
                insert($sub_end+1,')',']',']');         # Add the ending ']'
                insert($sub_start, 'y', 'multi', "[$INDEX_TEMP] for $INDEX_TEMP in ");      # 'y' is a special token type for "extra python code"
                insert($i, '(', '[', '[');              # Add the opening '['
                $i = $sub_end+3;
                if($debug > 3) {
                    say STDERR "fix_multi_subscripts: found $commas commas, updated code: =|$TokenStr|=";
                }
            }
        }
    }
}

sub remove_dereferences                     # issue 50
{
    # Run over the statement removing dereferences of the form &{...}, @{...} or %{...}
    # because python doesn't need them.  Also fix up hashref initialization.

    my %class_map = ('&'=>'i', '@'=>'a', '%'=>'h');

    for(my $i = 0; $i <= $#ValClass; $i++) {
        if($ValClass[$i] eq '&' || $ValClass[$i] eq '@' || $ValClass[$i] eq '%') {
            if($i < $#ValClass && $ValClass[$i+1] eq '(' && $ValPerl[$i+1] eq '{') {
                my $to=matching_br($i+1);
                next if($to < 0);
		$ValClass[$i+2] = $class_map{$ValClass[$i]} if($ValClass[$i+2] eq 's');
                destroy($to,1);                 # Delete the '}'
                destroy($i,2);                  # Delete the '@{'
                $i--;
            }
        } elsif($ValClass[$i] eq '(' && $ValPerl[$i] eq '{') {
            # This case happens in like $hash_ref = {this=>'that', these=>'those}
            # as by default all '{' are changed to '[', but in this case
            # they need to be restored to '{' and '}'.
            my $to = matching_br($i);
            next if($to < 0);
            my $j;
            if(($j = index($TokenStr,'A',$i+1)) > 0 && $j < $to) {   # $TokenStr is a string representation of @ValClass
                $ValPy[$i] = '{';
                $ValPy[$to] = '}';
            }
        }
    }
}

sub fix_global_and_eval_regex                                    # SNOOPYJC
# Fixup regex with non-existant re.G or re.E flags
{
    my $q = index($TokenStr, 'q');
    if($q < 0) {        # Look for f/re
        for(my $i = 0; $i <= $#ValClass; $i++) {
            if($ValClass[$i] eq 'f' && $ValPerl[$i] eq 're') {
                $q = $i;
                last;
            }
        }
    }
    return if($q < 0);

    return if($ValPy[$q] !~ /re\.[GE]/);

    if($ValPy[$q] =~ /re\.E/) {                                 # issue 78
        # re.sub(re.compile(rf"\$(\w+)",re.G|re.E),'expr'
        $ValPy[$q] =~ s/,re\.E\|/,/;
        $ValPy[$q] =~ s/.re\.E//;
        $ValPy[$q] =~ /,e'''(.*)'''/s;
        my $expr = $1;
        my $subname = "$ANONYMOUS_SUB$.";
        $nested_subs{$subname} = "$DEFAULT_MATCH";
        #say STDERR "expr=$expr, subname=$subname";
        $ValPy[$q] =~ s/,e'''.*'''/,$subname/s;
        $saved_eval_tokens = package_code();
        $saved_eval_lno = $.;
        my $t;
        my @tmpBuffer = @Perlscan::BufferValClass;      # SNOOPYJC: Skip the block on getting the next line
        @Perlscan::BufferValClass = ();
        while(($t = getline())) {
            push @saved_eval_buffer, $t;
            say STDERR "pushed $t onto saved_eval_buffer" if($debug >= 5);
        }
        @Perlscan::BufferValClass = @tmpBuffer;
        my @lines = split(/^/m, $expr);
        getline("sub $subname {");
        for my $ln (@lines) {
            say STDERR "pushed $ln to special buffer" if($debug >= 5);
            getline($ln,1);     # Push to special buffer
        }
        getline('}',1);        # Push to special buffer
        destroy(1, $#ValClass) if($#ValClass > 0);
        replace(0, 'C', 'nop', '');             # make it a no-op
        return;         # We handle the 'G' flag when generating the code on this one
    }
    return if($ValPy[$q] !~ /re\.G/);
    
    # '(_m:=re.search(re.compile(r'G',re.G),'

    # 2 cases: 
    if($ValClass[0] eq 'c' && $ValPerl[0] eq 'while') {
        # 1. while($scaler =~ /pat/g) {...}
        #   Generate: for _m in re.finditer(...)
        $ValPy[$q] =~ s/,re\.G\|/,/;
        $ValPy[$q] =~ s/.re\.G//;
        $ValPy[$q] =~ s/\($DEFAULT_MATCH:=re\.search/re.finditer/;
        $ValPy[$q] =~ s/^re\.search/re.finditer/;
        $ValPy[0] = $ValPerl[0] = 'for';
        insert($q+1, ')',')', ')');
        insert(1,'(','(','(');
        insert(1,'s',$DEFAULT_MATCH,$DEFAULT_MATCH);
        say STDERR "fix_global_and_eval_regex($q) produced =|$TokenStr|=" if($debug);
    } else {
        # 2. anything else:
        #   Generate: [_m[0] for _m in re.finditer(...)]
        # This is handled in regex_and_translate()
        ;
    }
}

sub fix_undef                                           # SNOOPYJC
# Change $a=$b=$c=undef; to undef $a, $c, $d; so we can generate the code that sets the
# value to the proper type (if we know it).
{
    return if(scalar(@ValClass) < 3);
    return if($ValClass[-1] ne 'f');
    return if($ValPerl[-1] ne 'undef');
    return if($ValClass[-2] ne '=');
    return if($ValClass[-3] ne 's');
    $start = 0;
    if($ValClass[0] eq 't') {
        return if($ValPerl[0] ne 'my');
        $start++;
    }
    insert($start, 'f', 'undef', $ValPy[-1]);
    destroy($#ValClass, 1);
    for(my $i = $start+1; $i<=$#ValClass; $i++) {
        replace($i, ',', ',', ',') if($ValClass[$i] eq '=');
    }
}

sub fix_expression_issues
{
   my $start = 0;
   my $limit = $#ValClass;
   my $end_pos = $limit;
   my $pos;

   # issue 74: Handle ++ and --
   while(($pos = next_matching_token('^', $start, $limit)) >= 0) {  # issue 74
       my $adjust = handle_incr_decr($start, $pos, $limit); # issue 74
       last if(!$adjust);                               # issue 74
       $end_pos += $adjust;                             # issue 74
       $limit += $adjust;                               # issue 74
   }                                                    # issue 74
   # SNOOPYJC: Handle cmp and <=>
   my $st = $start;
   while(($pos = next_matching_token('>', $st, $limit)) >= 0) {
       if($ValPerl[$pos] eq 'cmp' || $ValPerl[$pos] eq '<=>') {
           my $adjust = handle_cmp_spaceship($st, $pos, $limit);
           $end_pos += $adjust;
           $limit += $adjust;
       } else {
           $st = $pos+1;
       }
   }
   # issue 52: handle ? : operator
   while(($pos = next_matching_token('?', $start, $limit)) >= 0) {  # issue 52
       my $adjust = handle_question_mark_colon($start, $pos, $limit); # issue 52
       last if($adjust < 0);            # SNOOPYJC: Error case
       $end_pos += $adjust;                             # issue 52
       $limit += $adjust;                               # issue 52
   }                                                    # issue 52

   # issue 88: handle -bareword
   # We have to do it here and not in the lexer because of things like: t -timelocal(...)
   # was converting timelocal to "-timelocal"!!
   $st = $start;
   while(($pos = next_matching_token('-', $st, $limit)) >= 0) {
       if($pos+1 <= $#ValClass && $ValClass[$pos+1] eq 'i' && !$LocalSub{$ValPy[$pos+1]} && !$Constants{$ValPy[$pos+1]} &&
          ($pos == 0 || $ValClass[$pos-1] !~ /[s)]/)) {
           my $adjust = handle_negative_bareword($pos);
           $end_pos += $adjust;
           $limit += $adjust;
        } else {
            $st = $pos+1;
        }
   }

   # Check for use of IO::File:   $fh->read(scalar
   my $oorp = index($TokenStr, 'sDi(s');
   if($oorp >= 0 && exists $VarType{$ValPy[$oorp]} && exists $VarType{$ValPy[$oorp]}{$CurSub} &&
      $VarType{$ValPy[$oorp]}{$CurSub} eq 'H' && ($ValPerl[$oorp+2] eq 'read' || $ValPerl[$oorp+2] eq 'sysread')) {
        # Change it from an OO call to a normal function call so we can process it, as we can't change
        # the scalar in an OO call.
        # $fh->read(scalar  =>  read($fh, scalar
        #  0 1 2   3  4          0  1 2 3   4
        replace($oorp+3,',',',',',');
        my $perl = $ValPerl[$oorp+2];
        my $py = '.' . $ValPy[$oorp+2];
        replace($oorp+2,$ValClass[$oorp],$ValPerl[$oorp],$ValPy[$oorp]);
        replace($oorp+1,'(','(','(');
        replace($oorp,'f',$perl,$py);
   }
   # Check for use of IO::File: $fh->open(...) or $fh->binmode(...)
   my $oop = index($TokenStr, 'sDi(');
   if($oop >= 0 && exists $VarType{$ValPy[$oop]} && exists $VarType{$ValPy[$oop]}{$CurSub} &&
      $VarType{$ValPy[$oop]}{$CurSub} eq 'H' && ($ValPerl[$oop+2] eq 'open' || $ValPerl[$oop+2] eq 'fdopen' || $ValPerl[$oop+2] eq 'binmode' || $ValPerl[$oop+2] eq 'write')) {
        if($ValPerl[$oop+2] eq 'write') {
            # This one is easy as we just have to change it to "write_" as there already is
            # a fh.write() function, in fact we call it from "write_"!!
            $ValPy[$oop+2] = 'write_';
        } else {
            # Change it from an OO call to a normal function call so we can change the $fh to
            # the result of the function.
            # $fh->open(path  => open($fh, path
            #  0 1 2   3 4        0  1 2 3  4
            replace($oop+3,',',',',',');
            my $func = $ValPerl[$oop+2];
            my $py = '_' . $func;
            if($func eq 'open') {
                $func = 'IOFile_open';
                $py = '_IOFile_open';
            } elsif($func eq 'fdopen') {
                $py = '_fdopen';
            }
            replace($oop+2,$ValClass[$oop],$ValPerl[$oop],$ValPy[$oop]);
            replace($oop+1,'(','(','(');
            replace($oop,'f',$func,$py);
        }
   }

   # SNOOPYJC: Handle read in expressions
   $st = $start;
   while(($pos = next_matching_tokens('f', $st, $limit)) >= 0) {
       if($ValPy[$pos] eq '.read' || $ValPy[$pos] eq '.sysread') {
       	  my $adjust = fixup_read_in_expression($pos);
          $end_pos += $adjust;
          $limit += $adjust;
       }
       $st = $pos+1;
   }

   # SNOOPYJC: Handle assignment in expressions
   $st = $start;
   while(($pos = next_matching_tokens('=~', $st, $limit)) >= 0) {
       my $adjust = handle_assignment_in_expression($pos);
       $end_pos += $adjust;
       $limit += $adjust;
       $st = $pos+1;
   }

   # SNOOPYJC: Handle eval in expressions
   $st = $start;
   while(($pos = next_matching_tokens('C', $st, $limit)) >= 0) {
       if($ValPerl[$pos] eq 'eval') {
           my $adjust = handle_eval_in_expression($pos);
           $end_pos += $adjust;
           $limit += $adjust;
       }
       $st = $pos+1;
       last if($st > $limit);
   }

   # SNOOPYJC: Handle i=>x in sub/function calls and also fixup "new" method calls that are built-in functions
   $st = $start;
   while(($pos = next_matching_tokens('if', $st, $limit)) >= 0) {
       
       if($pos+1 <= $limit && $ValClass[$pos+1] eq '(') {    # Only handle parenthesized arglists for now
          my $end_pos = matching_br($pos+1);
          while(1) {
              my $arrow = next_same_level_token('A', $pos+2, $end_pos-1);   # '=>' operator
              last if($arrow == -1);
              $ValPy[$arrow] = ',';
              $pos = $arrow;
          }
       }
       $st = $pos+1;
       last if($st > $limit);
   }

   # issue 81: Handle anonymous sub in expression
   # It's always the last thing because we stop lexxing there
   if($#ValClass != 0 && $ValClass[$#ValClass] eq 'k' && $ValPerl[$#ValClass] eq 'sub') {
       handle_anonymous_sub_in_expression();
   }

#   goto SKIPITFORNOW;
#   $st = $start;
#   while(($pos = next_matching_token('k', $st, $limit)) >= 0) {
#       if($ValPerl[$pos] eq 'sub' && $pos != 0) {
#           my $adjust = handle_anonymous_sub_in_expression($start, $pos, $limit);
#           $end_pos += $adjust;
#           $limit += $adjust;
#        } else {
#            $st = $pos+1;
#        }
#    }
#    SKIPITFORNOW: ;
}

sub finish
# imitation of continue statement.
{
    if( defined($TrStatus) && $TrStatus < 0 ){
       push(@NoTrans,"[$.]: $line");
    }
    $generated_code = scalar(@Perlscan::PythonCode);            # issue 45
    # issue 45 gen_statement();
    my $prev_line = $line;                                      # issue 45
    $line=getline(0) if($deferred_statement < 2 && !defined $split_multiple_assignment); # get new line # issue 58, issue 45, issue 115
    #say STDERR "finish $CurSub generated_code=$generated_code, line=(($line)), prev_line=(($prev_line)), ValPerl=@ValPerl, CurNest=$Pythonizer::CurNest";
    #say STDERR "finish nested_sub_at_level=$nested_sub_at_level, nesting_level=$Perlscan::nesting_level";
    if(($CurSub ne '__main__' || scalar(@eval_stack) != 0 || $nested_sub_at_level > 0) && # issue 42, issue 41, issue 78
        defined $line &&                                        # issue 42
        ($line eq '}' || $line =~ m'^}\s*#' || $line eq '};' ||
         $line =~ m'^\s*}\s*$' || $line =~ m'^\s*};\s*$' ||     # SNOOPYJC
         $line =~ m'^\s*};\s*#') &&                                # issue 42
        #$ValPerl[0] ne 'return' && $Pythonizer::CurNest==1) {      # issue 45
        $ValPerl[0] ne 'return' && ($Perlscan::nesting_level==1 ||  # issue 45, SNOOPYJC: Handle sub with try block
        $Perlscan::nesting_level == $nested_sub_at_level)) {      # issue 78
        if($debug >= 5) {                                       # issue 45
            say STDERR "finish: prev_line=$prev_line, PythonCode=@Perlscan::PythonCode";               # issue 45
        }                                                       # issue 45
        my $comment='';                                         # SNOOPYJC
        $comment = $1 if($line =~ m'^\s*};?(\s*#.*)$');            # SNOOPYJC
        if($generated_code == 0 && index('fds"(-', $ValClass[0]) >= 0) {   # issue 45
            $prev_line =~ s/\s+#.*$//;                          # issue 45: remove comments
            $prev_line =~ s/\s+$//;                             # SNOOPYJC: remove trailing spaces
            $last_c = substr($prev_line,-1,1);                  # issue 45
            if($last_c eq '}' && $ValClass[-1] ne ')') {        # issue 45
                chop $prev_line;                                # issue 45
                $prev_line =~ s/\s+$//;                         # issue 45
                $last_c = substr($prev_line,-1,1);              # issue 45
            }                                                   # issue 45
            if($last_c eq ';') {                                # issue 45
                $line = "return ".$prev_line;                   # issue 45
            } else {                                            # issue 45
                $line = "return ".$prev_line.';';               # issue 45
            }                                                   # issue 45
            getline('}'.$comment);                              # issue 45, SNOOPYJC
        } elsif($ValClass[0] eq 'f') {                          # issue 45
            # In this case, we generated the code for a function call - sneak the 'return' in just before it
            my $return = 'return';                              # issue 45
            if(scalar(@eval_stack) != 0) {                      # issue 45
               $return = undef;                                 # issue 45
               if(exists $eval_stack[-1]->{assignment}) {       # issue 45
                  my $lno = $eval_stack[-1]->{lno};             # issue 45
                  $return = "$EVAL_RESULT$lno = ";              # issue 45: for an a = eval {...};, we set the EVAL_RESULT instead of returning
               }                                                # issue 45
            } elsif($Perlscan::PythonCode[0] =~ /^(?:(?:raise )|(?:return ))/) {    # issue 45 
                $return = undef;                                # issue 45
            } elsif($Perlscan::PythonCode[0] =~ /^[\w.]+\s*=/) {    # SNOOPYJC: as in fh = _open(...)
                my $perl_name = (($ValClass[1] eq '(') ? $ValPerl[2] : $ValPerl[1]);
                $line = "return $perl_name;";
                getline('}'.$comment);
                $return = undef;
            }                                                   # issue 45
            unshift @Perlscan::PythonCode,$return if($return);  # issue 45
        } elsif($ValClass[0] !~ /[cCk]/ && index($TokenStr,'=') > 0) {               # issue 45
            $prev_line =~ s/^\s*my\s+//;                        # issue 45
            $prev_line =~ s/^\s*own\s+//;                       # issue 45
            $prev_line =~ s/[+*\/\|\&.-]=/=/;                   # issue 45: Remove + from +=, etc
            $prev_line =~ s/^\s*\(//;                           # issue 45: Remove (
            my $p = index($prev_line,'=');                      # issue 45
            if($p < 0) {                                        # issue 45
                if($prev_line =~ s/^\s*(?:(?:\+\+)|(?:--))//) { # issue 45: pre-incr/pre-decr
                    $line = "return $prev_line";                # issue 45
                    $line =~ s/;.*$//;                          # issue 45
                } elsif($prev_line =~ /\+\+\s*;/) {             # issue 45: post-incr
                    $line = $prev_line;                         # issue 45
                    $line =~ s/^(.*)\+\+\s*;.*$/return $1-1/;   # issue 45
                } elsif($prev_line =~ /--\s*;/) {               # issue 45: post-decr
                    $line = $prev_line;                         # issue 45
                    $line =~ s/^(.*)--\s*;.*$/return $1+1/;     # issue 45
                }                                               # issue 45
            } else {                                            # issue 45
                $line = "return ".substr($prev_line, 0, $p);    # issue 45
                $line =~ s/\s*[.+*\/\|\&-]$//;                  # issue 45: remove char prior to '=', like in '+='
            }                                                   # issue 45
            $line .=';';                                        # issue 45
            getline('}'.$comment);                              # issue 45, SNOOPYJC
        }                                                       # issue 45
        if($debug >= 5) {                                       # issue 45
            say STDERR "finish: Resetting line to $line";       # issue 45
        }                                                       # issue 45
    }                                                           # issue 45
    gen_statement();                                            # issue 45
    getline(1);                                                 # issue 45

    $eval_nest = ((scalar(@eval_stack) == 0) ? -2 : $eval_stack[-1]->{eval_nest});        # issue 42
    if($debug >= 3 && scalar(@eval_stack)) {
        say STDERR "eval_stack=@eval_stack, eval_nest=$eval_nest";
    }
    if($eval_nest == $Pythonizer::CurNest && !$Perlscan::PREV_HAD_COLON) {  # issue 42
        gen_statement();                                        # issue 42
        if(exists $SpecialVarsUsed{'$@'}) {
            correct_nest(1,1);                                      # issue 42
            gen_statement('EVAL_ERROR = None');                     # issue 42
            correct_nest(-1,-1);                                    # issue 42
        }
        if(exists $eval_stack[-1]->{had_return}) {              # issue 42: there was a "return" statement
            gen_statement("except $EVAL_RETURN_EXCEPTION:");    # issue 42
            if(exists $SpecialVarsUsed{'$@'}) {
                correct_nest(1,1);                                  # issue 42
                gen_statement('EVAL_ERROR = None');                 # issue 42
                correct_nest(-1,-1);                                # issue 42
            }
        }                                                       # issue 42
        if(exists $SpecialVarsUsed{'$@'}) {
            gen_statement('except Exception as _e:');           # issue 42
        } else {
            gen_statement('except Exception:');                 # issue 42
        }
        correct_nest(1,1);                                      # issue 42
        output_line('traceback.print_exc()') if($traceback);    # SNOOPYJC
        if(exists $SpecialVarsUsed{'$@'}) {
            $Pyf{"_exc"} = 1;                       		# issue 42
            #gen_statement('EVAL_ERROR = _exc(_e)');             # issue 42
            gen_chunk('EVAL_ERROR = ', '_exc', '(_e)');         # SNOOPYJC: Gen separately to support perllib
            gen_statement();                                    # SNOOPYJC
        } else {
            gen_statement('pass');
        }
        correct_nest(-1,-1);                                    # issue 42
        if(exists $eval_stack[-1]->{assignment}) {              # issue 42
            unpackage_code($eval_stack[-1]->{assignment});      # issue 42
            if($ValClass[0] eq 's' && $ValPy[0] eq $ValPy[2]) { # issue 42: Skip generating _eval_result = _eval_result
                ;                                               # issue 42
            } else {                                            # issue 42
                assignment($ValClass[0] eq 't' ? 1 : 0);        # issue 42 - generate the code for the assignment we packaged up
            }                                                   # issue 42
            gen_statement();                                    # issue 42
        }                                                       # issue 42
        pop @eval_stack;                                        # issue 42
    }
    if($context_manager_nest == $Pythonizer::CurNest-1 && $ValClass[0] ne 'c') {    # issue 66
        if($debug >= 3) {                                       # issue 66
            say STDERR "Resetting context manager nest";        # issue 66
        }
        correct_nest(-1);                                       # issue 66
        $context_manager_nest = -2;                             # issue 66
    }                                                           # issue 66
    correct_nest();
    if($Perlscan::nesting_level < $nested_sub_at_level) {       # issue 78
        $nested_sub_at_level = -1;
    }
} # finish

sub copy_partially_initialized_locals                           # issue 108
# If we have locals that are only partially initialized (e.g. local ($arr[0]) = val;), then we must make a copy first
{
    ($from,$to)=@_;
    for(my $i=$from; $i<=$to; $i++) {
        if($ValClass[$i] eq 's' && $ValClass[$i+1] eq '(') {
            gen_statement("$ValPy[$i] = $ValPy[$i].copy()");
            $i = end_of_variable($i);
        }
    }
}

sub rename_state_var
{
($from,$to)=@_;
   for(my $i=$from; $i<=$to; $i++ ){
      if( defined($ValClass[$i]) &&  $ValClass[$i]=~/[sah]/ && exists($new_state_var_name{$ValPy[$i]}) ){
          if(exists $VarType{$ValPy[$i]} && exists $VarType{$ValPy[$i]}{$CurSub}) {    # SNOOPYJC: Copy it's type over
              $VarType{"${CurSub}_$ValPy[$i]"}{$CurSub} = $VarType{$ValPy[$i]}{$CurSub};
          }
          $ValPy[$i]=$CurSub.'_'.$ValPy[$i];
      }
   }
}
sub initialize_globals_for_state_vars
{
    my @state_var = keys %new_state_var_name;           # SNOOPYJC
    # SNOOPYJC my  @renamed_state_var=values(%new_state_var_name);
    if($debug >= 3) {           # SNOOPYJC
        say STDERR "initialize_globals_for_state_vars: @state_var";
    }
   return unless( defined($state_var[0]) ); # nothing to do     # SNOOPYJC
   # First generate varibles for which we have inialization
   foreach $sv (@state_var) {        # SNOOPYJC
      my $renamed_sv = $new_state_var_name{$sv};
      my $val = 'None';                         # SNOOPYJC
      $renamed_sv =~ /^(.*)_$sv$/;
      my $sv_sub = $1;                          # SNOOPYJC: Get the sub name from the renamed sv name
      #say STDERR "sv_sub = $sv_sub";
      if( exists($new_state_var_init{$sv}) ){
          $val = $new_state_var_init{$sv};
      } elsif(exists($VarType{$sv}{$sv_sub})) {         # SNOOPYJC
          $val = init_val($VarType{$sv}{$sv_sub});      # SNOOPYJC: Use our computed type for the init
      }
      gen_statement($renamed_sv.' = '.$val);
   }
# SNOOPYJC    # Now initialize the rest to None
# SNOOPYJC my $first=0;
# SNOOPYJC    for( $i=0; $i<@renamed_state_var; $i++){
# SNOOPYJC       unless( exists($new_state_var_init{$renamed_state_var[$i]}) ){
# SNOOPYJC          if( $first==0 ){
# SNOOPYJC             gen_chunk($renamed_state_var[$i]);
# SNOOPYJC             $first++;
# SNOOPYJC          }else{
# SNOOPYJC             gen_chunk(' = ',$renamed_state_var[$i]);
# SNOOPYJC          }
# SNOOPYJC       }
# SNOOPYJC    }
# SNOOPYJC    ($first) && gen_chunk(' = None');
# SNOOPYJC    gen_statement;
}
#
# Print statement for Python 3
#
sub print3
{
my $begin=$start=$_[0];
my ($k,$handle);
my $end_pos=$#ValClass;                                            # issue 10
# end="") instead of trailing comma in Python 2
   if($start+1 <= $#ValClass && $ValClass[$start+1] eq '(') {     # issue printf: handle bracketed
       $end_pos = matching_br($start+1) - 1;
       $start++;
   }
   if( $start+1 <= $#ValClass && $ValClass[$start+1] =~ /[is]/ ){ # issue 32
      $handle=$ValPy[$start+1];
      $k=$start+2;
      if($k <= $#ValClass && ($ValClass[$k] eq ',' || $ValClass[$k] eq 'D')) {    # issue 32; handle print $session->elapsed_time(...), issue 93
          $handle='';
          $k = $start+1;
      }elsif($ValClass[$start+1] eq 's' && ($#ValClass == $start+1 || $ValClass[$start+2] eq '(')) { # issue 32
          $handle='';
          $k = $start+1;
      }
   }else{
      $handle='';
      $k=$start+1;
      $handle=$_[1] if(scalar(@_) >= 2);        # SNOOPYJC: warn
   }
   # issue 10 if( $#ValClass>$k ){
   if($debug >= 3) {
      say STDERR "print3($begin) start=$start, handle=$handle, k=$k, end_pos=$end_pos\n";
   }
   if($begin != 0 && $ValClass[$begin-1] eq '(' && $ValClass[-1] eq ')') {	# issue 10: Surrounded by ( )
       $end_pos--;
       if($debug >= 3) {
          say STDERR "setting end_pos = $end_pos\n";
       }
   }
   if($start == 0 && ($traceback == 0 || $handle eq '' || $handle eq 'sys.stdout' || $handle eq 'sys.stderr')) {                    # issue 77
       gen_chunk($ValPy[$start],'(');
   } else {                             # issue 77
       $Pyf{"_perl_print"} = 1;		# issue 77
       gen_chunk('_perl_print', '(');        # issue 77 - this print returns 1 on success
   }                                    # issue 77
   if( $end_pos>=$k ){	# issue 10
      # issue 10 $TrStatus=expression($k,$#ValClass,0);
      if($ValPerl[$begin] eq 'printf') {                # issue printf
          my $comma=next_same_level_token(',',$k,$end_pos);
          $comma = $end_pos+1 if($comma < 0);
          $Pyf{_format} = 1;                    # SNOOPYJC
          gen_chunk('_format', '(');            # SNOOPYJC
          $TrStatus=expression($k,$comma-1,0);    # format
          return -1 if ($TrStatus<0);
          if($ValClass[$k] eq 'a' && $comma == $end_pos+1) {    # format is first element of the array
              # SNOOPYJC gen_chunk('[0] % (', $ValPy[$k], '[1:])');
              gen_chunk('[0], (', $ValPy[$k], '[1:])');        # SNOOPYJC
          } else {
              # SNOOPYJC gen_chunk(' % (');
              if($comma+1 <= $end_pos) {        # SNOOPYJC
                  gen_chunk(', (');        # SNOOPYJC
                  $TrStatus=expression($comma+1,$end_pos,0);   # list
                  gen_chunk(')');
              }
          }
          gen_chunk(')');               # SNOOPYJC
      } else {
          $TrStatus=expression($k,$end_pos,0);		# issue 10
      }
      return -1 if ($TrStatus<0);
   }else{
      $end = ($ValPerl[$begin] eq 'print' || $ValPerl[$begin] eq 'printf') ? ', end=""' : '';      # issue 59
      $def = $DEFAULT_VAR;              # issue printf
      if($ValPerl[$begin] eq 'printf') {
          $def .= ' % ()';
      }
      if(length($handle)>0){
          # issue 59 gen_chunk("file=$handle)");
         gen_chunk("$def, file=$handle$end)");      # issue 59
      }else{
          # issue 59 gen_chunk(')');
          gen_chunk("$def$end)");           # issue 59
      }
      return 0;
   }
   if (($ValPerl[$begin] eq 'print' || $ValPerl[$begin] eq 'printf') && $ValClass[-1] eq '"' ){
      if( $Perlscan::PythonCode[-1]=~qr[\\n["']$] ){
         substr($Perlscan::PythonCode[-1],-3,2)=''; # Perl print was actually say
      }else{
         gen_chunk(',end=""');
      }
   } elsif($ValPerl[$begin] eq 'print' || $ValPerl[$begin] eq 'printf') {               # issue 59
       gen_chunk(',end=""');
   }
   if( $handle){
      #printing to file handle
       gen_chunk(',file=',$handle); #  Python   3.x:   print('hello world', file=file_object)
   }

   #say
   gen_chunk(')');
   #if($end_pos != $#ValClass) {	# issue 10
   #gen_chunk(')');		# issue 10
   #}				# issue 10
   return scalar(@ValClass);
} # print3

sub assignment
#
# Analyse and generate code for Perl assignment statement
#
{
my $start=$_[0]; # start of analysys of assignment statement
   if( $start<0 || $TrStatus<0  ){
      return -255;
   }
my $limit=(scalar(@_)>1) ? $_[1] : $#ValClass; # Nov 11, 2019  accept not only the index of the first token, but also index of the last.
   if($debug >= 3) {
	   say STDERR "assignment($start, $limit) =|$TokenStr|= @ValPerl\n"
   }
my ($k,$split,$post_processing,$comma_pos,$colon_pos,$from,$to);
#
# Assignment with post condition need to be transformed into regular control structure in Python
#
   $k=$start;
   if(exists $SpecialVarR2L{$ValPy[$k]}) {      # SNOOPYJC: Change _nr() to INPUT_LINE_NUMBER etc
       $ValPy[$k] = $SpecialVarR2L{$ValPy[$k]};
   }

#
# C-style ++ and --
#
   if( $ValClass[$#ValClass] eq '^' ){
       if ($#ValClass-$start==1){
	 if($ValPy[$k] =~ /^\(len\((.*)\)-1\)$/) { # issue 14 - increment or decrement array length
            $arrName = $1;			# issue 14
	    if($ValPerl[$#ValClass] eq '++') {	# issue 14: add one element to array
	       gen_chunk("$arrName.append(None)");	# issue 14
	    } else {				# issue 14
	       gen_chunk("del $arrName".'[len('.$arrName.')-1:]');	# issue 14
	    }
	 } else {				# issue 14
            gen_chunk($ValPy[$k],$ValPy[$k+1]);
	 }
         return $#ValClass+1;
       }else{
         replace($#ValClass,'=','=',substr($ValPy[-1],0,2));
         append('d','1','1');
         $limit+=1;
         if($debug >= 3) {
	   say STDERR "assignment_updated($start, $limit) =|$TokenStr|= @ValPerl\n"
         }
       }
    }
#
# We assume this is a regular assignment with "=". Let's analyse the left  side.
#
   my $add_right_paren = 0;			# issue 14
   my $skip_assign_op = 0;                      # issue 14
   my $extra = -1;                              # SNOOPYJC
   my $orig_limit = $limit;                     # SNOOPYJC
   my $number_of_elements = undef;                     # issue 56, SNOOPYJC: Handle ()
   # issue 105 if( ($split=index($TokenStr,'=',$k))>-1 ){
   if( ($split=next_same_level_token('=', $k, $#ValClass)) != -1) {     # issue 105: skip any := in the LHS
       if($split+1 <= $#ValClass && $ValClass[$split+1] eq 'C') {         # issue 42
           if(handle_assign_eval($split+1)) {   # issue 42
               return $#ValClass;               # issue 42
           }                                    # issue 42
           $limit = $#ValClass;                 # issue 42 - we deleted the (...)
       }                                        # issue 42
       $extra = next_lower_or_equal_precedent_token(',', $split+1, $limit);     # SNOOPYJC
       # Handle things like $j=$i, $k=$j, ...
       if($extra >= 0 && $extra < $limit) {
           # Watch out for an unparenthesized function or sub call though, as those commas belong to him!
           for(my $x = $split+1; $x < $extra; $x++) {
               if($ValClass[$x] =~ /[if]/ && $ValClass[$x+1] ne '(') {
                   $extra = -1;
                   last;
                }
           }
           if($extra >= 0) {
               $limit = $extra-1;
               gen_chunk('(');
               $add_right_paren = 1;
               if($ValPy[$split] ne '=' && $ValPy[$split] ne ':=') {  # Handle +=, etc
                   # Change $a+=2 to $a = $a + 2
                    insert($split+1,$ValClass[$k],$ValPerl[$k],$ValPy[$k]);
                    $op = substr($ValPerl[$split],0,1);
                    insert($split+2,$op,$op,$op);
                    $limit += 2;
                    $extra += 2;
		    $orig_limit += 2;		# issue 116
               }
               $ValPy[$split] = ':=';
           }
       } else {
           $extra = -1;
       }
       if( $split-$k==1 ){
         if($ValPy[$k] =~ /^\(len\((.*)\)-1\)$/) { # issue 14 - assign array last element index
             if($ValPy[$split] ne '=' && $ValPy[$split] ne ':=') {	# issue 14 - handle +=, -=, etc
	        $ValPy[$split] = '=';		# issue 14
	        insert($split+1,$ValClass[$k],$ValPerl[$k],$ValPy[$k]);	# issue 14
		$op = substr($ValPerl[$split],0,1); # issue 14
	        insert($split+2,$op,$op,$op);	# issue 14
		$limit += 2;			# issue 14
	     }					# issue 14
     	     $Pyf{"_set_last_ndx"} = 1;		# issue 14
	     gen_chunk('_set_last_ndx', "($1,");	# issue 14
	     $add_right_paren = 1;		# issue 14
             $skip_assign_op = 1;               # issue 14
	 } else {				# issue 14
            # single token on the left side -- regular assignment;
            gen_chunk($ValPy[$k]); # simple scalar assignment -- varible of left side
            if($ValPerl[$k] eq '$?' && substr($CurSub, 0, 7) eq '__END__') {    # SNOOPYJC
                logme('W', "Sorry, python does not support setting the exit code in an END (atexit) block");
            }
	  }					# issue 14
       }elsif( $ValPerl[$k] eq '(' && $ValPerl[$k+1] eq ')') {  # SNOOPYJC: goatse
           $number_of_elements = 0;             # SNOOPYJC
           gen_chunk('[]');
       }elsif($k+2 < $split && $ValPerl[$k] eq '(' && $ValClass[$k+1] eq 'a' && $ValPerl[$k+2] eq ')') { # SNOOPYJC local (@arr) = ...
           gen_chunk($ValPy[$k+1]);
           $k += 3;
       }elsif( $ValPerl[$k] eq '(' ){
          # brackets on the right side -- we assume that this is the list on the left side
	  #
	  # Issue 56: perl allows the length of the list on the lhs and rhs to be different.  Handle this
	  # by inserting a function surrounding the rhs which returns the proper number of elements
	  # corresponding to the lhs.  Pass that # to the function.
	  #
          gen_chunk('[');
          $k++;
          if($ValClass[$k] eq 'f' && $ValPerl[$k] eq 'undef') { # issue 63
              gen_chunk('_');        # issue 63
          } elsif($ValClass[$k] eq 'G') {         # issue 108
              gen_chunk(&Perlscan::choose_glob($ValPerl[$k], $ValPy[$k]));
          } elsif($ValClass[$k] eq 's' && $ValClass[$k+1] eq '(') {     # Some sort of array index or hash key
              my $l = end_of_variable($k);
              $TrStatus = expression($k, $l, 0);
              $k = $l;
          } else {
              gen_chunk($ValPy[$k]); # first in the cascading assignement
          }
          $number_of_elements++;                # issue 56
          $k++;
          while($k<$split ){
             # this was we skip delimiters
             # issue 63 if( substr($TokenStr,$k,1)=~/^[sha]/ ){
             if( substr($TokenStr,$k,1)=~/^[shafG]/ ){   # issue 63: handle multiple undef in lhs list, issue 108
                if($ValClass[$k] eq 'f' && $ValPerl[$k] eq 'undef') {   # issue 63
                    gen_chunk(',_');                                    # issue 63
                } elsif($ValClass[$k] eq 'G') {         # issue 108
                    gen_chunk(','.&Perlscan::choose_glob($ValPerl[$k], $ValPy[$k]));
                } elsif($ValClass[$k] eq 's' && $ValClass[$k+1] eq '(') {     # Some sort of array index or hash key
                    my $l = end_of_variable($k);
                    gen_chunk(',');
                    $TrStatus = expression($k, $l, 0);
                    $k = $l;
                } else {
                    gen_chunk(','.$ValPy[$k]);
                }
                $number_of_elements++;          # issue 56
             }
             $k++;
          }
          gen_chunk(']');
          $k++;
      }else{
         # possibly  array with complex subscripts or complex hash key expression
	 if(substr($TokenStr,$k) =~ /^s\([si"]\)=\(\)$/ &&
	    $ValPerl[$k+1] eq '{' && $ValPy[$k+5] eq '(') {	# issue 36
	    # Assigning an empty tuple to a hash value is never what you want
            if($autovivification) {         # SNOOPYJC
               $Pyf{Hash} = 1;
	       $ValPy[$k+5] = ($import_perllib ? "$PERLLIB.Hash(" : 'Hash(');
	       $ValPy[$k+6] = ')';
            } else {
	       $ValPy[$k+5] = '{';					# issue 36
	       $ValPy[$k+6] = '}';					# issue 36
            }
	 }
         # SNOOPYJC: Assigning to $ARGV[n] produces code that doesn't work as
         # it assigns to the slice (sys.argv[1:]), not the real variable, so fix that up here.
         if($ValClass[$k] eq 's' && $ValPerl[$k] eq '$ARGV' && $ValClass[$k+1] eq '(') {        # SNOOPYJC
             substr($ValPy[$k],-4) = '';        # Lose the '[1:]'
             if($ValClass[$k+2] eq 'd') {       # Easy case
                 $ValPy[$k+2] += 1;
             } else {
                 insert($k+2, '+', '+', '+');
                 insert($k+2, 'd', '1', '1');
                 $split += 2;
                 $limit += 2;
             }
         }
         $k=expression($k,$split-1,0); # on the left side it can be array index or something more complex
         return -255 if ($k<0);
      }
      # issue 14 gen_chunk($ValPy[$split]); # generate appropriate operation hidden under generic token '=' (  +=, -=, etc)
      gen_chunk($ValPy[$split]) unless $skip_assign_op == 1; # issue 14: generate appropriate operation hidden under generic token '=' (  +=, -=, etc)

      if(defined $number_of_elements) {         # issue 56, SNOOPYJC: Handle goatse
        $Pyf{"_list_of_n"} = 1;		# issue 56
        gen_chunk('_list_of_n', '(');   # issue 56
      }                                 # issue 56

      if( $limit - $split == 1 ){
         # only one token after '='
	 if($debug >= 3) {
	 	say STDERR "assign, ValClass[limit] = $ValClass[$limit], ValPy=$ValPy[$limit], ValPerl=$ValPerl[$limit]\n";
         }
         if ($ValClass[$limit] eq 'x' ) {
            gen_chunk(qq{subprocess.run($ValPy[$split+1],capture_output=True,text=True,shell=True)});
            gen_statement();
            if($autodie || exists $SpecialVarsUsed{'$?'}) {        # SNOOPYJC
               gen_statement(qq{$SUBPROCESS_RC=$ValPy[$split-1].returncode});
            }
            gen_chunk($ValPy[$k]);
            gen_chunk($ValPy[$split]);
            gen_chunk($ValPy[$k].'.stdout');
            if($autodie) {                              # SNOOPYJC
                gen_statement();
                gen_statement("if $SUBPROCESS_RC:");
                correct_nest(1,1);
                gen_statement("raise Die(f'run(${\(escape_string(unquote_string($ValPy[$split+1]), '\''))}): failed with {$SUBPROCESS_RC}')");
                correct_nest(-1,-1);
            }
	 }elsif($ValClass[$limit] eq 'f') {	# Issue 8: this is a function like shift with no args
            function($limit,$limit);		# Issue 8
         # SNOOPYJC }elsif($ValClass[$limit] eq 'i' && $ValPy[$limit] eq $ValPerl[$limit]) {	# issue 13
	 }elsif($ValClass[$limit] eq 'i') {	# issue 13, SNOOPYJC
	      if( $LocalSub{$ValPy[$limit]} ){						# issue 13: local sub call with no parens
	        gen_chunk(escape_keywords($ValPy[$limit]));				# issue 13, issue 41
	        gen_chunk('()');							# issue 13
              } elsif ($Constants{$ValPy[$limit]}) {                                    # issue 13: constant or file handle
                gen_chunk($ValPy[$limit]);                 	        		# issue 13
	      } else {									# issue 13: bare word - treat as string
	        gen_chunk("'".$ValPy[$limit]."'");					# issue 13
	      }
         }elsif(defined $number_of_elements && $ValClass[$limit] eq 'h') {      # SNOOPYJC: "($k, $v) = %h;" tested in issue 115
            gen_chunk('list(*');            # Splat it
            gen_chunk($ValPy[$limit]); # that includes diamond operator <> and <HANDLE> Aug 10,2020
            gen_chunk('.items())');
         }else{
            gen_chunk($ValPy[$limit]); # that includes diamond operator <> and <HANDLE> Aug 10,2020
            #$is_numeric{$ValPerl[$k]}='d'; # capture the type of variable.
         }
         gen_chunk(", $number_of_elements)") if(defined $number_of_elements);    # issue 56, SNOOPYJC
	 gen_chunk(')') if($add_right_paren);		# issue 14
         # handle autoflush return($#ValClass);
      }elsif($limit - $split == 2 && $ValClass[$split+1] eq '(' && $ValClass[$split+2] eq ')') {        # issue paren
          # We have some sort of empty parens on the RHS.  Generate the correct type of code depending on
          # what type of parens the user entered.
          $k = $split+1;
          if($ValPerl[$k] eq '{') {             # {} = Empty hashref
              if($autovivification) {         # SNOOPYJC
                 $Pyf{Hash} = 1;
                 gen_chunk('Hash', '()');
              } else {
                 gen_chunk("dict()");
              }
          } else {                              # [] = Empty arrayref, () = Empty array
              if($autovivification) {         # SNOOPYJC
                 $Pyf{Array} = 1;
                 gen_chunk('Array', '()');
              } else {
                 gen_chunk("[]");
              }
          }
          gen_chunk(", $number_of_elements)") if(defined $number_of_elements);    # issue 56, SNOOPYJC
	  gen_chunk(')') if($add_right_paren);		# issue 14
          if($extra >= 0) {
	      gen_extra($extra, $orig_limit);	# issue 116
          }
          return($#ValClass);
      }else{
          # we have some kind of expression on  the right side
          # issue 52 if( (substr($TokenStr,$split,2) eq '=(')>-1 &&  (index($TokenStr,')?',$split))>-1 ){
         if( index($TokenStr,'?',$split) >-1 ){         # issue 52
            # this is C-style conditional assigment   x=(v>0)?y:z;  -or- x=v>0?y:z;
            # Step one analyse the expression in blackets
            my $bracketed = 0;                          # issue 52
            if($ValClass[$split+1] eq '(') {            # issue 52
                $to=matching_br($split+1);
                ($to<0) && return -255;
                $bracketed = 1;                         # issue 52
            } else {                                    # issue 52
                $to = index($TokenStr,'?',$split+1)-1;    # issue 52
            }

            # Fist we need to generate then part of ternary if expression

            $colon_pos=index($TokenStr,':',$to+2);
            #say "to=$to, colon_pos=$colon_pos, bracketed=$bracketed";
            if( $colon_pos>-1 ){
               $k=expression($to+2,$colon_pos-1,0);
               return -255 if( $k<0 );

            }else{
               $k=expression($to+2,$#ValClass,0);
               return -255 if( $k<0 );
            }
            gen_chunk(' if ');
            $k=$split+1;
            if($bracketed) {                            # issue 52
               if( $to==$k+2){
                  $k++;
                  gen_chunk($ValPy[$k]); # expression consist of one token
                  $k+=3; # the next symbol after ')?'
               }else{
                  $k=expression($k+1,$to-1,0); # generate conditon without brackets
                  return -255 if ($k<0);
               }
            } else {
                  $k=expression($k,$to,0); # generate conditon
                  return -255 if ($k<0);
            }
            if ($colon_pos>-1){
               gen_chunk(' else ');
               $k=expression($colon_pos+1,$#ValPerl,0); # up to the very end
               return -255 if( $k<0 );
            }
            gen_chunk(", $number_of_elements)") if(defined $number_of_elements);    # issue 56, SNOOPYJC
	    gen_chunk(')') if($add_right_paren);		# issue 14
            gen_statement(); # output if line
            if($extra >= 0) {
                gen_chunk($ValPy[$extra]);
                $k = next_lower_or_equal_precedent_token('=', $extra+1, $orig_limit);
                if($k < 0 || $ValClass[$k] ne '=') {
                    $TrStatus=expression($extra+1, $orig_limit, 0);
                } else {
                    $TrStatus=assignment($extra+1, $orig_limit);
                }
            }
            return $#ValClass;
         }else{
            if($autovivification && $ValClass[$start] =~ /[ah]/) {      # SNOOPYJC
                my $converter = $AUTOVIVIFICATION_CONVERTER_MAP{$ValClass[$start]};
                $Pyf{$converter} = 1;
                gen_chunk("$converter", '(');
            }
            $k=expression($split+1,$limit,0); # process expression without brackets -- last param is 0
            return -255 if( $k<0 );
            gen_chunk(", $number_of_elements)") if(defined $number_of_elements);    # issue 56, SNOOPYJC
	    gen_chunk(')') if($add_right_paren);		# issue 14
            if($autovivification && $ValClass[$start] =~ /[ah]/) {      # SNOOPYJC
                gen_chunk(')');
            }
         }
      }
   }elsif( ($split=index($TokenStr,'~',$k))>-1 && $ValPerl[$split] ne '~') {    # SNOOPYJC: Handle ~ operator
      $k=regex_and_translate($start,$k,$split,$limit);  # issue 106
      return $k+1;
   }elsif(index($TokenStr,'D')>-1) {         # SNOOPYJC: Some sort of OO construct such as $fh->autoflush(1); or $obj->method(args)
       $k = expression($start,$#ValClass,0);            # SNOOPYJC
       return -255 if( $k<0 );                          # SNOOPYJC
       return $k+1;                                     # SNOOPYJC
   }elsif($CurSub ne '__main__') {  # issue 45, issue 41
       ;                # issue 45: could be a return from a sub - just ignore it and don't give a warning
   }elsif(scalar(@ValClass) == 1) {             # SNOOPYJC: Simple declaration
       ;
   }else{
      if($debug >= 1) {
          say STDERR "assignment - returns -255";
      }
      return -255;
   }
   if($ValClass[0] eq 's' && $ValPerl[0] eq '$|') {             # SNOOPYJC: Handle autoflush
       gen_statement();
       gen_statement("$Perlscan::keyword_tr{STDOUT}.autoflush($ValPy[0])");
       gen_statement("$Perlscan::keyword_tr{STDERR}.autoflush($ValPy[0])");
   }
   if($extra >= 0) {
       gen_chunk($ValPy[$extra]);       # ',' or whatever it is
       $k = next_lower_or_equal_precedent_token('=', $extra+1, $orig_limit);
       if($k < 0 || $ValClass[$k] ne '=') {
           $TrStatus=expression($extra+1, $orig_limit, 0);
       } else {
           $TrStatus=assignment($extra+1, $orig_limit);
       }
   }
   return($#ValClass);
} # assignment

sub handle_assign_eval             # issue 42
#
# handle $var = eval {...} or $var = eval(...)
# arg1 = pointer to the eval
# returns 1 if we should not generate any code for the assignment
#
{
    my $exp = shift;            # pointer to the eval or x

    $was_block = gen_eval($exp, 1);
    $result = "$EVAL_RESULT$.";
    replace($exp, 's', $result, $result);
    if($exp != $#ValClass) {
        destroy($exp+1, $#ValClass-$exp);
    }
    if($was_block) {
        $eval_stack[-1]->{assignment} = package_code();
    }
    return $was_block;

} # handle_assign_eval

sub gen_eval                    # issue 42
{
    my $ep = shift;             # pointer to the eval start in @ValClass
    my $need_result = shift;

    say STDERR "gen_eval($ep, $need_result): =|$TokenStr|=" if($debug);
    if($need_result) {
        gen_statement("$EVAL_RESULT$. = None");
    }
    gen_statement('try:');                     # issue 42
    push @eval_stack,{eval_nest => $Pythonizer::CurNest, lno => $.};  # issue 42
    if(($ep < $#ValClass && $ValClass[$ep+1] eq '(' && $ValPerl[$ep+1] eq '(') ||   # we have (...)
       ($ep == $#ValClass && $line =~ /eval;/)) {              # we have $val = eval; -or just- eval;
        correct_nest(1, 1);
        gen_statement('EVAL_ERROR = None') if(exists $SpecialVarsUsed{'$@'});    # issue 42
        if($need_result) {
            gen_chunk("$EVAL_RESULT$. = ");
        }
        gen_chunk("subprocess.run(['perl','-e',");
        if($ep == $#ValClass) {
            gen_chunk(q{"print +" + }, $DEFAULT_VAR);
        } else {
            insert($ep+2, '.', '.', ' + ');
            insert($ep+2, '"', '', qq{'print +'});
            my $end_pos = matching_br($ep+1);
            $k = expression($ep+2, $end_pos-1, 0);
        }
        gen_chunk('],capture_output=True,text=True,check=True).stdout');
        gen_statement();
        correct_nest(-1, -1);
        if(exists $SpecialVarsUsed{'$@'}) {
            gen_statement('except Exception as _e:');               # issue 42
        } else {
            gen_statement('except Exception:');                 # issue 42
        }
        correct_nest(1,1);                                      # issue 42
        output_line('traceback.print_exc()') if($traceback);    # SNOOPYJC
        if(exists $SpecialVarsUsed{'$@'}) {
            $Pyf{"_exc"} = 1;                       		# issue 42
            gen_chunk('EVAL_ERROR = ', '_exc', '(_e)');     # issue 42
            gen_statement();
        } else {
            gen_statement('pass');
        }
        correct_nest(-1,-1);                                    # issue 42
        pop @eval_stack;                                        # issue 42
        return 0;
    } elsif($ep < $#ValClass && $ValClass[$ep+1] eq '(' && $ValPerl[$ep+1] eq '{') {   # we have {...}
        my $end_pos = matching_br($ep+1);
        if($end_pos < 0) {
            $TrStatus = -1;
        } else {
            correct_nest(1,1);
            my $semi = next_matching_token(';', $ep+2, $end_pos);
            $end_pos = $semi if($semi >= 0);
            if($need_result) {
                insert($ep+2, '=', '=', '=');
                insert($ep+2, 's', '$' . "$EVAL_RESULT$.", "$EVAL_RESULT$.");
                $end_pos += 2;
                $TrStatus = assignment($ep+2, $end_pos-1);
            } else {
                $TrStatus = expression($ep+2, $end_pos-1, 0);
            }
            gen_statement();
            correct_nest(-1,-1);
        }
    } elsif($ep < $#ValClass) {
        my $end_pos = $#ValClass;
        correct_nest(1,1);
        my $semi = next_matching_token(';', $ep+1, $end_pos);
        $end_pos = $semi-1 if($semi >= 0);
        if($need_result) {
            insert($ep+1, '=', '=', '=');
            insert($ep+1, 's', '$' . "$EVAL_RESULT$.", "$EVAL_RESULT$.");
            $end_pos += 2;
            $TrStatus = assignment($ep+1, $end_pos);
        } else {
            $TrStatus = expression($ep+1, $end_pos, 0);
        }
        gen_statement();
        correct_nest(-1,-1);
    }
    return 1;
}

sub package_code                 # issue 42
# Package up all the code in a cute little ref so we can generate it later
{
    say STDERR "package_code( =|$TokenStr|= ) ValPy = @ValPy" if($debug >= 3);
    my @_ValClass = @ValClass;
    my @_ValPerl = @ValPerl;
    my @_ValPy = @ValPy;
    my @_ValCom = @ValCom;
    my @_ValType = @ValType;
    return {class=>\@_ValClass, perl=>\@_ValPerl, py=>\@_ValPy, com=>\@_ValCom, type=>\@_ValType};
}

sub unpackage_code              # issue 42
# Restore the code from the cute little ref we created with package_code
{
    my $coderef = shift;

    @ValClass = @{$coderef->{class}};
    @ValPerl = @{$coderef->{perl}};
    @ValPy = @{$coderef->{py}};
    @ValCom = @{$coderef->{com}};
    @ValType = @{$coderef->{type}};
    $TokenStr=join('',@ValClass);
    say STDERR "unpackage_code() = =|$TokenStr|= ValPy = @ValPy" if($debug >= 3);
}

sub p_destroy
# Like destroy but for packaged code
{
    my ($package,$from,$howmany) = @_;

    splice(@{$package->{class}},$from,$howmany);
    splice(@{$package->{perl}},$from,$howmany);
    splice(@{$package->{py}},$from,$howmany);
    if(scalar(@{$package->{type}}) >= $from+$howmany) {
       splice(@{$package->{type}},$from,$howmany);
    }
}
sub p_replace
# Like replace but for packaged code
{
    my ($package,$pos,$class,$perl,$py) = @_;

    $package->{class}->[$pos] = $class;
    $package->{perl}->[$pos] = $perl;
    $package->{py}->[$pos] = $py;
    $package->{type}->[$pos] = '';
}
sub p_insert
# Like insert but for packaged code
{
    my ($package,$pos,$class,$perl,$py) = @_;

    if($pos == scalar @{$package->{class}}) {
        p_append($package,$pos,$class,$py);
        return;
    }
    splice(@{$package->{class}},$pos,0,$class);
    splice(@{$package->{perl}},$pos,0,$perl);
    splice(@{$package->{py}},$pos,0,$py);
    if($pos <= $#{$package->{type}}) {
        splice(@{$package->{type}},$pos,0,'');
    } else {
        $package->{type}->[$pos] = '';
    }
}
sub p_append
# Like append but for packaged code
{
    my ($package,$pos,$class,$perl,$py) = @_;

    $package->{class}->[scalar(@{$package->{class}})] = $class;
    $package->{perl}->[scalar(@{$package->{perl}})] = $perl;
    $package->{py}->[scalar(@{$package->{py}})] = $py;
    $package->{type}->[scalar(@{$package->{py}})] = '';     # We use the length of 'py' as not all elements have a type field
}

sub regex_and_translate
#
# process very tricky regex and tranlate function
#
{
my($start,$k,$split,$limit)=@_;         # issue 106
   # $start and $k are the same and point to the start of the expression
   # $split points to the '=~'
   # $limit points to the end
   say STDERR "regex_and_translate($start,$k,$split,$limit)" if($debug >= 3);  # SNOOPYJC
   # SNOOPYJC: And to make it even more tricky, we have 5 different cases to handle for each type:
   # 1. $var =~ s/a/b/
   # 2. $cnt = $var =~ s/a/b/
   # 3. $new = $var =~ s/a/b/r
   # 4. ($new = $old) =~ s/a/b/   Here only $new is changed, not $old
   # 5. _assign_global('pkg', 'var', $old) =~ s/a/b/
   #
   my $eq;      # SNOOPYJC
   my $eq_ok = ($start == 0 || ($start == 1 && $ValClass[0] eq 't'));    # When it's ok to use '=' instead of ':='
   if( $split+1 <= $#ValClass && $ValClass[$split+1] eq 'f' && $ValPerl[$split+1] eq 'tr'){     # SNOOPYJC
      # tr is a special case -- this is not regular expression
      my $flags = '';
      my $args = tr_flags_to_args($ValPy[$split+1]);
      if($ValPy[$split+1] =~ /,flags=([a-z]+)/) {
          $flags = $1;
          $ValPy[$split+1] =~ s/,flags=[a-z]+//;
      }
      if( $split-$k==1 ){
         # SNOOPYJC gen_chunk($ValPy[$split-1],'=',$ValPy[$split-1],'.translate(',$ValPy[$split-1],$ValPy[$split+1],')'); # a=a.trasnlate(a)
         if($flags =~ /r/) {
            gen_chunk($ValPy[$split-1],'.translate(','str',$ValPy[$split+1],')'); # SNOOPYJC a=a.translate(str.maketrans(..,..))
         } else {
            gen_chunk($ValPy[$split-1],'=',$ValPy[$split-1],'.translate(','str',$ValPy[$split+1],')'); # SNOOPYJC a=a.translate(str.maketrans(..,..))
         }
      }elsif(($eq = next_same_level_token('=', $start, $split-1)) != -1) {     # Case 2
          $Pyf{_translate_and_count} = 1;
          #gen_chunk('((', $DEFAULT_VAR, ':=', '(', $SUBSCRIPT_TEMP, '_translate_and_count(str', $py_name, ',', $DEFAULT_VAR, '))[0])', ',', $SUBSCRIPT_TEMP, ')[1][1]');
          if($eq_ok) {
             $k=expression($start, $eq-1, 0);
             return -255 if( $k<0 );
             gen_chunk('=');
          } else {
             gen_chunk('(');
             $k=expression($start, $eq-1, 0);
             return -255 if( $k<0 );
             gen_chunk(':=');
          }
          gen_chunk('((');
          $k=expression($eq+1, $split-1, 0);
          return -255 if( $k<0 );
          gen_chunk(':=', '(', $SUBSCRIPT_TEMP, ':=', '_translate_and_count', '(str', $args, ', var=');
          $k=expression($eq+1, $split-1, 0);
          gen_chunk('))[0])', ',', $SUBSCRIPT_TEMP, ')[1][1]');
          gen_chunk(')') if(!$eq_ok);
      }elsif($ValClass[$start] eq '(' && ($eq = next_same_level_token('=', $start+1, $split-2)) != -1) { # Case 4
          my $close = matching_br($start);
          if($flags =~ /r/) {
              gen_chunk('((');
              $k=expression($start+1, $eq-1, 0);         # new
              return -255 if( $k<0 );
              gen_chunk(':=');
              $k=expression($eq+1, $close-1, 0);            # old
              return -255 if( $k<0 );
              gen_chunk('), ');
          } else {
              if($eq_ok) {
                 $k=expression($start+1, $eq-1, 0);         # new
                 return -255 if( $k<0 );
                 gen_chunk('=');
              } else {
                 gen_chunk('(');
                 $k=expression($start+1, $eq-1, 0);         # new
                 return -255 if( $k<0 );
                 gen_chunk(':=');
              }
          }
          $k=expression($eq+1, $close-1, 0);            # old
          return -255 if( $k<0 );
          gen_chunk('.translate(');
          gen_chunk('str');
          gen_chunk($ValPy[$split+1],')');
          gen_chunk(')') if(!$eq_ok || $flags =~ /r/);
      }elsif($ValClass[$start] eq 'f' && $ValPy[$start] eq '_assign_global') {  # Case 5
          # 5. _assign_global('pkg', 'var', $old) =~ s/a/b/
          #my $pkg = unquote_string($ValPy[$start+2]);
          #my $var = unquote_string($ValPy[$start+4]);
          my $close = matching_br($start+1);
          my $old0 = $start+6;
          my $old1 = $close-1;
          if($flags !~ /r/) {
              for(my $i = $start; $i < $old0; $i++) {       # Spit out "_assign_global('pack', 'var',"
                  gen_chunk($ValPy[$i]);
              }
          }
          $k=expression($old0,$old1,0);
          return -255 if( $k<0 );
          gen_chunk('.translate(');
          gen_chunk('str');
          gen_chunk($ValPy[$split+1],')');
          gen_chunk(')') if($flags !~ /r/);
      }else{                    # Case 1
         if($flags !~ /r/) {
            $k=expression($start,$split-1,0); # can be array index or something  more problemtic ;-)
            return -255 if( $k<0 );
            gen_chunk('=');
         }
         $k=expression($start,$split-1,0); # replicate the left part of the assignment
         gen_chunk('.translate(');
         # SNOOPYJC $k=expression($start,$split-1,0); # replicate the left part of the assignment
         gen_chunk('str');
         gen_chunk($ValPy[$split+1],')');
      }
      # next token
      $k=$split+1;
   }elsif( ($split=index($TokenStr,'~',$k))>-1 ){
      #regular expression $string =~ /cat/ or $string =~m/cat/
      # re.search(r'cat', string): ...
      return -255 if($split+1 > $#ValClass);           # SNOOPYJC: Don't get stuck on ~ at end!
      if($ValClass[$split+1] eq 'q') {
         # match only; There is no variable to assign results
         gen_chunk('not') if($ValPerl[$split] eq '!~');        # issue 112
         if( substr($ValPy[$split+1],0,1) eq '.' ){     # e.g. .find(...)
            $k=expression($start,$split-1,0); # generate left side of the regular expression
            return -255 if( $k<0 );
            gen_chunk($ValPy[$split+1],')'); # add dot part generated by scanner
         }else{
             my $g_flag = 0;                                    # SNOOPYJC
             $g_flag = 1 if($ValPy[$split+1] =~ /\bre\.G/);
             if($g_flag) {
                $ValPy[$split+1] =~ s/,re\.G\|/,/;
                $ValPy[$split+1] =~ s/.re\.G//;
                $ValPy[$split+1] =~ s/\($DEFAULT_MATCH:=re\.search/[$DEFAULT_MATCH\[0] for $DEFAULT_MATCH in re.finditer/;
             }
             if($eq_ok && $ValPy[$split+1] =~ /^\($DEFAULT_MATCH:=/) {  # SNOOPYJC
                $ValPy[$split+1] =~ s/^\($DEFAULT_MATCH:=/$DEFAULT_MATCH = /;
             }
             gen_chunk($ValPy[$split+1]);
             $k=expression($start,$split-1,0); # generate left side of the regular expression, it can be array index or something even more problemtic ;-)
             return -255 if( $k<0 );
             if (index($ValPy[$split+1],':=')>-1){
                # issue 57: Generate proper code for when we're in list context or scalar context
                my $context = list_or_scalar_context($start);
                say STDERR "context of regex = $context" if($debug >= 5);
                if($context == 1) {       # list
                    gen_chunk("),${DEFAULT_MATCH}.groups() if $DEFAULT_MATCH else [])[1]");         # issue 57, 32
                } elsif($context == 0) {
                    gen_chunk("),bool($DEFAULT_MATCH))[1]");         # issue 57, 32
                } else {                                                                        # issue 57
                    gen_chunk('))'); # close function bracket and expression
                }
             }else{
                gen_chunk(')'); # close function bracket and expression
             }
             gen_chunk(']') if($g_flag);
         }
         $k=$split+1;
      }elsif( $ValClass[$split+1] eq 'f' && $ValPerl[$split+1] eq 're' ){       # s/.../.../FLAGS
         # this  is case of substirution
	 # issue 11: Handle the re.G flag which doesn't actually exist
         my $flags = process_re_flags($split+1);
         if( $split-$k==1 ){
            if($flags =~ /replace/) {
                $flags =~ s/replace=False,//;
            } else {
                gen_chunk($ValPy[$split-1]); # a
                if($ValClass[0] eq 'c') {           # SNOOPYJC
                    gen_chunk(':=');              # a=
                } else {
                    gen_chunk('=');              # a=
                }
            }
            if( substr($ValPy[$split+1],0,1) eq '.' ){
               gen_chunk($ValPy[$split-1].$ValPy[$split+1]); # a=a.find(string)
            }else{
	       # issue 11 gen_chunk("$ValPy[$split+1]$ValPy[$split-1])"); # a=re.sub(rexex,replacement,variable)
               gen_chunk("$ValPy[$split+1]$ValPy[$split-1],$flags)"); # a=re.sub(rexex,replacement,variable,count=N)	# issue 11
            }
          }elsif(($eq = next_same_level_token('=', $start, $split-1)) != -1) {     # Case 2
              # 2. $cnt = $var =~ s/a/b/
              $Pyf{_substitute_and_count} = 1;
              my $sac = '_substitute_and_count';
              $sac = "$PERLLIB.substitute_and_count" if($import_perllib);
              $ValPy[$split+1] =~ s/^re\.sub/$sac/;
              #gen_chunk('((', $DEFAULT_VAR, ':=', '(', $SUBSCRIPT_TEMP,':=', $py_name, ')[0])', ',', $SUBSCRIPT_TEMP, ')[1][1]');
              if($eq_ok) {
                 $k=expression($start, $eq-1, 0);
                 return -255 if( $k<0 );
                 gen_chunk('=');
              } else {
                 gen_chunk('(');
                 $k=expression($start, $eq-1, 0);
                 return -255 if( $k<0 );
                 gen_chunk(':=');
              }
              gen_chunk('((');
              if($ValClass[$eq+1] eq 'f' && $ValPy[$eq+1] eq $CONVERTER_MAP{S}) {
                  # We could have inserted a _str($v), so leave that out!
                  $k=expression($eq+3,$split-2,0);
              } else {
                  $k=expression($eq+1,$split-1,0); # can be array index or something  more problemtic ;-)
              }
              return -255 if( $k<0 );
              gen_chunk(':=', '(', $SUBSCRIPT_TEMP, ':=', $ValPy[$split+1], $flags, ',var=');
              $k=expression($eq+1, $split-1, 0);
              gen_chunk('))[0])', ',', $SUBSCRIPT_TEMP, ')[1][1]');
              gen_chunk(')') if(!$eq_ok);
          }elsif($ValClass[$start] eq '(' && ($eq = next_same_level_token('=', $start+1, $split-2)) != -1) { # Case 4
              # 4. ($new = $old) =~ s/a/b/   Here only $new is changed, not $old
              my $close = matching_br($start);
              if($flags =~ /replace/) {
                  $flags =~ s/replace=False,//;
                  gen_chunk('((');
                  $k=expression($start+1, $eq-1, 0);         # new
                  return -255 if( $k<0 );
                  gen_chunk(':=');
                  $k=expression($eq+1, $close-1, 0);            # old
                  return -255 if( $k<0 );
                  gen_chunk('), ');
              } else {
                  if($eq_ok) {
                     $k=expression($start+1, $eq-1, 0);         # new
                     return -255 if( $k<0 );
                     gen_chunk('=');
                  } else {
                     gen_chunk('(');
                     $k=expression($start+1, $eq-1, 0);         # new
                     return -255 if( $k<0 );
                     gen_chunk(':=');
                  }
              }
              gen_chunk($ValPy[$split+1]);
              $k=expression($eq+1, $close-1, 0);            # old
              return -255 if( $k<0 );
              gen_chunk(',', $flags) if($flags);
              gen_chunk(')');
              gen_chunk(')') if(!$eq_ok);
          }elsif($ValClass[$start] eq 'f' && $ValPy[$start] eq '_assign_global') {  # Case 5
              # 5. _assign_global('pkg', 'var', $old) =~ s/a/b/
              #my $pkg = unquote_string($ValPy[$start+2]);
              #my $var = unquote_string($ValPy[$start+4]);
              my $close = matching_br($start+1);
              my $old0 = $start+6;
              my $old1 = $close-1;
              my $replace = 1;
              if($flags =~ /replace/) {
                  $flags =~ s/replace=False,//;
                  $replace = 0;
              } else {
                  for(my $i = $start; $i < $old0; $i++) {   # Spit out the "_assign_global('pkg', 'var'"
                      gen_chunk($ValPy[$i]);
                  }
              }
              gen_chunk($ValPy[$split+1]);
              $k=expression($old0,$old1,0);
              return -255 if( $k<0 );
              gen_chunk(',', $flags) if($flags);
              gen_chunk(')');
              gen_chunk(')') if($replace);
         }else{
            if($flags =~ /replace/) {
                $flags =~ s/replace=False,//;
            } else {
                if($ValClass[$start] eq 'f' && $ValPy[$start] eq $CONVERTER_MAP{S}) {       # SNOOPYJC
                    # We could have inserted a _str($v), so leave that out!
                    $k=expression($start+2,$split-2,0);
                } else {
                    $k=expression($start,$split-1,0); # can be array index or something  more problemtic ;-)
                }
                return -255 if( $k<0 );
                if($ValClass[0] eq 'c') {           # SNOOPYJC
                    gen_chunk(':=');
                } else {
                    gen_chunk('=');
                }
            }
            if( substr($ValPy[$split+1],0,1) eq '.' ){
               $k=expression($start,$split-1,0); # replicate the left part of the assignment
               return -255 if( $k<0 );
               gen_chunk($ValPy[$split+1]);
            }else{
	       gen_chunk($ValPy[$split+1]);	# issue 11
               $k=expression($start,$split-1,0); # replicate the left part of the assignment
               return -255 if( $k<0 );
	       # issue 11 gen_chunk(')');
               gen_chunk(',', $flags) if($flags);       # issue 11
               gen_chunk(')');
            }
         }
         # next token
         $k=$split+1;
      }else{                                            # issue 106
          my $end_pos = next_lower_or_equal_precedent_token('~', $split+2, $limit)-1;
          #say STDERR "end_pos=$end_pos";
          $end_pos = $limit if($end_pos < 0);
          $k=expression($split+1, $end_pos, 0);
          return -255 if( $k<0 );
          gen_chunk('not') if($ValPerl[$split] eq '!~');        # issue 112
          gen_chunk('in');
          $k=expression($start,$split-1,0);
          return -255 if( $k<0 );
          $k = $end_pos;
      # issue 106 }else{
      # issue 106 return -255;
      }
   }
   return $k+1;
}

sub list_or_scalar_context
# For a regex, figure out if this is in list (1) or scalar (0) context or unknown (-1)
# Arg: start of expression
{
    my $start = shift;

    my $at = arg_type_from_pos($start);
    if(defined $at) {
        return 1 if($at eq 'a');
        return 0 if($at =~ /[sIFNm]/);
    }
    return 1 if(in_sub_call($start));
    #my $eq = next_same_level_token('=', 0, $start);
    my $eq = index($TokenStr, '=');     # Need to find the '=' even if it's inside an 'if' stmt
    return -1 if($eq <= 0);
    return 1 if($ValClass[$eq-1] eq 'a' || ($ValClass[$eq-1] eq ')' && $ValPerl[$eq-1] eq ')'));        # Array or list
    my $sv = start_of_var($eq-1);
    return 0 if($ValClass[$sv] eq 's');
    return -1;
}

#
# Extration of assignment statement from conditions and other places where Python prohibits them
# Added Nov 11, 2019
#
# SNOOPYJC: allow 2nd arg which means to leave lists intact
sub pre_assign
{
my  $assign_start=$_[0];
my  $assign_end=matching_br($assign_start);
   if($debug >= 3) {
	   say STDERR "pre_assign($assign_start, $_[1]), assign_end=$assign_end, =|$TokenStr|= @ValPerl\n"
   }
   $begin = $assign_start-1;
   ($assign_end<0) && return -255;
   if($ValClass[$assign_start+1] =~ /[n!]/) {              # issue 58 - skip any "not" clause, issue 93
       if($ValClass[$assign_start+2] eq '(') {
           $assign_start += 2;
           $assign_end = matching_br($assign_start);
        }
   }

   #say STDERR "ValPerl[$begin] = $ValPerl[$begin]";
   if($ValPerl[$begin] =~ /^(?:for|foreach|while|until)$/) {            # Issue 103: Looping construct
      # We don't want to pull the expression out of the loop in case it needs to run multiple times
      # e.g. in issue 103, it called the "each" iterator.
      return if(fixup_complex_assignment_in_control(2, $#ValClass-1) != -1);            # issue 103
   }
   my $from=index($TokenStr,'=',$assign_start+2); # issue 58
   if($ValPy[$from] eq ':=') {                    # issue 58: generate a regular '=', not a walrus operator
       $ValPy[$from] = '=';                       # issue 58
   }                                              # issue 58
   assignment($assign_start+1,$assign_end-1);
   gen_statement();
#
# remove everytnogh but variable name. we need to shink arrrays
#
# issue 58 my $from=index($TokenStr,'=',$assign_start+2); # "=" now is next to identifier; should be
#issue 58 my $howmany=$assign_end-$from+1; # closed interval

   my $use_default_match = 0;
   for(my $i = $from+1; $i <= $#ValClass; $i++) {
       if($ValClass[$i] eq 'q' && ($ValPy[$i] =~ /$DEFAULT_MATCH:=/)) {
           $use_default_match = 1;
           last;
       }
   }
   my $howmany=$assign_end-$from;          # issue 58 - keep the ')'
   #say STDERR $TokenStr;
   if( $howmany>0 ){
       destroy($from,$howmany);
   }
   #say STDERR $TokenStr;
   # issue 58 # Remove opening bracket -- it is no longer needed
   # issue 58 destroy($assign_start,1);
   #
   # issue 58: Replace ($this, $that) with $this, and ($this) with $this
   return if(scalar(@_) >=2);           # SNOOPYJC
   if($ValClass[$assign_start+1] eq '(') {
       my $end = matching_br($assign_start+1);
       my $comma = index($TokenStr,',',$assign_start+2);
       if($end > 0) {
           if($comma > $assign_start && $comma < $end) {
               destroy($comma,$end-$comma+1);         # remove from ',' to ')'
               #say STDERR $TokenStr;
           } else {
               destroy($end,1);
               #say STDERR $TokenStr;
           }
           destroy($assign_start+1,1);
           if($use_default_match) {
               replace($assign_start+1, 's', '$'.$DEFAULT_MATCH, $DEFAULT_MATCH);
           } else {
               if($ValClass[$assign_start+1] eq 'f' && $ValPerl[$assign_start+1] eq 'undef') {  # SNOOPYJC: Unfortunate to have (undef,...) at start of list
                   replace($assign_start+1, 's', 'undef', '_');
               }
               insert($assign_start+1, 'f', 'defined', 'defined');
           }
           #say STDERR $TokenStr;
       }
    }
}

#
# Process all control statements
#
sub control
{
my $begin=$_[0];
   if($debug >= 3) {
	   say STDERR "control($begin) =|$TokenStr|= @ValPerl\n"
   }
   if( $begin<0 || $TrStatus<0  ){
      return -255;
   }
my $limit;
my ($hashpos,$end_pos,$end_br_pos,$k,$increment,$tempvar);
   $start=$begin+1;
   # issue paren   if( $ValPerl[$start] eq '(' ){
   # issue paren    $start++;
   # issue paren   }
   # issue paren   if($ValClass[-1] eq ')' ){
   if(index(substr($TokenStr,$start),')=') >= 0) {      # issue 58: complicated assignment in expression
       pre_assign($start);                              # issue 58
   }                                                    # issue 58
   $limit = $#ValClass;         # issue paren
   my $hadparens = 0;		# issue paren
   if( $ValPerl[$start] eq '(' && $ValClass[-1] eq ')' && ($ValPerl[$begin] eq 'for' || $ValPerl[$begin] eq 'foreach' || $TokenStr !~ /=/)) {	# issue paren, issue 32 (walrus op has to be in parens - but skip the '=' in a 'for' loop)
      $hadparens = 1;		# issue paren
      Perlscan::destroy(-1); # eliminate last bracket  -- Perl does not enclose controlstatements in bralckts.
      Perlscan::destroy($start,1);				# issue paren
      $limit=$#ValClass; # exclude it from count
      if($debug >= 3) {
	   say STDERR "control-parens removed, begin=$begin start=$start =|$TokenStr|= @ValPerl\n"
      }
   }
   $limit = $_[1] if (scalar(@_) >= 2);         # issue 81


   if( $ValPerl[$begin] eq 'if'  || $ValPerl[$begin] eq 'unless' ){
	  # issue 18 if( $TokenStr eq 'c(i)') {
      # SNOOPYJC if( $TokenStr eq 'ci' && !$LocalSub{$ValPy[$start]}) {	# issue 18, issue paren: at this point the '()' are gone
      if( $TokenStr eq 'cj') {	# issue 18, issue paren: at this point the '()' are gone, SNOOPYJC
          # while(<SYSIN>)
          gen_chunk("$ValPy[$start] $DEFAULT_VAR = $ValPy[$start+1]:"); # gen initial keyword     # issue 32
          return($#ValClass);
      } elsif($TokenStr eq 'cqrq' || $TokenStr eq 'cdrq') {             # SNOOPYJC: issue range
          $Pyf{'_range'} = 1;
          my $key = substr($Pythonizer::fname,0,length($Pythonizer::fname)-3).':'.$.;    # filename and line # as key - each range gets it's own storage
          my $pat1;
          my $flags1 = 0;
          if($ValClass[1] eq 'd') {
             $pat1 = $ValPy[1];
          } else {
             $ValPy[1] =~ /^re\.search\((.*),.*(?:,\s?flags=(.*))?\)/;
             $pat1 = $1;
             return -255 if(!$pat1);
             $flags1 = $2 if($2);
          }
          $ValPy[3] =~ /re\.search\((.*),(.*)(?:,\s?flags=(.*))?\)/;
          my $pat2 = $1;
          return -255 if(!$pat2);
          my $var = $2;
          return -255 if(!$var);
          $flags2 = 0;
          $flags2 = $3 if($3);
          gen_chunk("$ValPy[$begin] ", '_range', "($var, $pat1, $flags1, $pat2, $flags2, '$key'):");
          return($#ValClass);
      }
      gen_chunk($ValPy[$begin]); # gen initial keyword
      if( $ValPerl[$begin] eq 'unless' ) { gen_chunk('('); }	# issue 20
      $k=expression($start,$limit,0); # last bracket was erased.
      return -255 if ($k<0);
      if( $ValPerl[$begin] eq 'unless' ) { gen_chunk(')'); }	# issue 20
      gen_chunk(':');
      return($#ValClass);
   }elsif( $ValPerl[$begin] eq 'while' || $ValPerl[$begin] eq 'until' ){
      # SNOOPYJC: Implement 'do':
      my $in_do = 0;
      if(defined $Perlscan::nesting_last && $Perlscan::nesting_last->{type} eq 'do') {
          my $lno = $Perlscan::nesting_last->{lno};
          $ValPy[0] =~ s/^while\s*/$DO_CONTROL$lno = (/;
          $in_do = 1;
          correct_nest(1,1);
          $Perlscan::nesting_last = undef;
      }
      # issue 18 if( $TokenStr eq 'c(s=i)' && substr($ValPerl[4],0,1) eq '<' ) {
      # SNOOPYJC if( $TokenStr eq 'cs=i' && substr($ValPerl[4],0,1) eq '<' ) {	# issue 18, issue paren
      if( $TokenStr eq 'cs=j' ) {	# issue 18, issue paren, SNOOPYJC
         gen_chunk("$ValPy[0] $ValPy[2] in $ValPy[4]" );
      # issue 18}elsif( substr($TokenStr,$start) eq 'c(d)' && $ValPy[$start+2]==1  ){
      }elsif( substr($TokenStr,$start) eq 'd' && $ValPy[$start] eq '1' ){	# issue 18
          gen_chunk("$ValPy[0] True" ); # while(1) Perl idiom
      # issue 18}elsif( substr($TokenStr,$start) eq 'c(i)' ){
      # SNOOPYJC }elsif( substr($TokenStr,$start) eq 'i' ){	# issue 18
      }elsif( substr($TokenStr,$start) eq 'j' ){	# issue 18, SNOOPYJC
	 # issue 18 gen_chunk("$ValPy[0] default_var in $ValPy[2]" ); # while(<stdin>)
         gen_chunk("$ValPy[0] ($DEFAULT_VAR:=$ValPy[1])" ); # while(<stdin>)	# issue 18, issue paren, issue 32
      }elsif( substr($TokenStr,$start) eq 'g' ){	# issue 66 - glob
	 save_code();                                   # issue 66
         gen_statement("$GLOB_LIST = $ValPy[$start]");  # issue 66
         restore_code();                                # issue 66
         gen_chunk("for $DEFAULT_VAR in $GLOB_LIST" );  # issue 66
      }else{
           gen_chunk($ValPy[$begin]); #while
           if ($ValClass[$start] eq '('){
              $TrStatus=expression($start,$limit,1); # gen expression
           }else{
              $TrStatus=expression($start,$limit,0); # gen expression
           }
      }
      if($in_do) {                      # SNOOPYJC
          gen_chunk(')');
          gen_statement();
          correct_nest(-1,-1);
      } else {
          gen_chunk(':');
      }
      return($#ValClass);
   # issue paren }elsif( $ValPerl[$begin] eq 'for' && $ValPerl[$begin+1] eq '('  && $ValClass[$begin+2] !~ /[ahf]/ ){
   }elsif( ($ValPerl[$begin] eq 'for' || $ValPerl[$begin] eq 'foreach') && $hadparens == 1 && $ValClass[$begin+1] !~ /[ahf]/ ){	# issue paren, issue foreach
      # regular for loop but can be foreach loop too
      my $gen_while = 0;                # issue for
      if( $ValPerl[-1] eq '++' && $ValClass[-2] eq 's' && $ValClass[-3] eq ';'){
         $increment='';
      }elsif( $ValPerl[-1] eq '--' && $ValClass[-2] eq 's' && $ValClass[-3] eq ';'){
         $increment='-1';
      } elsif(($k=index($TokenStr, ';((s=s+d)-d)')) > 0 && $k+11 == $#ValClass) {   # issue 74 - replacement code for ++
         $increment='';                                 # issue 74
      } elsif(($k=index($TokenStr, ';((s=s-d)+d)')) > 0 && $k+11 == $#ValClass) {   # issue 74 - replacement code for --
         $increment='-1';                               # issue 74
      } elsif(($k=index($TokenStr, ';((s=f(s)+d)-d)')) > 0 && $k+14 == $#ValClass) {       # SNOOPYJC: Handle us putting a _num conversion in
         $increment='';
      } elsif(($k=index($TokenStr, ';((s=f(s)-d)+d)')) > 0 && $k+14 == $#ValClass) {       # SNOOPYJC: Handle us putting a _num conversion in
         $increment='-1';
      } elsif(($k=index($TokenStr, ';s=d')) > 0 && $ValPerl[$k+2] eq '+=' && $k+3 == $#ValClass) {
          $increment=$ValPy[$k+3];
      } elsif(($k=index($TokenStr, ';s=d')) > 0 && $ValPerl[$k+2] eq '-=' && $k+3 == $#ValClass) {
          $increment= - $ValPy[$k+3];
      } elsif(($k=index($TokenStr, ';s=f(s)+d')) > 0 && $ValPerl[$k+1] eq $ValPerl[$k+5] &&
              $ValPy[$k+3] eq $CONVERTER_MAP{N} && $k+8 == $#ValClass) {
          $increment=$ValPy[$k+8];
      } elsif(($k=index($TokenStr, ';s=f(s)-d')) > 0 && $ValPerl[$k+1] eq $ValPerl[$k+5] &&
              $ValPy[$k+3] eq $CONVERTER_MAP{N} && $k+8 == $#ValClass) {
          $increment= - $ValPy[$k+8];
      }elsif( index($TokenStr,';',$begin+1) < 0 ) {	# issue foreach: Expression returning an iterable
         gen_chunk($ValPy[$begin]);			# issue foreach
	 gen_chunk("$DEFAULT_VAR in ");			# issue foreach, issue 32
         # issue range if( ($range=index($TokenStr,'r',$begin+1)) != -1) {	# issue range
         if( ($range=next_same_level_token('r',$begin+2,$limit-1)) != -1) {	# issue range
            gen_chunk('range(');				# issue range
	    $k=expression($begin+1,$range-1,0);			# issue range
            return -255 if ($k<0);				# issue range
	    gen_chunk(',');					# issue range
	    $k=expression($range+1,$limit,0);			# issue range
            return -255 if ($k<0);				# issue range
	    gen_chunk('+1)');					# issue range
         } else {						# issue range
            gen_chunk('(');				# issue foreach
            $k=expression($begin+1,$limit,0);		# issue foreach
            return -255 if ($k<0);			# issue foreach
            gen_chunk(')');				# issue foreach
         }							# issue range
         gen_chunk(':');				# issue foreach
         return $#ValClass;				# issue foreach
      }elsif($TokenStr eq "c;;") {                      # issue for: handle for(;;)
         gen_chunk('while True', ':');
         return $#ValClass;
      }else{
         $gen_while = 1;
         #logme('S', "In the current version more complex increment than ++ or -- requires manual translation");
         #$TrStatus=-1;
         #return -255;
      }
      $gen_while = 1 if($Perlscan::line_contains_for_loop_with_modified_counter{$.});
      $start=$begin;
      if($gen_while) {                          # issue for
          # Generate a 'while' loop instead to handle this case of a 'for' loop that
          # can't be handled using a range, or mod's the loop counter.
          my $semi1 = next_same_level_token(';', $start, $#ValClass);
          my $semi2 = next_same_level_token(';', $semi1+1, $#ValClass);
          if($semi1 < 0 || $semi2 < 0) {
              $TrStatus=-1;
              return -255;
          }
          if($semi1-$start != 1) {
             # We need to initialize the loop counter just above the while loop:
             # Temporarily save the tokens so we can pretend this is a stand-alone statement for fix_expression_issues
             my $tmp_code = package_code();
             destroy($semi1, (scalar(@ValClass)-$semi1));
             destroy(0, $start+1);
             fix_expression_issues();   # Run again here because we don't do much on "for" loops
             if(next_same_level_token(',', 0, $#ValClass) == -1) {
                my $eq = next_same_level_token('=', 0, $#ValClass);
                $ValPy[$eq] = '=' if($eq != -1 && $ValPy[$eq] eq ':=');
                $TrStatus=assignment(0, $#ValClass);
             } else {
                $TrStatus=expression(0, $#ValClass, 1);
             }
             gen_statement();
             unpackage_code($tmp_code);
          }
          gen_chunk('while');
          if($semi1+1 <= $semi2-1) {
              $TrStatus = expression($semi1+1, $semi2-1, 0) 
          } else {
              gen_chunk('True');
          }
          gen_chunk(':');
          gen_statement();
          my $my_code = package_code();
          p_destroy($my_code, 0, $semi2+1);
          &Perlscan::set_needs_implicit_continue($my_code);
          return($#ValClass);
      }
      gen_chunk($ValPy[$start]);
      # issue parens if ($ValClass[$start+2] eq ';'){
      # issue parens gen_chunk($ValPy[$start+3],' in range(',$ValPy[$start+3]);
      # issue parens $end_pos=$start+2;
      if ($ValClass[$start+1] eq ';'){		# issue parens
         my $loop_ctr = $ValPy[$start+2];       # issue for: Handle converter
         if($ValClass[$start+2] eq 'f' && ($loop_ctr eq $CONVERTER_MAP{N} || $loop_ctr eq $CONVERTER_MAP{I})) {
             $ValPy[$start+2] = $CONVERTER_MAP{I};      # Switch it to an integer converter for loop counter
             $loop_ctr = $ValPy[$start+4];
         }
         # issue for gen_chunk($ValPy[$start+2],' in range(',$ValPy[$start+2]);		# issue parens
         gen_chunk($loop_ctr,' in range(');
         my $condition = next_same_level_token('>', $start+2, $limit);
         $TrStatus=expression($start+2, $condition-1, 0);
         # issue for $end_pos=$start+1;		# issue parens
         $end_pos=$condition;		# issue for, issue parens
      }else{
	 # issue parens gen_chunk($ValPy[$start+2]); # index var
         gen_chunk($ValPy[$start+1]); # index var
         gen_chunk('in range(');
         $start=index($TokenStr,'=',$start); # find initialization. BTW it can be expression
         if( $start == -1 ){$TrStatus=-1; return -255;}
         $start++;

         # find end of initialization
         $end_pos=next_same_level_token(';',$start,$limit); # end of expression

         # issue foreach: could be function call with no args!  if( $end_pos-$start==1 ){
         # issue foreach: could be function call with no args!  gen_chunk($ValPy[$start]);
         # issue foreach: could be function call with no args!  }else{
         $TrStatus=expression($start,$end_pos-1,0); # gen expression
         if( $TrStatus < -1 ){return -255;}
         # issue foreach: could be function call with no args!  }
      }
      gen_chunk(',');
      #
      # Analize loop exit condition
      #
      $start=index($TokenStr,'>',$end_pos); # fron last ;
      if( $start == -1 ){$TrStatus=-1; return -255; }
      $inc = '';			# issue foreach
      if($ValPerl[$start] eq '<=') {	# issue foreach
         $inc = '+1';			# issue foreach
      }elsif($ValPerl[$start] eq '>=') { # issue foreach
         $inc = '-1';			# issue foreach
      }					# issue foreach
      $start++;
      # find end of loopexit condition
      $end_pos=next_same_level_token(';',$start,$limit);
      if( $end_pos == -1 ){$TrStatus=-1; return -255; }
      # issue foreach: could be function call with no args! if( $end_pos-$start==1 ){
          # issue foreach: could be function call with no args! if($ValClass[$start] eq 'a'){
             # issue foreach: could be function call with no args! gen_chunk($ValPy[$start]); # array as limit of the range
          # issue foreach: could be function call with no args! }else{
             # issue foreach: could be function call with no args! gen_chunk($ValPy[$start]); # all other cases of single limit of the range
          # issue foreach: could be function call with no args! }
      # issue foreach: could be function call with no args! }else{
      $TrStatus=expression($start,$end_pos-1); # gen expression for the limit of the range
      return -255 if ($TrStatus<0);
      # issue foreach: could be function call with no args! }
      if( $inc ) {		# issue foreach
	 gen_chunk($inc);	# issue foreach
      }				# issue foreach
      # we already got increamnt at the begining
      if( $increment) {
         gen_chunk(", $increment):");
      }else{
        gen_chunk('):');
      }
      return($#ValClass);
   }elsif( $ValPerl[$begin] eq 'for' || $ValPerl[$begin] eq 'foreach' ){
      gen_chunk($ValPy[$begin]);
      if ($ValClass[$start] eq 's'){
         gen_chunk($ValPy[$start].' in ');
      }else{
         gen_chunk("$DEFAULT_VAR in ");         # issue 32
	 $start--;	# issue foreach
      }
      if( $hadparens == 1 ) {		# issue parens, foreach - we removed the parens, but in this case we need them!
	 insert($start+1,'(','(','(');	# issue parens
	 append(')',')',')');		# issue parens
      } elsif($start+1 > $#ValClass) {  # issue parens: e.g. this($_) foreach @arr;
	 insert($start,'(','(','(');	# issue parens
	 append(')',')',')');		# issue parens
      } elsif($ValClass[$start+1] ne '(') {     # issue parens - could be STMT for LIST;
	 insert($start+1,'(','(','(');	# issue parens
	 append(')',')',')');		# issue parens
      }

      $start=index($TokenStr,'(',$start);
      if( substr($TokenStr,$start) eq '(a)') {
         # loop over an array
           gen_chunk($ValPy[$start+1]);
      }elsif( substr($TokenStr,$start) eq '(h)') {              # SNOOPYJC: Looping over a hash in perl gives the keys and the values
         # loop over a hash
         # SNOOPYJC gen_chunk('functools.reduce(lambda x,y:x+y,'.$ValPy[$start+1].'.items())');
         gen_chunk('itertools.chain.from_iterable('.$ValPy[$start+1].'.items())');      # SNOOPYJC
      }elsif( substr($TokenStr,$start)=~/^\(f\(?h\)/ ){
         # foreach loop over a hash
         $start++; # skip '('
         if( $ValPerl[$start] eq 'keys' || $ValPerl[$start] eq 'values'  ){
             $hashpos=index($TokenStr,'h',$start);
	     # issue foreach gen_chunk("$ValPy[$hashpos]q$ValPy[$start]()"); # translate keys function into postfix notation
             gen_chunk("$ValPy[$hashpos]$ValPy[$start]"); # translate keys function into postfix notation # issue foreach
         } elsif($ValPerl[$start] eq 'sort') {          # SNOOPYJC: Sort the keys and values
             $hashpos=index($TokenStr,'h',$start);      # SNOOPYJC
             # SNOOPYJC gen_chunk('sorted(list(functools.reduce(lambda x,y:x+y,'.$ValPy[$hashpos].'.items())))');  # SNOOPYJC
             gen_chunk('sorted(list(itertools.chain.from_iterable('.$ValPy[$hashpos].'.items())))');  # SNOOPYJC
         }else{
	    say STDERR "FIXME: Can't handle 'for' with $ValPerl[$start]\n";	# SNOOPYJC
            $TrStatus=-1; return -255;
         }
      }elsif( substr($TokenStr,$start) eq '(q)' && ($ValPy[$start+1] =~ /\.split\(\)$/ || $ValPy[$start+1] =~ /^re\.finditer/)) {        # SNOOPYJC: qw/.../
          gen_chunk($ValPy[$start+1]);
      }elsif( substr($TokenStr,$start)=~/^\((['"qds](,['"qds])*)\)/ ){
         # loop over explisit list
         $tempvar='[';
         for(my $i=$start+1;$i<$#ValClass;$i++){
           $tempvar.=$ValPy[$i];
         }
         gen_chunk($tempvar,']');
      # issue range }elsif( ($range=index($TokenStr,'r',$start)) != -1) {	# issue range
      }elsif( ($range=next_same_level_token('r',$start+1,$#ValClass-1)) != -1) {	# issue range
         gen_chunk('range(');					# issue range
	 $k=expression($start+1,$range-1,0);			# issue range
         return -255 if ($k<0);					# issue range
	 gen_chunk(',');					# issue range
	 $k=expression($range+1,$#ValClass-1,0);		# issue range
         return -255 if ($k<0);					# issue range
	 gen_chunk('+1)');					# issue range
      }else{
         #$end_pos = matching_br($start);	# issue foreach
	 if( $ValPerl[$start] ne '(' || $ValPerl[-1] ne ')' || index(substr($TokenStr,$start), ',') >= 0) {	# issue foreach: This is a list - keep the parens
            $k=expression($start,$#ValClass,0); # issue foreach
	 } else {				# issue foreach
            destroy($#ValClass, 1);		# issue foreach - eat the right paren
            $k=expression($start+1,$#ValClass,0); # issue foreach: No list - no parens
	 }					# issue foreach
         return -255 if ($k<0);
	 # issue foreach $TrStatus=-1; return -255;
      }
      gen_chunk(':');
      return $#ValClass;
   }elsif( $ValPerl[$begin] eq 'assert' ) {             # SNOOPYJC
       gen_chunk('assert');
       $k=expression($start,$#ValClass,0);
       return -255 if ($k<0);
       return $#ValClass;
   }elsif( $ValPerl[$begin] eq 'package' && $start <= $#ValClass) {             # SNOOPYJC
       gen_chunk("builtins.__PACKAGE__ = '$ValPy[$start]'");
       $CurPackage = $ValPy[$start];
       return $#ValClass;
   }else{
      $TrStatus=-1; return -255;
   }
} # control


sub _function
# Built-in  functions processing
{
my $begin=$_[0];
my ($limit,$start );  # $limit is the position of closing bracket, if any
                      # start is the position of the first symbol after the opening bracket
  $start=$begin+1; # default start for parentheiss less function;
  my $end_pos=$limit=$#ValClass;           # SNOOPYJC
  if( scalar(@_)>1 ){
    $end_pos=$limit=$_[1];
  }
   if($debug >= 3) {
	   say STDERR "function($begin, $limit) =|$TokenStr|= @ValPerl"
   }
my $bracketed=0;  # nessesary for the proper call of expression.
  if( $begin==$#ValClass || (scalar(@_)>1 && $begin==$limit) ){
     $bracketed=-1; # serves as zero arg flag;
  }elsif( $begin<$#ValClass && $ValClass[$begin+1] eq '(' ){
    $bracketed=1;
    $limit=matching_br($begin+1);
    $start=$begin+2;  # function call with normal pathethis
    if( $ValClass[$limit] eq ')' ){ $end_pos=$limit-1; }
  # issue 16 }elsif( ($k=index($TokenStr,'0'))>=1 ){
  }elsif( ($k=index($TokenStr,'0',$begin+1))>=1 ){	# issue 16
      $end_pos=$limit=$k-1 if($k-1 < $end_pos); # if we have && that function should end before it
      $bracketed=-1 if($end_pos < $start);              # issue 59
  }elsif( ($k=index($TokenStr,'o',$begin+1))>=1 ){	# issue 16, issue 93
      $end_pos=$limit=$k-1 if($k-1 < $end_pos); # if we have && that function should end before it
      $bracketed=-1 if($end_pos < $start);              # issue 59
  }elsif( ($k=index($TokenStr,'>',$begin+1))>=1 ){	# issue 16
      $end_pos=$limit=$k-1 if($k-1 < $end_pos); # if we have <,==,<=,>,>= that function should end before it
      $bracketed=-1 if($end_pos < $start);              # issue 59
  }elsif( ($k=index($TokenStr,'?',$begin+1))>=1 ){	# issue 16
      $end_pos=$limit=$k-1 if($k-1 < $end_pos); # if we have ? that function should end before it
      $bracketed=-1 if($end_pos < $start);              # issue 59
  }elsif( ($k=index($TokenStr,':',$begin+1))>=1 ){	# issue 16
      $end_pos=$limit=$k-1 if($k-1 < $end_pos); # if we have : that function should end before it
      $bracketed=-1 if($end_pos < $start);              # issue 59
  }elsif(scalar(@_)<2 && $begin != 0 && $ValClass[$begin-1] eq '(') {	# issue paren, issue 81
    # if the entire function call w/parameters is parenthesized, then the function ends
    # at the next right paren
    $end_pos=$limit=matching_br($begin-1)-1;		# issue paren
    if ($end_pos < $begin) {				# issue paren
       $end_pos=$limit=$#ValClass;			# issue paren
    }							# issue paren
  }elsif(scalar(@_)<2) {                                # issue 81
    $end_pos=$limit=$#ValClass;                         # issue paren: if we have (...f",") - then the ending paren isn't ours!
    if($ValClass[$end_pos] eq ')') {                    # issue paren
        $mb = reverse_matching_br($end_pos);            # issue paren
        if($mb < $begin) {                              # issue paren
            $end_pos=$limit-1;                          # issue paren
        }                                               # issue paren
    }                                                   # issue paren
  }
   if($debug >= 3) {
	   say STDERR "function start=$start, end_pos=$end_pos, bracketed=$bracketed";
   }
my ($k, $split, $split2, $delta, $dict, $incr, $arg1, $arg2, $perl_name, $py_name);
   if( $begin<0 || $TrStatus<0 ){
      $TrStatus=-255;  return -255;
   }
   $perl_name=$ValPerl[$begin];
   $py_name=$ValPy[$begin];
   if($perl_name eq 'die' && $py_name =~ /^raise / && $begin != 0) {    # SNOOPYJC
        $py_name = '_die';      # Can't use "raise" in the middle of an expression
   }
   #SNOOPYJC: See if this function has a special code module we need to include at the end
   if( !exists $Pyf{$py_name} ) {
     if( -e "$Pyf_dir/$py_name.py" ) {
	 $Pyf{$py_name} = 1;		#Include the module
         if($import_perllib) {
             $py_name = substr($py_name, 1) if(substr($py_name, 0, 1) eq '_');  # Eat initial '_', if any
             $py_name = escape_keywords($py_name);
             $py_name = "$PERLLIB.$py_name";
         } elsif(exists $PYF_CALLS{$py_name}) {      # If this module calls another one, include that too
             my @fcns = split(/,/, $PYF_CALLS{$py_name});
             for my $f (@fcns) {
                $Pyf{$f} = 1;
             }
         }
     } else {
	 $Pyf{$py_name} = 0;		#No module to include
     }
   }
#
# At this point
#   $start is the first token after prath (if presnet)
#   $end_pos is the sybol befor closing paren, if present
#   $limit -- the last symbol that belongs to this function, Scanning will start from $limit+1
   if( $perl_name eq 'substr' ){
      # substr($line,$from, To )
      #        0    1 2   3 4  5
      if( substr($TokenStr,$start,$end_pos-$start+1) =~ /^s,([-]?d),([-]?d)$/ ){	# issue 114
         # the simplest case when start and length of the substring are constants: substr($test,-1,1);
         $arg1=$ValPy[index($TokenStr,'d',$start)];     # start
         $arg2=$ValPy[$end_pos];                        # length
         $arg2=$ValPy[$end_pos];                        # length
         if( length($1) >= 2 && substr($1,0,1) eq '-' ){ $arg1=-$arg1; }
         if( length($2) >= 2 && substr($2,0,1) eq '-' ){ $arg2=-$arg2; }
         # issue 76 if( length($arg2)==1){
         if( $arg2==1){         # issue 76
            gen_chunk("$ValPy[$start]\[$arg1\]"); # single symbol
         }elsif( $arg1<0 && -$arg1>=$arg2 ){
             gen_chunk("$ValPy[$start]\[$arg1:\]"); # last symbol
         }elsif( $arg2>=0 ){            # issue 76
             $arg2+=$arg1;
             gen_chunk("$ValPy[$start]\[$arg1:$arg2\]"); # positive length added to the first index
         }elsif($arg2<0) {
             gen_chunk("$ValPy[$start]\[$arg1:$arg2\]"); # negative value is not length but the position from the last
         }else{
             $TrStatus=-1;  return -255;
         }
         return $limit+1; # $limit is the position of closing bracket, if any
      } elsif(substr($TokenStr,$start,$end_pos-$start+1) =~ /^[^,]+,[^,]+,[^,]+,/) {	# issue 114
         # issue 114: substr(this, start, length, replacement)
         # _substr returns a tuple with (new_this, result)
         # (this:=(_s:=_substr(this, start, length, replacement))[0], _s)[1][1]
         # Code only works if "this" is a scalar and not a global
         my $comma = next_same_level_token(',', $start, $end_pos);
         if($comma < 0) {
             $TrStatus=-1; return -255;
         }
         my $this_p = $start;
         if($this_p + 1 != $comma) {
             logme('S',"substr with replacement is not implemented on complex variable");
             $TrStatus=-1; return -255;
         } elsif(index($ValPy[$this_p], '.') >= 0) {
             logme('S',"substr with replacement is not implemented on package global variable");
             $TrStatus=-1; return -255;
         }
         $Pyf{_substr} = 1;
         gen_chunk('(', $ValPy[$this_p], ':=', '(', $SUBSCRIPT_TEMP, ':=', '_substr', '(');
         $TrStatus = expression($start, $end_pos, 0);
         gen_chunk(')', ')', '[0]', ',', $SUBSCRIPT_TEMP, ')', '[1]', '[1]');
	 return $limit+1;
      }
      # more complex case with varibles or expression in iether second or the third arguments
      #step1 -- generate varible from which substing is extracted (can be an expression)
      if( substr($TokenStr,$start+1,1) eq ',' ){
         # Simplest case -- scalar varaible or constant is used
         gen_chunk($ValPy[$start]); # a simple first arg -- the name of the variable or a string
         $split=$start+1;
      }else{
         $split=next_same_level_token(',',$start,$end_pos);
         if( $split==-1 ){
            $TrStatus=-1;  return -255
         }
         $k=expression($start,$split-1,0);
         return -255 if ($k<0);
      }
      #
      # Processing of thesecond arg -- starting position. Can beconstant or expression
      #
      gen_chunk('['); # opening  bracket
      if( substr($TokenStr,$split,3) =~ /,(\-?)d[),]/){
         $arg1=( length($1)==1) ? -$ValPy[$split+1] : $ValPy[$split+1];
         $arg1=$ValPy[$split+1];
      }
      #determine if there are two or three argument
      $split2=next_same_level_token(',',$split+1,$end_pos);
      if( $split2>-1 ){
          # substr($line,$start,$lenth) -- the third argumant is present
          $k=expression($split+1,$split2-1,0); # generate the secong arg
          return -255 if ($k<0);
          if( $end_pos-$split2==1 && $ValClass[$end_pos] eq 'd'){
               #positive length
               $arg2=$ValPy[$end_pos];
               if ( $ValPy[$split2+1] == 1 ){
                  gen_chunk(']'); # substr($line,$a,1) -- the third arg is 1
                  return $limit+1;
               }
               gen_chunk(':');
               if( defined($arg1) ){
                  # rescn first arg and add the second
                  if ($arg1==0){
                     gen_chunk($arg2);
                  }else{
                     $arg2=$arg1+$arg2;
                     gen_chunk($arg2);
                  }
               }else{
                  $k=expression($split2+1,$end_pos,0);
                   gen_chunk("+$arg2");
               }
               gen_chunk("]");
          }elsif( $end_pos-$split2==2 && substr($TokenStr,$split2,3) eq ',-d' ){
              # third arg is negative constant. Can be used directly.
              gen_chunk(':');
              $arg2=-$ValPy[$end_pos];
              gen_chunk("$arg2]");
          }else{
             # general case of the third argument -- need to rescan the first and add the second
              gen_chunk(':');
             if (defined($arg1)){
               gen_chunk("$arg1+");
               $k=expression($split2+1,$end_pos,0);
               gen_chunk(']');
             }else{
                $k=expression($split+1,$split2-1,0); # generate secong argument again
                return -255 if ($k<0);
                gen_chunk("+");
                $k=expression($split2+1,$end_pos,0);
                return -255 if ($k<0);
                gen_chunk(']');
             }
          }
      }else{
         # substr($line,$start)
         $k=expression($split+1,$end_pos,0);
         return -255 if ($k<0);
         gen_chunk(':]');
      }
   }elsif( $perl_name eq 'index' || $perl_name eq 'rindex' ){
      # index(text,'search',from)
      #       0   1 2      3 4
      # string.find(text, substr, start)
      if( $ValClass[$start+1] eq ',' ){
         # Simplest case -- scalar varaible is used
         gen_chunk("$ValPy[$start]$py_name("); # line.find -- .find is now in scannet table Nov 15, 2019 --NNB
         # issue 104 $split=$start+2;
         $split=$start+1;       # issue 104
      }else{
         $split=next_same_level_token(',',$start,$end_pos); # next comma on the same nesting level
         # issue 104 $k=expression($start+2,$split-1,0);
         $k=expression($start,$split-1,0);      # issue 104
         return -255 if ($k<0);
         # issue 104 gen_chunk("$ValPy[$start]("); # .find and opening  bracket
         gen_chunk("$py_name("); # .find and opening  bracket   # issue 104
      }
      $split2=next_same_level_token(',',$split+1,$end_pos);
      # processing string to find
      if( $split2>-1 ){
          # index($line,$string,$start)
          if( $split+2==$split2 ){
             gen_chunk($ValPy[$split+1]);
          }else{
             $k=expression($split+1,$split2-1,0);
             return -255 if ($k<0);
          }
          gen_chunk(',');
          $k=expression($split2+1,$end_pos,0);
          return -255 if ($k<0);
          gen_chunk(')');
      }else{
         # index($line,'xxx') -> line.find('xxx')
         # issue 104 $k=expression($split,$end_pos,0);
         $k=expression($split+1,$end_pos,0);    # issue 104
         return -255 if ($k<0);
         gen_chunk(')');
      }
   }elsif( $perl_name eq 'join' ){
      # issue 40 $args=join(' ',@ARGS) => args=ARGS.join(' ');
      # $args=join(' ',@ARGS) => args=' '.join(ARGS)    # issue 40
      $split=next_same_level_token(',',$start,$end_pos);
      # issue 40 if($end_pos-$split==1 ){
      if($split < 0) {                  # issue 40 - no ",list" is present
         # the second argument is not expression or function
         # issue 40 gen_chunk($ValPy[$end_pos],$py_name); # gen array.join('');
         gen_chunk("''");       # issue 40 - join with no expr is an empty string
      }else{                    # issue 40
          # issue 40 $TrStatus=expression($split+1,$end_pos);
          # issue 40 return $TrStatus if ($TrStatus<0);
          # issue 40 gen_chunk($py_name); # gen .join
          # issue 40 }
         if( $split-$start==1 ){
             # issue 40 gen_chunk($ValPy[$start].')'); # gen delimiter
            gen_chunk($ValPy[$start]); # issue 40: gen delimiter
         }else{
            $TrStatus=expression($start,$split-1);
            return $TrStatus if ($TrStatus<0);
         }
         gen_chunk($py_name);           # issue 40: gen .join(
         my $mapped = 1;
         if(&Pythonizer::expr_type($split+1, $end_pos, $CurSub) eq 'a of S') {
             $mapped = 0;
         }
         gen_chunk('map(_str, ') if($mapped);       # SNOOPYJC
         if($end_pos-$split==1) {       # issue 40: one thing (a list)
             gen_chunk($ValPy[$end_pos]);       # issue 40: arr
         } else {                       # issue 40: Multiple things: make them into a tuple by adding an extra set of parens
            gen_chunk('(');             # issue 40
            $TrStatus=expression($split+1,$end_pos);       # issue 40
            return $TrStatus if ($TrStatus<0);             # issue 40
            gen_chunk(')');             # issue 40
         }
         gen_chunk(')') if($mapped);                # SNOOPYC: End of map
         gen_chunk(')');                                # issue 40
      }                         # issue 40
   }elsif( $perl_name eq 'open' ){
      $TrStatus=open_fun($begin,$end_pos,'f'); # open like function, for example in if
      return -255 if( $TrStatus < 0 );
   }elsif( $perl_name eq 'opendir' ){	# SNOOPYJC:
      $TrStatus=open_dir($begin,$end_pos,'f'); # open like function, for example in if
      return -255 if( $TrStatus < 0 );
   }elsif( $perl_name eq 'exists' ){
      # applicable to the elemnt of hash only
      $k=$start;
      if( $ValClass[$k] eq 's') {
         # issue 91 $dict=$ValPy[$k];
         # issue 91 $k+=2;
         return -255 if($ValClass[$end_pos] ne ')');
         my $key_start = reverse_matching_br($end_pos);
	 if ( $debug > 4 ) {
	    say STDERR "exists k=$k, key_start=$key_start, length(ValPerl)=$#ValPerl, end_pos=$end_pos, limit=$limit\n";
	 }
         # issue 91 if( $k+1<=$#ValPerl && $k+1==$end_pos ) {
         # issue 91    #single token between {}
         # issue 91    if( $ValClass[$k] eq 's' || $ValClass[$k] eq '"' || $ValClass[$k] eq "'"){
         # issue 91       gen_chunk("$ValPy[$k] in $dict");
         # issue 91       # issue parens return $k+3; # you need to skip two closing brackets: })
         # issue 91       return (($bracketed == 1) ? $k+3 : $k+2); # you need to skip one or two closing brackets: })    # issue parens
         # issue 91    }
         # issue 91    return -255;
         # issue 91 }else{
         # issue 91 $k=expression($k-1,$limit,1); #preserve brackets
         $k=expression($key_start+1,$end_pos-1,0);     # issue 91
         return -255 if ($k<0);
         gen_chunk('in');                       # issue 91
         $k=expression($start,$key_start-1,0);  # issue 91
         return -255 if ($k<0);
         # issue 91}
      }else{
        return -255
      }
   }elsif(substr($perl_name,0,1) eq '-') {
      #file predicate, always one agument
       gen_chunk($py_name, '('.$ValPy[$start].')');
       return $start+1;		# issue 19
   }elsif( $perl_name eq 'split' ){
      $k=$start; # pos of the first arg
      if ($k > $#ValClass || ($bracketed==1 && $ValPerl[$k] eq ')')){   # SNOOPYJC: handle ... = split;
         # special case of splitting default varible on white space
	 # issue split gen_chunk("default_var.split(' ')");
         gen_chunk("${DEFAULT_VAR}.split()");	# issue split - split on white space, issue 32
         # SNOOPYJC return $end_pos+1;
         return $limit+1;                       # SNOOPYJC
      }
      $arg1=$ValPy[$k];  # first argument is present
      $arg1type=$ValClass[$k];
      $flags = '';                      # issue 21
      if($arg1type ne '"' && $k+1 <= $#ValClass && $ValClass[$k+1] eq 'i') {    # issue 21: we have FLAGS!
          $k++;
          foreach my $flag (split(//,$ValPerl[$k])) {
              next if($flag eq 'g');            # 'g' flag is meaningless here
              $flags .= '|re.'.uc($flag);     
          }
          $flags =~ s/^\|/, flags=/;
      }
      if(($k+1) > $#ValClass || $ValPerl[$k+1] ne ','){	# SNOOPYJC
         # special case of splitting degaqult varible on white space
         # issue 21 if( $arg1 eq ' ' || $arg1type eq '"' ){
         if( $arg1type eq '"' ){                        # issue 21: string
            $arg1 ='' if($arg1 eq "' '");               # issue 21: string of ' ' is a special case
            gen_chunk("${DEFAULT_VAR}.split($arg1)");           # issue 32
         }else{
	    # issue 21 gen_chunk($py_name,"($arg1,default_var"); # this is a regex function
            gen_chunk($py_name,"($arg1, $DEFAULT_VAR$flags)"); # this is a regex function	# issue 21, issue 32
         }
         # SNOOPYJC return $end_pos+1;
         return $limit+1;                     # SNOOPYJC
      }
      $k+=2; # $k now points to the start of the second argument
      if( $k==$end_pos ){
         $arg2=$ValPy[$k];
         $k+=1;
         # issue 21 if( $arg1 eq ' ' || $arg1type eq '"' ){
	 # issue 21    gen_chunk("$arg2.lstrip($arg1");
         if( $arg1type eq '"' ){        # issue 21
            $arg1 ='' if($arg1 eq "' '");       # issue 21: string of ' ' is a special case
            gen_chunk("$arg2.split($arg1");	# issue 21
         }else{
            gen_chunk($py_name,"($arg1,$arg2$flags"); # issue 21: this is a regex function
         }
      }elsif( ($split=next_same_level_token(',',$k+1,$end_pos))>-1 ){
         #we have third argument to split
         if($arg1type eq '"') {                 # issue 21
            $k=expression($k,$split-1);         # issue 21
            if($arg1 eq "' '") {       # issue 21: string of ' ' is a special case
                gen_chunk(".split(maxsplit=");       # issue 21
            } else {
                gen_chunk(".split($arg1,");          # issue 21
            }
         } else {
            gen_chunk($py_name,"($arg1,");
            $k=expression($k,$split-1);
            return -255 if($k<0);
            gen_chunk(',');
         }
         $k=expression($split+1,$end_pos,0);
         return -255 if($k<0);
	 gen_chunk("-1");	        # issue 21: # of times to split is different in python
         gen_chunk($flags) if($flags);  # issue 21
      }elsif($arg1type eq '"') {        # issue 21: Expression with string pattern and 2 args
         $k=expression($k,$end_pos);	# issue 21
         $arg1 ='' if($arg1 eq "' '");       # issue 21: string of ' ' is a special case
         gen_chunk(".split($arg1");     # issue 21
      }else{			# issue 21: Expression with regex pattern and 2 args
         gen_chunk($py_name,"($arg1,");	# issue 21
         $k=expression($k,$end_pos);	# issue 21
         gen_chunk($flags) if($flags);  # issue 21
      }
      gen_chunk(')');
   }elsif($perl_name eq 'print' || $perl_name eq 'printf') {
      $TrStatus=print3($begin); # in Python3 this is a function
      if ($TrStatus<0) { return -255; }
   }elsif($perl_name eq 'defined' ) {
      # open used without parantethisi. always has one argument
      $k=$start;
      # issue 25 gen_chunk("$ValPy[$k] != none");
      if($k+1 <= $#ValClass && $ValClass[$k+1] eq '(' && $ValPerl[$k+1] ne '(') {     # issue 25 - array element or hash value
          $e = end_of_variable($start);             # issue 25 addl fix, SNOOPYJC
          $k = expression($k, $e, 0);                           # issue 25
      } elsif( $bracketed==-1 ){                        # SNOOPYJC
          gen_chunk("$DEFAULT_VAR is not None");
          return $start;
      } elsif($ValClass[$k] =~ /[ah]/) {                # SNOOPYJC: Old perl allowed this
          logme('W',"'defined $ValPerl[$k]' is no longer allowed in perl - translated to bool($ValPy[$k])");      # SNOOPYJC
          gen_chunk("bool($ValPy[$k])");                # SNOOPYJC
      } elsif($ValClass[$k] eq 'i' && ($k+1 > $#ValClass || $ValClass[$k+1] ne '(')) {               # SNOOPYJC: sub or FH
          if(substr($ValPy[$k],0,4) eq 'sys.') {
              gen_chunk("True");            # We know it's defined if it's like sys.stdin or something
          } elsif($k+2 <= $#ValClass && $ValClass[$k+1] eq 'D' && $ValClass[$k+2] eq 'i') {     # defined fh->autoflush or something like that
              gen_chunk("hasattr($ValPy[$k], '$ValPy[$k+2]')");
              $Pyf{_autoflush} = 1 if($ValPerl[$k+2] eq 'autoflush');
              return $k+3;
          } elsif(index($ValPy[$k], '.') >= 0) {        # Package.func
              my @pieces = split /[.]/, $ValPy[$k];
              gen_chunk('(hasattr(builtins', ',', "'$pieces[0]'", ')');
              for(my $i = 1; $i < scalar(@pieces); $i++) {
                  gen_chunk('and', 'hasattr(');
                  for(my $j = 0; $j < $i; $j++) {
                      gen_chunk('.') if($j != 0);
                      gen_chunk($pieces[$j]);
                  }
                  gen_chunk(',', "'$pieces[$i]'", ')');
              }
              gen_chunk(')');
          } else {
              gen_chunk("'$ValPy[$k]' in globals()");
          }
          return ($bracketed == 1 ? $k+2 : $k+1);
      } elsif($ValClass[$k] eq 'f' && ($k+1 > $end_pos || $ValClass[$k+1] ne '(')) {
          #gen_chunk("(hasattr(builtins, '$ValPy[$k]') and callable($ValPy[$k]))");
          #
          # SNOOPYJC: If this is a function with no arguments, then call it and
          # see if the result is defined:               e.g. __SUB__
          #
          if(exists $Perlscan::FuncType{$ValPerl[$k]}) {
              my $ft = $Perlscan::FuncType{$ValPerl[$k]};
              my $arg0_type = substr($ft,0,1);
              if($arg0_type eq ':' || $arg0_type eq '') {
                  if( !exists $Pyf{$ValPy[$k]} ) {
                     if( -e "$Pyf_dir/$ValPy[$k].py" ) {
	                $Pyf{$ValPy[$k]} = 1;		#Include the module
                     }
                  }
                  gen_chunk($ValPy[$k],'()', 'is', 'not', 'None');
              } else {
                  gen_chunk("True");
              }
          } else {
              gen_chunk("True");            # We know it's an existing function if we classify it as such
          }
      } else {                                                  # issue 25
          # Special case for read
          if($bracketed == 1 && $end_pos+2 <= $#ValClass && $ValClass[$end_pos+2] eq 'y') {
             $k=expression($k-1,$end_pos+2,0);                     # issue 25
             return $k+1;
          } else {
             $k=expression($k,$end_pos,0);                         # issue 25
          }
          gen_chunk(' is not None');                             # issue 25
          #gen_chunk("$ValPy[$k] is not None");		        # issue 25
      }                                                         # issue 25
      $k=($k+1<=$#ValPerl && $ValPerl[$k+1] eq ')') ? $k+2 : $k+1;
   }elsif($perl_name eq 'unshift' ){
      # unshift ARRAY,LIST
      # arrayOrList.insert(0 , element)
      $k=$start;
      # issue 38 gen_chunk($ValPy[$k],$py_name,$ValPy[$k+2],')');
      # issue 38 $k=($k+3<=$#ValPerl && $ValPerl[$k+3] eq ')') ? $k+4 : $k+3;
      my $comma = next_same_level_token(',',$start,$end_pos);      # issue 38
      return -255 if $comma<0;                                     # issue 38
      if ($debug > 4) {
         say STDERR "unshift $ValClass[$comma+1]\n";
      }
      $slice = '[0:0]';                         # issue 66
      # issue 66: fix unshift into @ARGV for the test
      if($k == $comma-1 && substr($ValPy[$k],-4,4) eq '[1:]') {     # issue 66 like sys.argv[1:]
          substr($ValPy[$k],-2,2) = ':0]';      # issue 66
          $slice = '';                          # issue 66
      }                                         # issue 66
      my $t=expression($k,$comma-1,0);          # issue 38 Gen the LHS
      return -255 if $t<0;                      # issue 38
      if( $ValClass[$comma+1] eq 'a' ){         # issue 38
         gen_chunk("$slice = ",$ValPy[$comma+1]); # unshift(@x,@y)
      }elsif($ValClass[$comma+1] eq '(' ){
          gen_chunk("$slice = [");
          $k=expression($comma+2,$end_pos-1,0);	# issue 38
          gen_chunk(']');                       # issue 38
      }elsif(index("sd-\"", $ValClass[$comma+1]) >= 0 || ($ValClass[$comma+1] eq 'i' && $comma+1 == $#ValClass)) {   # issue 38: scalar
	  gen_chunk("$slice = [");	        # issue 38
          $k=expression($comma+1,$end_pos,0);	# issue 38
	  gen_chunk(']');			# issue 38
      }else{
	  gen_chunk("$slice = ");	        # issue 38
     	  $Pyf{"_make_list"} = 1;		# issue 38
          gen_chunk('_make_list', '(');         # issue 38
          $k=expression($comma+1,$end_pos,0);	# issue 38
	  gen_chunk(')');			# issue 38
      }
      # issue 28 }elsif($perl_name eq 'shift' ){
   }elsif($perl_name eq 'shift' || $perl_name eq 'pop'){        # issue 28
      # assent only a single arg -- array; if no argument then it uses @_ array
      $bracketed=-1 if($bracketed!=-1 && index('>0o+-*/',$ValClass[$start]) >= 0); # issue 28: pop has no arg if the next thing is an operator
      if( $bracketed==-1 ){
	  # issue 28 gen_chunk("perl_arg_array$py_name");
          if($CurSub eq '__main__' || substr($CurSub, 0, 7) eq '__END__') {     # issue 24
              if($perl_name eq 'shift') {
                  gen_chunk("(sys.argv.pop(1) if len(sys.argv)>1 else None)");	# issue 24
              } else {
                  gen_chunk("(sys.argv.pop() if len(sys.argv)>1 else None)");	# issue 24
              }
          } else {
              gen_chunk("($PERL_ARG_ARRAY$py_name if $PERL_ARG_ARRAY else None)");	# issue 28, issue 32
          }
          return $start;                       # issue 28
      # issue 28 }elsif( $end_pos==$start ){
      } else {          # issue 28
	 # issue 28 gen_chunk($ValPy[$start],$py_name);
         gen_chunk('(',$ValPy[$start],$py_name,"if",$ValPy[$start],"else", "None)");	# issue 28
         return $limit+1 if($bracketed == 1);   # issue parens
         return $start+1;                       # issue 28
      # issue 28 }else{
      # issue 28    return -255;
      }
   }elsif($perl_name eq 'mkdir' && $bracketed==-1) {            # SNOOPYJC
       gen_chunk("$py_name", "($DEFAULT_VAR)");
       return $start;
   }elsif($perl_name eq 'ord' || $perl_name eq 'chr' || $perl_name eq 'quotemeta') { # issue 59, SNOOPYJC
      if( $bracketed==-1 ){
          gen_chunk("$py_name", "($DEFAULT_VAR)");
          return $start;                       # issue 28
      } 
      gen_chunk("$py_name", '(');
      $k=expression($start,$end_pos,0);
      return -255 if $k<0;
      gen_chunk(')');
      return $limit+1;
   }elsif($perl_name eq 'oct' || $perl_name eq 'hex') { # issue 59, SNOOPYJC
      my $base = (($perl_name eq 'oct') ? 8 : 16);
      if( $bracketed==-1 ){
          gen_chunk("$py_name", "($DEFAULT_VAR, $base)");
          return $start;                       # issue 28
      } 
      gen_chunk("$py_name", '(');
      $k=expression($start,$end_pos,0);
      return -255 if $k<0;
      gen_chunk(',', $base);
      gen_chunk(')');
      return $limit+1;
   }elsif(($perl_name eq 'stat' || $perl_name eq 'lstat') && !$uses_file_stat) { # SNOOPYJC: old stat/lstat
      $Constants{_} = 1; 
      if( $bracketed==-1 ){
          if($begin == 0) {
              gen_chunk('_ = ', "$py_name", "($DEFAULT_VAR)");
          } else {
              gen_chunk('(_:=', "$py_name", "($DEFAULT_VAR))");
          }
          return $start;                       # issue 28
      } 
      if($begin == 0) {
          gen_chunk("_ = ", "$py_name", '(');
      } else {
          gen_chunk('(_:=', "$py_name", '(');
      }
      $k=expression($start,$end_pos,0);
      return -255 if $k<0;
      gen_chunk(')');
      gen_chunk(')') if($begin != 0);
      return $limit+1;
   }elsif($perl_name eq 'pos') {                                # SNOOPYJC
       # pos($scalar)
       # pos $scalar

       # We assume the scalar is matched by the last match object
       gen_chunk("$DEFAULT_MATCH.end()");
       return $limit+1;
   }elsif($perl_name eq 'grep' || $perl_name eq 'map') {        # issue 60
       # grep expr, @arr
       # grep /pat/, @arr
       # grep(expr, @arr)
       # grep(/pat/, @arr)
       # map f, @arr 
       # map(f, @arr)
       # map{block} @arr (or list)
       # grep{block} @arr (or list)
       $k=$start;
       gen_chunk('list(');             # filter or map, convert to list so we can use len and subscript
       gen_chunk($py_name);
       $need_lambda = 1;
       if($perl_name eq 'map') {
           # See if we have an equiv python function that's like "chr", and not like ".lower()".
           if(($bracketed == 0 || $ValPerl[$begin+1] eq '(') && $ValClass[$start] eq 'f' && substr($ValPy[$start],0,1) ne '.') {
               gen_chunk('(', $ValPy[$start]);
               $need_lambda = 0;
            }
       }
       $comma = $end_pos+1;
       if($need_lambda) {
            gen_chunk("(lambda $DEFAULT_VAR:");
            $comma = next_same_level_token(',', $start, $end_pos);
            $comma = $end_pos+1 if $comma<0;
            if($start == $comma-1 && $perl_name eq 'grep') {    # singleton
                if(index('sd"', $ValClass[$start]) >= 0) {   # scalar, digits, or string
                    gen_chunk($DEFAULT_VAR,'==', $ValPy[$start]);
                } elsif($ValClass[$start] eq 'q') {      # pattern
                    if(substr($ValPy[$start],0,3) eq 're.') {
                        gen_chunk($ValPy[$start]);      # it's ready to go!
                    } else {
                        gen_chunk('re.search(', $ValPy[$start], ',', $DEFAULT_VAR, ')');
                    }
                } else {
                    return -255;
                }
            } elsif($start == $comma-1 && $ValClass[$start] eq 'f' && substr($ValPy[$start],0,1) eq '.') {      # function like ".lower()"
                  gen_chunk($DEFAULT_VAR, $ValPy[$start]);
            } elsif($start == $comma-1 && $ValClass[$start] eq 'i' && $LocalSub{$ValPy[$start]} && $perl_name eq 'map') {
     	          $Pyf{"__mapf"} = 1;		# Need extra function because perl uses global $_ instead of passing an arg
                  gen_chunk('__mapf('.escape_keywords($ValPy[$k]).", $DEFAULT_VAR)");
            } else {
                $k = expression($start, $comma-1, 0);
                return -255 if $k<0;
            }
       } elsif($bracketed == 1 && $ValPerl[$begin+1] eq '(') {
            $comma = next_same_level_token(',', $start, $end_pos);
       }
       gen_chunk(',');
       if($bracketed == 1 && $ValPerl[$begin+1] eq '{') {
           # We chopped our limit to the matching '}', so put it back!
           $limit = $#ValClass;
           $limit = $_[1] if(scalar(@_)>1);
           $k = expression($end_pos+2, $limit, 0);
       } else {
           $k = expression($comma+1, $limit, 0);
       }
       gen_chunk(')') if($ValPerl[$limit] ne ')');
       gen_chunk(')');   # close list(...)
   }elsif($perl_name eq 'sort') {                       # SNOOPYJC
       # sort @arr (or list)
       # sort f @arr
       # sort{block} @arr (or list)
       #
       # Gen call to sorted(list, key=..., reverse=...) - this returns a list
       #
       $k=$start;
       gen_chunk($py_name);
       if(!($bracketed == 1 && $ValPerl[$begin+1] eq '{') && 
           ($ValClass[$k] ne 'i' || ($k+1 < $#ValClass && $ValClass[$k+1] eq '('))) {        # sub but not sub()
         # Simple case of sort @arr -or- sort (list)
         gen_chunk('(');
         $TrStatus=expression($start,$end_pos,0);
         return -255 if ($TrStatus<0);
         gen_chunk(')');
         return $limit+1;
       }
       gen_chunk('(');
       # Generate the list as the first argument to python's sorted()
       if($bracketed == 1 && $ValPerl[$begin+1] eq '{') {
           # We chopped our limit to the matching '}', so put it back!
           $limit = $#ValClass;
           $limit = $_[1] if(scalar(@_)>1);
           # If bracketed == 1, then end_pos points just before the '}'
           if($end_pos+2 == $limit && $ValClass[$limit] eq 'h') {       # sort a hash sorts the keys and values in perl
               # SNOOPYJC gen_chunk('functools.reduce(lambda x,y:x+y,'.$ValPy[$limit].'.items())')
               gen_chunk('itertools.chain.from_iterable('.$ValPy[$limit].'.items())')   # SNOOPYJC
           } else {
               $k = expression($end_pos+2, $limit, 0);
           }
       } elsif($start+1 == $limit && $ValClass[$limit] eq 'h') {        # sort a hash sorts the keys and values in perl
           # SNOOPYJC  gen_chunk('functools.reduce(lambda x,y:x+y,'.$ValPy[$limit].'.items())')
           gen_chunk('itertools.chain.from_iterable('.$ValPy[$limit].'.items())')
       } else {
           $k = expression($start+1, $limit, 0);
       }
       gen_chunk(', key=functools.cmp_to_key(lambda a,b:');
       if($bracketed == 0 && $ValClass[$start] eq 'i' && $LocalSub{$ValPy[$start]}) {
          $Pyf{"__sortf"} = 1;		# Need extra function because perl uses global $_ instead of passing an arg
          gen_chunk('__sortf('.escape_keywords($ValPy[$start]).", a, b)");
       } else {
           $k = expression($start, $end_pos, 0);
           return -255 if $k<0;
       }
       gen_chunk(')');   # Close the functools.cmp_to_key(...
       gen_chunk(')') if($ValPerl[$limit] ne ')');

   }elsif( $perl_name eq 'push' ){
      # push LHS, RSH => LSH.append(RSH) -or- LHS.extend(RHS)
      $k=$start;
      # issue 9 if( $ValClass[$k+2] =~ /[a"]/ ){
      # issue 9 }elsif( $ValClass[$k+2] eq 'a' ){
      my $comma = next_same_level_token(',',$start,$end_pos);      # issue 9
      return -255 if $comma<0;                                  # issue 9
      if ($debug > 4) {
         say STDERR "push $ValClass[$comma+1]\n";
      }
      my $t=expression($k,$comma-1,0);          # issue 9: Gen the LHS
      return -255 if $t<0;                                  # issue 9
      return -255 if($comma+1 > $#ValClass);
      if( $ValClass[$comma+1] eq 'a' ){
         gen_chunk($py_name,$ValPy[$comma+1],')'); # issue 9: push(@x,@y)
      }elsif($ValClass[$comma+1] eq '(' ){      # issue 9

          my $type = &Pythonizer::expr_type($comma+1, matching_br($comma+1), $CurSub);  # SNOOPYJC
          $py_name = '.append(' if(substr($type,0,1) !~ /[ah]/);        # SNOOPYJC: Use append if it's a scalar
          gen_chunk($py_name, $ValPy[$comma+1]); # issue 9
          $k=expression($comma+2,$end_pos-1,0);	# issue 9
          gen_chunk($ValPy[$end_pos], ')');     # issue 9
      }elsif(index("isd-\"", $ValClass[$comma+1]) >= 0 && $comma+1 == $end_pos) {   # issue 9: scalar
	  $py_name = '.append(';		# issue 9
	  gen_chunk($py_name);	                # issue 9
          $k=expression($comma+1,$end_pos,0);	# issue 9
	  gen_chunk(')');			# issue 9
      }else{
	  gen_chunk($py_name);	                # issue 9: .extend(
	  # issue 9 $k=expression($k+3,$end_pos,0);
     	  $Pyf{"_make_list"} = 1;		# issue 9
          gen_chunk('_make_list', '(');         # issue 9
          $k=expression($comma+1,$end_pos,0);	# issue 9
	  gen_chunk('))');			# issue 9
      }
   }elsif($perl_name eq 'delete' ){
      # open used without parantethisi. always has one argument
      # issue delete $k=($ValPerl[$start+1] eq '(') ? $start+2 : $start+1;
      $k=$start;              # issue delete
      if($ValClass[$k] eq 't' && $ValPerl[$k] eq 'local') {             # issue 108
          logme('W',"The 'delete local' statement is not implemented"); # issue 108
      } elsif($ValClass[$k] eq 'a') {                # issue delete - handle delete @options{list of keys}
          gen_chunk("for _ in ");
          $e = matching_br($k+1);
          # special case for delete @options{keys %options);, as the default code will give an error
          # about modifying the dict in the loop.
          $gen_close = 0;
          if($ValClass[$k+2] eq 'f' && $ValPerl[$k+2] eq 'keys' &&
             $ValClass[$k+3] eq 'h' && $ValPerl[$k]) {
             gen_chunk("list(");
             $gen_close = 1;
          }
          my $kk=expression($k+2, $e-1, 0);
          return -255 if $kk<0;
          gen_chunk(')') if($gen_close);
          gen_chunk(':');
          gen_statement();
          correct_nest(1,1);
          gen_chunk($ValPy[$k],$py_name,'_,None)'); # delete($hash{$key}) => hash.pop($key)
          gen_statement();
          correct_nest(-1,-1);
      } else {
        gen_chunk($ValPy[$k],$py_name,$ValPy[$k+2],',None)'); # delete($hash{$key}) => hash.pop($key)
      }
   }elsif($perl_name eq 'sprintf' ){
      #$ValPy[$start] -- format string
      # SNOOPYJC gen_chunk($ValPy[$start],' % ( '); # format string
      # SNOOPYJC $k=expression($start+2,$end_pos,0); # skip initial',' and scan all variables
      $k = end_of_variable($start);             # SNOOPYJC
      $Pyf{_format} = 1;                        # SNOOPYJC
      gen_chunk('_format', '(');                # SNOOPYJC
      $k=expression($start, $k, 0);             # SNOOPYJC
      # SNOOPYJC gen_chunk(' % ( ');                       # SNOOPYJC
      if($k+1 <= $end_pos) {
         gen_chunk(',');                         # SNOOPYJC
         gen_chunk('(');                         # SNOOPYJC
         $k=expression($k+1,$end_pos,0);  # SNOOPYJC: skip initial ',' and scan all variables
         return -255 if $k<0;
         gen_chunk(')'); #
      }
      gen_chunk(')'); #SNOOPYJC
   }elsif($perl_name eq 'undef'  ){
      # undef in Perl accepts list of arguments
      if( $bracketed==-1){
          if($begin != 0) {     # SNOOPYJC: don't gen code for "undef;", since it may be turned into a "return undef;"
            gen_chunk('None');
          }
      }else{
         if(index('?:,)', $ValClass[$start]) >= 0) {           # SNOOPYJC - undef by itself, followed by a ? : , or )
             gen_chunk('None');
             return $start;
         }
         # SNOOPYJC: If we know the type of the var, then init it to that value instead
         # If the var is used in a "defined" function, then the type is set to 'm' for mixed so
         # we init it to None.
         my @undefs = ($ValPy[$start]);                 # SNOOPYJC: new code
         for(my $i=$start+1; $i<$end_pos; $i+=2 ){
            last if ($ValClass[$i] ne ','); # check if the list endeded
            push @undefs, $ValPy[$i+1];
         }
         my $val = undef;
         foreach my $u (@undefs) {
             my $sval = 'None';
             if(exists $VarType{$u} && exists $VarType{$u}{$CurSub}) {
                   $sval = init_val($VarType{$u}{$CurSub});
             }
             if(defined $val && $sval ne $val) {
                 $val = undef;
                 last;
             }
             $val = $sval;
         }
         if(defined $val) {     # they are all the same
            gen_chunk(join(' = ', @undefs));
            gen_chunk(" = $val"); # final assignment
         } else {               # do it one by one
            foreach my $u (@undefs) {
                gen_chunk("$u = ");
                my $val = 'None';
                if(exists $VarType{$u} && exists $VarType{$u}{$CurSub}) {
                    $val = init_val($VarType{$u}{$CurSub});
                }
                gen_chunk($val);
                gen_statement();
            }
         }
     }
   }elsif($perl_name eq 'chomp' || $perl_name eq 'chop' ){      # SNOOPYJC
      if(index($TokenStr,'=') > 0) {            # SNOOPYJC chomp(my @a = <FH>);
          pre_assign($begin+1,1);
          $end_pos = $#ValClass-1;
          if($debug >= 3) {
	     say STDERR "after pre_assign: start=$start, end_pos=$end_pos, =|$TokenStr|= @ValPerl\n"
          }
      }
      if ($bracketed==-1){
          gen_chunk($ValPy[1].' = '.$DEFAULT_VAR.$py_name);         # issue 32: Be careful because $py_name contains '\n'
      }elsif ($start==$end_pos){
         if($ValClass[$start] eq 'a' || $ValClass[$start] eq 'h') {  # SNOOPYJC: Handle array or hash chomp
             if($ValClass[$start] eq 'a') {
                gen_statement("for $INDEX_TEMP in range(len($ValPy[$start])):");  # SNOOPYJC
             } else {
                gen_statement("for $INDEX_TEMP in $ValPy[$start]:");  # SNOOPYJC
             }
             correct_nest(1,1);                         # SNOOPYJC
             gen_chunk($ValPy[$start]."[$INDEX_TEMP] = ".$ValPy[$start]."[$INDEX_TEMP]".$py_name);    # SNOOPYJC
             gen_statement();
             correct_nest(-1,-1);                       # SNOOPYJC
         } else {                                       # SNOOPYJC
             gen_chunk($ValPy[$start].' = '.$ValPy[$start].$py_name);
         }
      }elsif(index($TokenStr,',') > 0) {                      # SNOOPYJC
         for(my $i=$start; $i<=$end_pos; $i+=2 ){             # SNOOPYJC
            # SNOOPYJC last if ($ValClass[$i] ne ','); # check if the list endeded
            # SNOOPYJC gen_chunk($ValPy[$i],'=',$ValPy[$i],$ValPy[0],';');
            # SNOOPYJC: After fix_type_issues runs, we could have _str(a) instead of just a, so handle that:
            if($ValClass[$i] eq 'f' && $ValPy[$i] eq $CONVERTER_MAP{S}) {       # SNOOPYJC
                gen_chunk($ValPy[$i+2],' = ',$ValPy[$i],'(',$ValPy[$i+2],')',$ValPy[0]);        # SNOOPYJC
                $i += 3;
            } else {
                gen_chunk($ValPy[$i],' = ',$ValPy[$i],$ValPy[0]); # SNOOPYJC
            }
            gen_statement();                                    # SNOOPYJC
         }
      } else {
          # What else??
      }
   }elsif($perl_name eq 'splice') {
       # splice ARRAY,OFFSET,LENGTH,LIST
       # splice ARRAY,OFFSET,LENGTH
       # splice ARRAY,OFFSET
       # splice ARRAY
       my $comma = next_same_level_token(',', $start, $end_pos);
       my $ar0 = $start;
       my $ar1 = $end_pos;
       $ar1 = $comma-1 if($comma != -1);
       gen_chunk($py_name, '(');
       $TrStatus = expression($ar0, $ar1, 0);   # Gen array
       if($comma != -1) {
           $comma = next_same_level_token(',', $comma+1, $end_pos);
           my $of0 = $ar1+2;
           my $of1 = $end_pos;
           $of1 = $comma-1 if($comma != -1);
           gen_chunk(',');
           if($of0 == $of1 && $ValClass[$of0] eq 'a' && $ValPerl[$of0] !~ /^len\(/) {
               gen_chunk('len', '(', $ValPy[$of0], ')');
           } else {
               $TrStatus = expression($of0, $of1, 0);   # Gen offset
           }
           if($comma != -1) {
               $comma = next_same_level_token(',', $comma+1, $end_pos);
               my $ln0 = $of1+2;
               my $ln1 = $end_pos;
               $ln1 = $comma-1 if($comma != -1);
               gen_chunk(',');
               $TrStatus = expression($ln0, $ln1, 0);   # Gen length
               if($comma != -1) {
                   my $ls0 = $ln1+2;
                   my $ls1 = $end_pos;
                   gen_chunk(',');
                   if($ls0 == $ls1 && $ValClass[$ls0] eq 'a') {
                       gen_chunk('*', $ValPy[$ls0]);
                   } else {
                       $TrStatus = expression($ls0, $ls1, 0);
                   }
               }
           }
       }
       gen_chunk(')');
   }elsif($perl_name eq 'reverse') {            # issue 65 - implement 'reverse'
       if(substr($py_name,0,1) eq '_' || $py_name eq "$PERLLIB.reverse_scalar") {     # _reverse_scalar - scalar context
           # Optimize some special cases
           if($bracketed==-1) {
                gen_chunk($DEFAULT_VAR.'[::-1]');
           } elsif($start == $end_pos && $ValClass[$start] =~ /([as])/) {        # a single thing
               if($1 eq 'a') {  # a (array)
                   gen_chunk("''.join($ValPy[$start])[::-1]");
               } elsif($1 eq 's') {     # s (scalar)
                   gen_chunk("$ValPy[$start]".'[::-1]');
               } else {         # h (hash)
                   gen_chunk("{_v: _k for _k, _v in $ValPy[$start].items()}");
               }
           } else {
               $Pyf{$py_name} = 1;
               gen_chunk($py_name);
               gen_chunk('(');
               $make_tuple = 0;
               if($ValClass[$start] ne '(' && next_same_level_token(',',$start,$end_pos) >= 0) {
                  gen_chunk('(');
                  $make_tuple = 1;
               }
               $TrStatus=expression($start,$end_pos,0);
               return -255 if ($TrStatus<0);
               gen_chunk(')') if($make_tuple);
               gen_chunk(')');
           }
       } else {
           if($bracketed==-1) {
               gen_chunk($DEFAULT_VAR);        # reversing a list of 1 element = identity
           } elsif($start == $end_pos && $ValClass[$start] eq 'h') {        # a single hash
               gen_chunk("{_v: _k for _k, _v in $ValPy[$start].items()}");
           } else {
               gen_chunk('(');
               $TrStatus=expression($start,$end_pos,0);
               return -255 if ($TrStatus<0);
               gen_chunk(')');
               gen_chunk($py_name);
           }
        }
   # SNOOPYJC }elsif($perl_name eq 'chop'){
   # SNOOPYJC gen_chunk("$ValPy[$start]=$ValPy[$start]".'[0,-1]');
   }elsif($perl_name eq 'GetOptions' && $bracketed==1 && (my $type = GetOptionsHandled($start, $end_pos))) { # issue 48
      GetOptions_fun($type, $start, $end_pos);                  # issue 48
   }elsif($perl_name eq 'binmode') {            # SNOOPYJC
       # binmode FH -or- binmode FH, "LAYER"
       my $fh = $start;
       my $ly = (($fh+2 <= $#ValClass) ? $fh+2 : undef);
       if(!defined $ly || $ValClass[$ly] ne '"') {
           $layer = ':raw';
       } else {
           $layer = $ValPerl[$ly];
       }
       my $mode = 'None';
       $mode = "'b'" if($layer eq ':raw' || $layer eq ':bytes');
       my $encoding = 'None';
       my $errors = 'None';
       $encoding = $1 if($layer =~ /:encoding=\((.*)\)/);
       if($layer eq ':utf8') {
           $encoding = "'UTF-8'";
           $errors = "'ignore'";
       }
       $Pyf{'_binmode'} = 1;
       if($begin == 0) {
          gen_chunk("$ValPy[$fh] = ", '_binmode', "($ValPy[$fh], mode=$mode, encoding=$encoding, errors=$errors)");
          gen_statement();
       } elsif(index($ValPy[$fh], '.') < 0) {
          gen_chunk("($ValPy[$fh]:=", '_binmode', "($ValPy[$fh], mode=$mode, encoding=$encoding, errors=$errors))");
       } else {
           my $ldot = rindex($ValPy[$fh], '.');
           $Pyf{_assign_global} = 1;
           gen_chunk("_assign_global('".substr($ValPy[$fh],0,$ldot)."','".substr($ValPy[$fh],$ldot+1)."', _binmode", 
                     "($ValPy[$fh], mode=$mode, encoding=$encoding, errors=$errors))");
       }
   }elsif($perl_name eq 'IOFile_open' || $perl_name eq 'fdopen') {        # SNOOPYJC
       # $fh->open(fname, mode, parms) -or- $fh->open(fname, IOLayers)
       # This has been already modified so when we see it, it looks like:
       # IOFile_open($fh, fname, mode, parms) -or- IOFile_open($fh, fname, mode, parms)
       my $fh = $start;
       $Pyf{$py_name} = 1;
       my $close = ')';
       if($begin == 0) {
          gen_chunk("$ValPy[$fh] = ", $py_name, "($ValPy[$fh], ");
       } elsif(index($ValPy[$fh], '.') < 0) {
          gen_chunk("($ValPy[$fh]:=", $py_name, "($ValPy[$fh], ");
          $close = '))';
       } else {
           my $ldot = rindex($ValPy[$fh], '.');
           $Pyf{_assign_global} = 1;
           gen_chunk("_assign_global('".substr($ValPy[$fh],0,$ldot)."','".substr($ValPy[$fh],$ldot+1)."', ", $py_name, 
                     "($ValPy[$fh], ");
           $close = '))';
       }
       my $comma = next_same_level_token(',', $fh, $end_pos);
       return -255 if($comma < 0);
       my $fn0 = $comma+1;
       $TrStatus=expression($fn0, $end_pos, 0);
       return -255 if ($TrStatus<0);
       gen_chunk($close);
   }elsif($perl_name eq 'caller') {                     # SNOOPYJC
       $Pyf{'_caller'} = 1;
       if($bracketed == -1) {                  # no args
           #gen_chunk(q(['main',__file__,sys._getframe(1).f_lineno]));
           gen_chunk('_caller', '()');
       } else {
           # definition here: https://perldoc.perl.org/functions/caller
           # note we leave some stuff out!
           #gen_chunk("['main',__file__,(_f:=sys._getframe(");
           gen_chunk('_caller', '(');
           $TrStatus=expression($start,$end_pos,0) if($end_pos >= $start);
           return -255 if ($TrStatus<0);
           gen_chunk(')');
           #gen_chunk(")).f_lineno,_f.f_code.co_name,_f.f_code.co_argcount,0,'',0,0,0,0]");
        }
   }elsif($perl_name eq 'seek') {              # SNOOPYJC
       gen_chunk($py_name); # method
       gen_chunk('(');
       my $fh = $start;
       my $comma = next_same_level_token(',', $start, $end_pos);
       $TrStatus=expression($fh, $comma-1, 0);
       return -255 if ($TrStatus<0);
       gen_chunk(',');
       my $pos = $comma+1;
       $comma = next_same_level_token(',', $pos, $end_pos);
       $TrStatus=expression($pos, $comma-1, 0);
       return -255 if ($TrStatus<0);
       gen_chunk(',');
       my $whence = $comma+1;
       $TrStatus=expression($whence, $end_pos, 0);
       return -255 if ($TrStatus<0);
       gen_chunk(')');
   }elsif($perl_name eq 'tell') {              # SNOOPYJC
       gen_chunk($py_name); # add method
       gen_chunk('(');
       my $fh = $start;
       $TrStatus=expression($fh, $end_pos, 0);
       return -255 if ($TrStatus<0);
       gen_chunk(')');
   }elsif($py_name eq '.read' || $py_name eq '.sysread') {     # issue 10 - read or sysread, not already transformed
       if(substr($perl_name,0,1) eq '.') {  # SNOOPYJC: We already modified the function in fixup_read_in_expression
          gen_chunk($py_name);
          return expression($begin+1,$limit,1);
       }
       # SNOOPYJC: Redid this whole thing to support complex args, though they are
       #           mostly handled above in fixup_read_in_expression
       #
       # read FILEHANDLE,SCALAR,LENGTH,OFFSET 
       # read FILEHANDLE,SCALAR,LENGTH
       my $fh0 = $start;
       my $comma1 = next_same_level_token(',', $start, $end_pos);
       return -255 if ($comma1<0);
       my $fh1 = $comma1-1;
       my $sc0 = $comma1+1;
       my $comma2 = next_same_level_token(',', $sc0, $end_pos);
       return -255 if ($comma2<0);
       my $sc1 = $comma2-1;
       my $ln0 = $comma2+1;
       my $comma3 = next_same_level_token(',', $ln0, $end_pos);
       my $ln1 = $comma3-1;
       my $of0 = undef;
       my $of1 = undef;
       if($comma3 < 0) {
           $ln1 = $end_pos;
       } else {
           $of0 = $comma3+1;
           $of1 = $end_pos;
       }
       my $readf = '_read';
       $readf = '_sysread' if($perl_name eq 'sysread');
       $Pyf{$readf} = 1;
       if($begin == 0) {                # We don't care about the result
           # scalar = _read(fh, length)
           # scalar = _read(fh, length, scalar, offset)
           $TrStatus = expression($sc0,$sc1,0);
           return -255 if ($TrStatus<0);
           gen_chunk('=');
           gen_chunk($readf, '(');
           $TrStatus = expression($fh0,$fh1,0);
           return -255 if ($TrStatus<0);
           gen_chunk(',');
           expression($sc0,$sc1,0);
           gen_chunk(',');
           $TrStatus = expression($ln0,$ln1,0);
           return -255 if ($TrStatus<0);
           if(defined $of0) {
                gen_chunk(',');
                $TrStatus = expression($of0,$of1,0);
                return -255 if ($TrStatus<0);
           }
           gen_chunk(')');
        } else {
            if(defined $of0) {
                gen_chunk("(($ValPy[$sc0]:=($SUBSCRIPT_TEMP:=", $readf, '(');
                $TrStatus = expression($fh0,$fh1,0);
                return -255 if ($TrStatus<0);
                gen_chunk(',');
                gen_chunk($ValPy[$sc0]);
                gen_chunk(',');
                $TrStatus = expression($ln0,$ln1,0);
                return -255 if ($TrStatus<0);
                gen_chunk(',');
                $TrStatus = expression($of0,$of1,0);
                return -255 if ($TrStatus<0);
                gen_chunk(',need_len=True))[0])', ',', $SUBSCRIPT_TEMP, '[1])[1]');
            } else {
                gen_chunk("(($ValPy[$sc0]:=($SUBSCRIPT_TEMP:=", $readf, '(');
                $TrStatus = expression($fh0,$fh1,0);
                return -255 if ($TrStatus<0);
                gen_chunk(',');
                gen_chunk($ValPy[$sc0]);
                gen_chunk(',');
                $TrStatus = expression($ln0,$ln1,0);
                return -255 if ($TrStatus<0);
                gen_chunk(',need_len=True))[0])', ',', $SUBSCRIPT_TEMP, '[1])[1]');
            }
        }
   }elsif($perl_name eq 're') {                 # SNOOPYJC: Regex without =~ or !~
      # $py_name is like re.sub(r'a',r'b',_d) -or- re.sub(re.compile(r'a',re.G),r'b',_d)
      my $flags = process_re_flags($begin);
      $py_name = $ValPy[$begin];
      $py_name =~ s/\)\Z/,$flags)/ if($flags);
      if($begin == 0) {         # Statement context
          if($flags =~ /replace/) {
                $py_name =~ s/replace=False,//;
                gen_chunk($py_name);
          } else {
              gen_chunk($DEFAULT_VAR, '=', $py_name);
          }
      } else {
          $Pyf{_substitute_and_count} = 1;
          my $sac = '_substitute_and_count';
          $sac = "$PERLLIB.substitute_and_count" if($import_perllib);
          $py_name =~ s/^re\.sub/$sac/;
          gen_chunk('((', $DEFAULT_VAR, ':=', '(', $SUBSCRIPT_TEMP,':=', $py_name, ')[0])', ',', $SUBSCRIPT_TEMP, ')[1][1]');
      }
      return $begin+1;
   }elsif($perl_name eq 'tr') {                 # SNOOPYJC: tr without =~
       # $py_name is like .maketrans(r'a',r'b'),flags=rc
       my $args = tr_flags_to_args($ValPy[$begin]);
       my $flags = '';
       if($ValPy[$begin] =~ /,flags=([a-z]+)/) {
           $flags = $1;
           $ValPy[$begin] =~ s/,flags=[a-z]+//;
       }
       if($begin == 0) {        # Statement context
          if($flags =~ /r/) {
             gen_chunk($DEFAULT_VAR,'.translate(str',$py_name,')'); # a=a.translate(str.maketrans(this, that))
          } else {
             gen_chunk($DEFAULT_VAR,'=',$DEFAULT_VAR,'.translate(str',$py_name,')'); # a=a.translate(str.maketrans(this, that))
          }
       } else {
          $Pyf{_translate_and_count} = 1;
          gen_chunk('((', $DEFAULT_VAR, ':=', '(', $SUBSCRIPT_TEMP, ':=', '_translate_and_count', '(str', $args, ',', $DEFAULT_VAR, '))[0])', ',', $SUBSCRIPT_TEMP, ')[1][1]');
       }
       return $begin+1;
   }elsif( substr($py_name,0,1) eq '.' ){
      #Generic Perl built-in function which is a method in Python
      $ValPy[$limit]='' if $bracketed==1; # in this case we do not need to process closing bracket.
      if($start > $end_pos) {           # SNOOPYJC
          $TrStatus = -1;
          return -255;
      }
      $TrStatus=expression($start,$end_pos,0);
      return -255 if ($TrStatus<0);
      gen_chunk($py_name); # add method
   }else{
      gen_chunk($py_name);
      if ( $bracketed==-1 || $end_pos < $start){        # issue paren
         # zero arguments -- special case
         gen_chunk('()');
      # issue 13 }elsif( $end_pos==$start ){
      # issue 13   # single argument                            # issue 13: int(PI) needs to call PI()!!
      # issue 13   gen_chunk('('.$ValPy[$start].')')
      }else{
         gen_chunk('(');
         gen_chunk('*') if($py_name ne 'len' && need_splat($start)); # SNOOPYJC
         $TrStatus=expression($start,$end_pos,0);
         return -255 if ($TrStatus<0);
         gen_chunk(')');
      }
   }
   return $#ValClass+1 if(!defined $limit);             # SNOOPYJC
   return $limit+1; # limit_1 always represnt the fist not scanned symbol for this function.
} #function

sub function            # SNOOPYJC
{
    my $result = _function(@_);
    say STDERR "function returns $result" if($debug >= 3);
    return $result;
}

sub need_splat          # SNOOPYJC: Does this function/sub arg need a '*' before it?
{
    my $k = shift;
    return 0 if($k > $#ValClass);
    return 1 if($ValClass[$k] eq 'a' && substr($ValPy[$k],0,4) ne 'len(');
    if($ValClass[$k] eq 'f' && substr(&Pythonizer::func_type($ValPerl[$k], $ValPy[$k]),0,1) eq 'a') {
        #NOTE: The following code is now handled by func_type:
        #if(exists $Perlscan::SPECIAL_FUNCTION_MAPPINGS{$ValPerl[$k]} &&
        #$Perlscan::SPECIAL_FUNCTION_MAPPINGS{$ValPerl[$k]}{scalar} eq $ValPy[$k]) {
        #return 0;
        #}
        return 1;
    } elsif($ValClass[$k] eq 's') {     # $val =~ /regex/ is in list context
        $k = end_of_variable($k);
        return 1 if($k+2 <= $#ValClass && $ValClass[$k+1] eq '~' && $ValClass[$k+2] eq 'q');
    } elsif($ValClass[$k] eq 'q' && $ValPy[$k] =~ /\.split\(\)$/) {       # qw(w1 w2 ..)
        return 1;
    }
    return 0;
}

sub GetOptionsHandled           # issue 48: Can we handle this GetOptions call?
{
    # We handle 2 types of GetOptions calls.  
    # Type 1:  GetOption(\%hash, str, str, str, str, ...);
    # Type 2:  GetOptions(str => \$var, str => \$var, ...);
    my $start = shift;
    my $end_pos = shift;
    #
    # First we check for Type 1:
    #
    if($ValClass[$start] eq '\\' && $ValClass[$start+1] eq 'h') {
        for(my $i = $start+2; ($i+1) <= $end_pos; $i+=2) {
            return 0 if($ValClass[$i] ne ',');
            return 0 if($ValClass[$i+1] ne '"');
        }
        return 1;
    } else {            # Check for Type 2:
        for(my $i = $start; ($i+4) <= $end_pos; $i += 5) {
            return 0 if($ValClass[$i] ne '"');
            return 0 if($ValClass[$i+1] ne 'A');        # issue 93
            return 0 if($ValClass[$i+2] ne '\\');
            return 0 if($ValClass[$i+3] ne 's' && $ValClass[$i+3] ne 'a');
            return 0 if($ValClass[$i+4] ne ',' && $ValClass[$i+4] ne ')');
        }
        return 2;
    }
}

sub GetOptions_split            # issue 48: Split the string GetOptions argument and return the pieces as a 3-array
{
    my $str = shift;
    my ($key, $op, $typ, $arr) = $str =~ /([A-Za-z0-9_-|]+)([:=!+]?)([a-z0-9]*)([\$\@\{\d,\}]*)/;
    my @keys = split /[|]/, $key;
    #say STDERR "GetOptions_split($str): keys = @keys\n";
    for(my $i=0; $i<scalar(@keys); $i++) {
        if(length($keys[$i]) == 1) {
            $keys[$i] = '-' . $keys[$i];
        } else {
            $keys[$i] = '--' . $keys[$i];
        }
    }
    $op = '' if(!defined($op));
    $typ = '' if(!defined($typ));
    $arr = '' if(!defined($arr));
    my %TypeMap = (s=>'str', i=>'int', f=>'float');
    $typ = $TypeMap{$typ} if(exists $TypeMap{$typ});
    #say STDERR "GetOptions_split($str) = (@keys, $op, $typ, $arr)\n";
    return (\@keys, $op, $typ, $arr);
}

sub GetOptions_fun              # issue 48: Generate code for GetOptions
{
    my $type = shift;           # 1 or 2
    my $start = shift;
    my $end_pos = shift;

    gen_statement("$ARG_PARSER = argparse.ArgumentParser(argument_default=argparse.SUPPRESS)");
    if($type == 1) {            # Type 1: GetOptions(\%hash, str, str, str...);
        for(my $i = $start+2; $i <= $end_pos; $i+=2) {
            my ($keys, $op, $typ, $arr) = GetOptions_split($ValPerl[$i+1]);
            gen_chunk("$ARG_PARSER.add_argument(");
            foreach my $key (@$keys) {
                gen_chunk("\"$key\", ");
            }
            $const = '""';
            $const = '0' if($typ eq 'int' || $typ eq 'float');
            if($typ =~ /\d+/) {
                gen_chunk("type=int, ");
                $const = $typ;
                $typ = 'int';
            } elsif($typ) {
                gen_chunk("type=$typ, ")
            }
            if($arr eq '%') {
                logme('S', "Sorry, GetOptions(...'$ValPerl[$i+1]'...) -  '%' hash option is not supported!");
                $TrStatus=-1;
            }
            $nargs = '';
            if($op eq ':') {
                $nargs = "'*'";
            } elsif($op eq '=') {
                $nargs = "'+'";
            }
            if($nargs) {
                if($arr eq '@') {
                    gen_chunk("action='append', ");
                } elsif($arr =~ /{(\d+)}/) {
                    gen_chunk("nargs=$1, ");
                } elsif($arr =~ /{,\d+}/ || $arr =~ /{,}/) {
                    gen_chunk("nargs=$nargs, ");
                } elsif($arr =~ /{0,\d+}/) {
                    gen_chunk("nargs='*', ");
                } elsif($arr =~ /{(\d+),(\d+)}/) {
                    if($1 eq $2) {
                        gen_chunk("nargs=$1, ");
                    } else {
                        gen_chunk("nargs='+', ");
                    }
                } elsif($op eq ':') {
                    gen_chunk("nargs='?', const=$const, ");
                }
            }
            if($op eq '+') {
                gen_chunk("action='count', default=0, ");
            }
            if($op eq '!' || $op eq '') {
                gen_chunk("action='store_true')");
                gen_statement();
            }
            if($op eq '!') {
                gen_chunk("$ARG_PARSER.add_argument(");
                foreach my $key (@$keys) {
                    next if(length($key) == 2);         # skip single flags
                    gen_chunk('"--no'.substr($key,2)."\", action='store_false', dest=\"".substr($key,2).'")');
                }
            } elsif($op ne '') {
                $Perlscan::PythonCode[-1] =~ s/, $/)/;           # Change the trailing ', ' to a ')'
            }
            gen_statement();
        }
        gen_statement("(${ARG_PARSER}_res, ${ARG_PARSER}_rem) = $ARG_PARSER.parse_known_args()");
        gen_statement("$ValPy[$start+1].update(vars(${ARG_PARSER}_res))");
        # issue 24 gen_statement("sys.argv[1:] = $PERL_ARG_ARRAY = ${ARG_PARSER}_rem");
        gen_statement("sys.argv[1:] = ${ARG_PARSER}_rem");      # issue 24
    } else {                    # Type 2:  GetOptions(str => \$var, str => \$var, ...);
        for(my $i = $start; $i <= $end_pos; $i+=5) {
            my ($keys, $op, $typ, $arr) = GetOptions_split($ValPerl[$i]);
            gen_chunk("$ARG_PARSER.add_argument(");
            foreach my $key (@$keys) {
                gen_chunk("\"$key\", ");
            }
            $const = '""';
            $const = '0' if($typ eq 'int' || $typ eq 'float');
            if($typ =~ /\d+/) {
                gen_chunk("type=int, ");
                $const = $typ;
                $typ = 'int';
            } elsif($typ) {
                gen_chunk("type=$typ, ")
            }
            #say STDERR "typ=$typ\n";
            $dest = $ValPy[$i+3];
            if($arr eq '%' || $ValClass[$i+3] eq 'h') {
                logme('S', "Sorry, GetOptions(...'$ValPerl[$i]'=>\\\%$ValPerl[$i+3]...) -  '%' hash option is not supported!");
                $TrStatus=-1;
            }
            $nargs = '';
            if($op eq ':') {
                $nargs = "'*'";
            } elsif($op eq '=') {
                $nargs = "'+'";
            }
            if($nargs) {
                if($arr eq '@') {
                    gen_chunk("action='append', ");
                } elsif($arr =~ /{(\d+)}/) {
                    gen_chunk("nargs=$1, ");
                } elsif($arr =~ /{,\d+}/ || $arr =~ /{,}/) {
                    gen_chunk("nargs=$nargs, ");
                } elsif($arr =~ /{0,\d+}/) {
                    gen_chunk("nargs='*', ");
                } elsif($arr =~ /{(\d+),(\d+)}/) {
                    if($1 eq $2) {
                        gen_chunk("nargs=$1, ");
                    } else {
                        gen_chunk("nargs='+', ");
                    }
                } elsif($ValClass[$i+3] eq 'a') {
                    gen_chunk("action='append', ");
                } elsif($op eq ':') {
                    gen_chunk("nargs='?', const=$const, default=$dest, ");
                }
            }
            if($op eq '+') {
                gen_chunk("action='count', default=0)");
            }
            if($op eq '!' || $op eq '') {
                gen_chunk("action='store_true', default=bool($dest))");
                gen_statement();
            }
            if($op eq '!') {
                gen_chunk("$ARG_PARSER.add_argument(");
                foreach my $key (@$keys) {
                    next if(length($key) == 2);         # skip single flags
                    gen_chunk('"--no'.substr($key,2)."\", action='store_false', dest=\"".substr($key,2).'")');
                }
            } elsif($op ne '') {
                $Perlscan::PythonCode[-1] =~ s/, $/)/;           # Change the trailing ', ' to a ')'
            #} elsif($op ne '' && $op ne '+') {
                #gen_chunk("default=bool($dest))");
            }
            gen_statement();
        }
        gen_statement("(${ARG_PARSER}_res, ${ARG_PARSER}_rem) = $ARG_PARSER.parse_known_args()");
        gen_statement("${ARG_PARSER}_opts=vars(${ARG_PARSER}_res)");
        for(my $i = $start; $i <= $end_pos; $i+=5) {
            $dest = $ValPy[$i+3];
            my ($keys, $op, $typ, $arr) = GetOptions_split($ValPerl[$i]);
            my $key = @$keys[0];
            $key =~ s/^[-]+//;
            gen_statement("$dest = ${ARG_PARSER}_opts.get(\"$key\", $dest)");
        }
        # issue 24 gen_statement("sys.argv[1:] = $PERL_ARG_ARRAY = ${ARG_PARSER}_rem");
        gen_statement("sys.argv[1:] = ${ARG_PARSER}_rem");      # issue 24
    }
}


sub open_fun
#
# Process Perl open statement
# assents three parameters
#   start --  Starting postion
#   limit --  End position
#   mode  -- 's' or 'f' statement or invocation in expression, or 'c' if it's an "if not open"
{
my ($start,$limit,$mode)=@_;
my $end_pos=($ValPerl[$start+1] eq '(') ? matching_br($start+1)-1 : $limit;
my($k,$myline, $target,$open_mode,$handle);
    #  open (SYSFORM,'>',$output_file ) || abend(__LINE__,"Cannot open file $output_file for");
   $k=($ValPerl[$start+1] eq '(') ? $start+2: $start+1;
   $handle=$ValPy[$k];
   unless( $ValClass[$k] =~ /[is]/ ){
      logme('W',"In open statement handle $ValPerl[$k] is not identifier or scalar variable. Translation might be incorrect");
   }
   $Constants{$handle} = 1 if $ValClass[$k] eq 'i';             # issue 13
   my $encoding = '';                   # SNOOPYJC
   my $errors = '';                     # SNOOPYJC
   my $dup = '';                        # SNOOPYJC
   $target = undef;                     # SNOOPYJC
   my $variable_mode = '';
   $k+=2 if(  $ValPerl[$k+1] eq ',');
   # SNOOPYJC if( $ValClass[$k] eq '"' && ($k+1) <= $#ValClass && $ValClass[$k+1] eq ',' ){
   if( ($k+1) <= $#ValClass && $ValClass[$k+1] eq ',' ){
      if($ValClass[$k] eq '"') {
        # this is the second argument like in open(FILE,'>',$path);
        $open_mode=$ValPerl[$k]; # constant without quotes
        if(substr($open_mode,-1,1) eq '&') {    # SNOOPYJC: dup
            $dup = '&';                         # SNOOPYJC: dup
            substr($open_mode,-1,1) = '';       # SNOOPYJC: dup
        }
      } elsif($ValClass[$k] eq 's') {           # SNOOPYJC: Variable
        $open_mode = undef;                     # SNOOPYJC
        $variable_mode=$ValPy[$k];              # SNOOPYJC
      } else {                                  # SNOOPYJC
          return -1;                            # SNOOPYJC
      }                                         # SNOOPYJC
      $k+=2;
      if( $ValClass[$k] eq '"' || $ValClass[$k] eq 's' ){
          $target=$ValPy[$k];
      } elsif($ValClass[$k] eq 'i' && $LocalSub{$ValPy[$k]}) {
          $target=escape_keywords($ValPy[$k]).'()';             # SNOOPYJC
      }
   }elsif( $ValClass[$k] eq '"'  ){
      # ValPerl does not preserve quotes
      # SNOOPYJC if( $ValPy[$k]=~/^(f?['"])([<->])+/ ){
      if( $ValPy[$k]=~/^(f?['"]+)\s*([<>+|-]*)([&]?)\s*(.*?)\s*([|]?)\s*(['"]+)$/) {        # SNOOPYJC
         $str_open=$1;          # SNOOPYJC
         $open_mode=$2;         # SNOOPYJC
         $dup=$3;               # SNOOPYJC
         $file=$4;              # SNOOPYJC
         $pipe=$5;              # SNOOPYJC
         $str_close=$6;         # SNOOPYJC
         if($open_mode eq '<-') {               # SNOOPYJC
             $target = "sys.stdin";
             $open_mode = undef;
         } elsif($open_mode eq '->') {
             $target = "sys.stdout";
             $open_mode = undef;
         } else {
             $target = $str_open.$file.$str_close;
         }
         if($pipe) {
             $open_mode = '-|';
         }
         # SNOOPYJC substr($ValPy[$k],length($1),1)='';
         # SNOOPYJC $target=$ValPy[$k];
      }
      if(defined $open_mode && $open_mode eq '' && $ValPy[$k] =~ /^['"]/) {   # SNOOPYJC: Not an 'f' string
         # implicit filemode
         $open_mode='<';
         $target=$ValPy[$k];
      }
   }elsif( $ValClass[$k] eq 's' ){
      # implicit filemode
      # issue 26 $open_mode='>';
      $open_mode=undef;		# issue 26
      if($k == $end_pos) {      # SNOOPYJC: Simple variable
          $target=$ValPy[$k];
      } else {                  # SNOOPYJC: Expression for target
          $target = undef;
      }
   }elsif( $ValClass[$k] eq 'i' && $LocalSub{$ValPy[$k]}) {
      $open_mode=undef;		# issue 26
      $target=escape_keywords($ValPy[$k]).'()';         # SNOOPYJC
   }
   # SNOOPYJC if ($target eq '-' ) {
   # SNOOPYJC    $target='sys.argv[1]';
   # SNOOPYJC }
   if (defined $open_mode) {              # SNOOPYJC
       if(index($open_mode, ':') >= 0) {
           ($open_mode, $ext) = split /:/, $open_mode;
           $open_mode .= 'b' if($ext eq 'raw' || $ext eq 'bytes');
           if($ext =~ /encoding\((.*)\)/) {
               $encoding = ", encoding='$1'";
           } elsif($ext eq 'utf8') {
               $encoding = ", encoding='UTF-8'";
               $errors = ", errors='ignore'";
           }
       }
       if (exists($PyOpen{$open_mode}) ){     # SNOOPYJC
          $open_mode=$PyOpen{$open_mode}
       }else{
          logme('E',"The mode '$open_mode' in open statement needs to be manually translated to Python");
          $open_mode = '?';
       }
   }
   my $function = '_open';              # SNOOPYJC
   if(!defined $open_mode) {
      $function = '_open_dynamic';
      $Pyf{'_open'} = 1;
      $Pyf{'_dup'} = 1;
      $open_mode = '';
      $open_mode = ", $variable_mode" if($variable_mode);
   } else {
       $open_mode = ", '$open_mode'";
       if($dup) {
           $function = '_dup';
       }
   }
   $Pyf{$function} = 1;	# SNOOPYJC

   my $orig_mode = $mode;               # SNOOPYJC: Handle complex handle
   if($mode ne 's' && $handle !~ /^[A-Za-z0-9_]+$/) {
       $mode = 's';
       save_code();
   }
   if( $mode eq 'f' ){
     # SNOOPYJC logme('E',"In case of error open function in Python raises the FileNotFoundError exception. The code should be revised");
     # SNOOPYJC gen_chunk("($handle:=open($target,'$open_mode'))");
     if(defined $target) {                              # SNOOPYJC
        gen_chunk("($handle:=", "$function", "($target$open_mode$encoding$errors))");	# SNOOPYJC
     } else {                                           # SNOOPYJC
        gen_chunk("($handle:=", "$function", '(');              # SNOOPYJC
        expression($k,$end_pos,0);                      # SNOOPYJC
        gen_chunk("$open_mode$encoding$errors))");	# SNOOPYJC
     }
     # issue paren return $k+1 if ($ValClass[$k+1] eq ')');
     return $k+1 if ($ValPerl[$start+1] eq '(');
     # issue paren return $k+1;
     return $k;			# issue paren
   }elsif( $mode eq 's' ){
       # SNOOPYJC $k+=2;
      if(defined $target) {                             # SNOOPYJC
         gen_chunk("$handle = ", "$function", "($target$open_mode$encoding$errors, checked=False)");
         gen_statement();
      } else {
         gen_chunk("$handle = ", "$function", '(');
         expression($k,$end_pos,0);                      # SNOOPYJC
         gen_chunk("$open_mode$encoding$errors, checked=False)");
       }
   }elsif( $mode eq 'c' ){                      # Control statement, like if
      if(defined $target) {                     # SNOOPYJC
         gen_chunk("if not ($handle:=", "$function", "($target$open_mode$encoding$errors)):");
         gen_statement();
      } else {
         gen_chunk("if not ($handle:=$function(");
         expression($k,$end_pos,0);                      # SNOOPYJC
         gen_chunk("$open_mode$encoding$errors)):");
      }
      $Perlscan::PREV_HAD_COLON = 1;
   } #if mode
   if($mode ne $orig_mode) {                    # SNOOPYJC: Handle complex handle like sys.stderr that can't appear in a :=
       gen_statement();
       restore_code();
       # issue 26: Since we are using "checked=False", we get back a closed file handle, not a "None"
       if($orig_mode eq 'f') {
           gen_chunk('not', $handle, '.closed');        # issue 26
       } else {
           output_line("if $handle.closed:");           # issue 26
           $Perlscan::PREV_HAD_COLON = 1;
       }
    }
   return $#ValClass;
} # open_fun

sub open_dir
#
# Process Perl opendir statement
# assents thrww parameters
#   start --  Starting postion
#   limit --  End position
#   mode  -- 's' or 'f' statement or invocation in expression, or 'c' for if not opendir
{
my ($start,$limit,$mode)=@_;
my $end_pos=($ValPerl[$start+1] eq '(') ? matching_br($start+1)-1 : $limit;
my($k,$myline, $target,$open_mode,$handle);
    #  open (SYSFORM,'>',$output_file ) || abend(__LINE__,"Cannot open file $output_file for");
   $k=($ValPerl[$start+1] eq '(') ? $start+2: $start+1;
   $handle=$ValPy[$k];
   unless( $ValClass[$k] =~ /[is]/ ){
      logme('W',"In opendir statement handle $ValPerl[$k] is not identifier or scalar variable. Translation might be incorrect");
   }
   $Constants{$handle} = 1 if $ValClass[$k] eq 'i';             # issue 13
   $k+=2 if(  $ValPerl[$k+1] eq ',');
   if( $ValClass[$k] eq 's' ){
      if($k == $end_pos) {      # SNOOPYJC: Simple variable
         $target=$ValPy[$k];
      } else {                  # expression
         $target = undef;
      }
   }elsif( $ValClass[$k] eq 'i' && $LocalSub{$ValPy[$k]}) {
      $target=escape_keywords($ValPy[$k]).'()';         # SNOOPYJC
   }
   $Pyf{'_opendir'} = 1;

   my $orig_mode = $mode;               # SNOOPYJC: Handle complex handle
   if($mode ne 's' && $handle !~ /^[A-Za-z0-9_]+$/) {
       $mode = 's';
       save_code();
   }
   if( $mode eq 'f' ){
     #logme('E',"In case of error open function in Python raises the FileNotFoundError exception. The code should be revised");
     if(defined $target) {
        gen_chunk("($handle:=", '_opendir', "($target))");
     } else {
        gen_chunk("($handle:=", '_opendir', '(');
        expression($k,$end_pos,0);                      # SNOOPYJC
        gen_chunk("))");
     }
     return $k+1 if ($ValClass[$k+1] eq ')');
     return $k;
   }elsif( $mode eq 's' ){
       # SNOOPYJC $k+=2;
       # SNOOPYJC if($autodie) {
      if(1) {           # SNOOPYJC: Our opendir does not normally raise exceptions
         if(defined $target) {
            gen_chunk("$handle = ", '_opendir', "($target)");
            gen_statement();
         } else {
            gen_chunk("$handle = ", '_opendir', '(');
            expression($k,$end_pos,0);                      # SNOOPYJC
            gen_chunk(')');
         }
      } else {
        output_line('try:');
        correct_nest(1,1);
        if(defined $target) {
            gen_chunk("$handle = ", '_opendir', "($target)");
            gen_statement();
        } else {
            gen_chunk("$handle = ", '_opendir', '(');
            expression($k,$end_pos,0);                      # SNOOPYJC
            gen_chunk(')');
            gen_statement();
        }
        correct_nest(-1,-1);
        output_line('except OSError as _e:');
        correct_nest(1,1);
        output_line('pass');
        correct_nest(-1,-1);
      }
   }elsif( $mode eq 'c' ){
       # SNOOPYJC if($autodie) {
      if(1) {           # SNOOPYJC: Our opendir does not normally raise exceptions
        if(defined $target) {
            gen_chunk("if not($handle:=", '_opendir', "($target)):");
            gen_statement();
        } else {
            gen_chunk("if not($handle:=", '_opendir', '(');
            expression($k,$end_pos,0);                      # SNOOPYJC
            gen_chunk(")):");
        }
      } else {
        output_line('try:');
        correct_nest(1,1);
        output_line("$handle = None");
        if(defined $target) {
            gen_chunk("$handle = ", '_opendir', "($target)"); # Opendir statement generation from collected info -- $handle and $target
            gen_statement();
        } else {
            gen_chunk("$handle = ", '_opendir', '(');
            expression($k,$end_pos,0);                      # SNOOPYJC
            gen_chunk(')');
            gen_statement();
        }
        correct_nest(-1,-1);
        output_line('except OSError as _e:');
        correct_nest(1,1);
        output_line('pass');
        correct_nest(-1,-1);
        output_line("if not $handle:");
        $Perlscan::PREV_HAD_COLON = 1;
      }
   } #if ValPerl
   if($mode ne $orig_mode) {            # SNOOPYJC: Handle complex handle like main_.dirh that can't appear in a :=
       gen_statement();
       restore_code();
       if($orig_mode eq 'f') {
           gen_chunk($handle);
       } else {
           output_line("if not $handle:");
           $Perlscan::PREV_HAD_COLON = 1;
       }
    }
    return $#ValClass;
} # open_dir


sub expression
#
# Anything in round brackets, including the list
# Arg1 == (obligatory) starting point
# Arg2 -- limit  -- the last token to scan.
# Arg3 -- mode of operation
#         -1 - Put '' in ValPy for external brackets
#         0 - do not intefere with external blackets
#         1 -preserve round brackets
# Arg 4 -- if given set recursion level to 0
{
my $begin=$_[0];
   unless(defined($begin) ){
      logme('S',"Internal error is expression call -- starting position is not defined while processlike $.: $line" );
      return -255;
   }

my ($bracketed,$cur_pos,$limit,$mode,$split,$start,$prev_k,$end_pos,$pos);
   if( $begin<0 || $TrStatus<0 ){
       $TrStatus=-1; return -255;
   }elsif( $begin>$#ValClass ){
      $cur_pos=$#ValClass;
   }else{
      $cur_pos=$begin;
   }    # issue times
   $start=$cur_pos;  # starting point possibly from && or ||  -- we need that for regular expressions.
   $mode=(scalar(@_)>2) ? $_[2] : 0; # $mode allows brackets to be supressed but only on recursion level 0
                                     # $mode 1 injects ( and ) if they are not present
   $limit=$#ValClass;
   $bracketed=0;
   if( scalar(@_)>1 ){
      $limit=$_[1];
   }elsif( $ValClass[$begin] eq '(' ){
         $limit=matching_br($begin);
         if($limit < 0) { $TrStatus=-1; return -255; }
   # issue 70 }else{
   # issue 70    $limit=$_[1];
   }
   # issue 90 $bracketed=1 if $ValClass[$begin] eq '(';
   $bracketed=1 if $ValClass[$begin] eq '(' && matching_br($begin) == $limit;   # issue 90
   $RecursionLevel++; # we are starting from 0
   if($RecursionLevel > $MAX_DEPTH) {            # SNOOPYJC
        logme("S","INTERNAL ERROR: Exceeded MAX_DEPTH ($MAX_DEPTH) recursion in expression processing!");
        $TrStatus=-1;
        return -255;
   }
   state $nest = 0;
   if($debug >= 3) {
       $nest++;
       print STDERR '>' x $nest;
       say STDERR "expression($begin, $limit, $mode) =|$TokenStr|= @ValPerl\n"
   }

   if($ValClass[$begin] eq '(' && $ValPerl[$begin] eq '(' && matching_br($begin) == $begin+1 &&
       $begin+1 != $#ValClass &&
      ($begin == 0 || $ValClass[$begin-1] !~ /[fi]/)) { # SNOOPYJC: goatse, not sub/function empty args, and not at end
       # Goatse is just used to signal list context, e.g. "my $l = () = localtime();" calls localtime and gives 9, not ctime
       $begin = $cur_pos = $begin+2;
       if($ValClass[$begin] eq '=') {
           $begin = $cur_pos = $begin+1;
       }
       $bracketed=1 if $ValClass[$begin] eq '(' && matching_br($begin) == $limit;   # issue 90
   }

   # issue 53: Change hash references to use ".get(...)" instead of "[...]"
   for(my $i = $begin; $i <= $limit; $i++) {    # issue 53
       if($ValClass[$i] eq '(' && $ValPy[$i] eq '[' && $ValPerl[$i] eq '{') {  # issue 53
           $l = matching_br($i);                        # issue 53
           next if($l < 0);                             # issue 53
           next if(index($TokenStr, '=') > $l);         # issue 53: skip if on lhs of assignment
           if(substr($TokenStr,$i,($l+1)-$i) !~ /[,A]/) {   # issue 53: don't change list or hash constant, issue 93
               $ValPy[$i] = '.get(';                        # issue 53
               $ValPy[$l] = ')';                            # issue 53
           }
           $i = $l;
       }
   }


   #
   # we need tocoorect end_pos in case there is a closing bracket to $limit-1
   #
   $end_pos=$limit;
   if( $mode==1 && $bracketed==0 ){
       gen_chunk('('); # generate opening bracket, as requested
   }elsif( $mode==-1  && $ValClass[$begin]  eq '(' && $ValClass[$limit] eq ')'){
      # eliminate closing bracket
      $ValPy[$limit]='';
      $end_pos=$limit-1;
   }

   $prev_k=-1; # starting position of infinite loop preventor.
   while($cur_pos<=$limit ){
      if( $cur_pos < 0 || $TrStatus<0 ){
         $TrStatus=-1; return -255;
       }
       unless( defined($ValClass[$cur_pos]) ){
         say "Undefined ValClass at pos $cur_pos. Attempting to switch to debug  mode ";
         $DB::single = 1;
      }
      #
      $pos = next_same_level_tokens('o0~,', $cur_pos, $limit);  # issue 101
      if($pos != -1) {                                          # issue 101
         if($ValClass[$pos] eq '~' && $ValPerl[$pos] ne '~') {  # issue 101, SNOOPYJC: Handle ~ operator
            $cur_pos=regex_and_translate($cur_pos,$cur_pos,$pos,$limit); # issue 101, issue 106
            next;                                               # issue 101
         }                                                      # issue 101: do nothing if we hit the 0 (or/and) or comma first
      }                                                         # issue 101
      if( $ValClass[$cur_pos] eq '(' ){
         # generate bracket if mode=1 or recursion level is above zero
         gen_chunk($ValPy[$cur_pos]);
	 # issue 15 $cur_pos=expression($cur_pos+1,$end_pos,0); # preserve brackets
         my $match = matching_br($cur_pos);             # issue paren
         if($match < 0) { $TrStatus=-1; return -255; }
         # SNOOPYJC: Handle [k=>v, ...] and (k=>v, ...) - needs to generate a list, not a hash (note not {...} brackets)
         if($ValPy[$cur_pos] ne '{') {
             for(my $i=$cur_pos+1; $i<$match; $i++) {
                 if($ValClass[$i] eq 'A') {             # issue 93
                     $ValPy[$i] = ',';
                 }
             }
         }
         $cur_pos=expression($cur_pos+1,$match-1,0); # preserve brackets	# issue 15, paren
         ($cur_pos<0) && return -255;
      }elsif(  $ValClass[$cur_pos] eq '<' ){
         gen_chunk('readline()');
         $cur_pos++;
      }elsif( $ValClass[$cur_pos] eq ')' ){
         $RecursionLevel--;
         gen_chunk($ValPy[$cur_pos]);
         # issue paren return $cur_pos+1;
         $cur_pos++;                    # issue paren
      }elsif( $ValClass[$cur_pos] =~ /[0o]/ ) {         # issue 93
         gen_chunk($ValPy[$cur_pos]);
         $start=$cur_pos=$cur_pos+1; # change starting point -- we need that for regular expressions.
       }elsif( $ValClass[$cur_pos] eq 'x' ){
         # execution of Unix uility via shell
         # SNOOPYJC: handle AUTODIE, TRACEBACK gen_chunk(qq{subprocess.run($ValPy[$cur_pos],capture_output=True,text=True,shell=True).stdout});
         $Pyf{_run} = 1;
         gen_chunk('_run', '(', $ValPy[$cur_pos], ')'); # SNOOPYJC:  handle AUTODIE, TRACEBACK
         $cur_pos++;
      }elsif( $ValClass[$cur_pos] =~ /[ahs]/ && $cur_pos+1 < $limit && $ValPy[$cur_pos+1] eq ':=' && $mode != 1 &&
              !(($cur_pos==0 || $ValPy[$cur_pos-1] eq '(') && ($limit+1>$#ValPy || $ValPy[$limit+1] eq ')' ))) {         # issue 93
         $pos = $cur_pos+1;                                     # issue 93: ":=" operators have to be in parens
         $pos = next_lower_or_equal_precedent_token('=', $pos+1, $limit);    # issue 93
         $pos = $limit+1 if($pos<0);                        # issue 93
         $cur_pos=expression($cur_pos, $pos-1, 1);          # issue 93: Add parens to the := operator
         # issue 42  $cur_pos++;
      }elsif( $ValClass[$cur_pos]=~ /[sf]/ ){
         # match in Puthon is library re.match
         # As the argument to =~ can be complex. currently we can transtalte only two simple case: a scalar and an element of array/hash
         $pos=next_same_level_tokens('0o',$cur_pos,$limit); # limit  of search for '~' below    # issue 93
         $end_pos=( $pos>-1 )? $pos : (($bracketed ==1) ? $limit-1 : $limit); # limit scan to next && or ||
         #say STDERR "found s/f at $cur_pos, pos=$pos, end_pos=$end_pos, limit=$limit, bracketed=$bracketed";
         if($cur_pos+1 <= $end_pos && $ValClass[$cur_pos+1] eq '=' &&
            exists $SpecialVarR2L{$ValPy[$cur_pos]}) {
            $ValPy[$cur_pos] = $SpecialVarR2L{$ValPy[$cur_pos]};        # SNOOPYJC: Map _nr() to INPUT_LINE_NUMBER, etc 
         }
         if( $end_pos-$cur_pos>=2 && $ValClass[$cur_pos] eq 's'
             && $ValClass[$cur_pos+1] eq '='  &&  $ValClass[$cur_pos+2] eq 'f' ){
            # can be method like while( $line=shift )
            if(inParens($cur_pos) && $ValPy[$cur_pos+1] eq '=') {            # SNOOPYJC
                gen_chunk($ValPy[$cur_pos], ':=');
            } else {
                gen_chunk($ValPy[$cur_pos],$ValPy[$cur_pos+1]);
            }
            $cur_pos=function($cur_pos+2,$end_pos);
         # issue 90 }elsif( $end_pos-$cur_pos>1 && ($split=index(substr($TokenStr,$cur_pos,$end_pos-$cur_pos+1),'~'))>-1 ){
         }elsif( $end_pos-$cur_pos>1 && ($split=next_same_level_token('~',$cur_pos,$end_pos))>-1 && $split <= $end_pos && $ValPerl[$split] ne '~') {     # issue 90, issue 99, SNOOPYJC: Handle ~ operator
            # REGEX processing $line=~/abc/
            # issue 90 $cur_pos=regex_and_translate($start,$cur_pos,$cur_pos+$split); # split is index from $cur_pos not abs index
            # issue 99 $cur_pos=regex_and_translate($start,$cur_pos,$split); # issue 90
            $cur_pos=regex_and_translate($cur_pos,$cur_pos,$split,$limit); # issue 90, issue 99, issue 106
         }elsif( $ValClass[$cur_pos] eq 'f'){
            $cur_pos=function($cur_pos,$end_pos);
            ($cur_pos<0) && return -255;
         }else{
            gen_chunk($ValPy[$cur_pos]);
            $cur_pos++;
         }
      # issue uninit value }elsif( $cur_pos<$#ValClass && $ValClass[$cur_pos] eq 'i' && $ValClass[$cur_pos+1] eq '(' ){ 
      }elsif( $cur_pos<$#ValClass && $ValClass[$cur_pos] eq 'i' && $ValClass[$cur_pos+1] eq '(' ){ # issue uninit
         $end_pos=matching_br($cur_pos+1); # find balanced bracket for the current bracket
         if($end_pos < 0) { $TrStatus=-1; return -255; }
         if($end_pos+1<=$limit && $ValClass[$end_pos+1] eq '~' && $ValPerl[$end_pos+1] ne '~') {  # issue 99, SNOOPYJC: Handle '~' operator
            $cur_pos=regex_and_translate($cur_pos,$cur_pos,$end_pos+1,$limit);         # issue 99, issue 106
         } else {
             # issue 41 gen_chunk($ValPy[$cur_pos]);
	     &Perlscan::add_package_name_sub($cur_pos);		# SNOOPYJC
             gen_chunk(escape_keywords($ValPy[$cur_pos]));
             if( $LocalSub{$ValPy[$cur_pos]} ){
                # Perl user defined function -- need to pass an array
                gen_chunk('(');         # SNOOPYJC
                # issue parens expression($cur_pos+2,$end_pos-1,0); # call without brackets
                $cur_pos += 2;
                while($cur_pos <= $end_pos-1) {
                    gen_chunk('*') if(need_splat($cur_pos)); # SNOOPYJC
                    my $comma = next_same_level_token(',', $cur_pos, $end_pos-1);
                    if($comma != -1) {
                        expression($cur_pos, $comma, 0);
                        $cur_pos = $comma+1;
                    } else {
                        expression($cur_pos,$end_pos-1,0) if($cur_pos <= $end_pos-1); # call without brackets   # issue paren
                        last;
                    }
                }
                gen_chunk(')');         # SNOOPYJC
                $cur_pos=$end_pos+1;
             }elsif( $ValClass[$cur_pos+2] eq 'f' ){
                #built-in function
                gen_chunk('(');
                # issue paren function($cur_pos+2,$end_pos-1);
                function($cur_pos+2,$end_pos-1) if($cur_pos+2 <= $end_pos-1);       # issue paren
                gen_chunk(')');
             }else{
                #function of unknown origin
                if($cur_pos == 0 || $ValClass[$cur_pos-1] ne 'D') {     # SNOOPYJC: Suppress warning on object methods
                    if(index($ValPy[$cur_pos], '.') < 0) {      # Suppress message on package refs
                        logme("W","Function $ValPy[$cur_pos] is neither internal nor built-in function. Please check the correspondence of arguments");
                    }
                }
                expression($cur_pos+1,$end_pos,1); # preseve brackets
             }
             $cur_pos=$end_pos+1;
         }                                                                      # issue 99
         # SNOOPYJC }elsif($ValClass[$cur_pos] eq 'i' && $ValPy[$cur_pos] eq $ValPerl[$cur_pos] && !inDotOp($cur_pos)) {	# issue 13
      }elsif($ValClass[$cur_pos] eq 'i' && !inDotOp($cur_pos)) {	# issue 13, SNOOPYJC
         $pos=next_same_level_tokens('o0>~)',$cur_pos,$limit);           # issue 13, issue 99
         $end_pos=( $pos>-1 )? $pos-1 : (($bracketed ==1) ? $limit-1 : $limit);      # issue 13: limit scan to next && or ||, issue 99
         if($pos>-1 && $ValClass[$pos] eq '~' && $ValPerl[$pos] ne '~') {    # issue 99, SNOOPYJC: Handle '~' operator
            $cur_pos=regex_and_translate($cur_pos,$cur_pos,$pos,$limit)-1;       # issue 99 (-1 is because we add 1 to it below), issue 106
         } elsif( ($LocalSub{$ValPy[$cur_pos]} || $ValPerl[$cur_pos] =~ /::/) && ($cur_pos+1 > $#ValClass || $ValPerl[$cur_pos+1] ne '=>')){		# issue 13: local sub call with no parens, SNOOPYJC: Handle module call with no parens
            if($cur_pos+1 <= $end_pos && $ValClass[$cur_pos+1] eq 'i' && 
               !$LocalSub{$ValPy[$cur_pos+1]} && !$Constants{$ValPy[$cur_pos+1]}) {    # SNOOPYJC: like new Package()
                gen_chunk($ValPy[$cur_pos+1], '.');
                gen_chunk(escape_keywords($ValPy[$cur_pos]));				# issue 13, issue 41
                $cur_pos++;
                if($cur_pos+1 <= $end_pos && $ValClass[$cur_pos+1] eq '(') {              # SNOOPYJC: eat the parens
                    $bracketed = 1;
                    $limit = matching_br($cur_pos+1);
                    if($limit < 0) { $TrStatus=-1; return -255; }
                    $end_pos = $limit-1;
                    $cur_pos++;
                }
            } else {
                gen_chunk(escape_keywords($ValPy[$cur_pos]));				# issue 13, issue 41
            }
            my $skip_parens = 0;
            $skip_parens = 1 if($cur_pos != 0 && $ValClass[$cur_pos-1] eq '\\');        # SNOOPYJC: Ref to a sub
            gen_chunk('(') if(!$skip_parens);                                           # issue 13, SNOOPYJC
            $k = 0;                                                                     # issue 13
            gen_chunk('*') if(need_splat($cur_pos+1)); # SNOOPYJC
            if($cur_pos+1 <= $end_pos) {
                if(index("^*~/%+-.HI>&|0or?:=,A", $ValClass[$cur_pos+1]) >= 0) {            # SNOOPYJC: If op next, then no args!
                    $end_pos = $cur_pos;
                } else {
                    $k=expression($cur_pos+1, $end_pos, 0);          # issue 13
                    if($k < 0) { $TrStatus=-1; return -255; }                                   # issue 13
                }
            }
            gen_chunk(')') if(!$skip_parens);	        				# issue 13, SNOOPYJC
            $cur_pos = $end_pos;                                                        # issue 13: we add one to it below
            $cur_pos++ if($bracketed == 1);                                             # issue 13
          } elsif ($Constants{$ValPy[$cur_pos]}) {                                      # issue 13: constant or file handle
            gen_chunk($ValPy[$cur_pos]);						# issue 13
          } elsif($cur_pos+1 <= $#ValClass && $ValClass[$cur_pos+1] eq 'i') {           # SNOOPYJC: Like new XXXX
              my $last_i;
              for($last_i = $cur_pos+1; $last_i <= $#ValClass; $last_i++) {
                  last if($ValClass[$last_i] ne 'i' && $ValClass[$last_i] ne 'D');
              }
              $last_i--;
              #say STDERR "last_i = $last_i";
              if($last_i <= $#ValClass && $ValClass[$last_i] eq 'i') {
                  $ValPy[$last_i] .= ".$ValPy[$cur_pos]";                               # SNOOPYJC: Change new XXXX to XXXX.new
              } else {
                  gen_chunk($ValPy[$cur_pos]);
              }
	  } else {									# issue 13: bare word - treat as string
            gen_chunk("'".$ValPy[$cur_pos]."'");					# issue 13
	  }										# issue 13
	  $cur_pos++;									# issue 13
      }elsif($ValClass[$cur_pos] eq 'i' && $cur_pos != 0 && $ValClass[$cur_pos-1] eq 'D' &&
             ($cur_pos+1 > $#ValClass || ($ValClass[$cur_pos+1] ne '(' && $ValClass[$cur_pos+1] ne 'D'))) {  # Method call with no ()
         gen_chunk($ValPy[$cur_pos], '()');
         $cur_pos++;
      }elsif($ValClass[$cur_pos] eq 'r') {		# issue range
         # See if this looks like a slice, then we can implement it
         if(inSubscript($cur_pos)) {                    # issue range/slice
             gen_chunk(':1+');                            # issue range/slice
         } else {
            logme('E',"'..' range operator not implemented outside of for loop");		# issue range
            gen_chunk($ValPy[$cur_pos]);							# issue range
         }
         $cur_pos++;									# issue range
      }elsif($ValClass[$cur_pos] eq '&' && $cur_pos+1 <= $#ValClass &&
             $ValClass[$cur_pos+1] eq 's' &&                           # SNOOPYJC: scalar that contains a subref
             ($cur_pos == 0 || index('difs)',$ValClass[$cur_pos-1])<0)) { # SNOOPYJC: but not a logical '&'
         if($cur_pos+2 > $#ValClass || $ValClass[$cur_pos+2] ne '(') {          # no args
             gen_chunk($ValPy[$cur_pos+1], '(', ')');
             $cur_pos++;
         } else {                               # has args
             ;          # Just ignore the '&'
         }
         $cur_pos++;
      }elsif($ValClass[$cur_pos] eq '+' && ($cur_pos == 0 || $ValClass[$cur_pos-1] eq '(' ||
              ($ValClass[$cur_pos-1] eq 'f' && $ValPy[$cur_pos-1] eq 'print'))) {       # issue unary +
          $cur_pos++;                           # skip it
      }elsif($ValClass[$cur_pos] eq 'k' && $ValPerl[$cur_pos] eq 'sub') {               # issue 81: sub in expression
          gen_chunk('lambda *', $PERL_ARG_ARRAY, ':');     # issue 81
          my $walrus = 0;
          for(my $i = $cur_pos+1; $i <= $limit; $i++) {
              if($ValClass[$i] eq 'f' && $ValPerl[$i] eq 'die') {
                  $Pyf{'_die'} = 1;
                  $ValPy[$i] = '_die';                                  # Can't use "raise" in a lambda
              } elsif($ValClass[$i] eq '=') {
                  $ValPy[$i] = ':=';
                  $walrus = 1;
              #} elsif($ValClass[$i] eq 'i' && $ValPy[$i] eq 'traceback.print_stack' &&
                  #$ValClass[$i+1] eq '(' && $ValClass[$i+2] eq 's') {
                  #$ValPy[$i+2] = 'f';   # Not main.f
              }
          }
          my $s = $cur_pos+1;
          my $end_pos = matching_br($s);
          if($end_pos < 0) { $TrStatus=-1; return -255; }
          my $e = $end_pos-1;
          $e-- if($ValClass[$e] eq ';');
          gen_chunk('(') if($walrus);
          if($s+1 <= $e) {
              $k = expression($s+1, $e, 0);
              if($k < 0) { $TrStatus=-1; return -255; }
          } else {                      # e.g. sub {}
              gen_chunk('None');
          }
          gen_chunk(')') if($walrus);
          $cur_pos = $end_pos+1;
      }elsif($ValClass[$cur_pos] eq 'k' && $cur_pos != 0) {              # SNOOPYJC
          if($ValPerl[$cur_pos] eq 'next' || $ValPerl[$cur_pos] eq 'last') {
              # If we have a next or last in an expression, during the first pass
              # we already marked this loop as to need an exception, so we just
              # need to raise the exception now - we use _raise(...) to do that
              # since we can't emit a raise statement here.
              $Pyf{_raise} = 1;
              if($cur_pos+1 <= $end_pos && $ValClass[$cur_pos+1] eq 'i') {
                  # We have a label
                  my $ex_name = label_exception_name($ValPerl[$cur_pos+1]);
                  gen_chunk('_raise', "($ex_name('$ValPy[$cur_pos]'))");
                  $cur_pos += 2;
              } else {
                  my $ex_name = label_exception_name(undef);
                  gen_chunk('_raise', "($ex_name('$ValPy[$cur_pos]'))");
                  $cur_pos++;
              }
          } elsif($ValPerl[$cur_pos] eq 'return') {
              # Return in an expression
              $Pyf{_raise} = 1;
              if(scalar(@eval_stack) != 0) {            # In an 'eval'
                  if($cur_pos != $end_pos) {            # Not a plain "return"
                      my $lno = $eval_stack[-1]->{lno};
                      gen_chunk('_raise', "($EVAL_RETURN_EXCEPTION($EVAL_RESULT$lno:=");
                      $TrStatus = expression($cur_pos+1, $end_pos, -1);
                      gen_chunk('))');
                      $cur_pos = $end_pos+1;
                  } else {
                      gen_chunk('_raise', "($EVAL_RETURN_EXCEPTION)");
                      $cur_pos++;
                  }
              } else {          # In a sub
                  if($cur_pos != $end_pos) {
                      gen_chunk('_raise', "($FUNCTION_RETURN_EXCEPTION(");
                      $TrStatus = expression($cur_pos+1, $end_pos, -1);
                      gen_chunk('))');
                      $cur_pos = $end_pos+1;
                  } else {
                      gen_chunk('_raise', "($FUNCTION_RETURN_EXCEPTION)");
                      $cur_pos++;
                  }
              }
          } elsif($ValPerl[$cur_pos] eq 'use' || $ValPerl[$cur_pos] eq 'require' || $ValPerl[$cur_pos] eq 'no') {   # SNOOPYJC
              $cur_pos = do_use_require($cur_pos);
          } else {
              $TrStatus = -255;
              $cur_pos++;
          }
      }elsif($ValClass[$cur_pos] eq '=' && $ValPy[$cur_pos] eq '=' && inParens($cur_pos)) {           # issue assign in expr
          gen_chunk(':=');
          $cur_pos++;
      }elsif($ValClass[$cur_pos] eq ',' && $cur_pos == $#ValClass) {    # issue trailing ',' - ignore it!
          $cur_pos++;
      }else{
         gen_chunk($ValPy[$cur_pos]);
         $cur_pos++;
      }
      if( $cur_pos eq $prev_k ){
         logme("S","Internal error -- no progress in scanning expression from position $cur_pos");
         $TrStatus=-1;
         return -255;
      }
      $prev_k=$cur_pos
   }
   # issue 90 if( $mode==1 && $ValClass[$begin] ne '(' ){
   if( $mode==1 && $bracketed == 0){    # issue 90
      #we generated opening bracket, so let's geneerate closing
      gen_chunk(')');
   }
   $RecursionLevel--;
   if($cur_pos > $limit) {              # issue paren
       $cur_pos = $limit;               # issue paren
   }                                    # issue paren
   if($debug >= 3) {
       print STDERR '<' x $nest;
       $nest--;
       say STDERR 'expression returns ' . ($cur_pos+1);
   }
   return $cur_pos+1;
} #expression

sub inDotOp				# issue 13 - check to see if this bare word is involved in a "->" operation
{
    my $pos = shift;
    if($pos != 0) {
	return 1 if($ValClass[$pos-1] eq 'D');
    }
    if($pos != $#ValClass) {
	return 1 if($ValClass[$pos+1] eq 'D');
    }
    return 0;
}

sub inSubscript                            # is this '::' operator in an array subscript?
{
    my $pos = shift;

    my $close_p = next_same_level_token(')', $pos+1, $#ValClass);
    return 0 if($close_p < 0);
    return 0 if($ValPy[$close_p] ne ']');
    my $open_p = reverse_matching_br($close_p);
    return 0 if($open_p < 0);
    return 1 if($open_p < $pos);
    return 0;
}

sub inParens                            # is this '=' operator in a parenthesized expression?
{
    my $pos = shift;

    my $close_p = next_same_level_token(')', $pos+1, $#ValClass);
    return 0 if($close_p < 0);
    my $open_p = reverse_matching_br($close_p);
    return 0 if($open_p < 0);
    return 1 if($open_p < $pos);
    return 0;
}

sub handle_incr_decr                    # issue 74: handle ++ and -- in expressions
{
    my $start = shift;
    my $op_pos = shift;
    my $limit = shift;

    # determine if this is a ++$t or a $t++
    my $op = $ValPerl[$op_pos] eq '++' ? '+' : '-';
    my $rop = $ValPerl[$op_pos] eq '++' ? '-' : '+';
    my $pre_op = 0;
    my $lvalue_start;
    my $lvalue_end;
    if($debug >= 3) {
        print STDERR "handle_incr_decr($start, $op_pos, $limit) with $ValPerl[$op_pos]";
    }
    if($op_pos == 0 && !has_comma_operator($start, $limit)) {
        print "\n" if($debug >= 3);
        return 0;               # we handle this case natively
    } elsif($ValClass[$op_pos-1] eq ';') {              # Like for(...;++i) { }
        print "\n" if($debug >= 3);
        return 0;               # we handle this case natively
    }
    if($op_pos+1 <= $#ValClass && $ValClass[$op_pos+1] eq 's') {
        $pre_op = 1;
        $lvalue_end = $lvalue_start = $op_pos+1;
        while($lvalue_end+1 <= $#ValClass && $ValClass[$lvalue_end+1] eq '(') {  # array sub or hash key
            $lvalue_end = matching_br($lvalue_end+1);
        }
    } elsif($op_pos == 0) {
        replace($op_pos, $op, $op, $op);
        if($debug >= 3) {
            say STDERR "- can't figure it out!";
        }
        return 0;               # Not sure what this is so ignore it
    } else {            # post op
        $lvalue_start = $lvalue_end = $op_pos-1;
        while($ValClass[$lvalue_start] eq ')') {        # Handle $num{$key}{$hour}++;
            $lvalue_start = reverse_matching_br($lvalue_start) - 1;
        }
        if((($lvalue_start == 0 && $lvalue_end == 0) || $ValClass[$lvalue_end-1] eq ';') && # ';' is before 'for' loop incr
           $op_pos == $limit) {
            print "\n" if($debug >= 3);
            return 0;                   # we handle this case natively
        }
    }
    if($debug >= 3) {
        print STDERR ", pre_op=$pre_op, lvalue_start=$lvalue_start, lvalue_end=$lvalue_end";
    }
    $inc = 0;
    if($lvalue_start != 0 && $ValClass[$lvalue_start-1] eq 'i' && $ValClass[$lvalue_start] ne '(' && $LocalSub{$ValPy[$lvalue_start-1]}) {
        # We have a sub call w/o parens here - since we may insert parens after the function reference,
        # we have to surround the entire set of args with parens to make sure we process it right
        $pos=next_same_level_tokens('o0~',$lvalue_start,$limit); 
        $end_pos=( $pos>-1 )? $pos-1 : $limit;
        insert($end_pos+1, ')', ')', ')');
        insert($lvalue_start, '(', '(', '(');
        $inc = 2;
        $limit += 2;
        $op_pos++;
        $lvalue_start++;
        $lvalue_end++;
    }
    if($lvalue_start == $lvalue_end) {          # simple scalar - handle using the walrus operator
	 if($ValPy[$lvalue_start] =~ /^\(len\((.*)\)-1\)$/) { # issue 14 - increment or decrement array length
            $arrName = $1;			# issue 14
            save_code();
	    if($op eq '+') {	                # issue 14: add one element to array
	       gen_chunk("$arrName.append(None)");	# issue 14
	    } else {				# issue 14
	       gen_chunk("del $arrName".'[len('.$arrName.')-1:]');	# issue 14
	    }
            gen_statement();
            restore_code();
            destroy($op_pos, 1);            # remove the ++ or --
            if(!$pre_op) {      # post - need to adjust the value
                $ValPy[$lvalue_start] =~ s/-1\)$/-2\)/;
            }
            if($debug >= 3) {
                say STDERR " = ".(-1+$inc)." now =|$TokenStr|=";
            }
            return -1+$inc;
        }
        if($pre_op) {                       # generate ($val:=$val+1) replacing ++$val
            destroy($op_pos, 1);            # remove the ++ or --
            $lvalue_start--;
            insert($lvalue_start+1, ')', ')', ')');
            insert($lvalue_start+1, 'd', '1', '1');
            insert($lvalue_start+1, $op, $op, $op);
            insert($lvalue_start+1, 's', $ValPerl[$lvalue_start], $ValPy[$lvalue_start]);
            insert($lvalue_start+1, '=', '=', ':=');
            insert($lvalue_start, '(', '(', '(');
            if($debug >= 3) {
                say STDERR " = ".(5+$inc)." now =|$TokenStr|=";
            }
            return 5+$inc;           # how many we inserted
        } else {        # post op: generate (($val:=$val+1)-1) replacing $val++
            destroy($op_pos, 1);            # remove the ++ or --
            insert($lvalue_start+1, ')', ')', ')');
            insert($lvalue_start+1, 'd', '1', '1');
            insert($lvalue_start+1, $rop, $rop, $rop);
            insert($lvalue_start+1, ')', ')', ')');
            insert($lvalue_start+1, 'd', '1', '1');
            insert($lvalue_start+1, $op, $op, $op);
            insert($lvalue_start+1, 's', $ValPerl[$lvalue_start], $ValPy[$lvalue_start]);
            insert($lvalue_start+1, '=', '=', ':=');
            insert($lvalue_start, '(', '(', '(');
            insert($lvalue_start, '(', '(', '(');
            if($debug >= 3) {
                say STDERR " = ".(9+$inc)." now =|$TokenStr|=";
            }
            return 9+$inc;           # how many we inserted
        }
    } else {            # array index or hashref - split it out
        # for pre:
        #   $arr[$ndx] += 1
        #   (... $arr[$ndx] ...)
        # for post:
        #   $arr[$ndx] += 1
        #   (... ($arr[$ndx]-1) ...)
       
        #
        # If we're replacing the entire statement, then just remove all the code since we are generating it
        #
        if($pre_op && $op_pos == 0 && $lvalue_end == $#ValClass) {      # entire line
            destroy($op_pos, 1);            # remove the ++ or --
            append('=', '+=', '+=');
            append('d', '1', '1');
            if($debug >= 3) {
                say STDERR " = ".(2+$inc)." now =|$TokenStr|=";
            }
            return 2+$inc;
        } elsif(!$pre_op && $lvalue_start == 0 && $op_pos == $#ValClass) {      # entire line
            replace($op_pos, '=', "$op=", "$op=");
            append('d', '1', '1');
            if($debug >= 3) {
                say STDERR " = ".(1+$inc)." now =|$TokenStr|=";
            }
            return 1+$inc;
        }
        save_code();
        if($pre_op) {
            insert($lvalue_end+1, '=', "$op= 1", "$op= 1");   # Not actually used but it tells expression() that we're on the LHS
        } else {
            replace($op_pos, '=', "$op= 1", "$op= 1");      # Not actually used but it tells expression() that we're on the LHS
        }
        my $adj = fix_type_issues($lvalue_start, $lvalue_end, undef);
        $lvalue_end += $adj;
        $k = expression($lvalue_start, $lvalue_end, 0);
        if($pre_op) {
            destroy($lvalue_end+1, 1);      # remove the extra '=' we put in
        } else {
            $op_pos += $adj;
        }
        gen_chunk(" $op= 1");            # += 1 or -= 1
        gen_statement();
        restore_code();
        if($debug >= 3) {
            print STDERR " =|$TokenStr|=, op_pos=$op_pos, ";
        }
        destroy($op_pos, 1);            # remove the ++ or --
        if($pre_op) {
            if($debug >= 3) {
                say STDERR " = ". (-1+$inc+$adj)." (arr/hash)"." now =|$TokenStr|=";
            }
            return -1+$inc+$adj;
        } else {                # post op
            insert($lvalue_end+1, ')', ')', ')');
            insert($lvalue_end+1, 'd', '1', '1');
            insert($lvalue_end+1, $rop, $rop, $rop);
            insert($lvalue_start, '(', '(', '(');
            if($debug >= 3) {
                say STDERR " = ".(3+$inc+$adj)." now =|$TokenStr|=";
            }
            return 3+$inc+$adj;
        }
    }
}

sub handle_cmp_spaceship                    # SNOOPYJC: Handle cmp and <=> operators
{
    my $start = shift;
    my $op_pos = shift;
    my $limit = shift;

    # Replace a cmp b with _cmp(a,b)
    # Replace a <=> b with _spaceship(a,b)
    # We determine where to stop by looking at the operator precidence chart here: https://perldoc.perl.org/perlop

    my ($a_start, $a_end, $b_start, $b_end);
    $a_end = $op_pos-1;
    for($a_start=$a_end; $a_start >= $start; $a_start--) {
        if($ValClass[$a_start] eq ')') {
            $a_start = reverse_matching_br($a_start);
        } elsif(index('&|^o0r:A?=,n(', $ValClass[$a_start]) >= 0) {
            last;
        }
    }
    $a_start++;
    $b_start = $op_pos+1;
    for($b_end=$b_start; $b_end <= $limit; $b_end++) {
        if($ValClass[$b_end] eq '(') {
            $b_end = matching_br($b_end);
        } elsif(index('&|^o0r:A?=,n)', $ValClass[$b_end]) >= 0) {
            last;
        }
    }
    $b_end--;
    insert($b_end+1, ')', ')', ')');
    my $pl = $ValPerl[$op_pos];
    my $py = $ValPy[$op_pos];
    replace($op_pos, ',', ',', ',');
    insert($a_start, '(', '(', '(');
    insert($a_start, 'f', $pl, $py);
    $Pyf{$py} = 1;      # Causes it to load the function from our library into the generated code
    if($debug >= 3) {
        say STDERR "handle_cmp_spaceship($start, $op_pos, $limit): a[$a_start:$a_end], b[$b_start:$b_end] = 3 (=|$TokenStr|=)";
    }
    return 3;           # How many things we added
}

sub handle_question_mark_colon                    # issue 52 handle ? : in expressions
{
    my $start = shift;
    my $q_pos = shift;
    my $limit = shift;
    # cond ? tval : fval
    my $c_pos = next_same_level_token(':', $q_pos+1, $limit);
    return -1 if($c_pos < 0);
    my $fval_start = $c_pos+1;
    #my $fval_end = next_same_level_tokens(',:!)', $fval_start+1, $limit)-1;
    my $tval_start = $q_pos+1;
    my $tval_end = $c_pos-1;
    my $cond_start = $start;
    my $cond_end = $q_pos-1;
    
    for($cond_start = $cond_end; $cond_start >= $start; $cond_start--) {
        if($ValClass[$cond_start] eq ')') {
            $cond_start = reverse_matching_br($cond_start);
        } elsif(index("(=,:kc", $ValClass[$cond_start]) >= 0) {
            last;
        }
    }
    $cond_start++;
    if($debug >= 3) {
        say STDERR "handle_question_mark_colon($start, $q_pos, $limit) cond=[$cond_start:$cond_end], fval=[$fval_start:], tval=[$tval_start:$tval_end]";
    }

    # we need to generate this code:
    #
    # tval if cond else fval
    replace($c_pos, ':', ':', 'else');
    for(my $i = $cond_end; $i >= $cond_start; $i--) {
        insert($c_pos, $ValClass[$i], $ValPerl[$i], $ValPy[$i]);
    }
    # now we have: cond ? tval cond else fval
    insert($tval_end+1, ':', '?', 'if');        # Needs to be an op with the same precedence, but not '?'
    # now we have: cond ? tval if cond else fval
    destroy($cond_start, $cond_end-$cond_start+2);
    # now we have: tval if cond else fval
    if($debug >= 3) {
        say STDERR "after handle_question_mark_colon: =|$TokenStr|=";
    }
    return 0;           # we have the same number of tokens as before
}

sub handle_negative_bareword                    # issue 88
{
    # given a -bareword, remove the - and put it in the bareword
    # arg = position of the '-'
    my $pos = shift;

    $ValPerl[$pos+1] = '-'.$ValPerl[$pos+1];
    $ValPy[$pos+1] = '-'.$ValPy[$pos+1];
    destroy($pos, 1);
    return -1;
}

sub start_of_var
# Get the start of this lvalue
{
    my $end_pos = shift;

    while($ValClass[$end_pos] eq ')' && ($ValPerl[$end_pos] eq ']' || $ValPerl[$end_pos] eq '}')) {
        $end_pos = reverse_matching_br($end_pos) - 1;
        return 0 if($end_pos < 0);
    }
    if($ValClass[$end_pos] eq 'D') {            # $s->[...]
        return $end_pos-1;
    }
    while($ValClass[$end_pos] eq 'i' && ($end_pos-2 >= 0 && $ValClass[$end_pos-1] eq 'D')) {
        $end_pos -= 2;
    }
    return $end_pos;
}

sub fixup_read_in_expression                              # SNOOPYJC
# Remove 0 offsets from read operations and add the length calculation
{
    my $pos = shift;

    # read FH,scalar,length,offset
    # read FH,scalar,length
    return 0 if($pos == 0);               # Nothing to do if this is a read statement
    my $begin = $pos;
    my $limit = $#ValClass;
    return 0 if(substr($ValPerl[$begin],0,1) eq '.');   # We were already here
    my $readf = "_read";
    $readf = "_sysread" if($ValPerl[$begin] eq 'sysread');
    $pos++;     # Point to FH
    my $bracketed = 0;
    if($pos <= $#ValClass && $ValClass[$pos] eq '(') {    # Skip any '('
        $limit = matching_br($pos) -1;
        return 0 if($limit < 0);
        $pos++;
        $bracketed = 1;
    }
    my $fh0 = $pos;
    my $comma = next_same_level_token(',', $pos, $limit);
    return 0 if($comma < 0);
    my $fh1 = $comma-1;
    my $sc0 = $comma+1;
    $comma = next_same_level_token(',', $sc0, $limit);
    return 0 if($comma < 0);
    my $sc1 = $comma-1;
    my $ln0 = $comma+1;
    $comma = next_same_level_token(',', $ln0, $limit);
    my $ln1 = $comma-1;
    my ($of0, $of1);
    if($comma < 0) {
        if(!$bracketed) {
            my $lower = next_lower_or_equal_precedent_token('F', $comma+1, $limit);
            $limit = $lower-1 if($lower != -1);
        }
        $ln1 = $limit;
        $of0 = undef;
    } else {
        $of0 = $comma+1;
        $of1 = $limit;
    }
    my $adjust = 0;
    if(defined $of0 && $ValClass[$of0] eq 'd' && $ValPy[$of0] eq '0') {
        destroy($of0-1, 2);
        $adjust = -2;
        $limit -= 2;
        $of0 = undef;
    }
# 
# Change read(fh,scalar,length) -to- ((scalar:=(_s:=_read(fh,length,need_len=True))[0]),_s[1])[1]
# Change read(fh,scalar,length,offset) -to- ((scalar:=(_s:=_read(fh,length,scalar,offset,need_len=True))[0]),_s[1])[1]
#        ^begin  ^sc0   ^ln0   ^of0 ^limit
#             ^fh0    ^sc1   ^ln1   ^of1

    my $read = $begin;
    if(!$bracketed) {
        insert($limit+1,')',')',')');
        insert($sc0,'(','(','(');
        $limit += 2;
        $adjust += 2;
        $fh0++;
        $fh1++;
        $sc0++;
        $sc1++;
        $ln0++;
        $ln1++;
        if(defined $of0) {
            $of0++;
            $of1++;
        }
    }
    $Pyf{$readf} = 1;
    replace($read,'f',$readf,$readf);
    my $j = 2;
    insert($limit+$j++,')',')',')');
    insert($limit+$j++,'y','','[0]');
    insert($limit+$j++,')',')',')');
    insert($limit+$j++,',',',',',');
    insert($limit+$j++,'y','',"$SUBSCRIPT_TEMP".'[1]');
    insert($limit+$j++,')',')',')');
    insert($limit+$j,'y','','[1]');
    $adjust += $j-2;
    insert($limit+1,'y','','need_len=True');
    insert($limit+1,',',',',',');
    $adjust += 2;
    $limit += 2;
    say STDERR "Read: after inserting end stuff =|$TokenStr|= ValPy=@ValPy, read=$read, limit=$limit, adjust=$adjust" if($debug >= 3);
    insert($read,'=','=',':=');
    insert($read,'s','$'.$SUBSCRIPT_TEMP,$SUBSCRIPT_TEMP);
    insert($read,'(','(','(');
    insert($read,'=','=',':=');
    my $here = $read;
    $read += 4;
    $fh0 += 4;
    $fh1 += 4;
    $sc0 += 4;
    $sc1 += 4;
    $ln0 += 4;
    $ln1 += 4;
    $adjust += 4;
    if(defined $of0) {
        $of0 += 4;
        $of1 += 4;
    }
    $j = 0;
    for(my $i = $sc0; $i <= $sc1; $i++) {
        insert($here+$j++, $ValClass[$i], $ValPerl[$i], $ValPy[$i]);
        $i++;
        $sc1++;
    }
    insert($here,'(','(','(');
    insert($here,'(','(','(');
    $read += $j+2;
    $fh0 += $j+2;
    $fh1 += $j+2;
    $sc0 += $j+2;
    $sc1 += 2;
    $ln0 += $j+2;
    $ln1 += $j+2;
    $adjust += $j+2;
    if(defined $of0) {
        $of0 += $j+2;
        $of1 += $j+2;
    }
    say STDERR "Read: completed =|$TokenStr|= ValPy=@ValPy, adjust=$adjust" if($debug >= 3);
    return $adjust;
}

sub split_up_multiple_assignment                # issue 115
# issue 115: Split up multiple assignment of the form %h1 = %h2 = ();
# or complex cases like ($k, $v) = %h1 = %h2 = @a1 = @a2 = ('key', 'value');
# We don't do anything on cases we already handle like $v1 = $v2 = value;  @a1 = @a2 = value; *G1 = *G1 = value;
# Return packaged code for what to generate next.
{
    my $test_only = $_[0] if(scalar(@_) > 0);   # Don't do any conversion, just test if we will

    return undef if($ValClass[0] eq 't');       # Only handles global vars, no 'my', etc.
    my $eq1 = next_same_level_tokens('=o0,', 0, $#ValClass);
    return undef if($eq1 < 0 || $ValClass[$eq1] ne '=');
    my $eq2 = next_same_level_tokens('=o0,', $eq1+1, $#ValClass);
    return undef if($eq2 < 0 || $ValClass[$eq2] ne '=');
    # Find the last '=' and remember the one before that
    my $prev_eq = $eq1;
    my $last_eq = $eq2;
    my $eqn;
    while(1) {
        $eqn = next_same_level_tokens('=o0,', $last_eq+1, $#ValClass);
        last if($eqn < 0 || $ValClass[$eqn] ne '=');
        $prev_eq = $last_eq;
        $last_eq = $eqn;
    }
    return undef if($eqn >= 0 && $ValClass[$eqn] ne '=');
    # See if it's something we handle elsewhere, namely ValClass all 's', all 'a' or all 'G' or goatse
    my $type = undef;
    my $yup = 1;
    for(my $i = 0; $i < $last_eq; $i+=2) {
        if($ValClass[$i] =~ /[asG]/ && $ValClass[$i+1] eq '=') {
            if(!defined $type) {
                $type = $ValClass[$i];
            } elsif($type ne $ValClass[$i]) {
                $yup = 0;
                last;
            }
        } elsif($ValClass[$i] eq '(' && $ValClass[$i+1] eq ')' && $ValClass[$i+2] eq '=') {     # goatse
            $i++;
        } else {
            $yup = 0;
            last;
        }
    }
    if($yup || $TokenStr =~ /=\(\)=/) {
        say STDERR "split_up_multiple_assignment($TokenStr) = undef, last_eq=$last_eq" if($debug);
        return undef;
    }
    return 1 if($test_only);

    # Ok we have a case like ($k, $v) = %h1 = %h2 = @a1 = @a2 = ('key', 'value');
    # or probably something simpler.  Using this as an example we would generate:
    #     @a2 = ('key', 'value');
    # and return packaged code of:
    #     ($k, $v) = %h1 = %h2 = @a1 = @a2

    $result = package_code();
    destroy(0, $prev_eq+1);     # Leaves us with "@a2 = ('key', 'value')" in our example
    p_destroy($result, $last_eq, (scalar(@{$result->{class}})-$last_eq)); # ($k, $v) = %h1 = %h2 = @a1 = @a2
    my $PkgTokenStr = join('', @{$result->{class}});
    say STDERR "split_up_multiple_assignment gives =|$TokenStr|= and packages =|$PkgTokenStr|= for next time" if($debug);
    return $result;
}

sub add_parens
# Helper for handle_assignment_in_expression
{
    my ($start, $pos, $end_pos, $adjust) = @_;

    if($start == 0 || $ValClass[$start-1] ne '(' || $ValPerl[$start-1] ne '(' || 
        $ValClass[$end_pos+1] ne ')' || $ValPerl[$end_pos+1] ne ')') {     # All := operations must be in '(' ')'
        insert($start, '(', '(', '(');
        $pos++;
        $end_pos++;
        $start++;
        insert($end_pos+1, ')', ')', ')');
        $adjust += 2;
    }
    return ($start, $pos, $end_pos, $adjust);
}

sub has_comma_operator
# Does this expressions have a comma operator at the current level?
{
    my $start = shift;
    my $end = shift;

    my $pos = next_same_level_tokens('if,',$start,$end);
    return 0 if($pos < 0);
    while($ValClass[$pos] ne ',' && $pos+1 <= $#ValClass && $ValClass[$pos+1] eq '(') {
        # Skip any function/sub calls with parens
        $pos = matching_br($pos+1);
        return 0 if($pos < 0);
        $pos = next_same_level_tokens('if,',$pos+1,$end);
        return 0 if($pos < 0);
    }
    return ($pos > 0 && $ValClass[$pos] eq ',');
}

sub handle_assignment_in_expression
{
    # Fixup any assignment operation that's not in a place we can handle
    # arg = position of the '=' or '=~'
    my $pos = shift;

    return 0 if($pos == 1 && $ValClass[0] =~ /[ashG]/ && !has_comma_operator(2,$#ValClass));    # $a = expr
    return 0 if($pos == 2 && $ValClass[0] eq 't' && $ValClass[1] =~ /[ashG]/ && !has_comma_operator(3,$#ValClass));    # my $a = expr;
    return 0 if($pos >= 3 && $ValClass[$pos-1] eq ')' && reverse_matching_br($pos-1) == 0);     # (...) = expr;
    return 0 if($pos >= 4 && $ValClass[$pos-1] eq ')' && reverse_matching_br($pos-1) == 1 && $ValClass[0] eq 't');     # my (.,.) = expr;
    return 0 if($ValClass[0] eq 's' && next_same_level_token('=', 0, $#ValClass) == $pos &&
                !has_comma_operator($pos+1,$#ValClass));                   # $a{...}[...] = expr;
    return 0 if($ValClass[0] eq 'c' && ($ValPerl[0] eq 'for' || $ValPerl[0] eq 'foreach') && index($TokenStr, ';') > 0);      # for(...;...;...)
    return 0 if($ValClass[0] eq 'f' && ($ValPerl[0] eq 'chomp' || $ValPerl[0] eq 'chop'));      # chomp($x = ...);
    return 0 if($ValClass[0] eq '(' && $ValClass[-1] eq ')' && next_same_level_token('=', 1, $#ValClass-1) == $pos &&
                !has_comma_operator($pos+1, $#ValClass-1));                        # ($a = 1) if...
    return 0 if($ValClass[$pos] eq '~' && $ValPerl[$pos] eq '~');       # Complement, not a regex
    return 0 if($ValClass[$pos] eq '~' && ($pos+1 > $#ValClass || $ValClass[$pos+1] ne 'f' || ($ValPerl[$pos+1] ne 're' && $ValPerl[$pos+1] ne 'tr')));
    return 0 if($pos >= 5 && $ValClass[0] eq 't' && $ValClass[1] eq 's' && $ValClass[2] eq '(' && end_of_variable(1)+1 == $pos);
    my $p = 0;
    $p = 1 if($ValClass[0] eq 't');
    if($ValClass[$p] =~ /[ashG]/ && $ValClass[$pos] eq '=' && !has_comma_operator($pos+1,$#ValClass)) { # See if this is @a=@b=@c
        my $yup = 1;
        for(my $i = $p; $i <= $pos; $i += 2) {
            if($ValClass[$i] !~ /[ashG]/ || $ValClass[$i+1] ne '=') {
                $yup = 0;
                last;
            }
        }
        return 0 if($yup);                                                                      # @a=@b=...
    }
    return 0 if(split_up_multiple_assignment(1));       # issue 115: Don't change it if we're gonna split it up
    my $start = start_of_var($pos-1);
    return 0 if($start < 0);                    # Not sure what this is
    return 0 if($ValClass[$start] !~ /[ashG]/); # Not something we handle
    my $end_pos = $#ValClass;
    $end_pos = matching_br($start-1)-1 if($start != 0 && $ValClass[$start-1] eq '(');
    my $lower = next_lower_or_equal_precedent_token($ValClass[$pos], $pos+1, $end_pos);
    $end_pos = $lower-1 if($lower >= 0);
    my $close = next_same_level_tokens(');', $pos+1, $end_pos);
    $end_pos = $close-1 if($close >= $pos && $close <= $end_pos);
    #say STDERR "pos=$pos, lower=$lower, close=$close, end_pos=$end_pos, \$#ValClass=$#ValClass" if($debug >= 5);
    my $adjust = 0;
    my $op;
    #if($start == 0 || $ValClass[$start-1] ne '(' || $ValClass[$end_pos+1] ne ')') {     # All := operations must be in '(' ')'
    #insert($start, '(', '(', '(');
    #$pos++;
    #$end_pos++;
    #$start++;
    #insert($end_pos+1, ')', ')', ')');
    #$adjust += 2;
    #}
    while($ValClass[$start+1] eq 'D' && $ValClass[$start+2] eq 'i') {       #  $obj->var, change to obj.var
        $ValPerl[$start] .= '->' . $ValPerl[$start+2];
        $ValPy[$start] .= '.' . $ValPy[$start+2];
        destroy($start+2, 2);
        $adjust -= 2;
    }
    if($ValClass[$start] =~ /[ashG]/ && $pos-$start == 1) {         # Something we can easily handle
        if($ValPy[$pos] eq '=') {
            ($start, $pos, $end_pos, $adjust) = add_parens($start, $pos, $end_pos, $adjust);
            $ValPy[$pos] = ':=';
        }
        if($ValClass[$pos] eq '=' && $ValPy[$pos] ne ':='){               # '+=' and friends
            ($start, $pos, $end_pos, $adjust) = add_parens($start, $pos, $end_pos, $adjust);
            $op = substr($ValPy[$pos],0,1);     # '+', etc
            insert($pos+1, $op, $op, $op);
            insert($pos+1, $ValClass[$start], $ValPerl[$start], $ValPy[$start]);
            $ValPy[$pos] = ':=';
            $ValPerl[$pos] = '=';
            $adjust += 2;
            $end_pos += 2;
        }
        if(index($ValPy[$start], '.') >= 0) {   # a.b := ..., change to _assign_global('a', 'b', ...)
            ($start, $pos, $end_pos, $adjust) = add_parens($start, $pos, $end_pos, $adjust);
            my $dot = rindex($ValPy[$start], '.');
            my $a = substr($ValPy[$start], 0, $dot);
            my $b = substr($ValPy[$start], $dot+1);
            $op = $ValClass[$pos];
            replace($start, '"', $ValPerl[$start], "'$a'");
            replace($pos, ',', ',', ',');
            insert($pos, '"', $b, "'$b'");
            insert($pos, ',', ',', ',');
            my $func = '_assign_global';
            if($op eq '~') {            # Regex
                if($ValPerl[$pos+3] eq 're') {
                    $func = '_substitute_global';
                    my $flags = process_re_flags($pos+3);
                    $ValPy[$pos+3] =~ s/^re\.sub\(//;
                    $ValPy[$pos+3] = $ValPy[$pos+3] . $flags;
                } else {
                    $func = '_translate_global';
                    $ValPy[$pos+3] = 'str' . tr_flags_to_args($ValPy[$pos+3]);
                }
                $ValClass[$pos+3] = 'y';        # Plain python code
            }
            insert($start-1, 'f', $func, $func);
            $Pyf{$func} = 1;
            $adjust += 3;
        }
    } elsif($ValClass[$pos-1] eq ')' && ($ValPerl[$pos-1] eq '}' || $ValPerl[$pos-1] eq ']')) {  # $a[...]{N} := ..., change to _set_element($a[...], N, ...)
        ($start, $pos, $end_pos, $adjust) = add_parens($start, $pos, $end_pos, $adjust);
        my $rev = reverse_matching_br($pos-1);
        return $adjust if($rev < 0);
        if($ValClass[$pos] eq '=') {
            $op = substr($ValPerl[$pos],0,length($ValPerl[$pos])-1);     # '+', '<<', etc
            $op = '' if($op eq '=' || $op eq ':');
            return $adjust if(!exists $ARRAY_INDEX_FUNCS{$op});
        } else {
            if($ValPerl[$pos+1] eq 'tr') {
                $op = '~tr';
                $ValPy[$pos+1] = 'str' . tr_flags_to_args($ValPy[$pos+1]);
                $ValClass[$pos+1] = 'y';        # Plain python code
            } else {
                $op = '~re';
                $ValClass[$pos+1] = 'y';        # Plain python code
                my $j = 2;
                my $flags = process_re_flags($pos+1);
                $ValPy[$pos+1] =~ s/^re\.sub\(//;
                insert($pos+$j++, 'y', '', $flags);
                $adjust++;
                #insert($pos+$j, ')', ')', ')');
                #$adjust++;
            }
        }
        my $func = $ARRAY_INDEX_FUNCS{$op};
        $Pyf{$func} = 1;
        replace($pos, ',', ',', ',');
        insert($rev, ',', ',', ',');
        destroy($pos,1);                # Eat the '}'
        destroy($rev+1,1);              # Eat the '{'
        insert($start-1, 'f', $func, $func);
    }
    say STDERR "After handle_assignment_in_expression($pos): =|$TokenStr|=, ValPy=@ValPy, adjust=$adjust" if($debug);
    return $adjust;
}

sub handle_eval_in_expression                   # issue 42
# If this expression has an eval in it, then generate the code for it first
{
    my $pos = shift;		# Point to the eval

    # Return in the only cases we handle already
    return 0 if($pos == 0 && ($#ValClass == 0 || $ValClass[1] eq '('));
    return 0 if($pos == 2 && $ValClass[0] eq 's' && $ValClass[1] eq '=');
    return 0 if($pos == 3 && $ValClass[0] eq 't' && $ValClass[1] eq 's' && $ValClass[2] eq '=');
    if($saved_eval_tokens) {
        logme('S', "Only 1 eval expression per line handled");
    }
    my $need_result = ($pos != 0);
    my $result = "$EVAL_RESULT$.";
    #
    # We save the original tokens, then change the current line to something we can handle, which is a simple
    # _eval_resultLNO = eval {...}
    # then replace the eval in the original tokens with the _eval_resultLNO.
    #
    $saved_eval_tokens = package_code();
    $saved_eval_lno = $.;
    my $t;
    my @tmpBuffer = @Perlscan::BufferValClass;      # SNOOPYJC: Skip the block on getting the next line
    @Perlscan::BufferValClass = ();
    while(($t = getline())) {
        push @saved_eval_buffer, $t;
        say STDERR "pushed $t onto saved_eval_buffer" if($debug >= 5);
    }
    @Perlscan::BufferValClass = @tmpBuffer;
    if($pos == 0) {     # We don't need the result
        p_replace($saved_eval_tokens, $pos, 'C', 'nop', '');            # Make it a no-op
    } else {
        p_replace($saved_eval_tokens, $pos, 's', '$'.$result, $result);
    }
    my $adjust = 0;
    if($ValClass[$pos+1] eq '"') {      # String or here doc string
        my $fc;
        if(($fc = substr($ValPy[$pos+1],0,1)) ne "'" && $fc ne '"') {
            logme('S', "eval with interpolated string not handled!");
        }
        p_destroy($saved_eval_tokens, $pos+1, 1);
        my $text;
        if(substr($ValPy[$pos+1],0,3) eq '"""') {
            $text = substr($ValPy[$pos+1],3,length($ValPy[$pos+1])-6);
        } else {
            $text = substr($ValPy[$pos+1], 1, length($ValPy[$pos+1])-2);
        }
        my @lines = split(/^/m, $text);
        getline('{');           # Push to regular buffer (helps us count lines easier)
        for my $ln (@lines) {
            #say STDERR "Pushing " . substr($ln,0,length($ln)-1);
            getline($ln,1);     # Push to special_buffer
        }
        getline('}',1);         # Push to special_buffer
        $adjust = $pos-$#ValClass;
        destroy($pos+1, $#ValClass-$pos);
    } elsif($ValClass[$pos+1] eq '(') {
        my $close = matching_br($pos+1);
        return 0 if($close < 0);
        $adjust = $close-$#ValClass;
        destroy($close+1, $#ValClass-$close) if($close != $#ValClass);
        p_destroy($saved_eval_tokens, $pos+1, $close-$pos);     # Remove the {...}
    } else {
        $end_pos = $#ValClass;
        my $close = next_same_level_token(')', $pos+1, $end_pos);
        $end_pos = $close-1 if($close > 0);
        $adjust = $end_pos-$#ValClass;
        destroy($end_pos+1, $#ValClass-$end_pos) if($end_pos != $#ValClass);
        p_destroy($saved_eval_tokens, $pos+1, $end_pos-$pos);
    }
    if($pos == 0) {     # We don't need the result
        ;
    } else {            # we need the result
        insert($pos, '=', '=', '=');
        destroy(0, $pos) if($pos != 0);
        insert(0, 's', '$'.$result, $result);
        $adjust += 2-$pos;
    }
    say STDERR "handle_eval_in_expression gives =|$TokenStr|=, adjust=$adjust, ValPy=@ValPy" if($debug);
    return $adjust;
}

sub tr_flags_to_args
# Convert flags on 'tr' to appropriate args for the handlers _translate_global and _translate_element
{
    my $py = shift;

    my %flag_map=(r=>'replace=False', c=>'complement=True');

    my $flags='';
    if($py =~ /,flags=([a-z]+)/) {
      $flags = $1;
      $py =~ s/,flags=[a-z]+//;
    }
    my @args = ();
    for(my $i=0; $i < length($flags); $i++) {
        $flag = substr($flags,$i,1);
        if(exists $flag_map{$flag}) {
            push @args, $flag_map{$flag};
        }
        if(@args) {
            $py .= ',' . join(',', @args);
        }
    }
    return $py;
}

sub process_re_flags
# Process the re flags that don't really exist by making them options
{

    my $pos = shift;

    my $re_count = 1;				# issue 11
    if($ValPy[$pos] =~ /re\.G/) {	# issue 11
        $re_count = 0;			# issue 11
        $ValPy[$pos] =~ s/,re\.G\|/,/;  # issue 11
        $ValPy[$pos] =~ s/.re\.G//;    # issue 11
    }
    my $replace = '';
    if($ValPy[$pos] =~ /re\.R/) {
        $replace = 'replace=False,';	
        $ValPy[$pos] =~ s/,re\.R\|/,/;
        $ValPy[$pos] =~ s/.re\.R//;
    }
    return "${replace}count=$re_count";
}

sub handle_anonymous_sub_in_expression
# We have a list of tokens that stop abruptly with a "sub", save those tokens,
# generate the code for the sub, then continue lexxing and generating the
# rest of the expression, with the sub replaced by a reference to it.
{
    my $subname = "$ANONYMOUS_SUB$.";
    $nested_subs{$subname} = "\*$PERL_ARG_ARRAY";
    $saved_sub_tokens = package_code();
    p_replace($saved_sub_tokens, $#ValClass,'"',$subname,$subname);     # Change the 'sub' to the subname reference
    destroy(0, $#ValClass);
    append('i', $subname, $subname);
    # Since we already processed the '{' after the 'sub', adjust the nesting_info at the top of the stack
    $top = $Perlscan::nesting_stack[-1];
    $top->{is_sub} = 1;
    $top->{in_sub} = 1;
    $top->{cur_sub} = $subname;
    $top->{type} = 'sub';
    # Now we go and generate the code for the nested sub
}

#sub handle_anonymous_sub_in_expression          # issue 81
#{
#    # given a "sub { ... }" in an expression, bust it out and replace it with an anonymous sub ref
#    # arg1 = starting position
#    # arg2 = position of "sub"
#    # arg3 = end of line
#    my $start = shift;
#    my $pos = shift;
#    my $limit = shift;
#    state $anon_counter = 1;
#
#    return if($pos == $limit || $ValClass[$pos+1] ne '(');
#    my $close_br = matching_br($pos+1);
#    my $fname = "$ANONYMOUS_SUB$anon_counter";
#    $anon_counter++;
#    insert($pos+1, 'i', $fname, $fname);
#    $close_br++;
#    control($pos, $close_br);
#    $adjust = ($close_br - ($pos+2))+1;
#    destroy($pos+2, $adjust);
#    destroy($pos, 1);
#    $adjust++;
#    return -$adjust;
#}

sub is_expression_simple
# Heuristic to see if this expression is simple or not
# This is used in the case of $arr[EXPR] += 1, where we have to
# first do a type conversion on the $arr[EXPR].  Since _num($arr[EXPR])+=1 won't do
# the trick, we have to generate arr[EXPR] = _num(arr[EXPR]) + 1.  If EXPR
# has any side-effects, or is slow to compute, we wouldn't want to run it twice,
# so we generate: arr[_s0] = _num(arr[(_s0:=EXPR)]) + 1.  (_t is called $SUBSCRIPT_TEMP)
# This is also used for a hash key.
{
    my $start = shift;
    my $end = shift;

    return 0 if($end-$start >= 10);             # too long
    for(my $i=$start; $i<=$end; $i++) {
        # Just allow a few simple things
        return 0 if(index('"ds+-*()', $ValClass[$i]) < 0);
    }
    return 1;
}

sub unquote_string                              # SNOOPYJC
# Remove the quotes (and escapes) from the given python string
{
    my $string = shift;

    $string =~ s/^(?:fr|rf|f|r)//;
    my $quote = substr($string,0,1);
    my $quote3 = substr($string,0,3);
    $quote = $quote3 if($quote3 eq '"""' || $quote3 eq "'''");
    my $result = '';
    for(my $i = length($quote); $i <= length($string)-length($quote); $i++) {
        my $ch = substr($string, $i, 1);
        if($ch eq "\\") {
            my $ch1 = substr($string,$i+1,1);
            if($ch1 eq "\\" || $ch1 eq '"' || $ch1 eq "'") {
                $result .= $ch1;
                $i++;
                next;
            }
        } elsif($ch eq $quote) {
            last;
        } elsif(length($quote) == 3 && substr($string,$i,3) eq $quote) {
            last;
        }
        $result .= $ch;
    }
    say STDERR "unquote_string($string) = $result" if($debug >= 5);
    return $result;
}

sub escape_string
# Escape any \ or delim chars in the given string
{
    my $string = shift;
    my $delim = shift;

    my $result = '';
    for(my $i=0; $i < length($string); $i++) {
        my $ch = substr($string, $i, 1);
        if($ch eq "\\" || $ch eq $delim) {
            $result .= "\\";
        }
        $result .= $ch;
    }
    return $result;
}

sub do_use_require
{
     # require VERSION
     # require EXPR
     # require  (uses $_ as EXPR)
     #
     # use Module VERSION LIST
     # use Module VERSION
     # use Module LIST
     # use Module
     # use VERSION
     #
     # no Module VERSION LIST
     # no Module VERSION
     # no Module LIST
     # no Module
     # no VERSION
     #
     # Lets get the 'VERSION' and predefined forms out of the way first:

     my $pos = shift;

     say STDERR "do_use_require($pos)" if($debug>=3);

     if($pos+1 <= $#ValClass &&                 # use v5.24.1 -or- use 5.24.1 -or- use 5.024_001 -or-
         ($ValClass[$pos+1] eq 'd' ||           # use Carp::Assert (something built-in)
         ($ValClass[$pos+1] eq '"' && substr($ValPy[$pos+1],0,3) eq "'\\x") || 
         ($ValClass[$pos+1] eq 'i' && exists $BUILTIN_LIBRARY_SET{$ValPerl[$pos+1]}))) {
        if(exists $STAT_SUB{$ValPerl[$pos+1]}) {
            $uses_file_stat = 1;
            #$Perlscan::keyword_tr{stat} = $STAT_SUB{$ValPerl[$pos+1]};  # Swap it out!
        }
        if(exists $LSTAT_SUB{$ValPerl[$pos+1]}) {
            $uses_file_stat = 1;
            #$Perlscan::keyword_tr{lstat} = $LSTAT_SUB{$ValPerl[$pos+1]};  # Swap it out!
        }
        if($ValPerl[$pos+1] eq 'autodie') {
            $autodie = 1;
            if($import_perllib) {
                gen_statement("$PERLLIB.AUTODIE = 1");
            } else {
                gen_statement("AUTODIE = 1");
            }
        } elsif($ValPerl[$pos+1] eq 'autovivification') {
            $autovivification = (($ValPerl[$pos] eq 'no') ? 0 : 1);
        }
        if($pos != 0) {
            gen_chunk('0');
        } elsif($Pythonizer::CurNest) {
            output_line('pass','    #SKIPPED: '.$line);        # issue 96
        } else {
            output_line('','#SKIPPED: '.$line);
        }
        say STDERR "do_use_require($pos) returns " . ($pos+2) if($debug>=3);
        return $pos+2;
    }
    if($ValPerl[$pos] eq 'no') {
        if($pos != 0) {
            gen_chunk('0');
        } elsif($Pythonizer::CurNest) {
            output_line('pass','    #SKIPPED: '.$line);        # issue 96
        } else {
            output_line('','#SKIPPED: '.$line);
        }
        say STDERR "do_use_require($pos) returns " . ($pos+2) if($debug>=3);
        return $pos+2;
    } elsif($ValPerl[$pos] eq 'require' && $implicit_global_my) {
        logme('W', "'require $ValPerl[$pos+1]' translated with -m flag will not allow global variables to be shared with that script");
    }
    if($pos+1 <= $#ValClass && $ValClass[$pos+1] eq 'i' && $ValPerl[$pos+1] eq 'lib') {
        # use lib LIST
        my @libs = ();
        for(my $i=$pos+2; $i<=$#ValClass; $i++) {
            if($ValClass[$i] eq '"') {          # Plain String
                push @libs, $ValPy[$i];
            } elsif($ValClass[$i] eq 'q') {     # qw(...) or the like
                if(index(q('"), substr($ValPy[$i],0,1)) >= 0) {
                    push @libs, $ValPy[$i];
                } else {
                    push @libs, map {'"'.$_.'"'} split(' ', $ValPy[$i]);         # qw(...) on use stmt doesn't generate the split
                }
            } elsif($ValClass[$i] eq 'f') {     # Handle dirname($0) only
                if($ValPerl[$i] eq 'dirname' && $ValPerl[$i+1] eq '$0') {
                    push @libs, '"' . dirname($Pythonizer::fname) . '"';
                    $i++;
                } elsif($ValPerl[$i] eq 'dirname' && $ValPerl[$i+1] eq '(' && $ValPerl[$i+2] eq '$0') {
                    push @libs, '"' . dirname($Pythonizer::fname) . '"';
                    $i += 3;
                } else {
                    logme('W', "use lib $ValPerl[$i]() not handled!");
                }
            }
        }
        say STDERR "For @ValPerl, using @libs (after stripping the '')" if($debug);
        unshift @UseLib, map {unquote_string($_)}  @libs;
        if($pos == 0) {
            gen_statement('sys.path[0:0] = [' . join(',', @libs) . ']');
        } else {
            $Pyf{_add_path} = 1;
            gen_chunk('_add_path', '([' . join(',', @libs) . ']');
        }
        say STDERR "do_use_require($pos) returns " . ($#ValClass+1) if($debug>=3);
        return $#ValClass+1;
    } elsif($pos+4 <= $#ValClass && $ValClass[$pos+1] eq 'i' && $ValPerl[$pos+1] eq 'constant') {
        # use constant NAME => expr;
        # use constant {NAME => expr, ...};

        my $result;
        if($ValClass[$pos+2] eq 'i' && $ValClass[$pos+3] eq 'A') {
            replace($pos+3,'=','=','=');
            $Constants{$ValPy[$pos+2]} = 1;
            $ValPy[$pos+2] = escape_keywords($ValPy[$pos+2]);
            $TrStatus=assignment($pos+2);
            $result = $pos+4;
        } elsif($ValClass[$pos+2] = '(') {
            my $i;
            for($i = $pos+3; $i <= $#ValClass; $i++) {
                last if($ValClass[$i] eq ')' && $ValPerl[$i] eq '}');
                $Constants{$ValPy[$i]} = 1;
                $ValPy[$i] = escape_keywords($ValPy[$i]);
                replace($i+1,'=','=','=');
                my $comma = next_same_level_token(',', $i+2, $#ValClass);
                $comma = $#ValClass if($comma < 0);
                $TrStatus=assignment($i,$comma-1);
                gen_statement();
                $i = $comma;
            }
            $result = $i+1;
        } else {
            $TrStatus = -255;
        }
        say STDERR "do_use_require($pos) returns " . $result if($debug>=3);
        return $result;
    }

    # Ok - now for the real ones
    my $limit = $#ValClass;
    my $opp = next_lower_or_equal_precedent_token('F', $pos, $limit);
    $limit = $opp-1 if($opp >= $pos);
    my $close = next_same_level_token(')', $pos, $limit);
    $limit = $close-1 if($close >= $pos);
    if($pos == $limit) {        # require;
        gen_variable_import_pre();
        gen_chunk($DEFAULT_VAR);
        #gen_variable_import_post("['*']");
        gen_variable_import_post("");
    } elsif($pos+1 == $limit && $ValClass[$pos+1] eq 's') {  # require $x or use $x
        gen_variable_import_pre();
        gen_chunk($ValPy[$pos+1]);
        if($ValPerl[$pos] eq 'use') {
            gen_variable_import_post("['*']") 
        } else {
            gen_variable_import_post("");
        }
    } elsif($pos+1 == $limit && $ValClass[$pos+1] eq '"') {  # require "..."
        if(substr($ValPy[$pos+1],0,1) eq 'f') {      # dynamic 'f' string
            gen_variable_import_pre();
            gen_chunk($ValPy[$pos+1]);
            #gen_variable_import_post("['*']");
            if($ValPerl[$pos] eq 'use') {
                gen_variable_import_post("['*']") 
            } else {
                gen_variable_import_post("");
            }
        } else {                                # Static string
            my ($path, $exports) = import_it($pos);
            $path = '' if($path eq '.');
            if($path eq $MODULES_DIR || $path eq "./$MODULES_DIR") {
                if(!$modules_path_added && $pos == 0) {
                    gen_statement("sys.path[0:0] = ['$path']");
                    $modules_path_added = 1;
                }
                $path = '';
            }
            if(substr($ValPy[$pos+1],-4,3) eq '.pl') {
                substr($ValPy[$pos+1],-2,1) = 'y';           # change to ".py"
            }
            #if($path) {
            #gen_statement("__import__(os.path.join('$path', $ValPy[1]))");
            #} else {
            #gen_statement("__import__($ValPy[1])");
            #}
            my $file = unquote_string($ValPy[$pos+1]);
            if($pos == 0 && !$path && $file =~ m'^[A-Za-z._][A-Za-z0-9._]*\.py$' && ($CurSub eq '__main__' || !$exports)) {     # issue 41
                $file =~ s'\.py$'';
                if($exports) {
                    gen_statement("from $file import $exports");
                } else {
                    gen_statement("import $file");
                }
            } else {
                gen_variable_import_pre();
                if($path) {
                    gen_chunk("os.path.join('$path', $ValPy[1])");
                } else {
                    gen_chunk($ValPy[1]);
                }
                if($exports) {
                    $exports = '[' . join(', ', map { "'" . $_ . "'" } split(/, /, $exports)) . ']';
                }
                gen_variable_import_post($exports);
            }
        }
    } elsif($pos+1 <= $limit && $ValClass[$pos+1] eq 'i') {              # use/require bare or use/require A::B
        my ($path, $exports) = import_it($pos);
        my $inLib = 0;
        my @places = @UseLib;
        push @places, @INC;
        if($path && @places) {
            for my $lpath (@places) {
                if($path eq $lpath) {
                    $inLib = 1;
                    last;
                }
            }
        }
        $path = '' if($inLib);
        $path = '' if($path eq '.');
        if($path eq $MODULES_DIR || $path eq "./$MODULES_DIR") {
            if(!$modules_path_added && $pos == 0) {
                gen_statement("sys.path[0:0] = ['$path']");
                $modules_path_added = 1;
            }
            $path = '';
        }
        if($pos == 0 && !$path && $ValPy[$pos+1] =~ /^[A-Za-z._][A-Za-z0-9._]*$/ &&
            ($CurSub eq '__main__' || !$exports)) {     # issue 41
            if($exports) {
                gen_statement("from $ValPy[$pos+1] import $exports");
            } else {
                gen_statement("import $ValPy[$pos+1]");
            }
        } else {
            gen_variable_import_pre();
            my $module = $ValPy[$pos+1];
            $module =~ s'\.'/'g;
            if($path) {
                gen_chunk("os.path.join('$path', '$module')");
            } else {
                gen_chunk("'$module'");
            }
            if($exports) {
                $exports = '[' . join(', ', map { "'" . $_ . "'" } split(/, /, $exports)) . ']';
            }
            gen_variable_import_post($exports);
        }
    } elsif($ValPerl[$pos] eq 'require' && $pos+1 <= $limit) {         # require expr
        gen_variable_import_pre();
        $TrStatus = expression($pos+1, $limit, 0);
        #gen_variable_import_post("['*']");
        gen_variable_import_post("");
    } else {
        $TrStatus = -255;
    }
    say STDERR "do_use_require($pos) returns " . ($limit+1) if($debug>=3);
    return $limit+1;
}

sub gen_variable_import_pre
# Generate the code to do an import where what we're importing isn't constant
# Opening code - before the expression
{
    # $Pyf{_prep_import} = 1;
    # gen_chunk("[$IMPORT_PATH_TEMP, $IMPORT_MODULE_TEMP] = _prep_import(");
    $Pyf{_import} = 1;
    gen_chunk('_import', '(globals(), ');
}
sub gen_variable_import_post
# Generate the code to do an import where what we're importing isn't constant
# Closing code - after the expression
{
    my $fromlist = shift;

    #gen_chunk(')');
    #gen_statement();
    #gen_statement("sys.path.insert(0, $IMPORT_PATH_TEMP)");
    if($fromlist) {
        gen_chunk(", fromlist=$fromlist)");
    } else {
        gen_chunk(')');
    }
    #gen_statement("sys.path.pop(0)");
}

sub import_it
# Part of handling a 'use' or 'require' statements - look for the source of the modules,
# translate it to python if need be, and do an optional version check and check what we should import.
# Returns a list of 2 elements, the path where we import from and list list of what to import.
# ValClass[$pos] will tell us if this is a require or use statement
# ValClass[$pos+1]/ValPy[$pos+1] is what to import
{

    my $pos = shift;

    my $file;
    my $filepy;
    my @places = @UseLib;
    push @places, @INC;
    if($ValClass[$pos+1] eq '"') {           # require '...' - at this point this is at least a constant string!
        $file = unquote_string($ValPy[$pos+1]);
        return ('', '') if($file !~ /[A-Za-z]/); # Not a good filename
        $filepy = $file;
        $filepy =~ s/\.pl$/.py/;
    } else {
        $file = $ValPy[$pos+1];
        return ('', '') if($file !~ /[A-Za-z]/); # Not a good filename
        $file =~ s([.])(/)g;
        $filepy = $file . '.py';
        $file .= '.pm';
    }
     # require VERSION
     # require EXPR
     # require  (uses $_ as EXPR)
     #
     # use Module VERSION LIST
     # use Module VERSION
     # use Module LIST
     # use Module
     # use VERSION
     my ($desired_version, @desired_imports);
     for(my $i = $pos+2; $i <= $#ValClass; $i++) {   # See what we have next
         if($ValClass[$i] eq 'i' && $ValPerl[$i] =~ /^v\d/) {
             $desired_version .= $ValPerl[$i];
         } elsif($ValClass[$i] eq 'd') {
             $desired_version .= $ValPerl[$i];
         } elsif($ValClass[$i] eq '"') {
             push @desired_imports, $ValPerl[$i];
         } elsif($ValClass[$i] eq 'q') {        # qw
            if(index(q('"), substr($ValPy[$i],0,1)) >= 0) {
                push @desired_imports, unquote_string($ValPy[$i]);
            } else {
                push @desired_imports, split(' ', $ValPy[$i]);         # qw(...) on use stmt doesn't generate the split
            }
        }
    }
    $desired_version = substr($desired_version,1) if($desired_version && substr($desired_version,0,1) eq 'v');

    my %found_map = ();

    my $path;
    my $fullfile = $file;
    my $fullpy = $filepy;
    if(file_name_is_absolute($file)) {
        $path = dirname($file);
    } else {
        for my $place (@places) {
            $fullfile = catfile($place, $file);
            if(-f $fullfile) {
                $path = $place;
                $fullpy = catfile($place, $filepy);
                last;
            } else {
                $fullfile = $file;
            }
        }
    }
    my $stat = 0;
    if(! -f $fullfile) {     # Can't find it
        my @py_export = map { import_perl_to_python(\%found_map, $_) } expand_extras(\@desired_imports, $fullfile);
        return ('', join(', ', @py_export)) 
    }
    if((! -f $fullpy) || (-M $fullpy >= -M $fullfile)) {
        # Copy the perl file to a new "Modules" folder in the same location as our source file if we can't write in
        # the directory where it lives now.
        my $dir = dirname($fullfile);
        my $canwrite = 1;
        for my $d (@STANDARD_LIBRARY_DIRS) {
            if($dir =~ /$d/) {
                $canwrite = 0;
                last;
            }
        }
        $canwrite = open(TMPF, '>', "$dir/pythonizer.tmp") if($canwrite);
        if($canwrite) {
            close(TMPF);
            unlink "$dir/pythonizer.tmp";
        } elsif($pythonize_standard_library) {
            my $srcdir = dirname($Pythonizer::fname);
            #if($MODULES_DIR ne substr($srcdir, -length($MODULES_DIR))) {
            if(index($srcdir, $MODULES_DIR) < 0) {
                # Append the Modules dir if it's not already there
                $srcdir = dirname($Pythonizer::fname) . "/$MODULES_DIR";
                mkdir $srcdir;
            }
            $fullpy = $srcdir . '/' . basename($fullpy);
            $path = $srcdir;
            
            my $mdx = index($srcdir, $MODULES_DIR);
            $mdx += length($MODULES_DIR);
            substr($srcdir,$mdx) = '';      # Remove anything past the PyModules dir

            # Use a subdir if they user said something like "use A::B;", which at this
            # point means there are one or more '/' in $file:
            if(index($file, '/') >= 0) {
                my @subdirs = split m'/', $file;
                pop @subdirs;           # Eat the last one
                for my $subd (@subdirs) {
                    mkdir "$srcdir/$subd";
                    $srcdir .= "/$subd";
                }
                $fullpy = $srcdir . '/' . basename($fullpy);
            }
            if((! -f $fullpy) || (-M $fullpy >= -M $fullfile)) {
                say STDERR "-M $fullpy=". (-M $fullpy) . ", -M $fullfile=". (-M $fullfile) if($debug);
                say STDERR "Copying $fullfile to writable $srcdir/";
                `cp -p "$fullfile" "$srcdir"/`;
                $fullfile = $srcdir . '/' . basename($fullfile);
                $fullpy = $srcdir . '/' . basename($fullpy);
            }
        }

        if(!$canwrite && !$pythonize_standard_library) {
            logme('W', "Skipped translating $fullfile to python for use in $ValPerl[$pos] $ValPerl[$pos+1] (use '-s' option to translate it (not recommended))");
            my @py_export = map { import_perl_to_python(\%found_map, $_) } expand_extras(\@desired_imports, $fullfile);
            return ($path, join(', ', @py_export)) 
        }
        
        if(((! -f $fullpy) || (-M $fullpy >= -M $fullfile)) && lock_it($fullpy)){
            say STDERR "-M $fullpy=". (-M $fullpy) . ", -M $fullfile=". (-M $fullfile) if($debug);
            my $subprocess_options = $SUBPROCESS_OPTIONS;
            $subprocess_options .= ' -P' if(!$import_perllib);
            $subprocess_options .= ' -s' if($pythonize_standard_library);
            say STDERR "Running $0 $subprocess_options $fullfile for $ValPerl[$pos] $ValPerl[$pos+1]";
            $stat = system "$0 $subprocess_options $fullfile";
            if($stat) {
                say STDERR "ERROR running $0 $fullfile for $ValPerl[$pos] $ValPerl[$pos+1]";
            } else {
                say STDERR "Success running $0 $fullfile for $ValPerl[$pos] $ValPerl[$pos+1]";
            }
            unlock_it($fullpy);
        }
    }
    if($stat) {
        logme('W', "$0 failed to translate $fullfile to python for use in $ValPerl[$pos] $ValPerl[$pos+1]!");
        my @py_export = map { import_perl_to_python(\%found_map, $_) } expand_extras(\@desired_imports, $fullfile);
        return ($path, join(', ', @py_export)) 
    }

    # Read the code and gather the import and version information
    if(!open(PYTHON, '<', $fullpy)) {
        logme('W', "Could not open $fullpy for use in $ValPerl[$pos] statement!");
        return ($path, '');
    }
    my $base_pattern = '\b[A-Za-z_][A-Za-z0-9_]*';
    my %sigil_patterns = ('$'=>scalar_var_name($base_pattern).'\b',
                          '@'=>array_var_name($base_pattern).'\b',
                          '%'=>hash_var_name($base_pattern).'\b');
    my (@export, @export_ok, %export_tags, $version, @can_export_classes, @can_export_defs, @can_export_vars);
    while(<PYTHON>) {
        if(/EXPORT = "([^"]*)"\.split()/) {
            @export = split(' ', $1);
        } elsif(/EXPORT_OK = "([^"]*)"\.split()/) {
            @export_ok = split(' ', $1);
        } elsif(/EXPORT_TAGS = (?:(?:$PERLLIB\.)?Hash\()?\{/) {
            while(/'([^']*)': \["([^"]*)"\.split()/g) {
                my @items = split(' ', $2);
                $export_tags{$1} = \@items;
            }
        } elsif(/VERSION = (.*)$/) {
            $version = $1;
            my $c;
            if(($c = substr($version,0,1)) eq '"' || $c eq "'") {
                $version = unquote_string($version);
            }
        } elsif(/^class ([A-Za-z][A-Za-z0-9_]*)/) {
            push @can_export_classes, $1;
        } elsif(/^def ([A-Za-z][A-Za-z0-9_]*)/) {
            push @can_export_defs, $1;
        } elsif(/^([A-Za-z][A-Za-z0-9_]*) = /) {
            push @can_export_vars, $1;
        }
        my $line = &Pythonizer::eat_strings($_);
        foreach my $sig (keys %sigil_patterns) {
            my $pat = $sigil_patterns{$sig};
            if($line =~ /($pat)/) {
                my $python_name = $1;
                my $perl_name = $sig . substr($python_name,0,length($python_name)-2);
                $found_map{$perl_name} = $python_name;
            }
        }
    }
    close(PYTHON);
    if($debug) {
        $Data::Dumper::Indent=0;
        $Data::Dumper::Terse = 1;
        no warnings 'uninitialized';
        say STDERR "For $fullpy, EXPORT=@export, EXPORT_OK=@export_ok, EXPORT_TAGS=" .
        Dumper(\%export_tags) . 
        ", VERSION=$version, found_map=@{[%found_map]}, can_export_classes=@can_export_classes, can_export_defs=@can_export_defs, can_export_vars=@can_export_vars" if($debug);
     }
    $version = substr($version,1) if($version && substr($version,0,1) eq 'v');
    if($desired_version && $version) {
        if($desired_version > $version) {
            logme('S', "For $ValPerl[$pos] $ValPerl[$pos+1], desired version $desired_version > actual version $version at $fullpy");
        }
    }
    if(!@desired_imports) {
        if($ValClass[-1] eq ')' && $ValClass[-2] eq '(') {      # like use Module ();
            say STDERR "For @ValPerl, return ($path, undef)" if($debug);
            return ($path, '');              # Import nothing
        }
        if(@export) {
            my @py_export = map { import_perl_to_python(\%found_map, $_) } @export;
            say STDERR "For @ValPerl, return ($path, " . join(', ', @py_export) . ")" if($debug);
            return ($path, join(', ', @py_export));
        } else {                # We have no declared exports
            #for my $can (@can_export_defs) {
            #$can = substr($can,0,length($can)-1) if(substr($can,-1,1) eq '_');      # Remove potential escape
            #if(exists $PotentialSub{$can}) {
            #say STDERR "import_it setting LocalSub{$can} = 3" if($debug >= 3);
            #$LocalSub{$can} = 3;                # Just suppress the message
            #}
            #}
            #return ($path, '*');
            return ($path, '');                 # Import nothing
        }
    }
    # [!]name         This name only
    # [!]:DEFAULT     All names in @EXPORT
    # [!]:tag         All names in $EXPORT_TAGS{tag} anonymous array
    # [!]/pattern/    All names in @EXPORT and @EXPORT_OK which match
    my %actual_imports;
    for my $desired (@desired_imports) {
        my $ch = substr($desired,0,1);
        if($ch eq '!') {
            if($desired eq $desired_imports[0]) {       # First one
                #push @actual_imports, @export;
                for my $e (@export) {
                    $actual_imports{$e} = 1;
                }
            }
            my $ch2 = substr($desired,1,1);
            if($ch2 eq ':') {
                $tag = substr($desired,2);
                if(exists $export_tags{$tag}) {
                    for my $e (@{$export_tags{$tag}}) {
                        delete $actual_imports{$e};
                    }
                }
            } elsif($ch2 eq '/') {
                $pat = substr($desired, 2);
                substr($pat,-1,1) = '';         # Remove trailing '/'
                for my $e (@export, @export_ok) {
                    if($e =~ /$pat/) {
                        delete $actual_imports{$e};
                    }
                }
            } else {
                delete $actual_imports{substr($desired,1)};
            }
        } elsif($ch eq ':') {
            $tag = substr($desired,1);
            if(exists $export_tags{$tag}) {
                for my $e (@{$export_tags{$tag}}) {
                    $actual_imports{$e} = 1;
                }
            } elsif($tag eq 'DEFAULT') {
                for my $e (@export) {
                    $actual_imports{$e} = 1;
                }
            }
        } elsif($ch eq '/') {
            $pat = substr($desired, 1);
            substr($pat,-1,1) = '';         # Remove trailing '/'
            for my $e (@export, @export_ok) {
                if($e =~ /$pat/) {
                    $actual_imports{$e} = 1;
                }
            }
        } else {
            $actual_imports{$desired} = 1;
        }
    }
    my @py_export = map { import_perl_to_python(\%found_map, $_) } keys %actual_imports;
    say STDERR "For @ValPerl, return ($path, " . join(', ', @py_export) . ")" if($debug);
    return ($path, join(', ', @py_export));
}

sub expand_extras
# Given a list of desired exports, work with the perl file to expand it to the full list (if possible)
{
    my $desired_imports = shift;
    my $fullfile = shift;

    my @result = ();
    my @export = ();
    my @export_ok = ();
    my %export_tags = ();
    my $version = undef;
    eval {
        no warnings;
        local $SIG{__WARN__} = sub { };
        require $fullfile;
        my $package = undef;
        open(SRC, '<', $fullfile);
        while(<SRC>) {
            if(/\bpackage\s+(.*);/) {
                $package = $1;
                last;
            }
        }
        return if(!defined $package);
        my %pkh = %{"${package}::"};
        #say STDERR keys %pkh;
        @export = @{$pkh{EXPORT}} if exists($pkh{EXPORT});
        @export_ok = @{$pkh{EXPORT_OK}} if exists($pkh{EXPORT_OK});
        %export_tags = %{$pkh{EXPORT_TAGS}} if exists($pkh{EXPORT_TAGS});
        $version = ${$pkh{VERSION}} if exists($pkh{VERSION});
        say STDERR "expand_extras: package=$package, version=$version, export=@export, export_ok=@export_ok, export_tags=@{[%export_tags]}" if($debug);
    };
    say STDERR "expand_extras: $@" if($@ && $debug);
    my $message = '';
    my $gen_message = 0;
    #  Can't locate Cisco/SNMP.pm in @INC (you may need to install the Cisco::SNMP module)
    if($@ =~ /you may need to install the (.*?) module/) {
        $message = "Module $1 not found in \@INC: Can't process";
    }
    
    # [!]name         This name only
    # [!]:DEFAULT     All names in @EXPORT
    # [!]:tag         All names in $EXPORT_TAGS{tag} anonymous array
    # [!]/pattern/    All names in @EXPORT and @EXPORT_OK which match
    my %actual_imports;
    for my $desired (@{$desired_imports}) {
        my $ch = substr($desired,0,1);
        if($ch eq '!') {
            if($message) {
                $message .= " $desired";
                $gen_message = 1;
            }
            if($desired eq $desired_imports->[0]) {       # First one
                for my $e (@export) {
                    $actual_imports{$e} = 1;
                }
            }
            my $ch2 = substr($desired,1,1);
            if($ch2 eq ':') {
                $tag = substr($desired,2);
                if(exists $export_tags{$tag}) {
                    for my $e (@{$export_tags{$tag}}) {
                        delete $actual_imports{$e};
                    }
                }
            } elsif($ch2 eq '/') {
                $pat = substr($desired, 2);
                substr($pat,-1,1) = '';         # Remove trailing '/'
                for my $e (@export, @export_ok) {
                    if($e =~ /$pat/) {
                        delete $actual_imports{$e};
                    }
                }
            } else {
                delete $actual_imports{substr($desired,1)};
            }
        } elsif($ch eq ':') {
            if($message) {
                $message .= " $desired";
                $gen_message = 1;
            }
            $tag = substr($desired,1);
            if(exists $export_tags{$tag}) {
                for my $e (@{$export_tags{$tag}}) {
                    $actual_imports{$e} = 1;
                }
            } elsif($tag eq 'DEFAULT') {
                for my $e (@export) {
                    $actual_imports{$e} = 1;
                }
            }
        } elsif($ch eq '/') {
            if($message) {
                $message .= " $desired";
                $gen_message = 1;
            }
            $pat = substr($desired, 1);
            substr($pat,-1,1) = '';         # Remove trailing '/'
            for my $e (@export, @export_ok) {
                if($e =~ /$pat/) {
                    $actual_imports{$e} = 1;
                }
            }
        } else {
            $actual_imports{$desired} = 1;
        }
    }
    logme('W', $message) if($gen_message);
    say STDERR "expand_extras(@{$desired_imports}, $fullfile) = " . join(' ', keys %actual_imports) if($debug);
    return keys %actual_imports;
}

sub import_perl_to_python
# Given a perl name, return the equivalent python name
# Used for the importer.  'mapref' is a map from perl names to python names
# as seen in the module to be imported.  'perl_name' is the name to be mapped.
# For subs, also marks them in LocalSub.
{
    my $mapref = shift;
    my $perl_name = shift;
    
    my $sig = substr($perl_name,0,1);
    my $result;
    if($sig eq '&') {
        $perl_name = substr($perl_name,1);        # remove '&'
        $result = escape_keywords($perl_name);
    } elsif(index('@$%', $sig) >= 0) {
        if(exists $mapref->{$perl_name}) {
            return $mapref->{$perl_name};               # e.g. @arr -> arr_a, if it exists in the generated code
        }
        return escape_keywords(substr($perl_name, 1));
    } else {
        $result = escape_keywords($perl_name);
    }
    say STDERR "import_perl_to_python: setting LocalSub{$result} = 2" if($debug >= 3);
    $LocalSub{$perl_name} = 2;             # Imported
    return $result;
}

sub _lock_file
# Create a lock filename based on an existing filename
{
    my $lf = shift;

    $lf =~ s/\.[a-z]+$/.lock/;
    return $lf;
}

sub lock_it
# Create an advisory lock on a file
# arg = full path to file
# Returns 1 if locking is successful
{
    my $fullpath = shift;

    my $lockfile = $fullpath;
    $lockfile = _lock_file($lockfile);
    if(-f $lockfile) {
        my $days_old = (-M $lockfile);
        if($days_old > ((5*60) / 86400.0)) {    # stale if older than 5 mins
            unlink $lockfile;
        }
    }
    if(-f $lockfile) {
        return 0;               # Already locked
    }
    # "touch" file file to create it
    say STDERR "Created $lockfile for $fullpath" if($debug);
    open(LF, '>', $lockfile);
    close(LF);
    return 1;
}

sub unlock_it
# Remove an advisory lock on a file
# arg = full path to file
{
    my $fullpath = shift;

    my $lockfile = $fullpath;
    $lockfile = _lock_file($lockfile);
    unlink $lockfile;
    say STDERR "Removed $lockfile for $fullpath" if($debug);
}

sub gen_implicit_continue               # issue for
# For a 'for' loop where the loop counter is modified or we can't use the range(...)
# operator, we generate a 'while' loop with an implicit 'continue' block where
# we put the increment code.  Returns 1 if we generate such a thing.
{
    my $tokens;
    if(($tokens = &Perlscan::needs_implicit_continue(1))) {
        unpackage_code($tokens);
        if($TokenStr eq '((s=f(s)+d)-d)' || $TokenStr eq '((s=f(s)-d)+d)' ||
           $TokenStr eq '((s=s+d)-d)' || $TokenStr eq '((s=s-d)+d)') {
           # Get rid of the extra non-needed reversal of the ++/--
           destroy(length($TokenStr)-4, 4);
           destroy(0, 2);
        }
        fix_expression_issues();
        if($ValClass[0] eq 's' && next_same_level_token(',', 0, $#ValClass) == -1) {
            my $eq = next_same_level_token('=', 0, $#ValClass);
            $ValPy[$eq] = '=' if($eq != -1 && $ValPy[$eq] eq ':=');
            $TrStatus=assignment(0, $#ValClass);
        } else {
            $TrStatus=expression(0, $#ValClass, 1);
        }
        gen_statement();
        return 1;
    }
    return 0;
}

sub gen_extra		# issue 116: generate the extra stuff after the statement
# extra points to the and/or/, etc token after the statement
# orig_limit is where we stop
{
    my $extra = shift;
    my $orig_limit = shift;

    return if($extra > $orig_limit);

    gen_chunk($ValPy[$extra]);
    my $k = next_lower_or_equal_precedent_token('=', $extra+1, $orig_limit);
    if($k < 0 || $ValClass[$k] ne '=') {
 	$TrStatus=expression($extra+1, $orig_limit, 0);
    } else {
 	$TrStatus=assignment($extra+1, $orig_limit);
    }
}

sub left_hand_substr
#
# Perl
#    substr(text, start, length)=replacement
# can be translated into Python:
#    text = text[:start] + replacement + text[start+length:]
# or
#    text = replacement.join(text[0:start],text[start+length:])
{
my  $equal_pos=index($TokenStr,'=');
# issue 70 my $comma_no=0;
# issue 70 state $temp_var=0;
# issue 70 my $var='';
my ($replacement,$k);

      if( $equal_pos == -1 ){
         return 255;
      }
      #
      # issue 70: recode it from scratch
      #
      # Potential issue with this code: if text or start contains an expression with
      # a function call or side effect, it will be run more than once!
      #
      $comma1 = next_same_level_token(',', 2, $equal_pos-1);
      $comma2 = next_same_level_token(',', $comma1+1, $equal_pos-1);
      $close_paren = matching_br(1);
      $k=expression(2, $comma1-1,0);      # text
      return -255 if($k<0);
      gen_chunk('=');
      $k=expression(2, $comma1-1,0);      # text
      gen_chunk('[:');
      $k=expression($comma1+1, $comma2-1,0);   # start
      return -255 if($k<0);
      gen_chunk("] + ");
      $k=expression($equal_pos+1);        # parse to the tail of the line  first starting from '='
      return -255 if ($k<0);
      gen_chunk(" + ");
      $k=expression(2, $comma1-1,0);      # text
      gen_chunk('[');
      $k=expression($comma1+1, $comma2-1,0);   # start
      gen_chunk('+');
      $k=expression($comma2+1, $close_paren-1,0);   # length
      gen_chunk(':]');
      return $close_paren+1;
      
      # issue 70 if( index(q(s'"qd),$ValClass[$equal_pos+1])>=1 && $#ValClass==$equal_pos+1 ){
      # issue 70 # $#ValClass==$equal_pos+1 means that we deal with =$str variant
      # issue 70 # substr($str,$from,$len)=$str2; -- no expression on the right part
      # issue 70 $replacement=$ValPy[$equal_pos+1]; # we can translate such subst in a single line
      # issue 70 }else{
      # issue 70 # we need a temp Variable to storethe replacement string
      # issue 70 $replacement="$REPLACEMENT$.";         # issue 32
      # issue 70 gen_chunk("$replacement.=");
      # issue 70 $k=expression($equal_pos+1); # parse the tail of te line  first starting from '='
      # issue 70 return -255 if ($k<0);
      # issue 70 gen_statement() # out the generated line
      # issue 70 }
      #
      # issue 70      if( $ValClass[1] eq '(' && $ValClass[2] eq 's' ){
      # issue 70         # the first argument should be scalar
      # issue 70        $var=$ValPy[2];
      # issue 70        gen_chunk("$var=$var".'[:');
      # issue 70      }else{
      # issue 70         return -255;
      # issue 70      }
      # issue 70       for( $k=4; $k<@ValClass; $k++ ){          # 4 is the position of "start"
      # issue 70          if( $ValClass[$k] eq ')' ){
      # issue 70            last;
      # issue 70          }elsif( $ValClass[$k] eq ',' ){
      # issue 70            $comma_no++;
      # issue 70            if( $comma_no==1 ){
      # issue 70               gen_chunk("] + $replacement + $var".'[('.$ValPy[$k-1]);
      # issue 70            }elsif( $comma_no==2 ){
      # issue 70               gen_chunk("+$ValPy[$k-1]:]");
      # issue 70            }
      # issue 70          }elsif( $ValClass[$k] eq 'f' ){
      # issue 70             $k=function($k);
      # issue 70             return -255 if ($k<0);
      # issue 70           }elsif( $ValClass[$k] eq '(' ){
      # issue 70             $k=expression($k+1);
      # issue 70             return -255 if ($k<0);
      # issue 70          }else{
      # issue 70            gen_chunk($ValPy[$k]);
      # issue 70            $k++;
      # issue 70          }
      # issue 70       } #for
      # issue 70       return $k;
} #left_hand_substr

__DATA__
def PostIncr(name, local={}):
    #Equivalent to name++
    if name in local:
        local[name]+=1
        return local[name]-1
    globals()[name]+=1
    return globals()[name]-1
def PostDecr(name, local={}):
    #Equivalent to name--
    if name in local:
        local[name]-=1
        return local[name]-1
    globals()[name]-=1
    return globals()[name]-1
