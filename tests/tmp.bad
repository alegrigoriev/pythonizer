 [Softpano-W318]:  Debug flag is set to 5


PYTHONIZER: Fuzzy translator of Python to Perl. Version 0.938 (mtime 220109_2342) Started at 22/01/10 01:12

Logs are at /tmp/Pythonizer/pythonizer.220110_0112.log. Type -h for help.
=============================================================================================================
Results of transcription are written to the file  issue_comments.py
=========================================================================================================================

Lexem 0 Current token='k' perl='use' value='import' Tokenstr |k| translated: import
Lexem 1 Current token='i' perl='Carp::Assert' value='Carp.Assert' Tokenstr |ki| translated: import Carp.Assert
>expr_type(1, 1, main)
<expr_type(1, 1, main) = S
Lexem 0 Current token='k' perl='sub' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' perl='test' value='test' Tokenstr |ki| translated: def test
enter_block at line 15, prior nesting_level=0, ValPerl=sub test {
nesting_info=is_eval  is_loop  is_sub 1 type def level 0 cur_sub test in_sub 1 varclasses HASH(0x80084f898) lno 15 in_loop 0
get_globals: switching to 'test' at line 15
>expr_type(1, 1, test)
<expr_type(1, 1, test) = m
Lexem 0 Current token='s' perl='$i' value='i' Tokenstr |s| translated: i
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: i =
Lexem 2 Current token='d' perl='1' value='1' Tokenstr |s=d| translated: i = 1
check_ref(test, i) at 0
>expr_type(2, 2, test)
<expr_type(2, 2, test) = I
merge_types(i, test, I)
>expr_type(0, 0, test)
<expr_type(0, 0, test) = I
>expr_type(0, 2, test)
>>expr_type(2, 2, test)
<<expr_type(2, 2, test) = I
<expr_type(0, 2, test) = I
Lexem 0 Current token='s' perl='$j' value='j' Tokenstr |s| translated: j
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: j =
Lexem 2 Current token='d' perl='2' value='2' Tokenstr |s=d| translated: j = 2
check_ref(test, j) at 0
>expr_type(2, 2, test)
<expr_type(2, 2, test) = I
merge_types(j, test, I)
>expr_type(0, 0, test)
<expr_type(0, 0, test) = I
>expr_type(0, 2, test)
>>expr_type(2, 2, test)
<<expr_type(2, 2, test) = I
<expr_type(0, 2, test) = I
Lexem 0 Current token='s' perl='$i' value='i' Tokenstr |s| translated: i
Lexem 1 Current token='+' perl='+' value='+' Tokenstr |s+| translated: i +
Lexem 2 Current token='s' perl='$j' value='j' Tokenstr |s+s| translated: i + j
check_ref(test, i) at 0
>expr_type(0, 0, test)
<expr_type(0, 0, test) = I
check_ref(test, j) at 2
>expr_type(2, 2, test)
<expr_type(2, 2, test) = I
>expr_type(0, 2, test)
<expr_type(0, 2, test) = N
exit_block at line 23, prior nesting_level=1, nesting_last->{type} is now def
get_globals: switching back to 'main' at line 23
merge_types(test, main, N)
Lexem 0 Current token='k' perl='sub' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' perl='test4' value='test4' Tokenstr |ki| translated: def test4
enter_block at line 29, prior nesting_level=0, ValPerl=sub test4 {
nesting_info=is_eval  is_loop  level 0 is_sub 1 type def varclasses HASH(0x800817218) lno 29 cur_sub test4 in_sub 1 in_loop 0
get_globals: switching to 'test4' at line 29
>expr_type(1, 1, test4)
<expr_type(1, 1, test4) = m
Lexem 0 Current token='d' perl='1' value='1' Tokenstr |d| translated: 1
>expr_type(0, 0, test4)
<expr_type(0, 0, test4) = I
exit_block at line 29, prior nesting_level=1, nesting_last->{type} is now def
get_globals: switching back to 'main' at line 29
merge_types(test4, main, I)
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='i' perl='test' value='test' Tokenstr |c(i| translated: assert ( test
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(i(| translated: assert ( test (
Lexem 4 Current token=')' perl=')' value=')' Tokenstr |c(i()| translated: assert ( test ( )
Lexem 5 Current token='>' perl='==' value='==' Tokenstr |c(i()>| translated: assert ( test ( ) ==
Lexem 6 Current token='d' perl='3' value='3' Tokenstr |c(i()>d| translated: assert ( test ( ) == 3
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |c(i()>d)| translated: assert ( test ( ) == 3 )
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='i' perl='test4' value='test4' Tokenstr |c(i| translated: assert ( test4
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(i(| translated: assert ( test4 (
Lexem 4 Current token=')' perl=')' value=')' Tokenstr |c(i()| translated: assert ( test4 ( )
Lexem 5 Current token='>' perl='==' value='==' Tokenstr |c(i()>| translated: assert ( test4 ( ) ==
Lexem 6 Current token='d' perl='1' value='1' Tokenstr |c(i()>d| translated: assert ( test4 ( ) == 1
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |c(i()>d)| translated: assert ( test4 ( ) == 1 )
Lexem 0 Current token='f' perl='open' value='open' Tokenstr |f| translated: open
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |f(| translated: open (
Lexem 2 Current token='i' perl='SRC' value='SRC' Tokenstr |f(i| translated: open ( SRC
Lexem 3 Current token=',' perl=',' value=',' Tokenstr |f(i,| translated: open ( SRC ,
>interpolate_strings(<$0, <$0, 5, 1, 0)
>extract_tokens_from_double_quoted_string(<$0)
 ExtractingTokensFromDoubleQuotedTokensEnd=-1, ExtractingTokensFromDoubleQuotedStringEnd=3
<extract_tokens_from_double_quoted_string(<$0) result=1
<interpolate_strings(<$0, <$0, 5, 1, 0)=2 (begin extract mode)
Lexem 4 Current token='"' perl='<' value='f"""<"""' Tokenstr |f(i,"| translated: open ( SRC , f"""<"""
>extract_tokens_from_double_quoted_string($0)
 ExtractingTokensFromDoubleQuotedTokensEnd=2, ExtractingTokensFromDoubleQuotedStringEnd=2
<extract_tokens_from_double_quoted_string($0) end=2, result=0
Lexem 5 Current token='s' perl='$0' value='__file__' Tokenstr |f(i,"s| translated: open ( SRC , f"""<""" __file__
>extract_tokens_from_double_quoted_string()
Lexem 6 Current token='"' perl='' value='f""""""' Tokenstr |f(i,"s"| translated: open ( SRC , f"""<""" __file__ f""""""
 ExtractingTokensFromDoubleQuotedTokensEnd=-1, ExtractingTokensFromDoubleQuotedStringEnd=0
<extract_tokens_from_double_quoted_string() end=-1, result=1
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |f(i,"s")| translated: open ( SRC , f"""<""" __file__ f"""""" )
check_ref(main, __file__) at 5
>expr_type(5, 5, main)
<expr_type(5, 5, main) = S
>expr_type(0, 7, main)
<expr_type(0, 7, main) = I
Lexem 0 Current token='h' perl='%blocks' value='blocks' Tokenstr |h| translated: blocks
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |h=| translated: blocks =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |h=(| translated: blocks = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |h=()| translated: blocks = ( )
check_ref(main, blocks) at 0
>expr_type(2, 3, main)
>>expr_type(3, 2, main)
<<expr_type(3, 2, main) = m
<expr_type(2, 3, main) = m
merge_types(blocks, main, h of m)
>expr_type(0, 3, main)
>>expr_type(2, 3, main)
>>>expr_type(3, 2, main)
<<<expr_type(3, 2, main) = m
<<expr_type(2, 3, main) = m
<expr_type(0, 3, main) = m
Lexem 0 Current token='s' perl='$lines' value='lines' Tokenstr |s| translated: lines
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: lines =
Lexem 2 Current token='"' perl='' value='''' Tokenstr |s="| translated: lines = ''
check_ref(main, lines) at 0
>expr_type(2, 2, main)
<expr_type(2, 2, main) = S
merge_types(lines, main, S)
>expr_type(0, 0, main)
<expr_type(0, 0, main) = S
>expr_type(0, 2, main)
>>expr_type(2, 2, main)
<<expr_type(2, 2, main) = S
<expr_type(0, 2, main) = S
Lexem 0 Current token='c' perl='while' value='while' Tokenstr |c| translated: while
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: while (
Lexem 2 Current token='j' perl='<SRC>' value='_readline(SRC)' Tokenstr |c(j| translated: while ( _readline(SRC)
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(j)| translated: while ( _readline(SRC) )
enter_block at line 36, prior nesting_level=0, ValPerl=while ( <SRC> ) {
nesting_info=type while is_sub  level 0 is_loop 1 is_eval  in_loop 1 in_sub 0 cur_sub  lno 36 varclasses HASH(0x800761928)
Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
perl_match(#BLOCK (\d): (\d), /, #BLOCK (\d): (\d)): modifier=r, groups_are_present=1
put_regex_in_quotes(#BLOCK (\d): (\d), /, #BLOCK (\d): (\d))
>interpolate_strings(#BLOCK (\d): (\d), #BLOCK (\d): (\d), 0, 0, 1)
<interpolate_strings(#BLOCK (\d): (\d), #BLOCK (\d): (\d), 0, 0, 1)=0, ValPy[2]='#BLOCK (\d): (\d)'
Lexem 2 Current token='q' perl='#BLOCK (\d): (\d)' value='(_m:=re.search(r'#BLOCK (\d): (\d)',_d))' Tokenstr |c(q| translated: if  ( (_m:=re.search(r'#BLOCK (\d): (\d)',_d))
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(q)| translated: if  ( (_m:=re.search(r'#BLOCK (\d): (\d)',_d)) )
enter_block at line 37, prior nesting_level=1, ValPerl=if ( #BLOCK (\d): (\d) ) {
nesting_info=level 1 is_sub  type if  is_eval  is_loop  in_loop 1 varclasses HASH(0x800b3d428) lno 37 cur_sub  in_sub 0
Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='!' perl='!' value='not' Tokenstr |c(!| translated: if  ( not
Lexem 3 Current token='f' perl='exists' value='in' Tokenstr |c(!f| translated: if  ( not in
Lexem 4 Current token='s' perl='$blocks' value='blocks' Tokenstr |c(!fs| translated: if  ( not in blocks
Lexem 5 Current token='(' perl='{' value='[' Tokenstr |c(!fs(| translated: if  ( not in blocks [
Lexem 6 Current token='s' perl='$1' value='_m.group(1)' Tokenstr |c(!fs(s| translated: if  ( not in blocks [ _m.group(1)
Lexem 7 Current token=')' perl='}' value=']' Tokenstr |c(!fs(s)| translated: if  ( not in blocks [ _m.group(1) ]
Lexem 8 Current token=')' perl=')' value=')' Tokenstr |c(!fs(s))| translated: if  ( not in blocks [ _m.group(1) ] )
enter_block at line 38, prior nesting_level=2, ValPerl=if ( ! exists $blocks { $1 } ) {
nesting_info=is_eval  is_loop  is_sub  type if  level 2 cur_sub  in_sub 0 varclasses HASH(0x800b52648) lno 38 in_loop 1
check_ref(main, blocks) at 4
check_ref(main, _m.group(1)) at 6
>expr_type(6, 6, main)
<expr_type(6, 6, main) = S
Lexem 0 Current token='s' perl='$blocks' value='blocks' Tokenstr |s| translated: blocks
Lexem 1 Current token='(' perl='{' value='[' Tokenstr |s(| translated: blocks [
Lexem 2 Current token='s' perl='$1' value='_m.group(1)' Tokenstr |s(s| translated: blocks [ _m.group(1)
Lexem 3 Current token=')' perl='}' value=']' Tokenstr |s(s)| translated: blocks [ _m.group(1) ]
Lexem 4 Current token='=' perl='=' value='=' Tokenstr |s(s)=| translated: blocks [ _m.group(1) ] =
Lexem 5 Current token='s' perl='$2' value='_m.group(2)' Tokenstr |s(s)=s| translated: blocks [ _m.group(1) ] = _m.group(2)
check_ref(main, blocks) at 0
>expr_type(5, 5, main)
<expr_type(5, 5, main) = S
merge_types(blocks, main, h of S)
merge_types: otype=h of m
check_ref(main, _m.group(1)) at 2
>expr_type(5, 5, main)
<expr_type(5, 5, main) = S
merge_types(_m.group(1), main, u)
merge_types: otype=S
>expr_type(2, 2, main)
<expr_type(2, 2, main) = S
check_ref(main, _m.group(2)) at 5
>expr_type(5, 5, main)
<expr_type(5, 5, main) = S
>expr_type(0, 5, main)
<expr_type(0, 5, main) = m
exit_block at line 40, prior nesting_level=3, nesting_last->{type} is now if 
Lexem 0 Current token='C' perl='else' value='else: ' Tokenstr |C| translated: else: 
enter_block at line 40, prior nesting_level=2, ValPerl=else {
nesting_info=in_sub 0 cur_sub  lno 40 varclasses HASH(0x800436ef0) in_loop 1 is_loop  is_eval  type else is_sub  level 2
Lexem 0 Current token='s' perl='$blocks' value='blocks' Tokenstr |s| translated: blocks
Lexem 1 Current token='(' perl='{' value='[' Tokenstr |s(| translated: blocks [
Lexem 2 Current token='s' perl='$1' value='_m.group(1)' Tokenstr |s(s| translated: blocks [ _m.group(1)
Lexem 3 Current token=')' perl='}' value=']' Tokenstr |s(s)| translated: blocks [ _m.group(1) ]
Lexem 4 Current token='=' perl='.=' value='+=' Tokenstr |s(s)=| translated: blocks [ _m.group(1) ] +=
Lexem 5 Current token='s' perl='$2' value='_m.group(2)' Tokenstr |s(s)=s| translated: blocks [ _m.group(1) ] += _m.group(2)
check_ref(main, blocks) at 0
>expr_type(5, 5, main)
<expr_type(5, 5, main) = S
merge_types(blocks, main, h of S)
merge_types: otype=h of m
check_ref(main, _m.group(1)) at 2
>expr_type(5, 5, main)
<expr_type(5, 5, main) = S
merge_types(_m.group(1), main, u)
merge_types: otype=S
>expr_type(2, 2, main)
<expr_type(2, 2, main) = S
check_ref(main, _m.group(2)) at 5
>expr_type(5, 5, main)
<expr_type(5, 5, main) = S
>expr_type(0, 5, main)
<expr_type(0, 5, main) = m
exit_block at line 42, prior nesting_level=3, nesting_last->{type} is now else
exit_block at line 43, prior nesting_level=2, nesting_last->{type} is now if 
Lexem 0 Current token='C' perl='elsif' value='elif ' Tokenstr |C| translated: elif 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |C(| translated: elif  (
perl_match(#LINE (\d), /, #LINE (\d)): modifier=r, groups_are_present=1
put_regex_in_quotes(#LINE (\d), /, #LINE (\d))
>interpolate_strings(#LINE (\d), #LINE (\d), 0, 0, 1)
<interpolate_strings(#LINE (\d), #LINE (\d), 0, 0, 1)=0, ValPy[2]='#LINE (\d)'
Lexem 2 Current token='q' perl='#LINE (\d)' value='(_m:=re.search(r'#LINE (\d)',_d))' Tokenstr |C(q| translated: elif  ( (_m:=re.search(r'#LINE (\d)',_d))
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |C(q)| translated: elif  ( (_m:=re.search(r'#LINE (\d)',_d)) )
enter_block at line 43, prior nesting_level=1, ValPerl=elsif ( #LINE (\d) ) {
nesting_info=in_loop 1 lno 43 varclasses HASH(0x800b52288) in_sub 0 cur_sub  level 1 type elif  is_sub  is_loop  is_eval 
Lexem 0 Current token='s' perl='$lines' value='lines' Tokenstr |s| translated: lines
Lexem 1 Current token='=' perl='.=' value='+=' Tokenstr |s=| translated: lines +=
Lexem 2 Current token='s' perl='$1' value='_m.group(1)' Tokenstr |s=s| translated: lines += _m.group(1)
check_ref(main, lines) at 0
>expr_type(2, 2, main)
<expr_type(2, 2, main) = S
merge_types(lines, main, S)
merge_types: otype=S
>expr_type(0, 0, main)
<expr_type(0, 0, main) = S
check_ref(main, _m.group(1)) at 2
>expr_type(2, 2, main)
<expr_type(2, 2, main) = S
>expr_type(0, 2, main)
>>expr_type(2, 2, main)
<<expr_type(2, 2, main) = S
<expr_type(0, 2, main) = S
exit_block at line 45, prior nesting_level=2, nesting_last->{type} is now elif 
exit_block at line 46, prior nesting_level=1, nesting_last->{type} is now while
Lexem 0 Current token='c' perl='for' value='for' Tokenstr |c| translated: for
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: for (
Lexem 2 Current token='t' perl='my' value='' Tokenstr |c(t| translated: for ( 
Lexem 3 Current token='s' perl='$i' value='i' Tokenstr |c(ts| translated: for (  i
Lexem 4 Current token='=' perl='=' value=':=' Tokenstr |c(ts=| translated: for (  i :=
Lexem 5 Current token='d' perl='1' value='1' Tokenstr |c(ts=d| translated: for (  i := 1
Lexem 6 Current token=';' perl=';' value=';' Tokenstr |c(ts=d;| translated: for (  i := 1 ;
Lexem 7 Current token='s' perl='$i' value='i' Tokenstr |c(ts=d;s| translated: for (  i := 1 ; i
Lexem 8 Current token='>' perl='<=' value='<=' Tokenstr |c(ts=d;s>| translated: for (  i := 1 ; i <=
Lexem 9 Current token='d' perl='4' value='4' Tokenstr |c(ts=d;s>d| translated: for (  i := 1 ; i <= 4
Lexem 10 Current token=';' perl=';' value=';' Tokenstr |c(ts=d;s>d;| translated: for (  i := 1 ; i <= 4 ;
Lexem 11 Current token='s' perl='$i' value='i' Tokenstr |c(ts=d;s>d;s| translated: for (  i := 1 ; i <= 4 ; i
Lexem 12 Current token='^' perl='++' value='+=1' Tokenstr |c(ts=d;s>d;s^| translated: for (  i := 1 ; i <= 4 ; i +=1
Lexem 13 Current token=')' perl=')' value=')' Tokenstr |c(ts=d;s>d;s^)| translated: for (  i := 1 ; i <= 4 ; i +=1 )
enter_block at line 47, prior nesting_level=0, ValPerl=for ( my $i = 1 ; $i <= 4 ; $i ++ ) {
nesting_info=is_loop 1 is_eval  type for is_sub  level 0 in_sub 0 cur_sub  lno 47 varclasses HASH(0x800b52888) in_loop 1
check_ref(main, i) at 3
>expr_type(5, 13, main)
<expr_type(5, 13, main) = I
merge_types(i, main, I)
>expr_type(3, 3, main)
<expr_type(3, 3, main) = I
check_ref(main, i) at 7
>expr_type(7, 7, main)
<expr_type(7, 7, main) = I
check_ref(main, i) at 11
merge_types(i, main, I)
merge_types: otype=I
>expr_type(11, 11, main)
<expr_type(11, 11, main) = I
>expr_type(5, 13, main)
<expr_type(5, 13, main) = I
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$blocks' value='blocks' Tokenstr |c(s| translated: assert ( blocks
Lexem 3 Current token='(' perl='{' value='[' Tokenstr |c(s(| translated: assert ( blocks [
Lexem 4 Current token='s' perl='$i' value='i' Tokenstr |c(s(s| translated: assert ( blocks [ i
Lexem 5 Current token=')' perl='}' value=']' Tokenstr |c(s(s)| translated: assert ( blocks [ i ]
Lexem 6 Current token='>' perl='eq' value='==' Tokenstr |c(s(s)>| translated: assert ( blocks [ i ] ==
Lexem 7 Current token='"' perl='1234' value=''1234'' Tokenstr |c(s(s)>"| translated: assert ( blocks [ i ] == '1234'
Lexem 8 Current token=')' perl=')' value=')' Tokenstr |c(s(s)>")| translated: assert ( blocks [ i ] == '1234' )
check_ref(main, blocks) at 2
check_ref(main, i) at 4
>expr_type(4, 4, main)
<expr_type(4, 4, main) = I
exit_block at line 49, prior nesting_level=1, nesting_last->{type} is now for
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$lines' value='lines' Tokenstr |c(s| translated: assert ( lines
Lexem 3 Current token='>' perl='eq' value='==' Tokenstr |c(s>| translated: assert ( lines ==
Lexem 4 Current token='"' perl='1234' value=''1234'' Tokenstr |c(s>"| translated: assert ( lines == '1234'
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(s>")| translated: assert ( lines == '1234' )
check_ref(main, lines) at 2
>expr_type(2, 2, main)
<expr_type(2, 2, main) = S
Lexem 0 Current token='f' perl='print' value='print' Tokenstr |f| translated: print
>interpolate_strings($0 - test passed!\n, $0 - test passed!\n, 21, 1, 0)
>extract_tokens_from_double_quoted_string($0 - test passed!\n)
 ExtractingTokensFromDoubleQuotedTokensEnd=-1, ExtractingTokensFromDoubleQuotedStringEnd=19
<extract_tokens_from_double_quoted_string($0 - test passed!\n) result=0
<interpolate_strings($0 - test passed!\n, $0 - test passed!\n, 21, 1, 0)=1 (begin extract mode)
Lexem 1 Current token='"' perl='' value='f""""""' Tokenstr |f"| translated: print f""""""
>extract_tokens_from_double_quoted_string($0 - test passed!\n)
 ExtractingTokensFromDoubleQuotedTokensEnd=2, ExtractingTokensFromDoubleQuotedStringEnd=19
<extract_tokens_from_double_quoted_string($0 - test passed!\n) end=2, result=0
Lexem 2 Current token='s' perl='$0' value='__file__' Tokenstr |f"s| translated: print f"""""" __file__
>extract_tokens_from_double_quoted_string( - test passed!\n)
Lexem 3 Current token='"' perl=' - test passed!\n' value='f""" - test passed!\n"""' Tokenstr |f"s"| translated: print f"""""" __file__ f""" - test passed!\n"""
 ExtractingTokensFromDoubleQuotedTokensEnd=-1, ExtractingTokensFromDoubleQuotedStringEnd=0
<extract_tokens_from_double_quoted_string( - test passed!\n) end=-1, result=18
check_ref(main, __file__) at 2
>expr_type(2, 2, main)
<expr_type(2, 2, main) = S
>expr_type(0, 3, main)
<expr_type(0, 3, main) = I
line_locals = {}

line_locals_map = {}

line_sub = {}

VarSubMap = {
  '_DUP_MAP' => {
    'main' => '+'
  },
  'AUTODIE' => {
    'main' => '+'
  },
  'INPUT_LINE_NUMBER' => {
    'main' => '+'
  },
  'TRACEBACK' => {
    'main' => '+'
  },
  'j' => {
    'test' => '+'
  },
  'INPUT_RECORD_SEPARATOR' => {
    'main' => '+'
  },
  'CHILD_ERROR' => {
    'main' => '+'
  },
  '_locals_stack' => {
    'main' => '+'
  },
  'lines' => {
    'main' => '+'
  },
  'BASETIME' => {
    'main' => '+'
  },
  'blocks' => {
    'main' => '+'
  },
  '_OPEN_MODE_MAP' => {
    'main' => '+'
  },
  'LIST_SEPARATOR' => {
    'main' => '+'
  },
  'OUTPUT_AUTOFLUSH' => {
    'main' => '+'
  },
  'i' => {
    'test' => '+'
  },
  'OS_ERROR' => {
    'main' => '+'
  }
}

VarType = {
  'OUTPUT_AUTOFLUSH' => {
    'main' => 'I'
  },
  'LIST_SEPARATOR' => {
    'main' => 'S'
  },
  'test4' => {
    'main' => 'I'
  },
  '__file__' => {
    'main' => 'S'
  },
  'os.name' => {
    'main' => 'S'
  },
  '_m.group(1)' => {
    'main' => 'S'
  },
  'EVAL_ERROR' => {
    'main' => 'S'
  },
  'j' => {
    'test' => 'I'
  },
  'TRACEBACK' => {
    'main' => 'I'
  },
  'AUTODIE' => {
    'main' => 'I'
  },
  '_DUP_MAP' => {
    'main' => 'h of I'
  },
  '_OPEN_MODE_MAP' => {
    'main' => 'h of S'
  },
  'sys.argv' => {
    'main' => 'a of S'
  },
  'blocks' => {
    'main' => 'h of m'
  },
  'BASETIME' => {
    'main' => 'I'
  },
  'OS_ERROR' => {
    'main' => 'S'
  },
  'test' => {
    'main' => 'N'
  },
  'i' => {
    'test' => 'I',
    'main' => 'I'
  },
  'os.environ' => {
    'main' => 'h of s'
  },
  'INPUT_LINE_NUMBER' => {
    'main' => 'I'
  },
  '_locals_stack' => {
    'main' => 'h of S'
  },
  'lines' => {
    'main' => 'S'
  },
  '_m.group(2)' => {
    'main' => 'S'
  },
  'CHILD_ERROR' => {
    'main' => 'I'
  },
  'INPUT_RECORD_SEPARATOR' => {
    'main' => 'm'
  }
}

initialized = {
  'main' => {
    '_m.group(2)' => 'S',
    'lines' => 'S',
    '_locals_stack' => 'h of S',
    'INPUT_RECORD_SEPARATOR' => 'm',
    'CHILD_ERROR' => 'I',
    'EVAL_ERROR' => 'S',
    'TRACEBACK' => 'I',
    '_DUP_MAP' => 'h of I',
    'AUTODIE' => 'I',
    'INPUT_LINE_NUMBER' => 'I',
    'OS_ERROR' => 'S',
    'os.name' => 'S',
    '__file__' => 'S',
    'os.environ' => 'h of s',
    '_m.group(1)' => 'u',
    'LIST_SEPARATOR' => 'S',
    'OUTPUT_AUTOFLUSH' => 'I',
    'blocks' => 'h of m',
    'sys.argv' => 'a of S',
    '_OPEN_MODE_MAP' => 'h of S',
    'BASETIME' => 'I'
  },
  'test' => {
    'j' => 'I',
    'i' => 'I'
  }
}

NeedsInitializing = {
  'main' => {
    'i' => 'I'
  }
}

NameMap = {
  'j' => {
    '$' => 'j'
  },
  'blocks' => {
    '%' => 'blocks'
  },
  'test4' => {
    '&' => 'test4'
  },
  'i' => {
    '$' => 'i'
  },
  'test' => {
    '&' => 'test'
  },
  'lines' => {
    '$' => 'lines'
  },
  'SRC' => {
    '' => 'SRC'
  }
}

sub_external_last_nexts = {}

line_needs_try_block = {}

SubAttributes = {}

line_substitutions = {}

line_varclasses = {
  '48' => {
    '$i' => 'global',
    '$1' => 'global',
    '$0' => 'global',
    '$j' => 'global',
    '$blocks' => 'global',
    '$2' => 'global',
    '%blocks' => 'global',
    '$lines' => 'global'
  },
  '52' => {
    '$lines' => 'global',
    '$blocks' => 'global',
    '$2' => 'global',
    '%blocks' => 'global',
    '$j' => 'global',
    '$0' => 'global',
    '$1' => 'global',
    '$i' => 'global'
  },
  '21' => {
    '$i' => 'global',
    '$j' => 'global'
  },
  '41' => {
    '$j' => 'global',
    '$0' => 'global',
    '$1' => 'global',
    '$i' => 'global',
    '$lines' => 'global',
    '%blocks' => 'global',
    '$blocks' => 'global',
    '$2' => 'global'
  },
  '37' => {
    '$j' => 'global',
    '$0' => 'global',
    '$i' => 'global',
    '$lines' => 'global',
    '%blocks' => 'global'
  },
  '35' => {
    '$j' => 'global',
    '$lines' => 'global',
    '$0' => 'global',
    '$i' => 'global',
    '%blocks' => 'global'
  },
  '43' => $VAR1->{'41'},
  '39' => {
    '$0' => 'global',
    '$j' => 'global',
    '$i' => 'global',
    '$1' => 'global',
    '$lines' => 'global',
    '%blocks' => 'global',
    '$blocks' => 'global',
    '$2' => 'global'
  },
  '23' => {
    '$i' => 'global',
    '$j' => 'global'
  },
  '16' => {
    '$i' => 'global'
  },
  '46' => {
    '$blocks' => 'global',
    '$2' => 'global',
    '%blocks' => 'global',
    '$lines' => 'global',
    '$1' => 'global',
    '$i' => 'global',
    '$0' => 'global',
    '$j' => 'global'
  },
  '40' => $VAR1->{'39'},
  '44' => $VAR1->{'46'},
  '34' => {
    '%blocks' => 'global',
    '$i' => 'global',
    '$j' => 'global',
    '$0' => 'global'
  },
  '36' => {
    '$i' => 'global',
    '$0' => 'global',
    '$j' => 'global',
    '%blocks' => 'global',
    '$lines' => 'global'
  },
  '50' => {
    '$i' => 'global',
    '$1' => 'global',
    '$0' => 'global',
    '$j' => 'global',
    '%blocks' => 'global',
    '$blocks' => 'global',
    '$2' => 'global',
    '$lines' => 'global'
  },
  '29' => $VAR1->{'23'},
  '49' => $VAR1->{'48'},
  '33' => {
    '$i' => 'global',
    '$j' => 'global',
    '$0' => 'global'
  },
  '47' => {
    '$blocks' => 'global',
    '$2' => 'global',
    '%blocks' => 'global',
    '$lines' => 'global',
    '$i' => 'global',
    '$1' => 'global',
    '$j' => 'global',
    '$0' => 'global'
  },
  '22' => $VAR1->{'23'},
  '45' => $VAR1->{'46'},
  '42' => $VAR1->{'41'},
  '38' => {
    '$blocks' => 'global',
    '%blocks' => 'global',
    '$lines' => 'global',
    '$1' => 'global',
    '$i' => 'global',
    '$0' => 'global',
    '$j' => 'global'
  },
  '15' => {}
}

LocalSub = {'test' => 1,'main' => 1,'test4' => 1}
PotentialSub = {'test4' => 1,'test' => 1,'SRC' => 1}

DETECTED GLOBAL VARIABLES:

AUTO-INITIALIZED VARIABLES:

List of local subroutines:
test main test4
mkdir: cannot create directory ‘/c/Users/Joe’: File exists
cp: target 'Orost/Archive/pythonizer' is not a directory
Use of uninitialized value $mylib in concatenation (.) or string at ../Softpano.pm line 55, <> line 53.
cp: target 'Orost/Archive/Softpano.pm' is not a directory
Use of uninitialized value $mylib in concatenation (.) or string at ../Softpano.pm line 55, <> line 53.
cp: target 'Orost/Archive/Perlscan.pm' is not a directory
Use of uninitialized value $mylib in concatenation (.) or string at ../Softpano.pm line 55, <> line 53.
cp: target 'Orost/Archive/Pythonizer.pm' is not a directory
   1 | 0 |   |#!/usr/bin/python3 -u
   1 | 0 |   |# Generated by pythonizer 0.938 run by Joe Orost on Mon Jan 10 01:12:07 2022
   1 | 0 |   |# Pythonizer was scrambling comments - test that isn't the case anymore
   2 | 0 |   |
   3 | 0 |   |import sys,os,re,fcntl,math,fileinput,subprocess,collections.abc,argparse,glob,warnings,inspect,functools,signal,traceback,io,tempfile,atexit,calendar,types,pdb,random,stat,dataclasses
   3 | 0 |   |import time as tm_py
   3 | 0 |   |_str = lambda s: '' if s is None else str(s)
   3 | 0 |   |TRACEBACK = 0
   3 | 0 |   |AUTODIE = 0
   3 | 0 |   |INPUT_LINE_NUMBER = 0
   3 | 0 |   |_DUP_MAP = dict(STDIN=0, STDOUT=1, STDERR=2)
   3 | 0 |   |_locals_stack = []
   3 | 0 |   |CHILD_ERROR = 0
   3 | 0 |   |INPUT_RECORD_SEPARATOR = "\n"
   3 | 0 |   |OUTPUT_AUTOFLUSH = 0
   3 | 0 |   |LIST_SEPARATOR = ' '
   3 | 0 |   |BASETIME = tm_py.time()
   3 | 0 |   |_OPEN_MODE_MAP = {'<': 'r', '>': 'w', '+<': 'r+', '+>': 'w+', '>>': 'a', '+>>': 'a+', '|': '|-'}
   3 | 0 |   |OS_ERROR = ''
   3 | 0 |   |class Die(Exception):
    pass
   3 | 0 |   |class EvalReturn(Exception):
    pass
   3 | 0 |   |class LoopControl(Exception):
    pass
   3 | 0 |   |_args = sys.argv[1:]
Main loop, line=use Carp::Assert;, BufferValClass=, deferred_statement=0


 === Line 3 Perl source:use Carp::Assert;===

Lexem 0 Current token='k' perl='use' value='import' Tokenstr |k| translated: import
Lexem 1 Current token='i' perl='Carp::Assert' value='Carp.Assert' Tokenstr |ki| translated: import Carp.Assert

Line:    3 TokenStr: =|ki|= @ValPy: import Carp.Assert
fix_type_issues(0, 1, )
fix_type_issues(0, 1, ): checking use at 0, limit=1
fix_type_issues(0, 1, ): checking Carp::Assert at 1, limit=1
insert_converter(0, 1, 0, 1, ): for =|ki|=, use, t=, converter=
do_use_require(0)
   3 | 0 |   |#SKIPPED: use Carp::Assert;
do_use_require(0) returns 2
  10 | 0 |   |
  10 | 0 |   |#BLOCK 1: 4
  10 | 0 |   |#BLOCK 1: 3
  10 | 0 |   |#BLOCK 1: 2
  10 | 0 |   |#BLOCK 1: 1
  10 | 0 |   |
Main loop, line=sub test, BufferValClass=, deferred_statement=0


 === Line 10 Perl source:sub test===

Lexem 0 Current token='k' perl='sub' value='def' Tokenstr |k| translated: def
  11 | 0 |   |#BLOCK 2: 1
  12 | 0 |   |#BLOCK 2: 2
  13 | 0 |   |#BLOCK 2: 3
  14 | 0 |   |#BLOCK 2: 4
Lexem 1 Current token='i' perl='test' value='test' Tokenstr |ki| translated: def test
enter_block at line 15, prior nesting_level=0, ValPerl=sub test {
nesting_info=type def is_sub 1 level 0 is_loop  is_eval  in_loop 0 in_sub 1 cur_sub test lno 15 varclasses HASH(0x800b84500)

Line:   15 TokenStr: =|ki|= @ValPy: def test
fix_type_issues(0, 1, )
Generated partial line deftest(*_args):
  15 | 0 |   |def test(*_args):                                                                       #PL: ^

Tokens: ki ValPy: 
Main loop, line=^, BufferValClass=, deferred_statement=0


 === Line 15 Perl source:^===


Line:   15 TokenStr: =|{|= @ValPy: {
fix_type_issues(0, 0, )
fix_type_issues(0, 0, ): checking { at 0, limit=0
insert_converter(0, 0, 0, 0, ): for =|{|=, {, t=, converter=
needs_try_block(0), top=type def is_sub 1 level 0 is_loop  is_eval  in_loop 0 in_sub 1 cur_sub test lno 15 varclasses HASH(0x800b84500)
needs_try_block(0), top=type def is_sub 1 level 0 is_loop  is_eval  in_loop 0 in_sub 1 cur_sub test lno 15 varclasses HASH(0x800b84500)
Main loop, line=$i = 1;             #LINE 1, BufferValClass=, deferred_statement=0


 === Line 16 Perl source:$i = 1;             #LINE 1===

Lexem 0 Current token='s' perl='$i' value='i' Tokenstr |s| translated: i
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: i =
Lexem 2 Current token='d' perl='1' value='1' Tokenstr |s=d| translated: i = 1

Line:   16 TokenStr: =|s=d|= @ValPy: i = 1
fix_type_issues(0, 2, )
fix_type_issues(0, 2, ): checking $i at 0, limit=2
insert_converter(0, 2, 0, 0, ): for =|s=d|=, $i, t=, converter=
fix_type_issues(0, 2, ): checking = at 1, limit=2
fix_type_issues(0, 2, ): checking 1 at 2, limit=2
insert_converter(0, 2, 2, 2, ): for =|s=d|=, 1, t=, converter=
insert_converter(0, 2, 0, 2, ): for =|s=d|=, $i, t=, converter=
assignment(0, 2) =|s=d|= $i = 1

Generated partial line i
Generated partial line i=
assign, ValClass[limit] = d, ValPy=1, ValPerl=1

Generated partial line i=1
  21 | 1 |   |    i = 1     #LINE 1
                                                                                                      #PL: $j = 2;

Tokens: s=d ValPy: 
  21 | 1 |   |    #BLOCK 3: 4
  21 | 1 |   |    #BLOCK 3: 3
  21 | 1 |   |    #BLOCK 3: 2
  21 | 1 |   |    #BLOCK 3: 1
Main loop, line=$j = 2;             #LINE 2, BufferValClass=, deferred_statement=0


 === Line 21 Perl source:$j = 2;             #LINE 2===

Lexem 0 Current token='s' perl='$j' value='j' Tokenstr |s| translated: j
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: j =
Lexem 2 Current token='d' perl='2' value='2' Tokenstr |s=d| translated: j = 2

Line:   21 TokenStr: =|s=d|= @ValPy: j = 2
fix_type_issues(0, 2, )
fix_type_issues(0, 2, ): checking $j at 0, limit=2
insert_converter(0, 2, 0, 0, ): for =|s=d|=, $j, t=, converter=
fix_type_issues(0, 2, ): checking = at 1, limit=2
fix_type_issues(0, 2, ): checking 2 at 2, limit=2
insert_converter(0, 2, 2, 2, ): for =|s=d|=, 2, t=, converter=
insert_converter(0, 2, 0, 2, ): for =|s=d|=, $j, t=, converter=
assignment(0, 2) =|s=d|= $j = 2

Generated partial line j
Generated partial line j=
assign, ValClass[limit] = d, ValPy=2, ValPerl=2

Generated partial line j=2
  22 | 1 |   |    j = 2     #LINE 2
                                                                                                      #PL: 

Tokens: s=d ValPy: 
Main loop, line=$i + $j;, BufferValClass=, deferred_statement=0


 === Line 22 Perl source:$i + $j;===

Lexem 0 Current token='s' perl='$i' value='i' Tokenstr |s| translated: i
Lexem 1 Current token='+' perl='+' value='+' Tokenstr |s+| translated: i +
Lexem 2 Current token='s' perl='$j' value='j' Tokenstr |s+s| translated: i + j

Line:   22 TokenStr: =|s+s|= @ValPy: i + j
fix_type_issues(0, 2, )
fix_type_issues(0, 2, ): checking $i at 0, limit=2
>expr_type(0, 0, test)
<expr_type(0, 0, test) = I
insert_converter(0, 2, 0, 0, ): for =|s+s|=, $i, t=N, converter=
fix_type_issues(0, 2, ): checking + at 1, limit=2
fix_type_issues(0, 2, ): checking $j at 2, limit=2
>expr_type(2, 2, test)
<expr_type(2, 2, test) = I
insert_converter(0, 2, 2, 2, ): for =|s+s|=, $j, t=N, converter=
insert_converter(0, 2, 0, 2, ): for =|s+s|=, $i, t=, converter=
assignment(0, 2) =|s+s|= $i + $j

finish: prev_line=$i + $j;, PythonCode=
finish: Resetting line to return $i + $j;
Main loop, line=return $i + $j;, BufferValClass=, deferred_statement=0


 === Line 23 Perl source:return $i + $j;===

Lexem 0 Current token='k' perl='return' value='return' Tokenstr |k| translated: return
Lexem 1 Current token='s' perl='$i' value='i' Tokenstr |ks| translated: return i
Lexem 2 Current token='+' perl='+' value='+' Tokenstr |ks+| translated: return i +
Lexem 3 Current token='s' perl='$j' value='j' Tokenstr |ks+s| translated: return i + j

Line:   23 TokenStr: =|ks+s|= @ValPy: return i + j
fix_type_issues(0, 3, )
fix_type_issues(0, 3, ): checking return at 0, limit=3
fix_type_issues(0, 3, ): checking $i at 1, limit=3
>expr_type(1, 1, test)
<expr_type(1, 1, test) = I
insert_converter(0, 3, 1, 1, ): for =|ks+s|=, $i, t=N, converter=
fix_type_issues(0, 3, ): checking + at 2, limit=3
fix_type_issues(0, 3, ): checking $j at 3, limit=3
>expr_type(3, 3, test)
<expr_type(3, 3, test) = I
insert_converter(0, 3, 3, 3, ): for =|ks+s|=, $j, t=N, converter=
insert_converter(0, 3, 0, 3, ): for =|ks+s|=, return, t=, converter=
Generated partial line return
>expression(1, 3, 0) =|ks+s|= return $i + $j

Generated partial line returni
Generated partial line returni+
Generated partial line returni+j
<expression returns 4
  23 | 1 |   |    return i+j                                                                          #PL: 

Tokens: ks+s ValPy: 
Main loop, line=}, BufferValClass=, deferred_statement=0


 === Line 23 Perl source:}===

exit_block at line 23, prior nesting_level=1, nesting_last->{type} is now def

Line:   23 TokenStr: =|}|= @ValPy: }
fix_type_issues(0, 0, )
fix_type_issues(0, 0, ): checking } at 0, limit=0
insert_converter(0, 0, 0, 0, ): for =|}|=, }, t=, converter=
needs_try_block(1), top=type def is_sub 1 level 0 is_loop  is_eval  in_loop 0 in_sub 1 cur_sub test lno 15 varclasses HASH(0x800b84500)
initialize_globals_for_state_vars: 
  29 | 0 |   |#BLOCK 4: 4
  29 | 0 |   |#BLOCK 4: 3
  29 | 0 |   |#BLOCK 4: 2
  29 | 0 |   |#BLOCK 4: 1
  29 | 0 |   |
Main loop, line=sub test4{ 1 };         #LINE 3, BufferValClass=, deferred_statement=0


 === Line 29 Perl source:sub test4{ 1 };         #LINE 3===

Lexem 0 Current token='k' perl='sub' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' perl='test4' value='test4' Tokenstr |ki| translated: def test4
enter_block at line 29, prior nesting_level=0, ValPerl=sub test4 {
nesting_info=level 0 is_sub 1 type def is_eval  is_loop  in_loop 0 varclasses HASH(0x800b52c00) lno 29 cur_sub test4 in_sub 1

Line:   29 TokenStr: =|ki|= @ValPy: def test4
fix_type_issues(0, 1, )
Generated partial line deftest4(*_args):
  29 | 0 |   |def test4(*_args):                                                                      #PL: ^

Tokens: ki ValPy: 
Main loop, line=^, BufferValClass=, deferred_statement=0


 === Line 29 Perl source:^===


Line:   29 TokenStr: =|{|= @ValPy: {
fix_type_issues(0, 0, )
fix_type_issues(0, 0, ): checking { at 0, limit=0
insert_converter(0, 0, 0, 0, ): for =|{|=, {, t=, converter=
needs_try_block(0), top=level 0 is_sub 1 type def is_eval  is_loop  in_loop 0 varclasses HASH(0x800b52c00) lno 29 cur_sub test4 in_sub 1
needs_try_block(0), top=level 0 is_sub 1 type def is_eval  is_loop  in_loop 0 varclasses HASH(0x800b52c00) lno 29 cur_sub test4 in_sub 1
Main loop, line=1 };         #LINE 3, BufferValClass=, deferred_statement=0


 === Line 29 Perl source:1 };         #LINE 3===

Lexem 0 Current token='d' perl='1' value='1' Tokenstr |d| translated: 1

Line:   29 TokenStr: =|d|= @ValPy: 1
fix_type_issues(0, 0, )
fix_type_issues(0, 0, ): checking 1 at 0, limit=0
insert_converter(0, 0, 0, 0, ): for =|d|=, 1, t=, converter=
insert_converter(0, 0, 0, 0, ): for =|d|=, 1, t=, converter=
Main loop, line=};         #LINE 3, BufferValClass=, deferred_statement=0


 === Line 29 Perl source:};         #LINE 3===

exit_block at line 29, prior nesting_level=1, nesting_last->{type} is now def

Line:   29 TokenStr: =|}|= @ValPy: }
fix_type_issues(0, 0, )
fix_type_issues(0, 0, ): checking } at 0, limit=0
insert_converter(0, 0, 0, 0, ): for =|}|=, }, t=, converter=
  29 | 1 |   |    pass                                                                                #PL: };         #LINE 3

Tokens: } ValPy: 
needs_try_block(1), top=level 0 is_sub 1 type def is_eval  is_loop  in_loop 0 varclasses HASH(0x800b52c00) lno 29 cur_sub test4 in_sub 1
initialize_globals_for_state_vars: 
Main loop, line=;         #LINE 3, BufferValClass=, deferred_statement=0


 === Line 29 Perl source:;         #LINE 3===


Line:   29 TokenStr: =||= @ValPy: 
  29 | 0 |   |pass                                                                                    #PL: ;         #LINE 3

Tokens:  ValPy: 
  29 | 0 |   |#LINE 3
  30 | 0 |   |
Main loop, line=assert(test() == 3);, BufferValClass=, deferred_statement=0


 === Line 31 Perl source:assert(test() == 3);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='i' perl='test' value='test' Tokenstr |c(i| translated: assert ( test
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(i(| translated: assert ( test (
Lexem 4 Current token=')' perl=')' value=')' Tokenstr |c(i()| translated: assert ( test ( )
Lexem 5 Current token='>' perl='==' value='==' Tokenstr |c(i()>| translated: assert ( test ( ) ==
Lexem 6 Current token='d' perl='3' value='3' Tokenstr |c(i()>d| translated: assert ( test ( ) == 3
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |c(i()>d)| translated: assert ( test ( ) == 3 )

Line:   31 TokenStr: =|c(i()>d)|= @ValPy: assert ( test ( ) == 3 )
fix_type_issues(0, 7, )
fix_type_issues(0, 7, ): checking assert at 0, limit=7
fix_type_issues(0, 7, ): checking ( at 1, limit=7
fix_type_issues(0, 7, ): checking test at 2, limit=7
>expr_type(2, 4, main)
<expr_type(2, 4, main) = N
insert_converter(0, 7, 2, 4, ): for =|c(i()>d)|=, test, t=N, converter=
fix_type_issues(0, 7, ): checking == at 5, limit=7
fix_type_issues(0, 7, ): checking 3 at 6, limit=7
>expr_type(6, 6, main)
<expr_type(6, 6, main) = I
insert_converter(0, 7, 6, 6, ): for =|c(i()>d)|=, 3, t=N, converter=
fix_type_issues(0, 7, ): checking ) at 7, limit=7
insert_converter(0, 7, 0, 7, ): for =|c(i()>d)|=, assert, t=, converter=
control(0) =|c(i()>d)|= assert ( test ( ) == 3 )

control-parens removed, begin=0 start=1 =|ci()>d|= assert test ( ) == 3

Generated partial line assert
>expression(1, 5, 0) =|ci()>d|= assert test ( ) == 3

Generated partial line asserttest
Generated partial line asserttest(
Generated partial line asserttest()
Generated partial line asserttest()==
Generated partial line asserttest()==3
<expression returns 6
  32 | 0 |   |assert test() == 3                                                                      #PL: assert(test4() == 1);   #LINE 4

Tokens: ci()>d ValPy: 
Main loop, line=assert(test4() == 1);   #LINE 4, BufferValClass=, deferred_statement=0


 === Line 32 Perl source:assert(test4() == 1);   #LINE 4===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='i' perl='test4' value='test4' Tokenstr |c(i| translated: assert ( test4
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(i(| translated: assert ( test4 (
Lexem 4 Current token=')' perl=')' value=')' Tokenstr |c(i()| translated: assert ( test4 ( )
Lexem 5 Current token='>' perl='==' value='==' Tokenstr |c(i()>| translated: assert ( test4 ( ) ==
Lexem 6 Current token='d' perl='1' value='1' Tokenstr |c(i()>d| translated: assert ( test4 ( ) == 1
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |c(i()>d)| translated: assert ( test4 ( ) == 1 )

Line:   32 TokenStr: =|c(i()>d)|= @ValPy: assert ( test4 ( ) == 1 )
fix_type_issues(0, 7, )
fix_type_issues(0, 7, ): checking assert at 0, limit=7
fix_type_issues(0, 7, ): checking ( at 1, limit=7
fix_type_issues(0, 7, ): checking test4 at 2, limit=7
>expr_type(2, 4, main)
<expr_type(2, 4, main) = I
insert_converter(0, 7, 2, 4, ): for =|c(i()>d)|=, test4, t=N, converter=
fix_type_issues(0, 7, ): checking == at 5, limit=7
fix_type_issues(0, 7, ): checking 1 at 6, limit=7
>expr_type(6, 6, main)
<expr_type(6, 6, main) = I
insert_converter(0, 7, 6, 6, ): for =|c(i()>d)|=, 1, t=N, converter=
fix_type_issues(0, 7, ): checking ) at 7, limit=7
insert_converter(0, 7, 0, 7, ): for =|c(i()>d)|=, assert, t=, converter=
control(0) =|c(i()>d)|= assert ( test4 ( ) == 1 )

control-parens removed, begin=0 start=1 =|ci()>d|= assert test4 ( ) == 1

Generated partial line assert
>expression(1, 5, 0) =|ci()>d|= assert test4 ( ) == 1

Generated partial line asserttest4
Generated partial line asserttest4(
Generated partial line asserttest4()
Generated partial line asserttest4()==
Generated partial line asserttest4()==1
<expression returns 6
  33 | 0 |   |assert test4() == 1 #LINE 4
                                                                                                      #PL: open(SR

Tokens: ci()>d ValPy: 
Main loop, line=open(SRC, "<$0");, BufferValClass=, deferred_statement=0


 === Line 33 Perl source:open(SRC, "<$0");===

Lexem 0 Current token='f' perl='open' value='open' Tokenstr |f| translated: open
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |f(| translated: open (
Lexem 2 Current token='i' perl='SRC' value='SRC' Tokenstr |f(i| translated: open ( SRC
Lexem 3 Current token=',' perl=',' value=',' Tokenstr |f(i,| translated: open ( SRC ,
>interpolate_strings(<$0, <$0, 5, 1, 0)
<interpolate_strings(, <$0, 5, 1, 0)=5, ValPy[4]=f"<{__file__}"
Lexem 4 Current token='"' perl='<$0' value='f"<{__file__}"' Tokenstr |f(i,"| translated: open ( SRC , f"<{__file__}"
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |f(i,")| translated: open ( SRC , f"<{__file__}" )

Line:   33 TokenStr: =|f(i,")|= @ValPy: open ( SRC , f"<{__file__}" )
fix_type_issues(0, 5, )
fix_type_issues(0, 5, ): checking open at 0, limit=5
fix_type_issues(4, 4, S)
fix_type_issues(4, 4, S): checking <$0 at 4, limit=4
>expr_type(4, 4, main)
<expr_type(4, 4, main) = S
insert_converter(4, 4, 4, 4, S): for =|f(i,")|=, <$0, t=S, converter=
>expr_type(4, 4, main)
<expr_type(4, 4, main) = S
insert_converter(4, 4, 4, 4, S): for =|f(i,")|=, <$0, t=S, converter=
insert_converter(0, 5, 0, 5, ): for =|f(i,")|=, open, t=, converter=
insert_converter(0, 5, 0, 5, ): for =|f(i,")|=, open, t=, converter=
  33 | 0 |   |SRC = _open(f"{__file__}", 'r', checked=False)                                          #PL: open(SRC, "<$0");
Main loop, line=%blocks = ();, BufferValClass=, deferred_statement=0


 === Line 34 Perl source:%blocks = ();===

Lexem 0 Current token='h' perl='%blocks' value='blocks' Tokenstr |h| translated: blocks
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |h=| translated: blocks =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |h=(| translated: blocks = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |h=()| translated: blocks = ( )

Line:   34 TokenStr: =|h=()|= @ValPy: blocks = ( )
fix_type_issues(0, 3, )
fix_type_issues(0, 3, ): checking %blocks at 0, limit=3
fix_type_issues(0, 3, ): checking = at 1, limit=3
fix_type_issues(0, 3, ): checking ( at 2, limit=3
fix_type_issues(0, 3, ): checking ) at 3, limit=3
insert_converter(0, 3, 0, 3, ): for =|h=()|=, %blocks, t=, converter=
Generated partial line blocks = {
Generated partial line blocks = {}
  35 | 0 |   |blocks = {}                                                                             #PL: $lines = '';

Tokens: h=() ValPy: 
Main loop, line=$lines = '';, BufferValClass=, deferred_statement=0


 === Line 35 Perl source:$lines = '';===

Lexem 0 Current token='s' perl='$lines' value='lines' Tokenstr |s| translated: lines
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: lines =
Lexem 2 Current token='"' perl='' value='''' Tokenstr |s="| translated: lines = ''

Line:   35 TokenStr: =|s="|= @ValPy: lines = ''
fix_type_issues(0, 2, )
fix_type_issues(0, 2, ): checking $lines at 0, limit=2
insert_converter(0, 2, 0, 0, ): for =|s="|=, $lines, t=, converter=
fix_type_issues(0, 2, ): checking = at 1, limit=2
fix_type_issues(0, 2, ): checking  at 2, limit=2
insert_converter(0, 2, 2, 2, ): for =|s="|=, , t=, converter=
insert_converter(0, 2, 0, 2, ): for =|s="|=, $lines, t=, converter=
assignment(0, 2) =|s="|= $lines = 

Generated partial line lines
Generated partial line lines=
assign, ValClass[limit] = ", ValPy='', ValPerl=

Generated partial line lines=''
  36 | 0 |   |lines = ''                                                                              #PL: while(<SRC>) {

Tokens: s=" ValPy: 
Main loop, line=while(<SRC>) {, BufferValClass=, deferred_statement=0


 === Line 36 Perl source:while(<SRC>) {===

Lexem 0 Current token='c' perl='while' value='while' Tokenstr |c| translated: while
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: while (
Lexem 2 Current token='j' perl='<SRC>' value='_readline(SRC)' Tokenstr |c(j| translated: while ( _readline(SRC)
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(j)| translated: while ( _readline(SRC) )
enter_block at line 36, prior nesting_level=0, ValPerl=while ( <SRC> ) {
nesting_info=is_loop 1 is_eval  type while is_sub  level 0 in_sub 0 cur_sub  lno 36 varclasses HASH(0x80079fa08) in_loop 1

Line:   36 TokenStr: =|c(j)|= @ValPy: while ( _readline(SRC) )
fix_type_issues(0, 3, )
fix_type_issues(0, 3, ): checking while at 0, limit=3
fix_type_issues(0, 3, ): checking ( at 1, limit=3
fix_type_issues(0, 3, ): checking <SRC> at 2, limit=3
fix_type_issues(0, 3, ): checking ) at 3, limit=3
insert_converter(0, 3, 0, 3, ): for =|c(j)|=, while, t=, converter=
control(0) =|c(j)|= while ( <SRC> )

control-parens removed, begin=0 start=1 =|cj|= while <SRC>

Generated partial line while (_d:=_readline(SRC))
Generated partial line while (_d:=_readline(SRC)):
  36 | 0 |   |while (_d:=_readline(SRC)):                                                             #PL: ^

Tokens: cj ValPy: 
Main loop, line=^, BufferValClass=, deferred_statement=0


 === Line 36 Perl source:^===


Line:   36 TokenStr: =|{|= @ValPy: {
fix_type_issues(0, 0, )
fix_type_issues(0, 0, ): checking { at 0, limit=0
insert_converter(0, 0, 0, 0, ): for =|{|=, {, t=, converter=
needs_try_block(0), top=is_loop 1 is_eval  type while is_sub  level 0 in_sub 0 cur_sub  lno 36 varclasses HASH(0x80079fa08) in_loop 1
needs_try_block(0), top=is_loop 1 is_eval  type while is_sub  level 0 in_sub 0 cur_sub  lno 36 varclasses HASH(0x80079fa08) in_loop 1
Main loop, line=if(/#BLOCK (\d): (\d)/) {, BufferValClass=, deferred_statement=0


 === Line 37 Perl source:if(/#BLOCK (\d): (\d)/) {===

Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
perl_match(#BLOCK (\d): (\d), /, #BLOCK (\d): (\d)): modifier=r, groups_are_present=1
put_regex_in_quotes(#BLOCK (\d): (\d), /, #BLOCK (\d): (\d))
>interpolate_strings(#BLOCK (\d): (\d), #BLOCK (\d): (\d), 0, 0, 1)
<interpolate_strings(#BLOCK (\d): (\d), #BLOCK (\d): (\d), 0, 0, 1)=0, ValPy[2]='#BLOCK (\d): (\d)'
Lexem 2 Current token='q' perl='#BLOCK (\d): (\d)' value='(_m:=re.search(r'#BLOCK (\d): (\d)',_d))' Tokenstr |c(q| translated: if  ( (_m:=re.search(r'#BLOCK (\d): (\d)',_d))
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(q)| translated: if  ( (_m:=re.search(r'#BLOCK (\d): (\d)',_d)) )
enter_block at line 37, prior nesting_level=1, ValPerl=if ( #BLOCK (\d): (\d) ) {
nesting_info=level 1 type if  is_sub  is_loop  is_eval  in_loop 1 lno 37 varclasses HASH(0x800b00a68) in_sub 0 cur_sub 

Line:   37 TokenStr: =|c(q)|= @ValPy: if  ( (_m:=re.search(r'#BLOCK (\d): (\d)',_d)) )
fix_type_issues(0, 3, )
fix_type_issues(0, 3, ): checking if at 0, limit=3
fix_type_issues(0, 3, ): checking ( at 1, limit=3
fix_type_issues(0, 3, ): checking #BLOCK (\d): (\d) at 2, limit=3
fix_type_issues(0, 3, ): checking ) at 3, limit=3
insert_converter(0, 3, 0, 3, ): for =|c(q)|=, if, t=, converter=
control(0) =|c(q)|= if ( #BLOCK (\d): (\d) )

control-parens removed, begin=0 start=1 =|cq|= if #BLOCK (\d): (\d)

Generated partial line if 
>expression(1, 1, 0) =|cq|= if #BLOCK (\d): (\d)

Generated partial line if (_m:=re.search(r'#BLOCK (\d): (\d)',_d))
<expression returns 2
Generated partial line if (_m:=re.search(r'#BLOCK (\d): (\d)',_d)):
  37 | 1 |   |    if (_m:=re.search(r'#BLOCK (\d): (\d)',_d)):                                        #PL: ^

Tokens: cq ValPy: 
Main loop, line=^, BufferValClass=, deferred_statement=0


 === Line 37 Perl source:^===


Line:   37 TokenStr: =|{|= @ValPy: {
fix_type_issues(0, 0, )
fix_type_issues(0, 0, ): checking { at 0, limit=0
insert_converter(0, 0, 0, 0, ): for =|{|=, {, t=, converter=
needs_try_block(0), top=level 1 type if  is_sub  is_loop  is_eval  in_loop 1 lno 37 varclasses HASH(0x800b00a68) in_sub 0 cur_sub 
needs_try_block(0), top=level 1 type if  is_sub  is_loop  is_eval  in_loop 1 lno 37 varclasses HASH(0x800b00a68) in_sub 0 cur_sub 
Main loop, line=if(!exists $blocks{$1}) {, BufferValClass=, deferred_statement=0


 === Line 38 Perl source:if(!exists $blocks{$1}) {===

Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='!' perl='!' value='not' Tokenstr |c(!| translated: if  ( not
Lexem 3 Current token='f' perl='exists' value='in' Tokenstr |c(!f| translated: if  ( not in
Lexem 4 Current token='s' perl='$blocks' value='blocks' Tokenstr |c(!fs| translated: if  ( not in blocks
Lexem 5 Current token='(' perl='{' value='[' Tokenstr |c(!fs(| translated: if  ( not in blocks [
Lexem 6 Current token='s' perl='$1' value='_m.group(1)' Tokenstr |c(!fs(s| translated: if  ( not in blocks [ _m.group(1)
Lexem 7 Current token=')' perl='}' value=']' Tokenstr |c(!fs(s)| translated: if  ( not in blocks [ _m.group(1) ]
Lexem 8 Current token=')' perl=')' value=')' Tokenstr |c(!fs(s))| translated: if  ( not in blocks [ _m.group(1) ] )
enter_block at line 38, prior nesting_level=2, ValPerl=if ( ! exists $blocks { $1 } ) {
nesting_info=level 2 is_sub  type if  is_eval  is_loop  in_loop 1 varclasses HASH(0x800b52180) lno 38 cur_sub  in_sub 0

Line:   38 TokenStr: =|c(!fs(s))|= @ValPy: if  ( not in blocks [ _m.group(1) ] )
fix_type_issues(0, 8, )
fix_type_issues(0, 8, ): checking if at 0, limit=8
fix_type_issues(0, 8, ): checking ( at 1, limit=8
fix_type_issues(0, 8, ): checking ! at 2, limit=8
fix_type_issues(0, 8, ): checking exists at 3, limit=8
fix_type_issues(4, 8, u)
fix_type_issues(4, 8, u): checking $blocks at 4, limit=8
fix_type_issues(6, 6, S)
fix_type_issues(6, 6, S): checking $1 at 6, limit=6
>expr_type(6, 6, main)
<expr_type(6, 6, main) = S
insert_converter(6, 6, 6, 6, S): for =|c(!fs(s))|=, $1, t=S, converter=
>expr_type(6, 6, main)
<expr_type(6, 6, main) = S
insert_converter(6, 6, 6, 6, S): for =|c(!fs(s))|=, $1, t=S, converter=
insert_converter(4, 8, 4, 7, u): for =|c(!fs(s))|=, $blocks, t=u, converter=
fix_type_issues(4, 8, u): checking ) at 8, limit=8
insert_converter(4, 8, 4, 8, u): for =|c(!fs(s))|=, $blocks, t=u, converter=
insert_converter(0, 8, 3, 8, ): for =|c(!fs(s))|=, exists, t=, converter=
insert_converter(0, 8, 0, 8, ): for =|c(!fs(s))|=, if, t=, converter=
control(0) =|c(!fs(s))|= if ( ! exists $blocks { $1 } )

control-parens removed, begin=0 start=1 =|c!fs(s)|= if ! exists $blocks { $1 }

Generated partial line if 
>expression(1, 6, 0) =|c!fs(s)|= if ! exists $blocks { $1 }

Generated partial line if not
function(2, 6) =|c!fs(s)|= if ! exists $blocks { $1 }
function start=3, end_pos=6, bracketed=0
exists k=3, key_start=4, length(ValPerl)=6, end_pos=6, limit=6

>>expression(5, 5, 0) =|c!fs(s)|= if ! exists $blocks { $1 }

Generated partial line if not_m.group(1)
<<expression returns 6
Generated partial line if not_m.group(1)in
>>expression(3, 3, 0) =|c!fs(s)|= if ! exists $blocks { $1 }

Generated partial line if not_m.group(1)inblocks
<<expression returns 4
function returns 7
<expression returns 7
Generated partial line if not_m.group(1)inblocks:
  38 | 2 |   |        if not _m.group(1) in blocks:                                                   #PL: ^

Tokens: c!fs(s) ValPy: 
Main loop, line=^, BufferValClass=, deferred_statement=0


 === Line 38 Perl source:^===


Line:   38 TokenStr: =|{|= @ValPy: {
fix_type_issues(0, 0, )
fix_type_issues(0, 0, ): checking { at 0, limit=0
insert_converter(0, 0, 0, 0, ): for =|{|=, {, t=, converter=
needs_try_block(0), top=level 2 is_sub  type if  is_eval  is_loop  in_loop 1 varclasses HASH(0x800b52180) lno 38 cur_sub  in_sub 0
needs_try_block(0), top=level 2 is_sub  type if  is_eval  is_loop  in_loop 1 varclasses HASH(0x800b52180) lno 38 cur_sub  in_sub 0
Main loop, line=$blocks{$1} = $2;, BufferValClass=, deferred_statement=0


 === Line 39 Perl source:$blocks{$1} = $2;===

Lexem 0 Current token='s' perl='$blocks' value='blocks' Tokenstr |s| translated: blocks
Lexem 1 Current token='(' perl='{' value='[' Tokenstr |s(| translated: blocks [
Lexem 2 Current token='s' perl='$1' value='_m.group(1)' Tokenstr |s(s| translated: blocks [ _m.group(1)
Lexem 3 Current token=')' perl='}' value=']' Tokenstr |s(s)| translated: blocks [ _m.group(1) ]
Lexem 4 Current token='=' perl='=' value='=' Tokenstr |s(s)=| translated: blocks [ _m.group(1) ] =
Lexem 5 Current token='s' perl='$2' value='_m.group(2)' Tokenstr |s(s)=s| translated: blocks [ _m.group(1) ] = _m.group(2)

Line:   39 TokenStr: =|s(s)=s|= @ValPy: blocks [ _m.group(1) ] = _m.group(2)
fix_type_issues(0, 5, )
fix_type_issues(0, 5, ): checking $blocks at 0, limit=5
fix_type_issues(2, 2, S)
fix_type_issues(2, 2, S): checking $1 at 2, limit=2
>expr_type(2, 2, main)
<expr_type(2, 2, main) = S
insert_converter(2, 2, 2, 2, S): for =|s(s)=s|=, $1, t=S, converter=
>expr_type(2, 2, main)
<expr_type(2, 2, main) = S
insert_converter(2, 2, 2, 2, S): for =|s(s)=s|=, $1, t=S, converter=
insert_converter(0, 5, 0, 3, ): for =|s(s)=s|=, $blocks, t=, converter=
fix_type_issues(0, 5, ): checking = at 4, limit=5
fix_type_issues(0, 5, ): checking $2 at 5, limit=5
insert_converter(0, 5, 5, 5, ): for =|s(s)=s|=, $2, t=, converter=
insert_converter(0, 5, 0, 5, ): for =|s(s)=s|=, $blocks, t=, converter=
assignment(0, 5) =|s(s)=s|= $blocks { $1 } = $2

>expression(0, 3, 0) =|s(s)=s|= $blocks { $1 } = $2

Generated partial line blocks
Generated partial line blocks[
>>expression(2, 2, 0) =|s(s)=s|= $blocks { $1 } = $2

Generated partial line blocks[_m.group(1)
<<expression returns 3
Generated partial line blocks[_m.group(1)]
<expression returns 4
Generated partial line blocks[_m.group(1)]=
assign, ValClass[limit] = s, ValPy=_m.group(2), ValPerl=$2

Generated partial line blocks[_m.group(1)]=_m.group(2)
  40 | 3 |   |            blocks[_m.group(1)] = _m.group(2)                                           #PL: } else {

Tokens: s(s)=s ValPy: 
Main loop, line=} else {, BufferValClass=, deferred_statement=0


 === Line 40 Perl source:} else {===

exit_block at line 40, prior nesting_level=3, nesting_last->{type} is now if 

Line:   40 TokenStr: =|}|= @ValPy: }
fix_type_issues(0, 0, )
fix_type_issues(0, 0, ): checking } at 0, limit=0
insert_converter(0, 0, 0, 0, ): for =|}|=, }, t=, converter=
needs_try_block(1), top=level 2 is_sub  type if  is_eval  is_loop  in_loop 1 varclasses HASH(0x800b52180) lno 38 cur_sub  in_sub 0
Main loop, line=else {, BufferValClass=, deferred_statement=0


 === Line 40 Perl source:else {===

Lexem 0 Current token='C' perl='else' value='else: ' Tokenstr |C| translated: else: 
enter_block at line 40, prior nesting_level=2, ValPerl=else {
nesting_info=type else is_sub  level 2 is_loop  is_eval  in_loop 1 in_sub 0 cur_sub  lno 40 varclasses HASH(0x800436b30)

Line:   40 TokenStr: =|C|= @ValPy: else: 
fix_type_issues(0, 0, )
fix_type_issues(0, 0, ): checking else at 0, limit=0
insert_converter(0, 0, 0, 0, ): for =|C|=, else, t=, converter=
Generated partial line else:
  40 | 2 |   |        else:                                                                           #PL: else {

Tokens: C ValPy: 
Main loop, line=^, BufferValClass=, deferred_statement=0


 === Line 40 Perl source:^===


Line:   40 TokenStr: =|{|= @ValPy: {
fix_type_issues(0, 0, )
fix_type_issues(0, 0, ): checking { at 0, limit=0
insert_converter(0, 0, 0, 0, ): for =|{|=, {, t=, converter=
needs_try_block(0), top=type else is_sub  level 2 is_loop  is_eval  in_loop 1 in_sub 0 cur_sub  lno 40 varclasses HASH(0x800436b30)
needs_try_block(0), top=type else is_sub  level 2 is_loop  is_eval  in_loop 1 in_sub 0 cur_sub  lno 40 varclasses HASH(0x800436b30)
Main loop, line=$blocks{$1} .= $2;, BufferValClass=, deferred_statement=0


 === Line 41 Perl source:$blocks{$1} .= $2;===

Lexem 0 Current token='s' perl='$blocks' value='blocks' Tokenstr |s| translated: blocks
Lexem 1 Current token='(' perl='{' value='[' Tokenstr |s(| translated: blocks [
Lexem 2 Current token='s' perl='$1' value='_m.group(1)' Tokenstr |s(s| translated: blocks [ _m.group(1)
Lexem 3 Current token=')' perl='}' value=']' Tokenstr |s(s)| translated: blocks [ _m.group(1) ]
Lexem 4 Current token='=' perl='.=' value='+=' Tokenstr |s(s)=| translated: blocks [ _m.group(1) ] +=
Lexem 5 Current token='s' perl='$2' value='_m.group(2)' Tokenstr |s(s)=s| translated: blocks [ _m.group(1) ] += _m.group(2)

Line:   41 TokenStr: =|s(s)=s|= @ValPy: blocks [ _m.group(1) ] += _m.group(2)
fix_type_issues(0, 5, )
fix_type_issues(0, 5, ): checking $blocks at 0, limit=5
fix_type_issues(2, 2, S)
fix_type_issues(2, 2, S): checking $1 at 2, limit=2
>expr_type(2, 2, main)
<expr_type(2, 2, main) = S
insert_converter(2, 2, 2, 2, S): for =|s(s)=s|=, $1, t=S, converter=
>expr_type(2, 2, main)
<expr_type(2, 2, main) = S
insert_converter(2, 2, 2, 2, S): for =|s(s)=s|=, $1, t=S, converter=
>expr_type(0, 3, main)
<expr_type(0, 3, main) = m
insert_converter(0, 5, 0, 3, ): for =|s(s)=s|=, $blocks, t=S, converter=_str
Use of uninitialized value $type in concatenation (.) or string at ../pythonizer line 1263, <> line 41.
insert_converter(0, 5, 0, 3, ): for =|s(s)=s|=, $blocks, t=S, converter=_str - calling expand_augmented_assignment
expand_augmented_assignment(0, 4) simple: gives =|s(s)=s(s).s|=, ValPy=blocks [ _m.group(1) ] = blocks [ _m.group(1) ] + _m.group(2), new_start=5, new_end=8, adjust=5
insert_converter(0, 10, 5, 8, ): new =|s(s)=f(s(s)).s|=, _str, result = 3+5
fix_type_issues(0, 13, ): checking . at 12, limit=13
fix_type_issues(0, 13, ): checking $2 at 13, limit=13
>expr_type(13, 13, main)
<expr_type(13, 13, main) = S
insert_converter(0, 13, 13, 13, ): for =|s(s)=f(s(s)).s|=, $2, t=S, converter=
insert_converter(0, 13, 0, 13, ): for =|s(s)=f(s(s)).s|=, $blocks, t=, converter=
After fix_type_issues: =|s(s)=f(s(s)).s|=, @ValPy: blocks [ _m.group(1) ] = _str ( blocks [ _m.group(1) ] ) + _m.group(2)
assignment(0, 13) =|s(s)=f(s(s)).s|= $blocks { $1 } = _str ( $blocks { $1 } ) . $2

>expression(0, 3, 0) =|s(s)=f(s(s)).s|= $blocks { $1 } = _str ( $blocks { $1 } ) . $2

Generated partial line blocks
Generated partial line blocks[
>>expression(2, 2, 0) =|s(s)=f(s(s)).s|= $blocks { $1 } = _str ( $blocks { $1 } ) . $2

Generated partial line blocks[_m.group(1)
<<expression returns 3
Generated partial line blocks[_m.group(1)]
<expression returns 4
Generated partial line blocks[_m.group(1)]=
>expression(5, 13, 0) =|s(s)=f(s(s)).s|= $blocks { $1 } = _str ( $blocks { $1 } ) . $2

function(5, 13) =|s(s)=f(s(s)).s|= $blocks { $1 } = _str ( $blocks { $1 } ) . $2
function start=7, end_pos=10, bracketed=1
Generated partial line blocks[_m.group(1)]=_str
Generated partial line blocks[_m.group(1)]=_str(
>>expression(7, 10, 0) =|s(s)=f(s(s)).s|= $blocks { $1 } = _str ( $blocks { $1 } ) . $2

Generated partial line blocks[_m.group(1)]=_str(blocks
Generated partial line blocks[_m.group(1)]=_str(blocks.get(
>>>expression(9, 9, 0) =|s(s)=f(s(s)).s|= $blocks { $1 } = _str ( $blocks { $1 } ) . $2

Generated partial line blocks[_m.group(1)]=_str(blocks.get(_m.group(1)
<<<expression returns 10
Generated partial line blocks[_m.group(1)]=_str(blocks.get(_m.group(1))
<<expression returns 11
Generated partial line blocks[_m.group(1)]=_str(blocks.get(_m.group(1)))
function returns 12
Generated partial line blocks[_m.group(1)]=_str(blocks.get(_m.group(1)))+
Generated partial line blocks[_m.group(1)]=_str(blocks.get(_m.group(1)))+_m.group(2)
<expression returns 14
  42 | 3 |   |            blocks[_m.group(1)] = _str(blocks.get(_m.group(1)))+_m.group(2)             #PL: 

Tokens: s(s)=f(s(s)).s ValPy: 
Main loop, line=}, BufferValClass=, deferred_statement=0


 === Line 42 Perl source:}===

exit_block at line 42, prior nesting_level=3, nesting_last->{type} is now else

Line:   42 TokenStr: =|}|= @ValPy: }
fix_type_issues(0, 0, )
fix_type_issues(0, 0, ): checking } at 0, limit=0
insert_converter(0, 0, 0, 0, ): for =|}|=, }, t=, converter=
needs_try_block(1), top=type else is_sub  level 2 is_loop  is_eval  in_loop 1 in_sub 0 cur_sub  lno 40 varclasses HASH(0x800436b30)
Main loop, line=} elsif(/#LINE (\d)/) {, BufferValClass=, deferred_statement=0


 === Line 43 Perl source:} elsif(/#LINE (\d)/) {===

exit_block at line 43, prior nesting_level=2, nesting_last->{type} is now if 

Line:   43 TokenStr: =|}|= @ValPy: }
fix_type_issues(0, 0, )
fix_type_issues(0, 0, ): checking } at 0, limit=0
insert_converter(0, 0, 0, 0, ): for =|}|=, }, t=, converter=
needs_try_block(1), top=level 1 type if  is_sub  is_loop  is_eval  in_loop 1 lno 37 varclasses HASH(0x800b00a68) in_sub 0 cur_sub 
Main loop, line=elsif(/#LINE (\d)/) {, BufferValClass=, deferred_statement=0


 === Line 43 Perl source:elsif(/#LINE (\d)/) {===

Lexem 0 Current token='C' perl='elsif' value='elif ' Tokenstr |C| translated: elif 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |C(| translated: elif  (
perl_match(#LINE (\d), /, #LINE (\d)): modifier=r, groups_are_present=1
put_regex_in_quotes(#LINE (\d), /, #LINE (\d))
>interpolate_strings(#LINE (\d), #LINE (\d), 0, 0, 1)
<interpolate_strings(#LINE (\d), #LINE (\d), 0, 0, 1)=0, ValPy[2]='#LINE (\d)'
Lexem 2 Current token='q' perl='#LINE (\d)' value='(_m:=re.search(r'#LINE (\d)',_d))' Tokenstr |C(q| translated: elif  ( (_m:=re.search(r'#LINE (\d)',_d))
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |C(q)| translated: elif  ( (_m:=re.search(r'#LINE (\d)',_d)) )
enter_block at line 43, prior nesting_level=1, ValPerl=elsif ( #LINE (\d) ) {
nesting_info=is_sub  type elif  level 1 is_eval  is_loop  in_loop 1 cur_sub  in_sub 0 varclasses HASH(0x800b52180) lno 43

Line:   43 TokenStr: =|C(q)|= @ValPy: elif  ( (_m:=re.search(r'#LINE (\d)',_d)) )
fix_type_issues(0, 3, )
fix_type_issues(0, 3, ): checking elsif at 0, limit=3
fix_type_issues(0, 3, ): checking ( at 1, limit=3
fix_type_issues(0, 3, ): checking #LINE (\d) at 2, limit=3
fix_type_issues(0, 3, ): checking ) at 3, limit=3
insert_converter(0, 3, 0, 3, ): for =|C(q)|=, elsif, t=, converter=
Generated partial line elif 
>expression(2, 2, 0) =|C(q)|= elsif ( #LINE (\d) )

Generated partial line elif (_m:=re.search(r'#LINE (\d)',_d))
<expression returns 3
Generated partial line elif (_m:=re.search(r'#LINE (\d)',_d)):
  43 | 1 |   |    elif (_m:=re.search(r'#LINE (\d)',_d)):                                             #PL: elsif(/#LINE (\d)/) {

Tokens: C(q) ValPy: 
Main loop, line=^, BufferValClass=, deferred_statement=0


 === Line 43 Perl source:^===


Line:   43 TokenStr: =|{|= @ValPy: {
fix_type_issues(0, 0, )
fix_type_issues(0, 0, ): checking { at 0, limit=0
insert_converter(0, 0, 0, 0, ): for =|{|=, {, t=, converter=
needs_try_block(0), top=is_sub  type elif  level 1 is_eval  is_loop  in_loop 1 cur_sub  in_sub 0 varclasses HASH(0x800b52180) lno 43
needs_try_block(0), top=is_sub  type elif  level 1 is_eval  is_loop  in_loop 1 cur_sub  in_sub 0 varclasses HASH(0x800b52180) lno 43
Main loop, line=$lines .= $1;, BufferValClass=, deferred_statement=0


 === Line 44 Perl source:$lines .= $1;===

Lexem 0 Current token='s' perl='$lines' value='lines' Tokenstr |s| translated: lines
Lexem 1 Current token='=' perl='.=' value='+=' Tokenstr |s=| translated: lines +=
Lexem 2 Current token='s' perl='$1' value='_m.group(1)' Tokenstr |s=s| translated: lines += _m.group(1)

Line:   44 TokenStr: =|s=s|= @ValPy: lines += _m.group(1)
fix_type_issues(0, 2, )
fix_type_issues(0, 2, ): checking $lines at 0, limit=2
>expr_type(0, 0, main)
<expr_type(0, 0, main) = S
insert_converter(0, 2, 0, 0, ): for =|s=s|=, $lines, t=S, converter=
fix_type_issues(0, 2, ): checking .= at 1, limit=2
fix_type_issues(0, 2, ): checking $1 at 2, limit=2
>expr_type(2, 2, main)
<expr_type(2, 2, main) = S
insert_converter(0, 2, 2, 2, ): for =|s=s|=, $1, t=S, converter=
insert_converter(0, 2, 0, 2, ): for =|s=s|=, $lines, t=, converter=
assignment(0, 2) =|s=s|= $lines .= $1

Generated partial line lines
Generated partial line lines+=
assign, ValClass[limit] = s, ValPy=_m.group(1), ValPerl=$1

Generated partial line lines+=_m.group(1)
  45 | 2 |   |        lines += _m.group(1)                                                            #PL: 

Tokens: s=s ValPy: 
Main loop, line=}, BufferValClass=, deferred_statement=0


 === Line 45 Perl source:}===

exit_block at line 45, prior nesting_level=2, nesting_last->{type} is now elif 

Line:   45 TokenStr: =|}|= @ValPy: }
fix_type_issues(0, 0, )
fix_type_issues(0, 0, ): checking } at 0, limit=0
insert_converter(0, 0, 0, 0, ): for =|}|=, }, t=, converter=
needs_try_block(1), top=is_sub  type elif  level 1 is_eval  is_loop  in_loop 1 cur_sub  in_sub 0 varclasses HASH(0x800b52180) lno 43
Main loop, line=}, BufferValClass=, deferred_statement=0


 === Line 46 Perl source:}===

exit_block at line 46, prior nesting_level=1, nesting_last->{type} is now while

Line:   46 TokenStr: =|}|= @ValPy: }
fix_type_issues(0, 0, )
fix_type_issues(0, 0, ): checking } at 0, limit=0
insert_converter(0, 0, 0, 0, ): for =|}|=, }, t=, converter=
needs_try_block(1), top=is_loop 1 is_eval  type while is_sub  level 0 in_sub 0 cur_sub  lno 36 varclasses HASH(0x80079fa08) in_loop 1
initialize_globals_for_state_vars: 
Main loop, line=for(my $i=1; $i<=4; $i++) {, BufferValClass=, deferred_statement=0


 === Line 47 Perl source:for(my $i=1; $i<=4; $i++) {===

Lexem 0 Current token='c' perl='for' value='for' Tokenstr |c| translated: for
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: for (
Lexem 2 Current token='s' perl='$i' value='i' Tokenstr |c(s| translated: for ( i
Lexem 3 Current token='=' perl='=' value=':=' Tokenstr |c(s=| translated: for ( i :=
Lexem 4 Current token='d' perl='1' value='1' Tokenstr |c(s=d| translated: for ( i := 1
Lexem 5 Current token=';' perl=';' value=';' Tokenstr |c(s=d;| translated: for ( i := 1 ;
Lexem 6 Current token='s' perl='$i' value='i' Tokenstr |c(s=d;s| translated: for ( i := 1 ; i
Lexem 7 Current token='>' perl='<=' value='<=' Tokenstr |c(s=d;s>| translated: for ( i := 1 ; i <=
Lexem 8 Current token='d' perl='4' value='4' Tokenstr |c(s=d;s>d| translated: for ( i := 1 ; i <= 4
Lexem 9 Current token=';' perl=';' value=';' Tokenstr |c(s=d;s>d;| translated: for ( i := 1 ; i <= 4 ;
Lexem 10 Current token='s' perl='$i' value='i' Tokenstr |c(s=d;s>d;s| translated: for ( i := 1 ; i <= 4 ; i
Lexem 11 Current token='^' perl='++' value='+=1' Tokenstr |c(s=d;s>d;s^| translated: for ( i := 1 ; i <= 4 ; i +=1
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |c(s=d;s>d;s^)| translated: for ( i := 1 ; i <= 4 ; i +=1 )
enter_block at line 47, prior nesting_level=0, ValPerl=for ( $i = 1 ; $i <= 4 ; $i ++ ) {
nesting_info=is_loop 1 is_eval  level 0 type for is_sub  lno 47 varclasses HASH(0x800b522d0) in_sub 0 cur_sub  in_loop 1

Line:   47 TokenStr: =|c(s=d;s>d;s^)|= @ValPy: for ( i := 1 ; i <= 4 ; i +=1 )
handle_incr_decr(0, 11, 12) with ++, pre_op=0, lvalue_start=10, lvalue_end=10 = 9 now =|c(s=d;s>d;((s=s+d)-d))|=
fix_type_issues(0, 21, )
fix_type_issues(0, 21, ): checking for at 0, limit=21
fix_type_issues(0, 21, ): checking ( at 1, limit=21
fix_type_issues(0, 21, ): checking $i at 2, limit=21
insert_converter(0, 21, 2, 2, ): for =|c(s=d;s>d;((s=s+d)-d))|=, $i, t=, converter=
fix_type_issues(0, 21, ): checking = at 3, limit=21
fix_type_issues(0, 21, ): checking 1 at 4, limit=21
insert_converter(0, 21, 4, 4, ): for =|c(s=d;s>d;((s=s+d)-d))|=, 1, t=, converter=
fix_type_issues(0, 21, ): checking ; at 5, limit=21
fix_type_issues(6, 5, )
control(0) =|c(s=d;s>d;((s=s+d)-d))|= for ( $i = 1 ; $i <= 4 ; ( ( $i = $i + 1 ) - 1 ) )

control-parens removed, begin=0 start=1 =|cs=d;s>d;((s=s+d)-d)|= for $i = 1 ; $i <= 4 ; ( ( $i = $i + 1 ) - 1 )

Generated partial line for
Generated partial line fori
Generated partial line foriin range(
>expression(3, 3, 0) =|cs=d;s>d;((s=s+d)-d)|= for $i = 1 ; $i <= 4 ; ( ( $i = $i + 1 ) - 1 )

Generated partial line foriin range(1
<expression returns 4
Generated partial line foriin range(1,
>expression(7, 7, 0) =|cs=d;s>d;((s=s+d)-d)|= for $i = 1 ; $i <= 4 ; ( ( $i = $i + 1 ) - 1 )

Generated partial line foriin range(1,4
<expression returns 8
Generated partial line foriin range(1,4+1
Generated partial line foriin range(1,4+1):
  47 | 0 |   |for i in range(1, 4+1):                                                                 #PL: ^

Tokens: cs=d;s>d;((s=s+d)-d) ValPy: 
Main loop, line=^, BufferValClass=, deferred_statement=0


 === Line 47 Perl source:^===


Line:   47 TokenStr: =|{|= @ValPy: {
fix_type_issues(0, 0, )
fix_type_issues(0, 0, ): checking { at 0, limit=0
insert_converter(0, 0, 0, 0, ): for =|{|=, {, t=, converter=
needs_try_block(0), top=is_loop 1 is_eval  level 0 type for is_sub  lno 47 varclasses HASH(0x800b522d0) in_sub 0 cur_sub  in_loop 1
needs_try_block(0), top=is_loop 1 is_eval  level 0 type for is_sub  lno 47 varclasses HASH(0x800b522d0) in_sub 0 cur_sub  in_loop 1
Main loop, line=assert($blocks{$i} eq '1234');, BufferValClass=, deferred_statement=0


 === Line 48 Perl source:assert($blocks{$i} eq '1234');===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$blocks' value='blocks' Tokenstr |c(s| translated: assert ( blocks
Lexem 3 Current token='(' perl='{' value='[' Tokenstr |c(s(| translated: assert ( blocks [
Lexem 4 Current token='s' perl='$i' value='i' Tokenstr |c(s(s| translated: assert ( blocks [ i
Lexem 5 Current token=')' perl='}' value=']' Tokenstr |c(s(s)| translated: assert ( blocks [ i ]
Lexem 6 Current token='>' perl='eq' value='==' Tokenstr |c(s(s)>| translated: assert ( blocks [ i ] ==
Lexem 7 Current token='"' perl='1234' value=''1234'' Tokenstr |c(s(s)>"| translated: assert ( blocks [ i ] == '1234'
Lexem 8 Current token=')' perl=')' value=')' Tokenstr |c(s(s)>")| translated: assert ( blocks [ i ] == '1234' )

Line:   48 TokenStr: =|c(s(s)>")|= @ValPy: assert ( blocks [ i ] == '1234' )
fix_type_issues(0, 8, )
fix_type_issues(0, 8, ): checking assert at 0, limit=8
fix_type_issues(0, 8, ): checking ( at 1, limit=8
fix_type_issues(0, 8, ): checking $blocks at 2, limit=8
fix_type_issues(4, 4, S)
fix_type_issues(4, 4, S): checking $i at 4, limit=4
>expr_type(4, 4, main)
<expr_type(4, 4, main) = I
insert_converter(4, 4, 4, 4, S): for =|c(s(s)>")|=, $i, t=S, converter=_str
insert_converter(4, 4, 4, 4, S): new =|c(s(f(s))>")|=, _str, result = 3+0
>expr_type(4, 7, main)
<expr_type(4, 7, main) = S
insert_converter(4, 7, 4, 7, S): for =|c(s(f(s))>")|=, _str, t=S, converter=
After fix_type_issues: =|c(s(f(s))>")|=, @ValPy: assert ( blocks [ _str ( i ) ] == '1234' )
>expr_type(2, 8, main)
<expr_type(2, 8, main) = m
insert_converter(0, 11, 2, 8, ): for =|c(s(f(s))>")|=, $blocks, t=S, converter=_str
insert_converter(0, 11, 2, 8, ): new =|c(f(s(f(s)))>")|=, _str, result = 3+0
fix_type_issues(0, 14, ): checking eq at 12, limit=14
fix_type_issues(0, 14, ): checking 1234 at 13, limit=14
>expr_type(13, 13, main)
<expr_type(13, 13, main) = S
insert_converter(0, 14, 13, 13, ): for =|c(f(s(f(s)))>")|=, 1234, t=S, converter=
fix_type_issues(0, 14, ): checking ) at 14, limit=14
insert_converter(0, 14, 0, 14, ): for =|c(f(s(f(s)))>")|=, assert, t=, converter=
After fix_type_issues: =|c(f(s(f(s)))>")|=, @ValPy: assert ( _str ( blocks [ _str ( i ) ] ) == '1234' )
control(0) =|c(f(s(f(s)))>")|= assert ( _str ( $blocks { _str ( $i ) } ) eq 1234 )

control-parens removed, begin=0 start=1 =|cf(s(f(s)))>"|= assert _str ( $blocks { _str ( $i ) } ) eq 1234

Generated partial line assert
>expression(1, 12, 0) =|cf(s(f(s)))>"|= assert _str ( $blocks { _str ( $i ) } ) eq 1234

function(1, 12) =|cf(s(f(s)))>"|= assert _str ( $blocks { _str ( $i ) } ) eq 1234
function start=3, end_pos=9, bracketed=1
Generated partial line assert_str
Generated partial line assert_str(
>>expression(3, 9, 0) =|cf(s(f(s)))>"|= assert _str ( $blocks { _str ( $i ) } ) eq 1234

Generated partial line assert_str(blocks
Generated partial line assert_str(blocks.get(
>>>expression(5, 8, 0) =|cf(s(f(s)))>"|= assert _str ( $blocks { _str ( $i ) } ) eq 1234

function(5, 8) =|cf(s(f(s)))>"|= assert _str ( $blocks { _str ( $i ) } ) eq 1234
function start=7, end_pos=7, bracketed=1
Generated partial line assert_str(blocks.get(_str
Generated partial line assert_str(blocks.get(_str(
>>>>expression(7, 7, 0) =|cf(s(f(s)))>"|= assert _str ( $blocks { _str ( $i ) } ) eq 1234

Generated partial line assert_str(blocks.get(_str(i
<<<<expression returns 8
Generated partial line assert_str(blocks.get(_str(i)
function returns 9
<<<expression returns 9
Generated partial line assert_str(blocks.get(_str(i))
<<expression returns 10
Generated partial line assert_str(blocks.get(_str(i)))
function returns 11
Generated partial line assert_str(blocks.get(_str(i)))==
Generated partial line assert_str(blocks.get(_str(i)))=='1234'
<expression returns 13
  49 | 1 |   |    assert _str(blocks.get(_str(i))) == '1234'                                          #PL: 

Tokens: cf(s(f(s)))>" ValPy: 
Main loop, line=}, BufferValClass=, deferred_statement=0


 === Line 49 Perl source:}===

exit_block at line 49, prior nesting_level=1, nesting_last->{type} is now for

Line:   49 TokenStr: =|}|= @ValPy: }
fix_type_issues(0, 0, )
fix_type_issues(0, 0, ): checking } at 0, limit=0
insert_converter(0, 0, 0, 0, ): for =|}|=, }, t=, converter=
needs_try_block(1), top=is_loop 1 is_eval  level 0 type for is_sub  lno 47 varclasses HASH(0x800b522d0) in_sub 0 cur_sub  in_loop 1
initialize_globals_for_state_vars: 
Main loop, line=assert($lines eq '1234');, BufferValClass=, deferred_statement=0


 === Line 50 Perl source:assert($lines eq '1234');===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$lines' value='lines' Tokenstr |c(s| translated: assert ( lines
Lexem 3 Current token='>' perl='eq' value='==' Tokenstr |c(s>| translated: assert ( lines ==
Lexem 4 Current token='"' perl='1234' value=''1234'' Tokenstr |c(s>"| translated: assert ( lines == '1234'
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(s>")| translated: assert ( lines == '1234' )

Line:   50 TokenStr: =|c(s>")|= @ValPy: assert ( lines == '1234' )
fix_type_issues(0, 5, )
fix_type_issues(0, 5, ): checking assert at 0, limit=5
fix_type_issues(0, 5, ): checking ( at 1, limit=5
fix_type_issues(0, 5, ): checking $lines at 2, limit=5
>expr_type(2, 2, main)
<expr_type(2, 2, main) = S
insert_converter(0, 5, 2, 2, ): for =|c(s>")|=, $lines, t=S, converter=
fix_type_issues(0, 5, ): checking eq at 3, limit=5
fix_type_issues(0, 5, ): checking 1234 at 4, limit=5
>expr_type(4, 4, main)
<expr_type(4, 4, main) = S
insert_converter(0, 5, 4, 4, ): for =|c(s>")|=, 1234, t=S, converter=
fix_type_issues(0, 5, ): checking ) at 5, limit=5
insert_converter(0, 5, 0, 5, ): for =|c(s>")|=, assert, t=, converter=
control(0) =|c(s>")|= assert ( $lines eq 1234 )

control-parens removed, begin=0 start=1 =|cs>"|= assert $lines eq 1234

Generated partial line assert
>expression(1, 3, 0) =|cs>"|= assert $lines eq 1234

Generated partial line assertlines
Generated partial line assertlines==
Generated partial line assertlines=='1234'
<expression returns 4
  52 | 0 |   |assert lines == '1234'                                                                  #PL: print "$0 - test passed!\n";

Tokens: cs>" ValPy: 
  52 | 0 |   |
Main loop, line=print "$0 - test passed!\n";, BufferValClass=, deferred_statement=0


 === Line 52 Perl source:print "$0 - test passed!\n";===

Lexem 0 Current token='f' perl='print' value='print' Tokenstr |f| translated: print
>interpolate_strings($0 - test passed!\n, $0 - test passed!\n, 21, 1, 0)
<interpolate_strings( - test passed!\n, $0 - test passed!\n, 21, 1, 0)=21, ValPy[1]=f"{__file__} - test passed!\n"
Lexem 1 Current token='"' perl='$0 - test passed!\n' value='f"{__file__} - test passed!\n"' Tokenstr |f"| translated: print f"{__file__} - test passed!\n"

Line:   52 TokenStr: =|f"|= @ValPy: print f"{__file__} - test passed!\n"
fix_type_issues(0, 1, )
fix_type_issues(1, 1, )
fix_type_issues(1, 1, ): checking $0 - test passed!\n at 1, limit=1
insert_converter(1, 1, 1, 1, ): for =|f"|=, $0 - test passed!\n, t=, converter=
insert_converter(1, 1, 1, 1, ): for =|f"|=, $0 - test passed!\n, t=, converter=
Generated partial line print(
print3(0) start=0, handle=, k=1, end_pos=1

>expression(1, 1, 0) =|f"|= print $0 - test passed!\n

Generated partial line print(f"{__file__} - test passed!\n"
<expression returns 2
Generated partial line print(f"{__file__} - test passed!")
  53 | 0 |   |print(f"{__file__} - test passed!")                                                     #PL: print "$0 - test passed!\n";

Tokens: f" ValPy: 
  53 | 0 |   |
initialize_globals_for_state_vars: 
move_defs_before_refs: Defs test4 46 test 27 _readline 74 _create_fh_methods 83 _open 91
move_defs_before_refs: Refs _readline 61 _create_fh_methods 108 _open 58 test4 57 test 56
dependencies: 
{'test4' => ['__main__'],'test' => ['__main__'],'_create_fh_methods' => ['_open','__main__','_open'],'__main__' => [],'_readline' => ['__main__'],'_open' => ['__main__']}
ordered_to_move: test test4 _readline _create_fh_methods _open __main__
Handling test on line 27
Handling test4 on line 46
Handling _readline on line 74
Handling _create_fh_methods on line 83
Handling _open on line 91
ERROR STATISTICS:  W: 1


 [Softpano-W318]:  Debug flag is set to 5


