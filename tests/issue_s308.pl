# issue s308 - Use of uninitialized value within @Pythonizer::ValClass in string eq at ../../Pythonizer.pm line 4740
use Carp::Assert;
no warnings 'experimental';

sub mySub {
   # FIXME: Generated call to _flatten incorrectly strings out the values of $arr into $x and $y
   # We should be using list interpolation: https://perldoc.perl.org/perldata#List-value-constructors
   my ($class, $x, $y, @r) = (ref($_[0]), @_);
   assert($class eq 'ARRAY');
   assert($x ~~ [1,2]);
   assert($y == 3);
   assert(\@r ~~ [4,5]);
}

my $arr = [1,2];
my $y = 3;
my @r = (4,5);

mySub($arr, $y, @r);

# Generated by chatGPT and me from the example in the documentation:

# Define arrays and a hash
my @foo = (1, 2, 3);
my @bar = (4, 5, 6);
my %glarch = ('a' => 7, 'b' => 8, 'c' => 9);

# Define a subroutine that returns a list
# NOTE: VarType{list_sub} = 'a of I'
sub list_sub {
    return (10, 11, 12);
}

# NOTE: VarType{list_ref_sub} = 'm'
sub list_ref_sub {
    my @result = (10, 11, 12);
    return \@result;
}

# NOTE: VarType{str_sub} = 'S'
sub str_sub { 'str_sub' }

my $aref = ['elem1', 'elem2'];

my $scalar = 'scalar';
my $int = 42;
my $href = {k1=>'v1'};

# NOTE: VarType{wa_sub} = 'm', but SubAttributes{wa_sub}{wantarray} = 1
sub wa_sub {
    return wantarray ? (22, 23) : 22;
}

# NOTE: VarType{echosub} = 'a'
sub echosub {
    assert($_[0] eq 'last' && $_[1] eq 'two');
    return @_;
}

# Test out splats in sub arg lists

my @expected = ();
sub expect_array {
    $actual_len = scalar(@_);
    $expected_len = scalar(@expected);
    assert($actual_len == $expected_len, "Expecting $expected_len elements (@expected), but got $actual_len (@_)");
    assert(\@_ ~~ \@expected, "Expecting @expected, got @_");
}
my $expected = '';
sub expect_scalar {
    assert(scalar(@_) == 1, "Expected scalar, but got array with " . scalar(@_) . " elements");
    assert($_[0] ~~ $expected, "Expected $expected, but got $_[0]");
}

sub expect_glarch {
    my %g = @_;
    assert(\%g ~~ \%glarch, "Expected hash @{[%glarch]}, but got @{[%g]}");
}

@expected = @foo;
expect_array(@foo);
expect_array @foo;
my $fooref = \@foo;
expect_array(@$fooref);
expect_array @$fooref;

@expected = (@foo, 'x');
expect_array(@foo, 'x');

@expected = ('x', @foo);
expect_array('x', @foo);

@expected = (@foo, @bar);
expect_array(@foo, @bar);
expect_array @foo, @bar;

# Here is a lambda function to check a function result:
# _sl = lambda r: [r] if isinstance(r, str) or not hasattr(r, '__iter__') else r
# 
@expected = (10, 11, 12);
expect_array(&list_sub);
expect_array &list_sub;
expect_array(1==1 ? &list_sub : &str_sub);
expect_array(10..12);
expect_array 10..12;
expect_array 10, 11, 12;

@expected = (22, 23);
expect_array(&wa_sub);

$expected = 'str_sub';
expect_scalar(&str_sub);
expect_scalar(1==0 ? &list_sub : &str_sub);

$expected = 22;
expect_scalar(0+wa_sub());
expect_scalar &wa_sub+0;

@expected = qw/x y/;
expect_array(split / /, 'x y');

@expected = qw/d e f/;
expect_array('d e f' =~ /[a-z]/g);

@expected = qw/these two/;
expect_array qw/these two/;
expect_array(('these', 'two'));
expect_array(@{['these', 'two']});
expect_array(1==1 ? ('these', 'two') : 'nope');
$expected = 'nope';
expect_scalar(1==0 ? ('these', 'two') : 'nope');

$expected = [10, 11, 12];
expect_scalar(&list_ref_sub);

@expected = qw/last two/;
expect_array(echosub 'last', 'two');

expect_glarch(%glarch);

# Evaluate a list that interpolates the arrays, subroutine, hash, array ref, 2 scalars, a hashref, a function returning a list,
# and a conditional nested list.
#
# Example of how to handle the sub results, where we are not sure if the result is a list or not:
# list_ = [*foo, *bar, *(_s if not isinstance(_s := list_sub(), str) and hasattr(_s, '__iter__') else [_s]), ...]
# (We can assume if the sub has a 'wantarray' that it's gonna return a list and just splat it)
# 
my @list = (@foo, @bar, &list_sub, %glarch, &str_sub, $aref, $scalar, $int, $href, split(/ /, 'x y'), 0==1 ? 'nope' : &wa_sub, 'string' . 'expression',
            12+24, 'd e f' =~ /[a-z]/g, 1==1 ? ('these', 'two') : ('not', 'used'), echosub 'last', 'two');

# Assert that the list contains the expected values
assert(@list == 33, 'The list should have 33 elements, but it has ' . (scalar @list));
assert($list[0] == 1);  # @foo should be splatted
assert($list[1] == 2);
assert($list[2] == 3);
assert($list[3] == 4);  # @bar should be splatted
assert($list[4] == 5);
assert($list[5] == 6);
assert($list[6] == 10); # &list_sub should be splatted
assert($list[7] == 11);
assert($list[8] == 12);
assert(($list[9] eq 'a' && $list[10] == 7) ||   # %glarch should be splatted
       ($list[9] eq 'b' && $list[10] == 8) ||
       ($list[9] eq 'c' && $list[10] == 9));
assert(($list[11] eq 'a' && $list[12] == 7) ||
       ($list[11] eq 'b' && $list[12] == 8) ||
       ($list[11] eq 'c' && $list[12] == 9));
assert(($list[13] eq 'a' && $list[14] == 7) ||
       ($list[13] eq 'b' && $list[14] == 8) ||
       ($list[13] eq 'c' && $list[14] == 9));
assert($list[15] eq 'str_sub');     # &str_sub should NOT be splatted
assert($list[16] ~~ ['elem1', 'elem2']);    # $aref should NOT be splatted
assert($list[17] eq 'scalar');      # string scalar should not be splatted into a char array
assert($list[18] == 42);            # int scalar should come thru as is
assert($list[19] ~~ {k1=>'v1'});    # $href should NOT be splatted
assert($list[20] eq 'x');           # function returning a list should be splatted
assert($list[21] eq 'y');
assert($list[22] == 22);            # wantarray sub should be splatted
assert($list[23] == 23);            # "
assert($list[24] eq 'stringexpression');
assert($list[25] == 36);
assert($list[26] eq 'd');           # regex with g flag
assert($list[27] eq 'e');
assert($list[28] eq 'f');
assert($list[29] eq 'these');       # (..., ...) should be splatted
assert($list[30] eq 'two');         # "
assert($list[31] eq 'last');        # sub call w/o parens should be splatted
assert($list[32] eq 'two');         # "

print "$0 - test passed!\n";
