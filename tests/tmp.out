 [Softpano-W317]:  Debug flag is set to 5


PYTHONIZER: Fuzzy translator of Python to Perl. Version 0.924 (mtime 211214_0022) Started at 21/12/14 00:36

Logs are at /tmp/Pythonizer/pythonizer.211214_0036.log. Type -h for help.
=============================================================================================================
Results of transcription are written to the file  issue_99.py
=========================================================================================================================

Lexem 0 Current token='c' perl='use' value='NoTrans!' Tokenstr |c| translated: NoTrans!
Lexem 1 Current token='i' perl='Carp::Assert' value='Carp.Assert' Tokenstr |ci| translated: NoTrans! Carp.Assert
Lexem 0 Current token='k' perl='sub' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' perl='sub1' value='sub1' Tokenstr |ki| translated: def sub1
enter_block at line 5, prior nesting_level=0, ValPerl=sub sub1 {
nesting_info=lno 5 is_sub 1 in_sub 1 level 0 cur_sub sub1 is_eval  in_loop 0 is_loop  type def
get_globals: switching to 'sub1' at line 5
expr_type(1, 1, sub1)
Lexem 0 Current token='k' perl='return' value='return' Tokenstr |k| translated: return
Lexem 1 Current token='"' perl='sub1' value=''sub1'' Tokenstr |k"| translated: return 'sub1'
expr_type(1, 1, sub1)
merge_types(sub1, main, S)
expr_type(1, 1, sub1)
exit_block at line 7, prior nesting_level=1
get_globals: switching back to 'main' at line 7
merge_types(sub1, main, S)
merge_types: otype=S
Lexem 0 Current token='k' perl='sub' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' perl='sub2' value='sub2' Tokenstr |ki| translated: def sub2
enter_block at line 10, prior nesting_level=0, ValPerl=sub sub2 {
nesting_info=type def level 0 cur_sub sub2 is_loop  in_loop 0 is_eval  lno 10 in_sub 1 is_sub 1
get_globals: switching to 'sub2' at line 10
expr_type(1, 1, sub2)
Lexem 0 Current token='s' perl='$arg' value='arg' Tokenstr |s| translated: arg
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: arg =
Lexem 2 Current token='f' perl='shift' value='.pop(0)' Tokenstr |s=f| translated: arg = .pop(0)
check_ref(sub2, arg) at 0
expr_type(2, 2, sub2)
merge_types(arg, sub2, s)
expr_type(0, 2, sub2)
exit_block at line 12, prior nesting_level=1
get_globals: switching back to 'main' at line 12
merge_types(sub2, main, u)
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='i' perl='sub1' value='sub1' Tokenstr |c(i| translated: assert ( sub1
Lexem 3 Current token='~' perl='=~' value='' Tokenstr |c(i~| translated: assert ( sub1 
Lexem 4 Current token='q' perl='^sub1$' value='re.search(r'^sub1$',' Tokenstr |c(i~q| translated: assert ( sub1  re.search(r'^sub1$',
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(i~q)| translated: assert ( sub1  re.search(r'^sub1$', )
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='i' perl='sub2' value='sub2' Tokenstr |c(i| translated: assert ( sub2
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(i(| translated: assert ( sub2 (
Lexem 4 Current token='"' perl='arg' value=''arg'' Tokenstr |c(i("| translated: assert ( sub2 ( 'arg'
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(i(")| translated: assert ( sub2 ( 'arg' )
Lexem 6 Current token='~' perl='=~' value='' Tokenstr |c(i(")~| translated: assert ( sub2 ( 'arg' ) 
Lexem 7 Current token='q' perl='^arg$' value='re.search(r'^arg$',' Tokenstr |c(i(")~q| translated: assert ( sub2 ( 'arg' )  re.search(r'^arg$',
Lexem 8 Current token=')' perl=')' value=')' Tokenstr |c(i(")~q)| translated: assert ( sub2 ( 'arg' )  re.search(r'^arg$', )
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='i' perl='sub2' value='sub2' Tokenstr |c(i| translated: assert ( sub2
Lexem 3 Current token='"' perl='argb' value=''argb'' Tokenstr |c(i"| translated: assert ( sub2 'argb'
Lexem 4 Current token='~' perl='=~' value='' Tokenstr |c(i"~| translated: assert ( sub2 'argb' 
Lexem 5 Current token='q' perl='^argb$' value='re.search(r'^argb$',' Tokenstr |c(i"~q| translated: assert ( sub2 'argb'  re.search(r'^argb$',
Lexem 6 Current token=')' perl=')' value=')' Tokenstr |c(i"~q)| translated: assert ( sub2 'argb'  re.search(r'^argb$', )
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='substr' value='' Tokenstr |c(f| translated: assert ( 
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert (  (
Lexem 4 Current token='"' perl='arg' value=''arg'' Tokenstr |c(f("| translated: assert (  ( 'arg'
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |c(f(",| translated: assert (  ( 'arg' ,
Lexem 6 Current token='d' perl='0' value='0' Tokenstr |c(f(",d| translated: assert (  ( 'arg' , 0
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |c(f(",d)| translated: assert (  ( 'arg' , 0 )
Lexem 8 Current token='~' perl='=~' value='' Tokenstr |c(f(",d)~| translated: assert (  ( 'arg' , 0 ) 
Lexem 9 Current token='q' perl='^arg$' value='re.search(r'^arg$',' Tokenstr |c(f(",d)~q| translated: assert (  ( 'arg' , 0 )  re.search(r'^arg$',
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |c(f(",d)~q)| translated: assert (  ( 'arg' , 0 )  re.search(r'^arg$', )
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='substr' value='' Tokenstr |c(f| translated: assert ( 
Lexem 3 Current token='"' perl='arg' value=''arg'' Tokenstr |c(f"| translated: assert (  'arg'
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |c(f",| translated: assert (  'arg' ,
Lexem 5 Current token='d' perl='0' value='0' Tokenstr |c(f",d| translated: assert (  'arg' , 0
Lexem 6 Current token='~' perl='=~' value='' Tokenstr |c(f",d~| translated: assert (  'arg' , 0 
Lexem 7 Current token='q' perl='^arg$' value='re.search(r'^arg$',' Tokenstr |c(f",d~q| translated: assert (  'arg' , 0  re.search(r'^arg$',
Lexem 8 Current token=')' perl=')' value=')' Tokenstr |c(f",d~q)| translated: assert (  'arg' , 0  re.search(r'^arg$', )
Lexem 0 Current token='s' perl='$_' value='_d' Tokenstr |s| translated: _d
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: _d =
Lexem 2 Current token='f' perl='ord' value='ord' Tokenstr |s=f| translated: _d = ord
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |s=f(| translated: _d = ord (
Lexem 4 Current token='"' perl='a' value=''a'' Tokenstr |s=f("| translated: _d = ord ( 'a'
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |s=f(")| translated: _d = ord ( 'a' )
check_ref(main, _d) at 0
expr_type(2, 5, main)
merge_types(_d, main, I)
expr_type(0, 5, main)
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='chr' value='chr' Tokenstr |c(f| translated: assert ( chr
Lexem 3 Current token='~' perl='=~' value='' Tokenstr |c(f~| translated: assert ( chr 
Lexem 4 Current token='q' perl='^a$' value='re.search(r'^a$',' Tokenstr |c(f~q| translated: assert ( chr  re.search(r'^a$',
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(f~q)| translated: assert ( chr  re.search(r'^a$', )
Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |ta| translated:  arr
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  arr =
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |ta=(| translated:  arr = (
Lexem 4 Current token='"' perl='aa' value=''aa'' Tokenstr |ta=("| translated:  arr = ( 'aa'
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |ta=(",| translated:  arr = ( 'aa' ,
Lexem 6 Current token='"' perl='bb' value=''bb'' Tokenstr |ta=(","| translated:  arr = ( 'aa' , 'bb'
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |ta=(",")| translated:  arr = ( 'aa' , 'bb' )
check_ref(main, arr) at 1
expr_type(3, 7, main)
expr_type(4, 4, main)
merge_types(arr, main, a of u)
Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='s' perl='$i' value='i' Tokenstr |ts| translated:  i
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ts=| translated:  i =
Lexem 3 Current token='d' perl='0' value='0' Tokenstr |ts=d| translated:  i = 0
check_ref(main, i) at 1
expr_type(3, 3, main)
merge_types(i, main, I)
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$arr' value='arr' Tokenstr |c(s| translated: assert ( arr
Lexem 3 Current token='(' perl='[' value='[' Tokenstr |c(s(| translated: assert ( arr [
Lexem 4 Current token='s' perl='$i' value='i' Tokenstr |c(s(s| translated: assert ( arr [ i
Lexem 5 Current token=')' perl=']' value=']' Tokenstr |c(s(s)| translated: assert ( arr [ i ]
Lexem 6 Current token='~' perl='=~' value='' Tokenstr |c(s(s)~| translated: assert ( arr [ i ] 
Lexem 7 Current token='q' perl='^aa$' value='re.search(r'^aa$',' Tokenstr |c(s(s)~q| translated: assert ( arr [ i ]  re.search(r'^aa$',
Lexem 8 Current token=')' perl=')' value=')' Tokenstr |c(s(s)~q)| translated: assert ( arr [ i ]  re.search(r'^aa$', )
check_ref(main, arr) at 2
merge_types(arr, main, a of u)
merge_types: otype=a of u
check_ref(main, i) at 4
scalar_reference_type(4) = I
Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='h' perl='hash' value='hash' Tokenstr |th| translated:  hash
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |th=| translated:  hash =
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |th=(| translated:  hash = (
Lexem 4 Current token='i' perl='k1' value='k1' Tokenstr |th=(i| translated:  hash = ( k1
Lexem 5 Current token=':' perl='=>' value=': ' Tokenstr |th=(i:| translated:  hash = ( k1 : 
Lexem 6 Current token='"' perl='v1' value=''v1'' Tokenstr |th=(i:"| translated:  hash = ( k1 :  'v1'
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |th=(i:")| translated:  hash = ( k1 :  'v1' )
check_ref(main, hash) at 1
expr_type(3, 7, main)
expr_type(4, 6, main)
merge_types(hash, main, S)
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$hash' value='hash' Tokenstr |c(s| translated: assert ( hash
Lexem 3 Current token='(' perl='{' value='[' Tokenstr |c(s(| translated: assert ( hash [
Lexem 4 Current token='i' perl='k1' value='k1' Tokenstr |c(s(i| translated: assert ( hash [ k1
Lexem 5 Current token=')' perl='}' value=']' Tokenstr |c(s(")| translated: assert ( hash [ 'k1' ]
Lexem 6 Current token='~' perl='=~' value='' Tokenstr |c(s(")~| translated: assert ( hash [ 'k1' ] 
Lexem 7 Current token='q' perl='^v1$' value='re.search(r'^v1$',' Tokenstr |c(s(")~q| translated: assert ( hash [ 'k1' ]  re.search(r'^v1$',
Lexem 8 Current token=')' perl=')' value=')' Tokenstr |c(s(")~q)| translated: assert ( hash [ 'k1' ]  re.search(r'^v1$', )
check_ref(main, hash) at 2
merge_types(hash, main, h of u)
merge_types: otype=S
Lexem 0 Current token='f' perl='print' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='"' perl='$0 - test passed!\n' value='f"{__file__} - test passed!\n"' Tokenstr |f"| translated: print f"{__file__} - test passed!\n"
expr_type(0, 1, main)
VarSubMap = $VAR1 = {
  '_DUP_MAP' => {
    'main' => '+'
  },
  'LIST_SEPARATOR' => {
    'main' => '+'
  },
  'TRACEBACK' => {
    'main' => '+'
  },
  'CHILD_ERROR' => {
    'main' => '+'
  },
  'OS_ERROR' => {
    'main' => '+'
  },
  'AUTODIE' => {
    'main' => '+'
  },
  'arg' => {
    'sub2' => '+'
  },
  '_OPEN_MODE_MAP' => {
    'main' => '+'
  },
  '_script_start' => {
    'main' => '+'
  }
};

VarType = $VAR1 = {
  'i' => {
    'main' => 'I'
  },
  'hash' => {
    'main' => 'm'
  },
  'arg' => {
    'sub2' => 's'
  },
  'os.environ' => {
    'main' => 'h of S'
  },
  'k1' => {},
  'sub1' => {
    'main' => 'S'
  },
  '_script_start' => {
    'main' => 'I'
  },
  'EVAL_ERROR' => {
    'main' => 'S'
  },
  'os.name' => {
    'main' => 'S'
  },
  'sys.argv' => {
    'main' => 'a of S'
  },
  'OS_ERROR' => {
    'main' => 'S'
  },
  'arr' => {
    'main' => 'a of u'
  },
  'LIST_SEPARATOR' => {
    'main' => 'S'
  },
  'sub2' => {
    'main' => 'u'
  },
  'main' => {},
  '_d' => {
    'main' => 'I'
  }
};

initialized = $VAR1 = {
  'sub2' => {
    'arg' => 's'
  },
  'main' => {
    'os.environ' => 'h of S',
    'hash' => 'S',
    'os.name' => 'S',
    'sys.argv' => 'a of S',
    'EVAL_ERROR' => 'S',
    'i' => 'I',
    '_script_start' => 'I',
    '_d' => 'I',
    'LIST_SEPARATOR' => 'S',
    'arr' => 'a of u',
    'OS_ERROR' => 'S'
  }
};

NeedsInitializing = $VAR1 = {};

sub_external_last_nexts = $VAR1 = {};

line_needs_try_block = $VAR1 = {};


DETECTED GLOBAL VARIABLES:

AUTO-INITIALIZED VARIABLES:

List of local subroutines:
sub1 main sub2
mkdir: cannot create directory ‘/c/Users/Joe’: File exists
cp: target 'Orost/Archive/pythonizer' is not a directory
cp: target 'Orost/Archive/Softpano.pm' is not a directory
cp: target 'Orost/Archive/Perlscan.pm' is not a directory
cp: target 'Orost/Archive/Pythonizer.pm' is not a directory
   1 | 0 |   |#!/usr/bin/python3 -u
   1 | 0 |   |# Generated by pythonizer 0.924 run by Joe Orost on Tue Dec 14 00:36:36 2021
   1 | 0 |   |# issue 95 - Regex with local sub call generated bad code
   2 | 0 |   |import sys,os,re,fcntl,math,fileinput,subprocess,inspect,collections.abc,argparse,glob,warnings,inspect,functools,signal,traceback,io,tempfile,atexit,calendar
   2 | 0 |   |import time as tm_py
   2 | 0 |   |AUTODIE = 0
   2 | 0 |   |_OPEN_MODE_MAP = {'<': 'r', '>': 'w', '+<': 'r+', '+>': 'w+', '>>': 'a', '+>>': 'a+', '|': '|-'}
   2 | 0 |   |_script_start = tm_py.time()
   2 | 0 |   |TRACEBACK = 0
   2 | 0 |   |_DUP_MAP = dict(STDIN=0, STDOUT=1, STDERR=2)
   2 | 0 |   |LIST_SEPARATOR = ' '
   2 | 0 |   |OS_ERROR = ''
   2 | 0 |   |CHILD_ERROR = 0
   2 | 0 |   |class Die(Exception):
    pass
   2 | 0 |   |class EvalReturn(Exception):
    pass
   2 | 0 |   |class LoopControl(Exception):
    pass
   2 | 0 |   |_args = sys.argv[1:]
Main loop, line=use Carp::Assert;, BufferValClass=


 === Line 2 Perl source:use Carp::Assert;===

Lexem 0 Current token='c' perl='use' value='NoTrans!' Tokenstr |c| translated: NoTrans!
Lexem 1 Current token='i' perl='Carp::Assert' value='Carp.Assert' Tokenstr |ci| translated: NoTrans! Carp.Assert

Line:    2 TokenStr: =|ci|= @ValPy: NoTrans! Carp.Assert
   2 | 0 |   |#SKIPPED: use Carp::Assert;
   3 | 0 |   |
Main loop, line=sub sub1, BufferValClass=


 === Line 4 Perl source:sub sub1===

Lexem 0 Current token='k' perl='sub' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' perl='sub1' value='sub1' Tokenstr |ki| translated: def sub1
enter_block at line 5, prior nesting_level=0, ValPerl=sub sub1 {
nesting_info=level 0 in_loop 0 is_loop  is_eval  cur_sub sub1 in_sub 1 is_sub 1 lno 5 type def

Line:    5 TokenStr: =|ki|= @ValPy: def sub1
Generated partial line defsub1(_args):
   5 | 0 |   |def sub1(_args):                                                                        #PL: 

Tokens: ki ValPy: 
Main loop, line={, BufferValClass=


 === Line 5 Perl source:{===


Line:    5 TokenStr: =|{|= @ValPy: {
loop_needs_try_block(0), top=level 0 in_loop 0 is_loop  is_eval  cur_sub sub1 in_sub 1 is_sub 1 lno 5 type def
Main loop, line=return 'sub1';, BufferValClass=


 === Line 6 Perl source:return 'sub1';===

Lexem 0 Current token='k' perl='return' value='return' Tokenstr |k| translated: return
Lexem 1 Current token='"' perl='sub1' value=''sub1'' Tokenstr |k"| translated: return 'sub1'

Line:    6 TokenStr: =|k"|= @ValPy: return 'sub1'
Generated partial line return
expression(1, 1, 0) =|k"|= return sub1

Generated partial line return'sub1'
expression returns 2
   7 | 1 |   |    return 'sub1'                                                                       #PL: 

Tokens: k" ValPy: 
Main loop, line=}, BufferValClass=


 === Line 7 Perl source:}===

exit_block at line 7, prior nesting_level=1

Line:    7 TokenStr: =|}|= @ValPy: }
loop_needs_try_block(1), top=level 0 in_loop 0 is_loop  is_eval  cur_sub sub1 in_sub 1 is_sub 1 lno 5 type def
initialize_globals_for_state_vars: 
   7 | 0 |   |
   8 | 0 |   |
Main loop, line=sub sub2, BufferValClass=


 === Line 9 Perl source:sub sub2===

Lexem 0 Current token='k' perl='sub' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' perl='sub2' value='sub2' Tokenstr |ki| translated: def sub2
enter_block at line 10, prior nesting_level=0, ValPerl=sub sub2 {
nesting_info=lno 10 in_sub 1 is_sub 1 level 0 cur_sub sub2 is_loop  in_loop 0 is_eval  type def

Line:   10 TokenStr: =|ki|= @ValPy: def sub2
Generated partial line defsub2(_args):
  10 | 0 |   |def sub2(_args):                                                                        #PL: 

Tokens: ki ValPy: 
Main loop, line={, BufferValClass=


 === Line 10 Perl source:{===


Line:   10 TokenStr: =|{|= @ValPy: {
loop_needs_try_block(0), top=lno 10 in_sub 1 is_sub 1 level 0 cur_sub sub2 is_loop  in_loop 0 is_eval  type def
Main loop, line=$arg = shift;, BufferValClass=


 === Line 11 Perl source:$arg = shift;===

Lexem 0 Current token='s' perl='$arg' value='arg' Tokenstr |s| translated: arg
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: arg =
Lexem 2 Current token='f' perl='shift' value='.pop(0)' Tokenstr |s=f| translated: arg = .pop(0)

Line:   11 TokenStr: =|s=f|= @ValPy: arg = .pop(0)
assignment(0, 2) =|s=f|= $arg = shift

Generated partial line arg
Generated partial line arg=
assign, ValClass[limit] = f, ValPy=.pop(0), ValPerl=shift

function(2, 2) =|s=f|= $arg = shift

function start=3, end_pos=2, bracketed=-1
Generated partial line arg=(_args.pop(0) if _args else None)
finish: prev_line=$arg = shift;, PythonCode=arg = (_args.pop(0) if _args else None)
finish: Resetting line to return $arg ;
  12 | 1 |   |    arg = (_args.pop(0) if _args else None)                                             #PL: 

Tokens: s=f ValPy: 
Main loop, line=return $arg ;, BufferValClass=


 === Line 12 Perl source:return $arg ;===

Lexem 0 Current token='k' perl='return' value='return' Tokenstr |k| translated: return
Lexem 1 Current token='s' perl='$arg' value='arg' Tokenstr |ks| translated: return arg

Line:   12 TokenStr: =|ks|= @ValPy: return arg
Generated partial line return
expression(1, 1, 0) =|ks|= return $arg

Generated partial line returnarg
expression returns 2
  12 | 1 |   |    return arg                                                                          #PL: 

Tokens: ks ValPy: 
Main loop, line=}, BufferValClass=


 === Line 12 Perl source:}===

exit_block at line 12, prior nesting_level=1

Line:   12 TokenStr: =|}|= @ValPy: }
loop_needs_try_block(1), top=lno 10 in_sub 1 is_sub 1 level 0 cur_sub sub2 is_loop  in_loop 0 is_eval  type def
initialize_globals_for_state_vars: 
  12 | 0 |   |
  13 | 0 |   |
Main loop, line=assert(sub1 =~ /^sub1$/);, BufferValClass=


 === Line 14 Perl source:assert(sub1 =~ /^sub1$/);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='i' perl='sub1' value='sub1' Tokenstr |c(i| translated: assert ( sub1
Lexem 3 Current token='~' perl='=~' value='' Tokenstr |c(i~| translated: assert ( sub1 
Lexem 4 Current token='q' perl='^sub1$' value='re.search(r'^sub1$',' Tokenstr |c(i~q| translated: assert ( sub1  re.search(r'^sub1$',
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(i~q)| translated: assert ( sub1  re.search(r'^sub1$', )

Line:   14 TokenStr: =|c(i~q)|= @ValPy: assert ( sub1  re.search(r'^sub1$', )
control(0) =|c(i~q)|= assert ( sub1 =~ ^sub1$ )

control-parens removed, begin=0 start=1 =|ci~q|= assert sub1 =~ ^sub1$

Generated partial line assert
expression(1, 3, 0) =|ci~q|= assert sub1 =~ ^sub1$

Generated partial line assertre.search(r'^sub1$',
expression(1, 1, 0) =|ci~q|= assert sub1 =~ ^sub1$

Generated partial line assertre.search(r'^sub1$',sub1
Generated partial line assertre.search(r'^sub1$',sub1([
Generated partial line assertre.search(r'^sub1$',sub1([])
expression returns 2
Generated partial line assertre.search(r'^sub1$',sub1([]))
expression returns 4
  15 | 0 |   |assert re.search(r'^sub1$',sub1([]))                                                    #PL: assert(sub2('arg') =~ /^arg$/);

Tokens: ci~q ValPy: 
Main loop, line=assert(sub2('arg') =~ /^arg$/);, BufferValClass=


 === Line 15 Perl source:assert(sub2('arg') =~ /^arg$/);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='i' perl='sub2' value='sub2' Tokenstr |c(i| translated: assert ( sub2
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(i(| translated: assert ( sub2 (
Lexem 4 Current token='"' perl='arg' value=''arg'' Tokenstr |c(i("| translated: assert ( sub2 ( 'arg'
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(i(")| translated: assert ( sub2 ( 'arg' )
Lexem 6 Current token='~' perl='=~' value='' Tokenstr |c(i(")~| translated: assert ( sub2 ( 'arg' ) 
Lexem 7 Current token='q' perl='^arg$' value='re.search(r'^arg$',' Tokenstr |c(i(")~q| translated: assert ( sub2 ( 'arg' )  re.search(r'^arg$',
Lexem 8 Current token=')' perl=')' value=')' Tokenstr |c(i(")~q)| translated: assert ( sub2 ( 'arg' )  re.search(r'^arg$', )

Line:   15 TokenStr: =|c(i(")~q)|= @ValPy: assert ( sub2 ( 'arg' )  re.search(r'^arg$', )
control(0) =|c(i(")~q)|= assert ( sub2 ( arg ) =~ ^arg$ )

control-parens removed, begin=0 start=1 =|ci(")~q|= assert sub2 ( arg ) =~ ^arg$

Generated partial line assert
expression(1, 6, 0) =|ci(")~q|= assert sub2 ( arg ) =~ ^arg$

Generated partial line assertre.search(r'^arg$',
expression(1, 4, 0) =|ci(")~q|= assert sub2 ( arg ) =~ ^arg$

Generated partial line assertre.search(r'^arg$',sub2
Generated partial line assertre.search(r'^arg$',sub2([
expression(3, 3, 0) =|ci(")~q|= assert sub2 ( arg ) =~ ^arg$

Generated partial line assertre.search(r'^arg$',sub2(['arg'
expression returns 4
Generated partial line assertre.search(r'^arg$',sub2(['arg'])
expression returns 5
Generated partial line assertre.search(r'^arg$',sub2(['arg']))
expression returns 7
  16 | 0 |   |assert re.search(r'^arg$',sub2(['arg']))                                                #PL: assert(sub2 'argb' =~ /^argb$/);

Tokens: ci(")~q ValPy: 
Main loop, line=assert(sub2 'argb' =~ /^argb$/);, BufferValClass=


 === Line 16 Perl source:assert(sub2 'argb' =~ /^argb$/);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='i' perl='sub2' value='sub2' Tokenstr |c(i| translated: assert ( sub2
Lexem 3 Current token='"' perl='argb' value=''argb'' Tokenstr |c(i"| translated: assert ( sub2 'argb'
Lexem 4 Current token='~' perl='=~' value='' Tokenstr |c(i"~| translated: assert ( sub2 'argb' 
Lexem 5 Current token='q' perl='^argb$' value='re.search(r'^argb$',' Tokenstr |c(i"~q| translated: assert ( sub2 'argb'  re.search(r'^argb$',
Lexem 6 Current token=')' perl=')' value=')' Tokenstr |c(i"~q)| translated: assert ( sub2 'argb'  re.search(r'^argb$', )

Line:   16 TokenStr: =|c(i"~q)|= @ValPy: assert ( sub2 'argb'  re.search(r'^argb$', )
control(0) =|c(i"~q)|= assert ( sub2 argb =~ ^argb$ )

control-parens removed, begin=0 start=1 =|ci"~q|= assert sub2 argb =~ ^argb$

Generated partial line assert
expression(1, 4, 0) =|ci"~q|= assert sub2 argb =~ ^argb$

Generated partial line assertre.search(r'^argb$',
expression(1, 2, 0) =|ci"~q|= assert sub2 argb =~ ^argb$

Generated partial line assertre.search(r'^argb$',sub2
Generated partial line assertre.search(r'^argb$',sub2([
expression(2, 2, 0) =|ci"~q|= assert sub2 argb =~ ^argb$

Generated partial line assertre.search(r'^argb$',sub2(['argb'
expression returns 3
Generated partial line assertre.search(r'^argb$',sub2(['argb'])
expression returns 3
Generated partial line assertre.search(r'^argb$',sub2(['argb']))
expression returns 5
  17 | 0 |   |assert re.search(r'^argb$',sub2(['argb']))                                              #PL: assert(substr('arg',0) =~ /^arg$/);

Tokens: ci"~q ValPy: 
Main loop, line=assert(substr('arg',0) =~ /^arg$/);, BufferValClass=


 === Line 17 Perl source:assert(substr('arg',0) =~ /^arg$/);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='substr' value='' Tokenstr |c(f| translated: assert ( 
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert (  (
Lexem 4 Current token='"' perl='arg' value=''arg'' Tokenstr |c(f("| translated: assert (  ( 'arg'
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |c(f(",| translated: assert (  ( 'arg' ,
Lexem 6 Current token='d' perl='0' value='0' Tokenstr |c(f(",d| translated: assert (  ( 'arg' , 0
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |c(f(",d)| translated: assert (  ( 'arg' , 0 )
Lexem 8 Current token='~' perl='=~' value='' Tokenstr |c(f(",d)~| translated: assert (  ( 'arg' , 0 ) 
Lexem 9 Current token='q' perl='^arg$' value='re.search(r'^arg$',' Tokenstr |c(f(",d)~q| translated: assert (  ( 'arg' , 0 )  re.search(r'^arg$',
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |c(f(",d)~q)| translated: assert (  ( 'arg' , 0 )  re.search(r'^arg$', )

Line:   17 TokenStr: =|c(f(",d)~q)|= @ValPy: assert (  ( 'arg' , 0 )  re.search(r'^arg$', )
control(0) =|c(f(",d)~q)|= assert ( substr ( arg , 0 ) =~ ^arg$ )

control-parens removed, begin=0 start=1 =|cf(",d)~q|= assert substr ( arg , 0 ) =~ ^arg$

Generated partial line assert
expression(1, 8, 0) =|cf(",d)~q|= assert substr ( arg , 0 ) =~ ^arg$

Generated partial line assertre.search(r'^arg$',
expression(1, 6, 0) =|cf(",d)~q|= assert substr ( arg , 0 ) =~ ^arg$

function(1, 6) =|cf(",d)~q|= assert substr ( arg , 0 ) =~ ^arg$

function start=3, end_pos=5, bracketed=1
Generated partial line assertre.search(r'^arg$','arg'
Generated partial line assertre.search(r'^arg$','arg'[
expression(5, 5, 0) =|cf(",d)~q|= assert substr ( arg , 0 ) =~ ^arg$

Generated partial line assertre.search(r'^arg$','arg'[0
expression returns 6
Generated partial line assertre.search(r'^arg$','arg'[0:]
expression returns 7
Generated partial line assertre.search(r'^arg$','arg'[0:])
expression returns 9
  18 | 0 |   |assert re.search(r'^arg$','arg'[0:])                                                    #PL: assert(substr 'arg',0  =~ /^arg$/);

Tokens: cf(",d)~q ValPy: 
Main loop, line=assert(substr 'arg',0  =~ /^arg$/);, BufferValClass=


 === Line 18 Perl source:assert(substr 'arg',0  =~ /^arg$/);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='substr' value='' Tokenstr |c(f| translated: assert ( 
Lexem 3 Current token='"' perl='arg' value=''arg'' Tokenstr |c(f"| translated: assert (  'arg'
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |c(f",| translated: assert (  'arg' ,
Lexem 5 Current token='d' perl='0' value='0' Tokenstr |c(f",d| translated: assert (  'arg' , 0
Lexem 6 Current token='~' perl='=~' value='' Tokenstr |c(f",d~| translated: assert (  'arg' , 0 
Lexem 7 Current token='q' perl='^arg$' value='re.search(r'^arg$',' Tokenstr |c(f",d~q| translated: assert (  'arg' , 0  re.search(r'^arg$',
Lexem 8 Current token=')' perl=')' value=')' Tokenstr |c(f",d~q)| translated: assert (  'arg' , 0  re.search(r'^arg$', )

Line:   18 TokenStr: =|c(f",d~q)|= @ValPy: assert (  'arg' , 0  re.search(r'^arg$', )
control(0) =|c(f",d~q)|= assert ( substr arg , 0 =~ ^arg$ )

control-parens removed, begin=0 start=1 =|cf",d~q|= assert substr arg , 0 =~ ^arg$

Generated partial line assert
expression(1, 6, 0) =|cf",d~q|= assert substr arg , 0 =~ ^arg$

Generated partial line assertre.search(r'^arg$',
expression(1, 4, 0) =|cf",d~q|= assert substr arg , 0 =~ ^arg$

function(1, 4) =|cf",d~q|= assert substr arg , 0 =~ ^arg$

function start=2, end_pos=4, bracketed=0
Generated partial line assertre.search(r'^arg$','arg'
Generated partial line assertre.search(r'^arg$','arg'[
expression(4, 4, 0) =|cf",d~q|= assert substr arg , 0 =~ ^arg$

Generated partial line assertre.search(r'^arg$','arg'[0
expression returns 5
Generated partial line assertre.search(r'^arg$','arg'[0:]
expression returns 5
Generated partial line assertre.search(r'^arg$','arg'[0:])
expression returns 7
  19 | 0 |   |
  20 | 0 |   |assert re.search(r'^arg$','arg'[0:])                                                    #PL: $_ = ord('a');

Tokens: cf",d~q ValPy: 
Main loop, line=$_ = ord('a');, BufferValClass=


 === Line 20 Perl source:$_ = ord('a');===

Lexem 0 Current token='s' perl='$_' value='_d' Tokenstr |s| translated: _d
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: _d =
Lexem 2 Current token='f' perl='ord' value='ord' Tokenstr |s=f| translated: _d = ord
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |s=f(| translated: _d = ord (
Lexem 4 Current token='"' perl='a' value=''a'' Tokenstr |s=f("| translated: _d = ord ( 'a'
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |s=f(")| translated: _d = ord ( 'a' )

Line:   20 TokenStr: =|s=f(")|= @ValPy: _d = ord ( 'a' )
assignment(0, 5) =|s=f(")|= $_ = ord ( a )

Generated partial line _d
Generated partial line _d=
expression(2, 5, 0) =|s=f(")|= $_ = ord ( a )

function(2, 5) =|s=f(")|= $_ = ord ( a )

function start=4, end_pos=4, bracketed=1
Generated partial line _d=ord(
expression(4, 4, 0) =|s=f(")|= $_ = ord ( a )

Generated partial line _d=ord('a'
expression returns 5
Generated partial line _d=ord('a')
expression returns 6
  21 | 0 |   |_d = ord('a')                                                                           #PL: assert(chr =~ /^a$/);

Tokens: s=f(") ValPy: 
Main loop, line=assert(chr =~ /^a$/);, BufferValClass=


 === Line 21 Perl source:assert(chr =~ /^a$/);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='chr' value='chr' Tokenstr |c(f| translated: assert ( chr
Lexem 3 Current token='~' perl='=~' value='' Tokenstr |c(f~| translated: assert ( chr 
Lexem 4 Current token='q' perl='^a$' value='re.search(r'^a$',' Tokenstr |c(f~q| translated: assert ( chr  re.search(r'^a$',
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(f~q)| translated: assert ( chr  re.search(r'^a$', )

Line:   21 TokenStr: =|c(f~q)|= @ValPy: assert ( chr  re.search(r'^a$', )
control(0) =|c(f~q)|= assert ( chr =~ ^a$ )

control-parens removed, begin=0 start=1 =|cf~q|= assert chr =~ ^a$

Generated partial line assert
expression(1, 3, 0) =|cf~q|= assert chr =~ ^a$

Generated partial line assertre.search(r'^a$',
expression(1, 1, 0) =|cf~q|= assert chr =~ ^a$

function(1, 1) =|cf~q|= assert chr =~ ^a$

function start=2, end_pos=1, bracketed=-1
Generated partial line assertre.search(r'^a$',chr(_d)
expression returns 2
Generated partial line assertre.search(r'^a$',chr(_d))
expression returns 4
  22 | 0 |   |
  23 | 0 |   |assert re.search(r'^a$',chr(_d))                                                        #PL: my @arr = ('aa', 'bb');

Tokens: cf~q ValPy: 
Main loop, line=my @arr = ('aa', 'bb');, BufferValClass=


 === Line 23 Perl source:my @arr = ('aa', 'bb');===

Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |ta| translated:  arr
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  arr =
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |ta=(| translated:  arr = (
Lexem 4 Current token='"' perl='aa' value=''aa'' Tokenstr |ta=("| translated:  arr = ( 'aa'
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |ta=(",| translated:  arr = ( 'aa' ,
Lexem 6 Current token='"' perl='bb' value=''bb'' Tokenstr |ta=(","| translated:  arr = ( 'aa' , 'bb'
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |ta=(",")| translated:  arr = ( 'aa' , 'bb' )

Line:   23 TokenStr: =|ta=(",")|= @ValPy:  arr = ( 'aa' , 'bb' )
Generated partial line arr = [
Generated partial line arr = ['aa'
Generated partial line arr = ['aa',
Generated partial line arr = ['aa','bb'
Generated partial line arr = ['aa','bb']
  24 | 0 |   |arr = ['aa', 'bb']                                                                      #PL: my $i = 0;

Tokens: a=(",") ValPy: 
Main loop, line=my $i = 0;, BufferValClass=


 === Line 24 Perl source:my $i = 0;===

Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='s' perl='$i' value='i' Tokenstr |ts| translated:  i
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ts=| translated:  i =
Lexem 3 Current token='d' perl='0' value='0' Tokenstr |ts=d| translated:  i = 0

Line:   24 TokenStr: =|ts=d|= @ValPy:  i = 0
  24 | 0 |   |i=0                                                                                     #PL: my $i = 0;
Main loop, line=assert($arr[$i] =~ /^aa$/);, BufferValClass=


 === Line 25 Perl source:assert($arr[$i] =~ /^aa$/);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$arr' value='arr' Tokenstr |c(s| translated: assert ( arr
Lexem 3 Current token='(' perl='[' value='[' Tokenstr |c(s(| translated: assert ( arr [
Lexem 4 Current token='s' perl='$i' value='i' Tokenstr |c(s(s| translated: assert ( arr [ i
Lexem 5 Current token=')' perl=']' value=']' Tokenstr |c(s(s)| translated: assert ( arr [ i ]
Lexem 6 Current token='~' perl='=~' value='' Tokenstr |c(s(s)~| translated: assert ( arr [ i ] 
Lexem 7 Current token='q' perl='^aa$' value='re.search(r'^aa$',' Tokenstr |c(s(s)~q| translated: assert ( arr [ i ]  re.search(r'^aa$',
Lexem 8 Current token=')' perl=')' value=')' Tokenstr |c(s(s)~q)| translated: assert ( arr [ i ]  re.search(r'^aa$', )

Line:   25 TokenStr: =|c(s(s)~q)|= @ValPy: assert ( arr [ i ]  re.search(r'^aa$', )
control(0) =|c(s(s)~q)|= assert ( $arr [ $i ] =~ ^aa$ )

control-parens removed, begin=0 start=1 =|cs(s)~q|= assert $arr [ $i ] =~ ^aa$

Generated partial line assert
expression(1, 6, 0) =|cs(s)~q|= assert $arr [ $i ] =~ ^aa$

Generated partial line assertre.search(r'^aa$',
expression(1, 4, 0) =|cs(s)~q|= assert $arr [ $i ] =~ ^aa$

Generated partial line assertre.search(r'^aa$',arr
Generated partial line assertre.search(r'^aa$',arr[
expression(3, 3, 0) =|cs(s)~q|= assert $arr [ $i ] =~ ^aa$

Generated partial line assertre.search(r'^aa$',arr[i
expression returns 4
Generated partial line assertre.search(r'^aa$',arr[i]
expression returns 5
Generated partial line assertre.search(r'^aa$',arr[i])
expression returns 7
  26 | 0 |   |assert re.search(r'^aa$',arr[i])                                                        #PL: my %hash = (k1=>'v1');

Tokens: cs(s)~q ValPy: 
Main loop, line=my %hash = (k1=>'v1');, BufferValClass=


 === Line 26 Perl source:my %hash = (k1=>'v1');===

Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='h' perl='hash' value='hash' Tokenstr |th| translated:  hash
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |th=| translated:  hash =
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |th=(| translated:  hash = (
Lexem 4 Current token='i' perl='k1' value='k1' Tokenstr |th=(i| translated:  hash = ( k1
Lexem 5 Current token=':' perl='=>' value=': ' Tokenstr |th=(i:| translated:  hash = ( k1 : 
Lexem 6 Current token='"' perl='v1' value=''v1'' Tokenstr |th=(i:"| translated:  hash = ( k1 :  'v1'
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |th=(i:")| translated:  hash = ( k1 :  'v1' )

Line:   26 TokenStr: =|th=(i:")|= @ValPy:  hash = ( k1 :  'v1' )
Generated partial line hash = {
Generated partial line hash = {'k1'
Generated partial line hash = {'k1': 
Generated partial line hash = {'k1': 'v1'
Generated partial line hash = {'k1': 'v1'}
  27 | 0 |   |hash = {'k1': 'v1'}                                                                     #PL: assert($hash{k1} =~ /^v1$/);

Tokens: h=(i:") ValPy: 
Main loop, line=assert($hash{k1} =~ /^v1$/);, BufferValClass=


 === Line 27 Perl source:assert($hash{k1} =~ /^v1$/);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$hash' value='hash' Tokenstr |c(s| translated: assert ( hash
Lexem 3 Current token='(' perl='{' value='[' Tokenstr |c(s(| translated: assert ( hash [
Lexem 4 Current token='i' perl='k1' value='k1' Tokenstr |c(s(i| translated: assert ( hash [ k1
Lexem 5 Current token=')' perl='}' value=']' Tokenstr |c(s(")| translated: assert ( hash [ 'k1' ]
Lexem 6 Current token='~' perl='=~' value='' Tokenstr |c(s(")~| translated: assert ( hash [ 'k1' ] 
Lexem 7 Current token='q' perl='^v1$' value='re.search(r'^v1$',' Tokenstr |c(s(")~q| translated: assert ( hash [ 'k1' ]  re.search(r'^v1$',
Lexem 8 Current token=')' perl=')' value=')' Tokenstr |c(s(")~q)| translated: assert ( hash [ 'k1' ]  re.search(r'^v1$', )

Line:   27 TokenStr: =|c(s(")~q)|= @ValPy: assert ( hash [ 'k1' ]  re.search(r'^v1$', )
control(0) =|c(s(")~q)|= assert ( $hash { k1 } =~ ^v1$ )

control-parens removed, begin=0 start=1 =|cs(")~q|= assert $hash { k1 } =~ ^v1$

Generated partial line assert
expression(1, 6, 0) =|cs(")~q|= assert $hash { k1 } =~ ^v1$

Generated partial line assertre.search(r'^v1$',
expression(1, 4, 0) =|cs(")~q|= assert $hash { k1 } =~ ^v1$

Generated partial line assertre.search(r'^v1$',hash
Generated partial line assertre.search(r'^v1$',hash.get(
expression(3, 3, 0) =|cs(")~q|= assert $hash { k1 } =~ ^v1$

Generated partial line assertre.search(r'^v1$',hash.get('k1'
expression returns 4
Generated partial line assertre.search(r'^v1$',hash.get('k1')
expression returns 5
Generated partial line assertre.search(r'^v1$',hash.get('k1'))
expression returns 7
  28 | 0 |   |
  29 | 0 |   |assert re.search(r'^v1$',hash.get('k1'))                                                #PL: print "$0 - test passed!\n";

Tokens: cs(")~q ValPy: 
Main loop, line=print "$0 - test passed!\n";, BufferValClass=


 === Line 29 Perl source:print "$0 - test passed!\n";===

Lexem 0 Current token='f' perl='print' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='"' perl='$0 - test passed!\n' value='f"{__file__} - test passed!\n"' Tokenstr |f"| translated: print f"{__file__} - test passed!\n"

Line:   29 TokenStr: =|f"|= @ValPy: print f"{__file__} - test passed!\n"
Generated partial line print(
print3(0) start=0, handle=, k=1, end_pos=1

expression(1, 1, 0) =|f"|= print $0 - test passed!\n

Generated partial line print(f"{__file__} - test passed!\n"
expression returns 2
Generated partial line print(f"{__file__} - test passed!")
  29 | 0 |   |print(f"{__file__} - test passed!")                                                     #PL: print "$0 - test passed!\n";

Tokens: f" ValPy: 
initialize_globals_for_state_vars: 
ERROR STATISTICS:  W: 1


 [Softpano-W317]:  Debug flag is set to 5


