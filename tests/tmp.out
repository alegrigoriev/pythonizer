 [Softpano-W317]:  Debug flag is set to 5


PYTHONIZER: Fuzzy translator of Python to Perl. Version 0.922 (mtime 211210_1111) Started at 21/12/10 11:11

Logs are at /tmp/Pythonizer/pythonizer.211210_1111.log. Type -h for help.
=============================================================================================================
Results of transcription are written to the file  test_foreach.py
=========================================================================================================================

Lexem 0 Current token='c' perl='use' value='NoTrans!' Tokenstr |c| translated: NoTrans!
Lexem 1 Current token='i' perl='Carp::Assert' value='Carp.Assert' Tokenstr |ci| translated: NoTrans! Carp.Assert
Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='h' perl='hash' value='hash' Tokenstr |th| translated:  hash
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |th=| translated:  hash =
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |th=(| translated:  hash = (
Lexem 4 Current token='i' perl='k1' value='k1' Tokenstr |th=(i| translated:  hash = ( k1
Lexem 5 Current token=':' perl='=>' value=': ' Tokenstr |th=(i:| translated:  hash = ( k1 : 
Lexem 6 Current token='"' perl='v1' value=''v1'' Tokenstr |th=(i:"| translated:  hash = ( k1 :  'v1'
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |th=(i:",| translated:  hash = ( k1 :  'v1' ,
Lexem 8 Current token='i' perl='k3' value='k3' Tokenstr |th=(i:",i| translated:  hash = ( k1 :  'v1' , k3
Lexem 9 Current token=':' perl='=>' value=': ' Tokenstr |th=(i:",i:| translated:  hash = ( k1 :  'v1' , k3 : 
Lexem 10 Current token='"' perl='v3' value=''v3'' Tokenstr |th=(i:",i:"| translated:  hash = ( k1 :  'v1' , k3 :  'v3'
Lexem 11 Current token=',' perl=',' value=',' Tokenstr |th=(i:",i:",| translated:  hash = ( k1 :  'v1' , k3 :  'v3' ,
Lexem 12 Current token='i' perl='k2' value='k2' Tokenstr |th=(i:",i:",i| translated:  hash = ( k1 :  'v1' , k3 :  'v3' , k2
Lexem 13 Current token=':' perl='=>' value=': ' Tokenstr |th=(i:",i:",i:| translated:  hash = ( k1 :  'v1' , k3 :  'v3' , k2 : 
Lexem 14 Current token='"' perl='v2' value=''v2'' Tokenstr |th=(i:",i:",i:"| translated:  hash = ( k1 :  'v1' , k3 :  'v3' , k2 :  'v2'
Lexem 15 Current token=')' perl=')' value=')' Tokenstr |th=(i:",i:",i:")| translated:  hash = ( k1 :  'v1' , k3 :  'v3' , k2 :  'v2' )
check_ref(main, hash) at 1
expr_type(3, 15, main)
expr_type(6, 6, main)
expr_type(10, 10, main)
merge_types(hash, main, h of u)
Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@khash' value='khash' Tokenstr |ta| translated:  khash
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  khash =
Lexem 3 Current token='f' perl='keys' value='.keys()' Tokenstr |ta=f| translated:  khash = .keys()
Lexem 4 Current token='h' perl='hash' value='hash' Tokenstr |ta=fh| translated:  khash = .keys() hash
check_ref(main, khash) at 1
expr_type(3, 4, main)
merge_types(khash, main, a of S)
check_ref(main, hash) at 4
Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@files' value='files' Tokenstr |ta| translated:  files
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  files =
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |ta=(| translated:  files = (
Lexem 4 Current token='"' perl='file1' value=''file1'' Tokenstr |ta=("| translated:  files = ( 'file1'
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |ta=(",| translated:  files = ( 'file1' ,
Lexem 6 Current token='"' perl='file3' value=''file3'' Tokenstr |ta=(","| translated:  files = ( 'file1' , 'file3'
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |ta=(",",| translated:  files = ( 'file1' , 'file3' ,
Lexem 8 Current token='"' perl='file2' value=''file2'' Tokenstr |ta=(",","| translated:  files = ( 'file1' , 'file3' , 'file2'
Lexem 9 Current token=')' perl=')' value=')' Tokenstr |ta=(",",")| translated:  files = ( 'file1' , 'file3' , 'file2' )
check_ref(main, files) at 1
expr_type(3, 9, main)
expr_type(4, 4, main)
expr_type(6, 6, main)
merge_types(files, main, a of u)
Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |ta| translated:  arr
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  arr =
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |ta=(| translated:  arr = (
Lexem 4 Current token=')' perl=')' value=')' Tokenstr |ta=()| translated:  arr = ( )
check_ref(main, arr) at 1
expr_type(3, 4, main)
expr_type(4, 3, main)
merge_types(arr, main, u)
Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='h' perl='tickets' value='tickets' Tokenstr |th| translated:  tickets
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |th=| translated:  tickets =
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |th=(| translated:  tickets = (
Lexem 4 Current token='i' perl='t1' value='t1' Tokenstr |th=(i| translated:  tickets = ( t1
Lexem 5 Current token=':' perl='=>' value=': ' Tokenstr |th=(i:| translated:  tickets = ( t1 : 
Lexem 6 Current token='"' perl='v1' value=''v1'' Tokenstr |th=(i:"| translated:  tickets = ( t1 :  'v1'
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |th=(i:",| translated:  tickets = ( t1 :  'v1' ,
Lexem 8 Current token='i' perl='t3' value='t3' Tokenstr |th=(i:",i| translated:  tickets = ( t1 :  'v1' , t3
Lexem 9 Current token=':' perl='=>' value=': ' Tokenstr |th=(i:",i:| translated:  tickets = ( t1 :  'v1' , t3 : 
Lexem 10 Current token='"' perl='v3' value=''v3'' Tokenstr |th=(i:",i:"| translated:  tickets = ( t1 :  'v1' , t3 :  'v3'
Lexem 11 Current token=',' perl=',' value=',' Tokenstr |th=(i:",i:",| translated:  tickets = ( t1 :  'v1' , t3 :  'v3' ,
Lexem 12 Current token='i' perl='t2' value='t2' Tokenstr |th=(i:",i:",i| translated:  tickets = ( t1 :  'v1' , t3 :  'v3' , t2
Lexem 13 Current token=':' perl='=>' value=': ' Tokenstr |th=(i:",i:",i:| translated:  tickets = ( t1 :  'v1' , t3 :  'v3' , t2 : 
Lexem 14 Current token='"' perl='v2' value=''v2'' Tokenstr |th=(i:",i:",i:"| translated:  tickets = ( t1 :  'v1' , t3 :  'v3' , t2 :  'v2'
Lexem 15 Current token=')' perl=')' value=')' Tokenstr |th=(i:",i:",i:")| translated:  tickets = ( t1 :  'v1' , t3 :  'v3' , t2 :  'v2' )
check_ref(main, tickets) at 1
expr_type(3, 15, main)
expr_type(6, 6, main)
expr_type(10, 10, main)
merge_types(tickets, main, h of u)
Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@tkts' value='tkts' Tokenstr |ta| translated:  tkts
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  tkts =
Lexem 3 Current token='h' perl='tickets' value='tickets' Tokenstr |ta=h| translated:  tkts = tickets
check_ref(main, tkts) at 1
expr_type(3, 3, main)
merge_types(tkts, main, u)
check_ref(main, tickets) at 3
Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='h' perl='tk' value='tk' Tokenstr |th| translated:  tk
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |th=| translated:  tk =
Lexem 3 Current token='a' perl='@tkts' value='tkts' Tokenstr |th=a| translated:  tk = tkts
check_ref(main, tk) at 1
expr_type(3, 3, main)
merge_types(tk, main, u)
check_ref(main, tkts) at 3
Lexem 0 Current token='i' perl='aeq_unordered' value='aeq_unordered' Tokenstr |i| translated: aeq_unordered
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeq_unordered (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeq_unordered ( 
Lexem 3 Current token='a' perl='@tkts' value='tkts' Tokenstr |i(\a| translated: aeq_unordered (  tkts
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeq_unordered (  tkts ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeq_unordered (  tkts , [
Lexem 6 Current token='"' perl='t1' value=''t1'' Tokenstr |i(\a,("| translated: aeq_unordered (  tkts , [ 't1'
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",| translated: aeq_unordered (  tkts , [ 't1' ,
Lexem 8 Current token='"' perl='t2' value=''t2'' Tokenstr |i(\a,(","| translated: aeq_unordered (  tkts , [ 't1' , 't2'
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",",| translated: aeq_unordered (  tkts , [ 't1' , 't2' ,
Lexem 10 Current token='"' perl='t3' value=''t3'' Tokenstr |i(\a,(",","| translated: aeq_unordered (  tkts , [ 't1' , 't2' , 't3'
Lexem 11 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",",",| translated: aeq_unordered (  tkts , [ 't1' , 't2' , 't3' ,
Lexem 12 Current token='"' perl='v1' value=''v1'' Tokenstr |i(\a,(",",","| translated: aeq_unordered (  tkts , [ 't1' , 't2' , 't3' , 'v1'
Lexem 13 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",",",",| translated: aeq_unordered (  tkts , [ 't1' , 't2' , 't3' , 'v1' ,
Lexem 14 Current token='"' perl='v2' value=''v2'' Tokenstr |i(\a,(",",",","| translated: aeq_unordered (  tkts , [ 't1' , 't2' , 't3' , 'v1' , 'v2'
Lexem 15 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",",",",",| translated: aeq_unordered (  tkts , [ 't1' , 't2' , 't3' , 'v1' , 'v2' ,
Lexem 16 Current token='"' perl='v3' value=''v3'' Tokenstr |i(\a,(",",",",","| translated: aeq_unordered (  tkts , [ 't1' , 't2' , 't3' , 'v1' , 'v2' , 'v3'
Lexem 17 Current token=')' perl=']' value=']' Tokenstr |i(\a,(",",",",",")| translated: aeq_unordered (  tkts , [ 't1' , 't2' , 't3' , 'v1' , 'v2' , 'v3' ]
Lexem 18 Current token=')' perl=')' value=')' Tokenstr |i(\a,(",",",",","))| translated: aeq_unordered (  tkts , [ 't1' , 't2' , 't3' , 'v1' , 'v2' , 'v3' ] )
check_ref(main, tkts) at 3
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='scalar' value='len' Tokenstr |c(f| translated: assert ( len
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( len (
Lexem 4 Current token='h' perl='tk' value='tk' Tokenstr |c(f(h| translated: assert ( len ( tk
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(f(h)| translated: assert ( len ( tk )
Lexem 6 Current token='>' perl='==' value='==' Tokenstr |c(f(h)>| translated: assert ( len ( tk ) ==
Lexem 7 Current token='d' perl='3' value='3' Tokenstr |c(f(h)>d| translated: assert ( len ( tk ) == 3
Lexem 8 Current token='0' perl='&&' value=' and ' Tokenstr |c(f(h)>d0| translated: assert ( len ( tk ) == 3  and 
Lexem 9 Current token='s' perl='$tk' value='tk' Tokenstr |c(f(h)>d0s| translated: assert ( len ( tk ) == 3  and  tk
Lexem 10 Current token='(' perl='{' value='[' Tokenstr |c(f(h)>d0s(| translated: assert ( len ( tk ) == 3  and  tk [
Lexem 11 Current token='i' perl='t1' value='t1' Tokenstr |c(f(h)>d0s(i| translated: assert ( len ( tk ) == 3  and  tk [ t1
Lexem 12 Current token=')' perl='}' value=']' Tokenstr |c(f(h)>d0s(")| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ]
Lexem 13 Current token='>' perl='eq' value='==' Tokenstr |c(f(h)>d0s(")>| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] ==
Lexem 14 Current token='"' perl='v1' value=''v1'' Tokenstr |c(f(h)>d0s(")>"| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'
Lexem 15 Current token='0' perl='&&' value=' and ' Tokenstr |c(f(h)>d0s(")>"0| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'  and 
Lexem 16 Current token='s' perl='$tk' value='tk' Tokenstr |c(f(h)>d0s(")>"0s| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'  and  tk
Lexem 17 Current token='(' perl='{' value='[' Tokenstr |c(f(h)>d0s(")>"0s(| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'  and  tk [
Lexem 18 Current token='i' perl='t2' value='t2' Tokenstr |c(f(h)>d0s(")>"0s(i| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'  and  tk [ t2
Lexem 19 Current token=')' perl='}' value=']' Tokenstr |c(f(h)>d0s(")>"0s(")| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'  and  tk [ 't2' ]
Lexem 20 Current token='>' perl='eq' value='==' Tokenstr |c(f(h)>d0s(")>"0s(")>| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'  and  tk [ 't2' ] ==
Lexem 21 Current token='"' perl='v2' value=''v2'' Tokenstr |c(f(h)>d0s(")>"0s(")>"| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'  and  tk [ 't2' ] == 'v2'
Lexem 22 Current token='0' perl='&&' value=' and ' Tokenstr |c(f(h)>d0s(")>"0s(")>"0| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'  and  tk [ 't2' ] == 'v2'  and 
Lexem 23 Current token='s' perl='$tk' value='tk' Tokenstr |c(f(h)>d0s(")>"0s(")>"0s| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'  and  tk [ 't2' ] == 'v2'  and  tk
Lexem 24 Current token='(' perl='{' value='[' Tokenstr |c(f(h)>d0s(")>"0s(")>"0s(| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'  and  tk [ 't2' ] == 'v2'  and  tk [
Lexem 25 Current token='i' perl='t3' value='t3' Tokenstr |c(f(h)>d0s(")>"0s(")>"0s(i| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'  and  tk [ 't2' ] == 'v2'  and  tk [ t3
Lexem 26 Current token=')' perl='}' value=']' Tokenstr |c(f(h)>d0s(")>"0s(")>"0s(")| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'  and  tk [ 't2' ] == 'v2'  and  tk [ 't3' ]
Lexem 27 Current token='>' perl='eq' value='==' Tokenstr |c(f(h)>d0s(")>"0s(")>"0s(")>| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'  and  tk [ 't2' ] == 'v2'  and  tk [ 't3' ] ==
Lexem 28 Current token='"' perl='v3' value=''v3'' Tokenstr |c(f(h)>d0s(")>"0s(")>"0s(")>"| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'  and  tk [ 't2' ] == 'v2'  and  tk [ 't3' ] == 'v3'
Lexem 29 Current token=')' perl=')' value=')' Tokenstr |c(f(h)>d0s(")>"0s(")>"0s(")>")| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'  and  tk [ 't2' ] == 'v2'  and  tk [ 't3' ] == 'v3' )
check_ref(main, tk) at 4
check_ref(main, tk) at 9
merge_types(tk, main, h of u)
merge_types: otype=u
check_ref(main, tk) at 16
merge_types(tk, main, h of u)
merge_types: otype=h of u
check_ref(main, tk) at 23
merge_types(tk, main, h of u)
merge_types: otype=h of u
Lexem 0 Current token='c' perl='foreach' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='s' perl='$p' value='p' Tokenstr |cs| translated: for  p
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |cs(| translated: for  p (
Lexem 3 Current token='f' perl='keys' value='.keys()' Tokenstr |cs(f| translated: for  p ( .keys()
Lexem 4 Current token='h' perl='hash' value='hash' Tokenstr |cs(fh| translated: for  p ( .keys() hash
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |cs(fh)| translated: for  p ( .keys() hash )
check_ref(main, p) at 1
scalar_reference_type(1) = u
merge_types(p, main, u)
check_ref(main, hash) at 4
Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$p' value='p' Tokenstr |fa,s| translated: .extend( arr , p
check_ref(main, arr) at 1
check_ref(main, p) at 3
arg_type(push, 2) = s
scalar_reference_type(3) = s
merge_types(p, main, s)
merge_types: otype=u
expr_type(0, 3, main)
Lexem 0 Current token='i' perl='aeq_unordered' value='aeq_unordered' Tokenstr |i| translated: aeq_unordered
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeq_unordered (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeq_unordered ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeq_unordered (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeq_unordered (  arr ,
Lexem 5 Current token='\' perl='\' value='' Tokenstr |i(\a,\| translated: aeq_unordered (  arr , 
Lexem 6 Current token='a' perl='@khash' value='khash' Tokenstr |i(\a,\a| translated: aeq_unordered (  arr ,  khash
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |i(\a,\a)| translated: aeq_unordered (  arr ,  khash )
check_ref(main, arr) at 3
check_ref(main, khash) at 6
Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )
check_ref(main, arr) at 0
expr_type(2, 3, main)
expr_type(3, 2, main)
merge_types(arr, main, u)
merge_types: otype=u
expr_type(0, 3, main)
Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='s' perl='$file' value='file' Tokenstr |cs| translated: for  file
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |cs(| translated: for  file (
Lexem 3 Current token='a' perl='@files' value='files' Tokenstr |cs(a| translated: for  file ( files
Lexem 4 Current token=')' perl=')' value=')' Tokenstr |cs(a)| translated: for  file ( files )
check_ref(main, file) at 1
scalar_reference_type(1) = u
merge_types(file, main, u)
check_ref(main, files) at 3
Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$file' value='file' Tokenstr |fa,s| translated: .extend( arr , file
check_ref(main, arr) at 1
check_ref(main, file) at 3
arg_type(push, 2) = s
scalar_reference_type(3) = s
merge_types(file, main, s)
merge_types: otype=u
expr_type(0, 3, main)
Lexem 0 Current token='i' perl='aeq' value='aeq' Tokenstr |i| translated: aeq
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeq (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeq ( 
Lexem 3 Current token='a' perl='@files' value='files' Tokenstr |i(\a| translated: aeq (  files
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeq (  files ,
Lexem 5 Current token='\' perl='\' value='' Tokenstr |i(\a,\| translated: aeq (  files , 
Lexem 6 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a,\a| translated: aeq (  files ,  arr
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |i(\a,\a)| translated: aeq (  files ,  arr )
check_ref(main, files) at 3
check_ref(main, arr) at 6
Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )
check_ref(main, arr) at 0
expr_type(2, 3, main)
expr_type(3, 2, main)
merge_types(arr, main, u)
merge_types: otype=u
expr_type(0, 3, main)
Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='a' perl='@files' value='files' Tokenstr |c(a| translated: for  ( files
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(a)| translated: for  ( files )
check_ref(main, files) at 2
Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$_' value='_d' Tokenstr |fa,s| translated: .extend( arr , _d
check_ref(main, arr) at 1
check_ref(main, _d) at 3
arg_type(push, 2) = s
scalar_reference_type(3) = s
merge_types(_d, main, s)
expr_type(0, 3, main)
Lexem 0 Current token='i' perl='aeq' value='aeq' Tokenstr |i| translated: aeq
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeq (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeq ( 
Lexem 3 Current token='a' perl='@files' value='files' Tokenstr |i(\a| translated: aeq (  files
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeq (  files ,
Lexem 5 Current token='\' perl='\' value='' Tokenstr |i(\a,\| translated: aeq (  files , 
Lexem 6 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a,\a| translated: aeq (  files ,  arr
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |i(\a,\a)| translated: aeq (  files ,  arr )
check_ref(main, files) at 3
check_ref(main, arr) at 6
Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )
check_ref(main, arr) at 0
expr_type(2, 3, main)
expr_type(3, 2, main)
merge_types(arr, main, u)
merge_types: otype=u
expr_type(0, 3, main)
Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='t' perl='my' value='' Tokenstr |ct| translated: for  
Lexem 2 Current token='s' perl='$file' value='file' Tokenstr |cts| translated: for   file
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |cts(| translated: for   file (
Lexem 4 Current token='a' perl='@files' value='files' Tokenstr |cts(a| translated: for   file ( files
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |cts(a)| translated: for   file ( files )
check_ref(main, file) at 2
scalar_reference_type(2) = u
check_ref(main, files) at 4
Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$file' value='file' Tokenstr |fa,s| translated: .extend( arr , file
check_ref(main, arr) at 1
check_ref(main, file) at 3
arg_type(push, 2) = s
scalar_reference_type(3) = s
expr_type(0, 3, main)
Lexem 0 Current token='i' perl='aeq' value='aeq' Tokenstr |i| translated: aeq
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeq (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeq ( 
Lexem 3 Current token='a' perl='@files' value='files' Tokenstr |i(\a| translated: aeq (  files
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeq (  files ,
Lexem 5 Current token='\' perl='\' value='' Tokenstr |i(\a,\| translated: aeq (  files , 
Lexem 6 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a,\a| translated: aeq (  files ,  arr
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |i(\a,\a)| translated: aeq (  files ,  arr )
check_ref(main, files) at 3
check_ref(main, arr) at 6
Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )
check_ref(main, arr) at 0
expr_type(2, 3, main)
expr_type(3, 2, main)
merge_types(arr, main, u)
merge_types: otype=u
expr_type(0, 3, main)
Lexem 0 Current token='c' perl='foreach' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='s' perl='$file' value='file' Tokenstr |cs| translated: for  file
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |cs(| translated: for  file (
Lexem 3 Current token='a' perl='@files' value='files' Tokenstr |cs(a| translated: for  file ( files
Lexem 4 Current token=')' perl=')' value=')' Tokenstr |cs(a)| translated: for  file ( files )
check_ref(main, file) at 1
scalar_reference_type(1) = u
check_ref(main, files) at 3
Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$file' value='file' Tokenstr |fa,s| translated: .extend( arr , file
check_ref(main, arr) at 1
check_ref(main, file) at 3
arg_type(push, 2) = s
scalar_reference_type(3) = s
expr_type(0, 3, main)
Lexem 0 Current token='i' perl='aeq' value='aeq' Tokenstr |i| translated: aeq
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeq (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeq ( 
Lexem 3 Current token='a' perl='@files' value='files' Tokenstr |i(\a| translated: aeq (  files
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeq (  files ,
Lexem 5 Current token='\' perl='\' value='' Tokenstr |i(\a,\| translated: aeq (  files , 
Lexem 6 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a,\a| translated: aeq (  files ,  arr
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |i(\a,\a)| translated: aeq (  files ,  arr )
check_ref(main, files) at 3
check_ref(main, arr) at 6
Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )
check_ref(main, arr) at 0
expr_type(2, 3, main)
expr_type(3, 2, main)
merge_types(arr, main, u)
merge_types: otype=u
expr_type(0, 3, main)
Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='t' perl='my' value='' Tokenstr |c(t| translated: for  ( 
Lexem 3 Current token='s' perl='$i' value='i' Tokenstr |c(ts| translated: for  (  i
Lexem 4 Current token='=' perl='=' value=':=' Tokenstr |c(ts=| translated: for  (  i :=
Lexem 5 Current token='d' perl='5' value='5' Tokenstr |c(ts=d| translated: for  (  i := 5
Lexem 6 Current token=';' perl=';' value=';' Tokenstr |c(ts=d;| translated: for  (  i := 5 ;
Lexem 7 Current token='s' perl='$i' value='i' Tokenstr |c(ts=d;s| translated: for  (  i := 5 ; i
Lexem 8 Current token='>' perl='>=' value='>=' Tokenstr |c(ts=d;s>| translated: for  (  i := 5 ; i >=
Lexem 9 Current token='d' perl='0' value='0' Tokenstr |c(ts=d;s>d| translated: for  (  i := 5 ; i >= 0
Lexem 10 Current token=';' perl=';' value=';' Tokenstr |c(ts=d;s>d;| translated: for  (  i := 5 ; i >= 0 ;
Lexem 11 Current token='s' perl='$i' value='i' Tokenstr |c(ts=d;s>d;s| translated: for  (  i := 5 ; i >= 0 ; i
Lexem 12 Current token='^' perl='--' value='-=1' Tokenstr |c(ts=d;s>d;s^| translated: for  (  i := 5 ; i >= 0 ; i -=1
Lexem 13 Current token=')' perl=')' value=')' Tokenstr |c(ts=d;s>d;s^)| translated: for  (  i := 5 ; i >= 0 ; i -=1 )
check_ref(main, i) at 3
expr_type(5, 13, main)
merge_types(i, main, I)
check_ref(main, i) at 7
scalar_reference_type(7) = I
check_ref(main, i) at 11
merge_types(i, main, I)
merge_types: otype=I
expr_type(5, 13, main)
Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$i' value='i' Tokenstr |fa,s| translated: .extend( arr , i
check_ref(main, arr) at 1
check_ref(main, i) at 3
arg_type(push, 2) = s
scalar_reference_type(3) = s
expr_type(0, 3, main)
Lexem 0 Current token='i' perl='aeqi' value='aeqi' Tokenstr |i| translated: aeqi
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeqi (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeqi ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeqi (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeqi (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeqi (  arr , [
Lexem 6 Current token='d' perl='5' value='5' Tokenstr |i(\a,(d| translated: aeqi (  arr , [ 5
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,| translated: aeqi (  arr , [ 5 ,
Lexem 8 Current token='d' perl='4' value='4' Tokenstr |i(\a,(d,d| translated: aeqi (  arr , [ 5 , 4
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,| translated: aeqi (  arr , [ 5 , 4 ,
Lexem 10 Current token='d' perl='3' value='3' Tokenstr |i(\a,(d,d,d| translated: aeqi (  arr , [ 5 , 4 , 3
Lexem 11 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,d,| translated: aeqi (  arr , [ 5 , 4 , 3 ,
Lexem 12 Current token='d' perl='2' value='2' Tokenstr |i(\a,(d,d,d,d| translated: aeqi (  arr , [ 5 , 4 , 3 , 2
Lexem 13 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,d,d,| translated: aeqi (  arr , [ 5 , 4 , 3 , 2 ,
Lexem 14 Current token='d' perl='1' value='1' Tokenstr |i(\a,(d,d,d,d,d| translated: aeqi (  arr , [ 5 , 4 , 3 , 2 , 1
Lexem 15 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,d,d,d,| translated: aeqi (  arr , [ 5 , 4 , 3 , 2 , 1 ,
Lexem 16 Current token='d' perl='0' value='0' Tokenstr |i(\a,(d,d,d,d,d,d| translated: aeqi (  arr , [ 5 , 4 , 3 , 2 , 1 , 0
Lexem 17 Current token=')' perl=']' value=']' Tokenstr |i(\a,(d,d,d,d,d,d)| translated: aeqi (  arr , [ 5 , 4 , 3 , 2 , 1 , 0 ]
Lexem 18 Current token=')' perl=')' value=')' Tokenstr |i(\a,(d,d,d,d,d,d))| translated: aeqi (  arr , [ 5 , 4 , 3 , 2 , 1 , 0 ] )
check_ref(main, arr) at 3
Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )
check_ref(main, arr) at 0
expr_type(2, 3, main)
expr_type(3, 2, main)
merge_types(arr, main, u)
merge_types: otype=u
expr_type(0, 3, main)
Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='t' perl='my' value='' Tokenstr |c(t| translated: for  ( 
Lexem 3 Current token='s' perl='$i' value='i' Tokenstr |c(ts| translated: for  (  i
Lexem 4 Current token='=' perl='=' value=':=' Tokenstr |c(ts=| translated: for  (  i :=
Lexem 5 Current token='d' perl='5' value='5' Tokenstr |c(ts=d| translated: for  (  i := 5
Lexem 6 Current token=';' perl=';' value=';' Tokenstr |c(ts=d;| translated: for  (  i := 5 ;
Lexem 7 Current token='s' perl='$i' value='i' Tokenstr |c(ts=d;s| translated: for  (  i := 5 ; i
Lexem 8 Current token='>' perl='>' value='>' Tokenstr |c(ts=d;s>| translated: for  (  i := 5 ; i >
Lexem 9 Current token='d' perl='0' value='0' Tokenstr |c(ts=d;s>d| translated: for  (  i := 5 ; i > 0
Lexem 10 Current token=';' perl=';' value=';' Tokenstr |c(ts=d;s>d;| translated: for  (  i := 5 ; i > 0 ;
Lexem 11 Current token='s' perl='$i' value='i' Tokenstr |c(ts=d;s>d;s| translated: for  (  i := 5 ; i > 0 ; i
Lexem 12 Current token='^' perl='--' value='-=1' Tokenstr |c(ts=d;s>d;s^| translated: for  (  i := 5 ; i > 0 ; i -=1
Lexem 13 Current token=')' perl=')' value=')' Tokenstr |c(ts=d;s>d;s^)| translated: for  (  i := 5 ; i > 0 ; i -=1 )
check_ref(main, i) at 3
expr_type(5, 13, main)
merge_types(i, main, I)
merge_types: otype=I
check_ref(main, i) at 7
scalar_reference_type(7) = I
check_ref(main, i) at 11
merge_types(i, main, I)
merge_types: otype=I
expr_type(5, 13, main)
Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$i' value='i' Tokenstr |fa,s| translated: .extend( arr , i
check_ref(main, arr) at 1
check_ref(main, i) at 3
arg_type(push, 2) = s
scalar_reference_type(3) = s
expr_type(0, 3, main)
Lexem 0 Current token='i' perl='aeqi' value='aeqi' Tokenstr |i| translated: aeqi
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeqi (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeqi ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeqi (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeqi (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeqi (  arr , [
Lexem 6 Current token='d' perl='5' value='5' Tokenstr |i(\a,(d| translated: aeqi (  arr , [ 5
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,| translated: aeqi (  arr , [ 5 ,
Lexem 8 Current token='d' perl='4' value='4' Tokenstr |i(\a,(d,d| translated: aeqi (  arr , [ 5 , 4
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,| translated: aeqi (  arr , [ 5 , 4 ,
Lexem 10 Current token='d' perl='3' value='3' Tokenstr |i(\a,(d,d,d| translated: aeqi (  arr , [ 5 , 4 , 3
Lexem 11 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,d,| translated: aeqi (  arr , [ 5 , 4 , 3 ,
Lexem 12 Current token='d' perl='2' value='2' Tokenstr |i(\a,(d,d,d,d| translated: aeqi (  arr , [ 5 , 4 , 3 , 2
Lexem 13 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,d,d,| translated: aeqi (  arr , [ 5 , 4 , 3 , 2 ,
Lexem 14 Current token='d' perl='1' value='1' Tokenstr |i(\a,(d,d,d,d,d| translated: aeqi (  arr , [ 5 , 4 , 3 , 2 , 1
Lexem 15 Current token=')' perl=']' value=']' Tokenstr |i(\a,(d,d,d,d,d)| translated: aeqi (  arr , [ 5 , 4 , 3 , 2 , 1 ]
Lexem 16 Current token=')' perl=')' value=')' Tokenstr |i(\a,(d,d,d,d,d))| translated: aeqi (  arr , [ 5 , 4 , 3 , 2 , 1 ] )
check_ref(main, arr) at 3
Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )
check_ref(main, arr) at 0
expr_type(2, 3, main)
expr_type(3, 2, main)
merge_types(arr, main, u)
merge_types: otype=u
expr_type(0, 3, main)
Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='t' perl='my' value='' Tokenstr |c(t| translated: for  ( 
Lexem 3 Current token='s' perl='$i' value='i' Tokenstr |c(ts| translated: for  (  i
Lexem 4 Current token='=' perl='=' value=':=' Tokenstr |c(ts=| translated: for  (  i :=
Lexem 5 Current token='d' perl='0' value='0' Tokenstr |c(ts=d| translated: for  (  i := 0
Lexem 6 Current token=';' perl=';' value=';' Tokenstr |c(ts=d;| translated: for  (  i := 0 ;
Lexem 7 Current token='s' perl='$i' value='i' Tokenstr |c(ts=d;s| translated: for  (  i := 0 ; i
Lexem 8 Current token='>' perl='<' value='<' Tokenstr |c(ts=d;s>| translated: for  (  i := 0 ; i <
Lexem 9 Current token='d' perl='5' value='5' Tokenstr |c(ts=d;s>d| translated: for  (  i := 0 ; i < 5
Lexem 10 Current token=';' perl=';' value=';' Tokenstr |c(ts=d;s>d;| translated: for  (  i := 0 ; i < 5 ;
Lexem 11 Current token='s' perl='$i' value='i' Tokenstr |c(ts=d;s>d;s| translated: for  (  i := 0 ; i < 5 ; i
Lexem 12 Current token='^' perl='++' value='+=1' Tokenstr |c(ts=d;s>d;s^| translated: for  (  i := 0 ; i < 5 ; i +=1
Lexem 13 Current token=')' perl=')' value=')' Tokenstr |c(ts=d;s>d;s^)| translated: for  (  i := 0 ; i < 5 ; i +=1 )
check_ref(main, i) at 3
expr_type(5, 13, main)
merge_types(i, main, I)
merge_types: otype=I
check_ref(main, i) at 7
scalar_reference_type(7) = I
check_ref(main, i) at 11
merge_types(i, main, I)
merge_types: otype=I
expr_type(5, 13, main)
Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$i' value='i' Tokenstr |fa,s| translated: .extend( arr , i
check_ref(main, arr) at 1
check_ref(main, i) at 3
arg_type(push, 2) = s
scalar_reference_type(3) = s
expr_type(0, 3, main)
Lexem 0 Current token='i' perl='aeqi' value='aeqi' Tokenstr |i| translated: aeqi
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeqi (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeqi ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeqi (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeqi (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeqi (  arr , [
Lexem 6 Current token='d' perl='0' value='0' Tokenstr |i(\a,(d| translated: aeqi (  arr , [ 0
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,| translated: aeqi (  arr , [ 0 ,
Lexem 8 Current token='d' perl='1' value='1' Tokenstr |i(\a,(d,d| translated: aeqi (  arr , [ 0 , 1
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,| translated: aeqi (  arr , [ 0 , 1 ,
Lexem 10 Current token='d' perl='2' value='2' Tokenstr |i(\a,(d,d,d| translated: aeqi (  arr , [ 0 , 1 , 2
Lexem 11 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,d,| translated: aeqi (  arr , [ 0 , 1 , 2 ,
Lexem 12 Current token='d' perl='3' value='3' Tokenstr |i(\a,(d,d,d,d| translated: aeqi (  arr , [ 0 , 1 , 2 , 3
Lexem 13 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,d,d,| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 ,
Lexem 14 Current token='d' perl='4' value='4' Tokenstr |i(\a,(d,d,d,d,d| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4
Lexem 15 Current token=')' perl=']' value=']' Tokenstr |i(\a,(d,d,d,d,d)| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4 ]
Lexem 16 Current token=')' perl=')' value=')' Tokenstr |i(\a,(d,d,d,d,d))| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4 ] )
check_ref(main, arr) at 3
Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )
check_ref(main, arr) at 0
expr_type(2, 3, main)
expr_type(3, 2, main)
merge_types(arr, main, u)
merge_types: otype=u
expr_type(0, 3, main)
Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='t' perl='my' value='' Tokenstr |c(t| translated: for  ( 
Lexem 3 Current token='s' perl='$i' value='i' Tokenstr |c(ts| translated: for  (  i
Lexem 4 Current token='=' perl='=' value=':=' Tokenstr |c(ts=| translated: for  (  i :=
Lexem 5 Current token='d' perl='0' value='0' Tokenstr |c(ts=d| translated: for  (  i := 0
Lexem 6 Current token=';' perl=';' value=';' Tokenstr |c(ts=d;| translated: for  (  i := 0 ;
Lexem 7 Current token='s' perl='$i' value='i' Tokenstr |c(ts=d;s| translated: for  (  i := 0 ; i
Lexem 8 Current token='>' perl='<=' value='<=' Tokenstr |c(ts=d;s>| translated: for  (  i := 0 ; i <=
Lexem 9 Current token='d' perl='5' value='5' Tokenstr |c(ts=d;s>d| translated: for  (  i := 0 ; i <= 5
Lexem 10 Current token=';' perl=';' value=';' Tokenstr |c(ts=d;s>d;| translated: for  (  i := 0 ; i <= 5 ;
Lexem 11 Current token='s' perl='$i' value='i' Tokenstr |c(ts=d;s>d;s| translated: for  (  i := 0 ; i <= 5 ; i
Lexem 12 Current token='^' perl='++' value='+=1' Tokenstr |c(ts=d;s>d;s^| translated: for  (  i := 0 ; i <= 5 ; i +=1
Lexem 13 Current token=')' perl=')' value=')' Tokenstr |c(ts=d;s>d;s^)| translated: for  (  i := 0 ; i <= 5 ; i +=1 )
check_ref(main, i) at 3
expr_type(5, 13, main)
merge_types(i, main, I)
merge_types: otype=I
check_ref(main, i) at 7
scalar_reference_type(7) = I
check_ref(main, i) at 11
merge_types(i, main, I)
merge_types: otype=I
expr_type(5, 13, main)
Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$i' value='i' Tokenstr |fa,s| translated: .extend( arr , i
check_ref(main, arr) at 1
check_ref(main, i) at 3
arg_type(push, 2) = s
scalar_reference_type(3) = s
expr_type(0, 3, main)
Lexem 0 Current token='i' perl='aeqi' value='aeqi' Tokenstr |i| translated: aeqi
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeqi (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeqi ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeqi (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeqi (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeqi (  arr , [
Lexem 6 Current token='d' perl='0' value='0' Tokenstr |i(\a,(d| translated: aeqi (  arr , [ 0
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,| translated: aeqi (  arr , [ 0 ,
Lexem 8 Current token='d' perl='1' value='1' Tokenstr |i(\a,(d,d| translated: aeqi (  arr , [ 0 , 1
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,| translated: aeqi (  arr , [ 0 , 1 ,
Lexem 10 Current token='d' perl='2' value='2' Tokenstr |i(\a,(d,d,d| translated: aeqi (  arr , [ 0 , 1 , 2
Lexem 11 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,d,| translated: aeqi (  arr , [ 0 , 1 , 2 ,
Lexem 12 Current token='d' perl='3' value='3' Tokenstr |i(\a,(d,d,d,d| translated: aeqi (  arr , [ 0 , 1 , 2 , 3
Lexem 13 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,d,d,| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 ,
Lexem 14 Current token='d' perl='4' value='4' Tokenstr |i(\a,(d,d,d,d,d| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4
Lexem 15 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,d,d,d,| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4 ,
Lexem 16 Current token='d' perl='5' value='5' Tokenstr |i(\a,(d,d,d,d,d,d| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4 , 5
Lexem 17 Current token=')' perl=']' value=']' Tokenstr |i(\a,(d,d,d,d,d,d)| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4 , 5 ]
Lexem 18 Current token=')' perl=')' value=')' Tokenstr |i(\a,(d,d,d,d,d,d))| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4 , 5 ] )
check_ref(main, arr) at 3
Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )
check_ref(main, arr) at 0
expr_type(2, 3, main)
expr_type(3, 2, main)
merge_types(arr, main, u)
merge_types: otype=u
expr_type(0, 3, main)
Lexem 0 Current token='c' perl='foreach' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='s' perl='$j' value='j' Tokenstr |cs| translated: for  j
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |cs(| translated: for  j (
Lexem 3 Current token='d' perl='0' value='0' Tokenstr |cs(d| translated: for  j ( 0
Lexem 4 Current token='r' perl='..' value='..' Tokenstr |cs(dr| translated: for  j ( 0 ..
Lexem 5 Current token='d' perl='4' value='4' Tokenstr |cs(drd| translated: for  j ( 0 .. 4
Lexem 6 Current token=')' perl=')' value=')' Tokenstr |cs(drd)| translated: for  j ( 0 .. 4 )
check_ref(main, j) at 1
scalar_reference_type(1) = u
merge_types(j, main, u)
Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$j' value='j' Tokenstr |fa,s| translated: .extend( arr , j
check_ref(main, arr) at 1
check_ref(main, j) at 3
arg_type(push, 2) = s
scalar_reference_type(3) = s
merge_types(j, main, s)
merge_types: otype=u
expr_type(0, 3, main)
Lexem 0 Current token='i' perl='aeqi' value='aeqi' Tokenstr |i| translated: aeqi
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeqi (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeqi ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeqi (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeqi (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeqi (  arr , [
Lexem 6 Current token='d' perl='0' value='0' Tokenstr |i(\a,(d| translated: aeqi (  arr , [ 0
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,| translated: aeqi (  arr , [ 0 ,
Lexem 8 Current token='d' perl='1' value='1' Tokenstr |i(\a,(d,d| translated: aeqi (  arr , [ 0 , 1
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,| translated: aeqi (  arr , [ 0 , 1 ,
Lexem 10 Current token='d' perl='2' value='2' Tokenstr |i(\a,(d,d,d| translated: aeqi (  arr , [ 0 , 1 , 2
Lexem 11 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,d,| translated: aeqi (  arr , [ 0 , 1 , 2 ,
Lexem 12 Current token='d' perl='3' value='3' Tokenstr |i(\a,(d,d,d,d| translated: aeqi (  arr , [ 0 , 1 , 2 , 3
Lexem 13 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,d,d,| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 ,
Lexem 14 Current token='d' perl='4' value='4' Tokenstr |i(\a,(d,d,d,d,d| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4
Lexem 15 Current token=')' perl=']' value=']' Tokenstr |i(\a,(d,d,d,d,d)| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4 ]
Lexem 16 Current token=')' perl=')' value=')' Tokenstr |i(\a,(d,d,d,d,d))| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4 ] )
check_ref(main, arr) at 3
Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )
check_ref(main, arr) at 0
expr_type(2, 3, main)
expr_type(3, 2, main)
merge_types(arr, main, u)
merge_types: otype=u
expr_type(0, 3, main)
Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='d' perl='0' value='0' Tokenstr |c(d| translated: for  ( 0
Lexem 3 Current token='r' perl='..' value='..' Tokenstr |c(dr| translated: for  ( 0 ..
Lexem 4 Current token='d' perl='4' value='4' Tokenstr |c(drd| translated: for  ( 0 .. 4
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(drd)| translated: for  ( 0 .. 4 )
Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$_' value='_d' Tokenstr |fa,s| translated: .extend( arr , _d
check_ref(main, arr) at 1
check_ref(main, _d) at 3
arg_type(push, 2) = s
scalar_reference_type(3) = s
expr_type(0, 3, main)
Lexem 0 Current token='i' perl='aeqi' value='aeqi' Tokenstr |i| translated: aeqi
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeqi (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeqi ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeqi (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeqi (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeqi (  arr , [
Lexem 6 Current token='d' perl='0' value='0' Tokenstr |i(\a,(d| translated: aeqi (  arr , [ 0
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,| translated: aeqi (  arr , [ 0 ,
Lexem 8 Current token='d' perl='1' value='1' Tokenstr |i(\a,(d,d| translated: aeqi (  arr , [ 0 , 1
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,| translated: aeqi (  arr , [ 0 , 1 ,
Lexem 10 Current token='d' perl='2' value='2' Tokenstr |i(\a,(d,d,d| translated: aeqi (  arr , [ 0 , 1 , 2
Lexem 11 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,d,| translated: aeqi (  arr , [ 0 , 1 , 2 ,
Lexem 12 Current token='d' perl='3' value='3' Tokenstr |i(\a,(d,d,d,d| translated: aeqi (  arr , [ 0 , 1 , 2 , 3
Lexem 13 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,d,d,| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 ,
Lexem 14 Current token='d' perl='4' value='4' Tokenstr |i(\a,(d,d,d,d,d| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4
Lexem 15 Current token=')' perl=']' value=']' Tokenstr |i(\a,(d,d,d,d,d)| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4 ]
Lexem 16 Current token=')' perl=')' value=')' Tokenstr |i(\a,(d,d,d,d,d))| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4 ] )
check_ref(main, arr) at 3
Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )
check_ref(main, arr) at 0
expr_type(2, 3, main)
expr_type(3, 2, main)
merge_types(arr, main, u)
merge_types: otype=u
expr_type(0, 3, main)
Lexem 0 Current token='c' perl='foreach' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='s' perl='$i' value='i' Tokenstr |cs| translated: for  i
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |cs(| translated: for  i (
Lexem 3 Current token='d' perl='2' value='2' Tokenstr |cs(d| translated: for  i ( 2
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |cs(d,| translated: for  i ( 2 ,
Lexem 5 Current token='d' perl='4' value='4' Tokenstr |cs(d,d| translated: for  i ( 2 , 4
Lexem 6 Current token=',' perl=',' value=',' Tokenstr |cs(d,d,| translated: for  i ( 2 , 4 ,
Lexem 7 Current token='d' perl='16' value='16' Tokenstr |cs(d,d,d| translated: for  i ( 2 , 4 , 16
Lexem 8 Current token=',' perl=',' value=',' Tokenstr |cs(d,d,d,| translated: for  i ( 2 , 4 , 16 ,
Lexem 9 Current token='d' perl='64' value='64' Tokenstr |cs(d,d,d,d| translated: for  i ( 2 , 4 , 16 , 64
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |cs(d,d,d,d)| translated: for  i ( 2 , 4 , 16 , 64 )
check_ref(main, i) at 1
scalar_reference_type(1) = u
Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$i' value='i' Tokenstr |fa,s| translated: .extend( arr , i
check_ref(main, arr) at 1
check_ref(main, i) at 3
arg_type(push, 2) = s
scalar_reference_type(3) = s
expr_type(0, 3, main)
Lexem 0 Current token='i' perl='aeqi' value='aeqi' Tokenstr |i| translated: aeqi
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeqi (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeqi ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeqi (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeqi (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeqi (  arr , [
Lexem 6 Current token='d' perl='2' value='2' Tokenstr |i(\a,(d| translated: aeqi (  arr , [ 2
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,| translated: aeqi (  arr , [ 2 ,
Lexem 8 Current token='d' perl='4' value='4' Tokenstr |i(\a,(d,d| translated: aeqi (  arr , [ 2 , 4
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,| translated: aeqi (  arr , [ 2 , 4 ,
Lexem 10 Current token='d' perl='16' value='16' Tokenstr |i(\a,(d,d,d| translated: aeqi (  arr , [ 2 , 4 , 16
Lexem 11 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,d,| translated: aeqi (  arr , [ 2 , 4 , 16 ,
Lexem 12 Current token='d' perl='64' value='64' Tokenstr |i(\a,(d,d,d,d| translated: aeqi (  arr , [ 2 , 4 , 16 , 64
Lexem 13 Current token=')' perl=']' value=']' Tokenstr |i(\a,(d,d,d,d)| translated: aeqi (  arr , [ 2 , 4 , 16 , 64 ]
Lexem 14 Current token=')' perl=')' value=')' Tokenstr |i(\a,(d,d,d,d))| translated: aeqi (  arr , [ 2 , 4 , 16 , 64 ] )
check_ref(main, arr) at 3
Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )
check_ref(main, arr) at 0
expr_type(2, 3, main)
expr_type(3, 2, main)
merge_types(arr, main, u)
merge_types: otype=u
expr_type(0, 3, main)
Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='t' perl='my' value='' Tokenstr |ct| translated: for  
Lexem 2 Current token='s' perl='$j' value='j' Tokenstr |cts| translated: for   j
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |cts(| translated: for   j (
Lexem 4 Current token='d' perl='2' value='2' Tokenstr |cts(d| translated: for   j ( 2
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |cts(d,| translated: for   j ( 2 ,
Lexem 6 Current token='d' perl='4' value='4' Tokenstr |cts(d,d| translated: for   j ( 2 , 4
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |cts(d,d,| translated: for   j ( 2 , 4 ,
Lexem 8 Current token='d' perl='16' value='16' Tokenstr |cts(d,d,d| translated: for   j ( 2 , 4 , 16
Lexem 9 Current token=')' perl=')' value=')' Tokenstr |cts(d,d,d)| translated: for   j ( 2 , 4 , 16 )
check_ref(main, j) at 2
scalar_reference_type(2) = u
Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$j' value='j' Tokenstr |fa,s| translated: .extend( arr , j
check_ref(main, arr) at 1
check_ref(main, j) at 3
arg_type(push, 2) = s
scalar_reference_type(3) = s
expr_type(0, 3, main)
Lexem 0 Current token='i' perl='aeqi' value='aeqi' Tokenstr |i| translated: aeqi
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeqi (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeqi ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeqi (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeqi (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeqi (  arr , [
Lexem 6 Current token='d' perl='2' value='2' Tokenstr |i(\a,(d| translated: aeqi (  arr , [ 2
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,| translated: aeqi (  arr , [ 2 ,
Lexem 8 Current token='d' perl='4' value='4' Tokenstr |i(\a,(d,d| translated: aeqi (  arr , [ 2 , 4
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,| translated: aeqi (  arr , [ 2 , 4 ,
Lexem 10 Current token='d' perl='16' value='16' Tokenstr |i(\a,(d,d,d| translated: aeqi (  arr , [ 2 , 4 , 16
Lexem 11 Current token=')' perl=']' value=']' Tokenstr |i(\a,(d,d,d)| translated: aeqi (  arr , [ 2 , 4 , 16 ]
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |i(\a,(d,d,d))| translated: aeqi (  arr , [ 2 , 4 , 16 ] )
check_ref(main, arr) at 3
Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )
check_ref(main, arr) at 0
expr_type(2, 3, main)
expr_type(3, 2, main)
merge_types(arr, main, u)
merge_types: otype=u
expr_type(0, 3, main)
Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='d' perl='3' value='3' Tokenstr |c(d| translated: for  ( 3
Lexem 3 Current token=',' perl=',' value=',' Tokenstr |c(d,| translated: for  ( 3 ,
Lexem 4 Current token='d' perl='6' value='6' Tokenstr |c(d,d| translated: for  ( 3 , 6
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |c(d,d,| translated: for  ( 3 , 6 ,
Lexem 6 Current token='d' perl='9' value='9' Tokenstr |c(d,d,d| translated: for  ( 3 , 6 , 9
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |c(d,d,d)| translated: for  ( 3 , 6 , 9 )
Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$_' value='_d' Tokenstr |fa,s| translated: .extend( arr , _d
check_ref(main, arr) at 1
check_ref(main, _d) at 3
arg_type(push, 2) = s
scalar_reference_type(3) = s
expr_type(0, 3, main)
Lexem 0 Current token='i' perl='aeqi' value='aeqi' Tokenstr |i| translated: aeqi
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeqi (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeqi ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeqi (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeqi (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeqi (  arr , [
Lexem 6 Current token='d' perl='3' value='3' Tokenstr |i(\a,(d| translated: aeqi (  arr , [ 3
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,| translated: aeqi (  arr , [ 3 ,
Lexem 8 Current token='d' perl='6' value='6' Tokenstr |i(\a,(d,d| translated: aeqi (  arr , [ 3 , 6
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,| translated: aeqi (  arr , [ 3 , 6 ,
Lexem 10 Current token='d' perl='9' value='9' Tokenstr |i(\a,(d,d,d| translated: aeqi (  arr , [ 3 , 6 , 9
Lexem 11 Current token=')' perl=']' value=']' Tokenstr |i(\a,(d,d,d)| translated: aeqi (  arr , [ 3 , 6 , 9 ]
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |i(\a,(d,d,d))| translated: aeqi (  arr , [ 3 , 6 , 9 ] )
check_ref(main, arr) at 3
Lexem 0 Current token='k' perl='sub' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' perl='myFunc' value='myFunc' Tokenstr |ki| translated: def myFunc
get_globals: switching to 'myFunc' at line 96
expr_type(1, 1, myFunc)
Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@result' value='result' Tokenstr |ta| translated:  result
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  result =
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |ta=(| translated:  result = (
Lexem 4 Current token='"' perl='a' value=''a'' Tokenstr |ta=("| translated:  result = ( 'a'
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |ta=(",| translated:  result = ( 'a' ,
Lexem 6 Current token='"' perl='c' value=''c'' Tokenstr |ta=(","| translated:  result = ( 'a' , 'c'
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |ta=(",",| translated:  result = ( 'a' , 'c' ,
Lexem 8 Current token='"' perl='b' value=''b'' Tokenstr |ta=(",","| translated:  result = ( 'a' , 'c' , 'b'
Lexem 9 Current token=')' perl=')' value=')' Tokenstr |ta=(",",")| translated:  result = ( 'a' , 'c' , 'b' )
check_ref(myFunc, result) at 1
expr_type(3, 9, myFunc)
expr_type(4, 4, myFunc)
expr_type(6, 6, myFunc)
merge_types(result, myFunc, a of u)
Lexem 0 Current token='k' perl='return' value='return' Tokenstr |k| translated: return
Lexem 1 Current token='\' perl='\' value='' Tokenstr |k\| translated: return 
Lexem 2 Current token='a' perl='@result' value='result' Tokenstr |k\a| translated: return  result
check_ref(myFunc, result) at 2
expr_type(1, 2, myFunc)
merge_types(myFunc, main, u)
expr_type(1, 2, myFunc)
get_globals: switching back to 'main' at line 99
merge_types(myFunc, main, u)
merge_types: otype=u
Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )
check_ref(main, arr) at 0
expr_type(2, 3, main)
expr_type(3, 2, main)
merge_types(arr, main, u)
merge_types: otype=u
expr_type(0, 3, main)
Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='@' perl='@' value='@' Tokenstr |c(@| translated: for  ( @
Lexem 3 Current token='(' perl='{' value='[' Tokenstr |c(@(| translated: for  ( @ [
Lexem 4 Current token='i' perl='myFunc' value='myFunc' Tokenstr |c(@(i| translated: for  ( @ [ myFunc
Lexem 5 Current token='(' perl='(' value='(' Tokenstr |c(@(i(| translated: for  ( @ [ myFunc (
Lexem 6 Current token=')' perl=')' value=')' Tokenstr |c(@(i()| translated: for  ( @ [ myFunc ( )
Lexem 7 Current token=')' perl='}' value=']' Tokenstr |c(@(i())| translated: for  ( @ [ myFunc ( ) ]
Lexem 8 Current token=')' perl=')' value=')' Tokenstr |c(@(i()))| translated: for  ( @ [ myFunc ( ) ] )
Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$_' value='_d' Tokenstr |fa,s| translated: .extend( arr , _d
check_ref(main, arr) at 1
check_ref(main, _d) at 3
arg_type(push, 2) = s
scalar_reference_type(3) = s
expr_type(0, 3, main)
Lexem 0 Current token='i' perl='aeq' value='aeq' Tokenstr |i| translated: aeq
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeq (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeq ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeq (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeq (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeq (  arr , [
Lexem 6 Current token='"' perl='a' value=''a'' Tokenstr |i(\a,("| translated: aeq (  arr , [ 'a'
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",| translated: aeq (  arr , [ 'a' ,
Lexem 8 Current token='"' perl='c' value=''c'' Tokenstr |i(\a,(","| translated: aeq (  arr , [ 'a' , 'c'
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",",| translated: aeq (  arr , [ 'a' , 'c' ,
Lexem 10 Current token='"' perl='b' value=''b'' Tokenstr |i(\a,(",","| translated: aeq (  arr , [ 'a' , 'c' , 'b'
Lexem 11 Current token=')' perl=']' value=']' Tokenstr |i(\a,(",",")| translated: aeq (  arr , [ 'a' , 'c' , 'b' ]
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |i(\a,(",","))| translated: aeq (  arr , [ 'a' , 'c' , 'b' ] )
check_ref(main, arr) at 3
Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )
check_ref(main, arr) at 0
expr_type(2, 3, main)
expr_type(3, 2, main)
merge_types(arr, main, u)
merge_types: otype=u
expr_type(0, 3, main)
Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='f' perl='sort' value='sorted' Tokenstr |c(f| translated: for  ( sorted
Lexem 3 Current token='@' perl='@' value='@' Tokenstr |c(f@| translated: for  ( sorted @
Lexem 4 Current token='(' perl='{' value='[' Tokenstr |c(f@(| translated: for  ( sorted @ [
Lexem 5 Current token='i' perl='myFunc' value='myFunc' Tokenstr |c(f@(i| translated: for  ( sorted @ [ myFunc
Lexem 6 Current token='(' perl='(' value='(' Tokenstr |c(f@(i(| translated: for  ( sorted @ [ myFunc (
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |c(f@(i()| translated: for  ( sorted @ [ myFunc ( )
Lexem 8 Current token=')' perl='}' value=']' Tokenstr |c(f@(i())| translated: for  ( sorted @ [ myFunc ( ) ]
Lexem 9 Current token=')' perl=')' value=')' Tokenstr |c(f@(i()))| translated: for  ( sorted @ [ myFunc ( ) ] )
Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$_' value='_d' Tokenstr |fa,s| translated: .extend( arr , _d
check_ref(main, arr) at 1
check_ref(main, _d) at 3
arg_type(push, 2) = s
scalar_reference_type(3) = s
expr_type(0, 3, main)
Lexem 0 Current token='i' perl='aeq' value='aeq' Tokenstr |i| translated: aeq
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeq (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeq ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeq (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeq (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeq (  arr , [
Lexem 6 Current token='"' perl='a' value=''a'' Tokenstr |i(\a,("| translated: aeq (  arr , [ 'a'
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",| translated: aeq (  arr , [ 'a' ,
Lexem 8 Current token='"' perl='b' value=''b'' Tokenstr |i(\a,(","| translated: aeq (  arr , [ 'a' , 'b'
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",",| translated: aeq (  arr , [ 'a' , 'b' ,
Lexem 10 Current token='"' perl='c' value=''c'' Tokenstr |i(\a,(",","| translated: aeq (  arr , [ 'a' , 'b' , 'c'
Lexem 11 Current token=')' perl=']' value=']' Tokenstr |i(\a,(",",")| translated: aeq (  arr , [ 'a' , 'b' , 'c' ]
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |i(\a,(",","))| translated: aeq (  arr , [ 'a' , 'b' , 'c' ] )
check_ref(main, arr) at 3
Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )
check_ref(main, arr) at 0
expr_type(2, 3, main)
expr_type(3, 2, main)
merge_types(arr, main, u)
merge_types: otype=u
expr_type(0, 3, main)
Lexem 0 Current token='c' perl='foreach' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='s' perl='$region' value='region' Tokenstr |cs| translated: for  region
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |cs(| translated: for  region (
Lexem 3 Current token='i' perl='A' value='A' Tokenstr |cs(i| translated: for  region ( A
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |cs(i,| translated: for  region ( A ,
Lexem 5 Current token='i' perl='ABC' value='ABC' Tokenstr |cs(i,i| translated: for  region ( A , ABC
Lexem 6 Current token=',' perl=',' value=',' Tokenstr |cs(i,i,| translated: for  region ( A , ABC ,
Lexem 7 Current token='i' perl='D' value='D' Tokenstr |cs(i,i,i| translated: for  region ( A , ABC , D
Lexem 8 Current token=',' perl=',' value=',' Tokenstr |cs(i,i,i,| translated: for  region ( A , ABC , D ,
Lexem 9 Current token='i' perl='EF' value='EF' Tokenstr |cs(i,i,i,i| translated: for  region ( A , ABC , D , EF
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |cs(i,i,i,i)| translated: for  region ( A , ABC , D , EF )
check_ref(main, region) at 1
scalar_reference_type(1) = u
merge_types(region, main, u)
Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$region' value='region' Tokenstr |fa,s| translated: .extend( arr , region
check_ref(main, arr) at 1
check_ref(main, region) at 3
arg_type(push, 2) = s
scalar_reference_type(3) = s
merge_types(region, main, s)
merge_types: otype=u
expr_type(0, 3, main)
Lexem 0 Current token='i' perl='aeqi' value='aeqi' Tokenstr |i| translated: aeqi
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeqi (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeqi ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeqi (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeqi (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeqi (  arr , [
Lexem 6 Current token='i' perl='A' value='A' Tokenstr |i(\a,(i| translated: aeqi (  arr , [ A
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(i,| translated: aeqi (  arr , [ A ,
Lexem 8 Current token='i' perl='ABC' value='ABC' Tokenstr |i(\a,(i,i| translated: aeqi (  arr , [ A , ABC
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(i,i,| translated: aeqi (  arr , [ A , ABC ,
Lexem 10 Current token='i' perl='D' value='D' Tokenstr |i(\a,(i,i,i| translated: aeqi (  arr , [ A , ABC , D
Lexem 11 Current token=',' perl=',' value=',' Tokenstr |i(\a,(i,i,i,| translated: aeqi (  arr , [ A , ABC , D ,
Lexem 12 Current token='i' perl='EF' value='EF' Tokenstr |i(\a,(i,i,i,i| translated: aeqi (  arr , [ A , ABC , D , EF
Lexem 13 Current token=')' perl=']' value=']' Tokenstr |i(\a,(i,i,i,i)| translated: aeqi (  arr , [ A , ABC , D , EF ]
Lexem 14 Current token=')' perl=')' value=')' Tokenstr |i(\a,(i,i,i,i))| translated: aeqi (  arr , [ A , ABC , D , EF ] )
check_ref(main, arr) at 3
Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )
check_ref(main, arr) at 0
expr_type(2, 3, main)
expr_type(3, 2, main)
merge_types(arr, main, u)
merge_types: otype=u
expr_type(0, 3, main)
Lexem 0 Current token='c' perl='foreach' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='s' perl='$id' value='id' Tokenstr |cs| translated: for  id
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |cs(| translated: for  id (
Lexem 3 Current token='f' perl='keys' value='.keys()' Tokenstr |cs(f| translated: for  id ( .keys()
Lexem 4 Current token='h' perl='tickets' value='tickets' Tokenstr |cs(fh| translated: for  id ( .keys() tickets
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |cs(fh)| translated: for  id ( .keys() tickets )
check_ref(main, id) at 1
scalar_reference_type(1) = u
merge_types(id, main, u)
check_ref(main, tickets) at 4
Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$id' value='id' Tokenstr |fa,s| translated: .extend( arr , id
check_ref(main, arr) at 1
check_ref(main, id) at 3
arg_type(push, 2) = s
scalar_reference_type(3) = s
merge_types(id, main, s)
merge_types: otype=u
expr_type(0, 3, main)
Lexem 0 Current token='i' perl='aeq_unordered' value='aeq_unordered' Tokenstr |i| translated: aeq_unordered
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeq_unordered (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeq_unordered ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeq_unordered (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeq_unordered (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeq_unordered (  arr , [
Lexem 6 Current token='"' perl='t1' value=''t1'' Tokenstr |i(\a,("| translated: aeq_unordered (  arr , [ 't1'
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",| translated: aeq_unordered (  arr , [ 't1' ,
Lexem 8 Current token='"' perl='t2' value=''t2'' Tokenstr |i(\a,(","| translated: aeq_unordered (  arr , [ 't1' , 't2'
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",",| translated: aeq_unordered (  arr , [ 't1' , 't2' ,
Lexem 10 Current token='"' perl='t3' value=''t3'' Tokenstr |i(\a,(",","| translated: aeq_unordered (  arr , [ 't1' , 't2' , 't3'
Lexem 11 Current token=')' perl=']' value=']' Tokenstr |i(\a,(",",")| translated: aeq_unordered (  arr , [ 't1' , 't2' , 't3' ]
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |i(\a,(",","))| translated: aeq_unordered (  arr , [ 't1' , 't2' , 't3' ] )
check_ref(main, arr) at 3
Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )
check_ref(main, arr) at 0
expr_type(2, 3, main)
expr_type(3, 2, main)
merge_types(arr, main, u)
merge_types: otype=u
expr_type(0, 3, main)
Lexem 0 Current token='c' perl='foreach' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='s' perl='$id' value='id' Tokenstr |cs| translated: for  id
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |cs(| translated: for  id (
Lexem 3 Current token='h' perl='tickets' value='tickets' Tokenstr |cs(h| translated: for  id ( tickets
Lexem 4 Current token=')' perl=')' value=')' Tokenstr |cs(h)| translated: for  id ( tickets )
check_ref(main, id) at 1
scalar_reference_type(1) = u
check_ref(main, tickets) at 3
Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$id' value='id' Tokenstr |fa,s| translated: .extend( arr , id
check_ref(main, arr) at 1
check_ref(main, id) at 3
arg_type(push, 2) = s
scalar_reference_type(3) = s
expr_type(0, 3, main)
Lexem 0 Current token='i' perl='aeq_unordered' value='aeq_unordered' Tokenstr |i| translated: aeq_unordered
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeq_unordered (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeq_unordered ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeq_unordered (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeq_unordered (  arr ,
Lexem 5 Current token='\' perl='\' value='' Tokenstr |i(\a,\| translated: aeq_unordered (  arr , 
Lexem 6 Current token='a' perl='@tkts' value='tkts' Tokenstr |i(\a,\a| translated: aeq_unordered (  arr ,  tkts
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |i(\a,\a)| translated: aeq_unordered (  arr ,  tkts )
check_ref(main, arr) at 3
check_ref(main, tkts) at 6
Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )
check_ref(main, arr) at 0
expr_type(2, 3, main)
expr_type(3, 2, main)
merge_types(arr, main, u)
merge_types: otype=u
expr_type(0, 3, main)
Lexem 0 Current token='c' perl='foreach' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='s' perl='$id' value='id' Tokenstr |cs| translated: for  id
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |cs(| translated: for  id (
Lexem 3 Current token='f' perl='sort' value='sorted' Tokenstr |cs(f| translated: for  id ( sorted
Lexem 4 Current token='f' perl='values' value='.values()' Tokenstr |cs(ff| translated: for  id ( sorted .values()
Lexem 5 Current token='h' perl='tickets' value='tickets' Tokenstr |cs(ffh| translated: for  id ( sorted .values() tickets
Lexem 6 Current token=')' perl=')' value=')' Tokenstr |cs(ffh)| translated: for  id ( sorted .values() tickets )
check_ref(main, id) at 1
scalar_reference_type(1) = u
check_ref(main, tickets) at 5
Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$id' value='id' Tokenstr |fa,s| translated: .extend( arr , id
check_ref(main, arr) at 1
check_ref(main, id) at 3
arg_type(push, 2) = s
scalar_reference_type(3) = s
expr_type(0, 3, main)
Lexem 0 Current token='i' perl='aeq' value='aeq' Tokenstr |i| translated: aeq
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeq (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeq ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeq (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeq (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeq (  arr , [
Lexem 6 Current token='"' perl='v1' value=''v1'' Tokenstr |i(\a,("| translated: aeq (  arr , [ 'v1'
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",| translated: aeq (  arr , [ 'v1' ,
Lexem 8 Current token='"' perl='v2' value=''v2'' Tokenstr |i(\a,(","| translated: aeq (  arr , [ 'v1' , 'v2'
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",",| translated: aeq (  arr , [ 'v1' , 'v2' ,
Lexem 10 Current token='"' perl='v3' value=''v3'' Tokenstr |i(\a,(",","| translated: aeq (  arr , [ 'v1' , 'v2' , 'v3'
Lexem 11 Current token=')' perl=']' value=']' Tokenstr |i(\a,(",",")| translated: aeq (  arr , [ 'v1' , 'v2' , 'v3' ]
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |i(\a,(",","))| translated: aeq (  arr , [ 'v1' , 'v2' , 'v3' ] )
check_ref(main, arr) at 3
Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )
check_ref(main, arr) at 0
expr_type(2, 3, main)
expr_type(3, 2, main)
merge_types(arr, main, u)
merge_types: otype=u
expr_type(0, 3, main)
Lexem 0 Current token='c' perl='foreach' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='s' perl='$id' value='id' Tokenstr |cs| translated: for  id
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |cs(| translated: for  id (
Lexem 3 Current token='f' perl='reverse' value='[::-1]' Tokenstr |cs(f| translated: for  id ( [::-1]
Lexem 4 Current token='f' perl='sort' value='sorted' Tokenstr |cs(ff| translated: for  id ( [::-1] sorted
Lexem 5 Current token='f' perl='keys' value='.keys()' Tokenstr |cs(fff| translated: for  id ( [::-1] sorted .keys()
Lexem 6 Current token='h' perl='tickets' value='tickets' Tokenstr |cs(fffh| translated: for  id ( [::-1] sorted .keys() tickets
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |cs(fffh)| translated: for  id ( [::-1] sorted .keys() tickets )
check_ref(main, id) at 1
scalar_reference_type(1) = u
check_ref(main, tickets) at 6
Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$id' value='id' Tokenstr |fa,s| translated: .extend( arr , id
check_ref(main, arr) at 1
check_ref(main, id) at 3
arg_type(push, 2) = s
scalar_reference_type(3) = s
expr_type(0, 3, main)
Lexem 0 Current token='i' perl='aeq' value='aeq' Tokenstr |i| translated: aeq
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeq (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeq ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeq (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeq (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeq (  arr , [
Lexem 6 Current token='"' perl='t3' value=''t3'' Tokenstr |i(\a,("| translated: aeq (  arr , [ 't3'
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",| translated: aeq (  arr , [ 't3' ,
Lexem 8 Current token='"' perl='t2' value=''t2'' Tokenstr |i(\a,(","| translated: aeq (  arr , [ 't3' , 't2'
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",",| translated: aeq (  arr , [ 't3' , 't2' ,
Lexem 10 Current token='"' perl='t1' value=''t1'' Tokenstr |i(\a,(",","| translated: aeq (  arr , [ 't3' , 't2' , 't1'
Lexem 11 Current token=')' perl=']' value=']' Tokenstr |i(\a,(",",")| translated: aeq (  arr , [ 't3' , 't2' , 't1' ]
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |i(\a,(",","))| translated: aeq (  arr , [ 't3' , 't2' , 't1' ] )
check_ref(main, arr) at 3
Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )
check_ref(main, arr) at 0
expr_type(2, 3, main)
expr_type(3, 2, main)
merge_types(arr, main, u)
merge_types: otype=u
expr_type(0, 3, main)
Lexem 0 Current token='c' perl='foreach' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='s' perl='$id' value='id' Tokenstr |cs| translated: for  id
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |cs(| translated: for  id (
Lexem 3 Current token='f' perl='sort' value='sorted' Tokenstr |cs(f| translated: for  id ( sorted
Lexem 4 Current token='f' perl='keys' value='.keys()' Tokenstr |cs(ff| translated: for  id ( sorted .keys()
Lexem 5 Current token='h' perl='tickets' value='tickets' Tokenstr |cs(ffh| translated: for  id ( sorted .keys() tickets
Lexem 6 Current token=')' perl=')' value=')' Tokenstr |cs(ffh)| translated: for  id ( sorted .keys() tickets )
check_ref(main, id) at 1
scalar_reference_type(1) = u
check_ref(main, tickets) at 5
Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$id' value='id' Tokenstr |fa,s| translated: .extend( arr , id
check_ref(main, arr) at 1
check_ref(main, id) at 3
arg_type(push, 2) = s
scalar_reference_type(3) = s
expr_type(0, 3, main)
Lexem 0 Current token='i' perl='aeq' value='aeq' Tokenstr |i| translated: aeq
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeq (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeq ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeq (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeq (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeq (  arr , [
Lexem 6 Current token='"' perl='t1' value=''t1'' Tokenstr |i(\a,("| translated: aeq (  arr , [ 't1'
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",| translated: aeq (  arr , [ 't1' ,
Lexem 8 Current token='"' perl='t2' value=''t2'' Tokenstr |i(\a,(","| translated: aeq (  arr , [ 't1' , 't2'
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",",| translated: aeq (  arr , [ 't1' , 't2' ,
Lexem 10 Current token='"' perl='t3' value=''t3'' Tokenstr |i(\a,(",","| translated: aeq (  arr , [ 't1' , 't2' , 't3'
Lexem 11 Current token=')' perl=']' value=']' Tokenstr |i(\a,(",",")| translated: aeq (  arr , [ 't1' , 't2' , 't3' ]
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |i(\a,(",","))| translated: aeq (  arr , [ 't1' , 't2' , 't3' ] )
check_ref(main, arr) at 3
Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )
check_ref(main, arr) at 0
expr_type(2, 3, main)
expr_type(3, 2, main)
merge_types(arr, main, u)
merge_types: otype=u
expr_type(0, 3, main)
Lexem 0 Current token='c' perl='foreach' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='s' perl='$id' value='id' Tokenstr |cs| translated: for  id
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |cs(| translated: for  id (
Lexem 3 Current token='f' perl='sort' value='sorted' Tokenstr |cs(f| translated: for  id ( sorted
Lexem 4 Current token='h' perl='tickets' value='tickets' Tokenstr |cs(fh| translated: for  id ( sorted tickets
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |cs(fh)| translated: for  id ( sorted tickets )
check_ref(main, id) at 1
scalar_reference_type(1) = u
check_ref(main, tickets) at 4
Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$id' value='id' Tokenstr |fa,s| translated: .extend( arr , id
check_ref(main, arr) at 1
check_ref(main, id) at 3
arg_type(push, 2) = s
scalar_reference_type(3) = s
expr_type(0, 3, main)
Lexem 0 Current token='i' perl='aeq' value='aeq' Tokenstr |i| translated: aeq
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeq (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeq ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeq (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeq (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeq (  arr , [
Lexem 6 Current token='"' perl='t1' value=''t1'' Tokenstr |i(\a,("| translated: aeq (  arr , [ 't1'
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",| translated: aeq (  arr , [ 't1' ,
Lexem 8 Current token='"' perl='t2' value=''t2'' Tokenstr |i(\a,(","| translated: aeq (  arr , [ 't1' , 't2'
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",",| translated: aeq (  arr , [ 't1' , 't2' ,
Lexem 10 Current token='"' perl='t3' value=''t3'' Tokenstr |i(\a,(",","| translated: aeq (  arr , [ 't1' , 't2' , 't3'
Lexem 11 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",",",| translated: aeq (  arr , [ 't1' , 't2' , 't3' ,
Lexem 12 Current token='"' perl='v1' value=''v1'' Tokenstr |i(\a,(",",","| translated: aeq (  arr , [ 't1' , 't2' , 't3' , 'v1'
Lexem 13 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",",",",| translated: aeq (  arr , [ 't1' , 't2' , 't3' , 'v1' ,
Lexem 14 Current token='"' perl='v2' value=''v2'' Tokenstr |i(\a,(",",",","| translated: aeq (  arr , [ 't1' , 't2' , 't3' , 'v1' , 'v2'
Lexem 15 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",",",",",| translated: aeq (  arr , [ 't1' , 't2' , 't3' , 'v1' , 'v2' ,
Lexem 16 Current token='"' perl='v3' value=''v3'' Tokenstr |i(\a,(",",",",","| translated: aeq (  arr , [ 't1' , 't2' , 't3' , 'v1' , 'v2' , 'v3'
Lexem 17 Current token=')' perl=']' value=']' Tokenstr |i(\a,(",",",",",")| translated: aeq (  arr , [ 't1' , 't2' , 't3' , 'v1' , 'v2' , 'v3' ]
Lexem 18 Current token=')' perl=')' value=')' Tokenstr |i(\a,(",",",",","))| translated: aeq (  arr , [ 't1' , 't2' , 't3' , 'v1' , 'v2' , 'v3' ] )
check_ref(main, arr) at 3
Lexem 0 Current token='k' perl='sub' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' perl='aeq' value='aeq' Tokenstr |ki| translated: def aeq
get_globals: switching to 'aeq' at line 162
expr_type(1, 1, aeq)
Lexem 0 Current token='s' perl='$a_ref1' value='a_ref1' Tokenstr |s| translated: a_ref1
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: a_ref1 =
Lexem 2 Current token='f' perl='shift' value='.pop(0)' Tokenstr |s=f| translated: a_ref1 = .pop(0)
check_ref(aeq, a_ref1) at 0
expr_type(2, 2, aeq)
merge_types(a_ref1, aeq, s)
expr_type(0, 2, aeq)
Lexem 0 Current token='s' perl='$a_ref2' value='a_ref2' Tokenstr |s| translated: a_ref2
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: a_ref2 =
Lexem 2 Current token='f' perl='shift' value='.pop(0)' Tokenstr |s=f| translated: a_ref2 = .pop(0)
check_ref(aeq, a_ref2) at 0
expr_type(2, 2, aeq)
merge_types(a_ref2, aeq, s)
expr_type(0, 2, aeq)
Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |t(| translated:  (
Lexem 2 Current token='s' perl='$package' value='package' Tokenstr |t(s| translated:  ( package
Lexem 3 Current token=',' perl=',' value=',' Tokenstr |t(s,| translated:  ( package ,
Lexem 4 Current token='s' perl='$filename' value='filename' Tokenstr |t(s,s| translated:  ( package , filename
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |t(s,s,| translated:  ( package , filename ,
Lexem 6 Current token='s' perl='$line' value='line' Tokenstr |t(s,s,s| translated:  ( package , filename , line
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |t(s,s,s)| translated:  ( package , filename , line )
Lexem 8 Current token='=' perl='=' value='=' Tokenstr |t(s,s,s)=| translated:  ( package , filename , line ) =
Lexem 9 Current token='f' perl='caller' value='caller' Tokenstr |t(s,s,s)=f| translated:  ( package , filename , line ) = caller
check_ref(aeq, package) at 2
expr_type(9, 9, aeq)
scalar_reference_type(2) = u
merge_types(package, aeq, u)
check_ref(aeq, filename) at 4
expr_type(9, 9, aeq)
scalar_reference_type(4) = u
merge_types(filename, aeq, u)
check_ref(aeq, line) at 6
expr_type(9, 9, aeq)
scalar_reference_type(6) = u
merge_types(line, aeq, u)
Lexem 0 Current token='C' perl='eval' value='try' Tokenstr |C| translated: try
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='scalar' value='len' Tokenstr |c(f| translated: assert ( len
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( len (
Lexem 4 Current token='@' perl='@' value='@' Tokenstr |c(f(@| translated: assert ( len ( @
Lexem 4 Current token='s' perl='$a_ref1' value='a_ref1' Tokenstr |c(f(s| translated: assert ( len ( a_ref1
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(f(s)| translated: assert ( len ( a_ref1 )
Lexem 6 Current token='>' perl='==' value='==' Tokenstr |c(f(s)>| translated: assert ( len ( a_ref1 ) ==
Lexem 7 Current token='f' perl='scalar' value='len' Tokenstr |c(f(s)>f| translated: assert ( len ( a_ref1 ) == len
Lexem 8 Current token='(' perl='(' value='(' Tokenstr |c(f(s)>f(| translated: assert ( len ( a_ref1 ) == len (
Lexem 9 Current token='@' perl='@' value='@' Tokenstr |c(f(s)>f(@| translated: assert ( len ( a_ref1 ) == len ( @
Lexem 9 Current token='s' perl='$a_ref2' value='a_ref2' Tokenstr |c(f(s)>f(s| translated: assert ( len ( a_ref1 ) == len ( a_ref2
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |c(f(s)>f(s)| translated: assert ( len ( a_ref1 ) == len ( a_ref2 )
Lexem 11 Current token=')' perl=')' value=')' Tokenstr |c(f(s)>f(s))| translated: assert ( len ( a_ref1 ) == len ( a_ref2 ) )
check_ref(aeq, a_ref1) at 4
arg_type(scalar, 0) = a
scalar_reference_type(4) = a
check_ref(aeq, a_ref2) at 9
arg_type(scalar, 0) = a
scalar_reference_type(9) = a
Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' perl='$' value='EVAL_ERROR' Tokenstr |c(s| translated: if  ( EVAL_ERROR
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(s)| translated: if  ( EVAL_ERROR )
check_ref(aeq, EVAL_ERROR) at 2
scalar_reference_type(2) = u
merge_types(EVAL_ERROR, aeq, u)
Lexem 0 Current token='f' perl='say' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='i' perl='STDERR' value='sys.stderr' Tokenstr |fi| translated: print sys.stderr
Lexem 2 Current token='"' perl='scalar(\@\$a_ref1) != scalar(\@\$a_ref2), ' value='f"scalar(@$a_ref1) != scalar(@$a_ref2), "' Tokenstr |fi"| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "
Lexem 3 Current token='.' perl='.' value=' + ' Tokenstr |fi".| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  + 
Lexem 4 Current token='f' perl='scalar' value='len' Tokenstr |fi".f| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len
Lexem 5 Current token='(' perl='(' value='(' Tokenstr |fi".f(| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len (
Lexem 6 Current token='@' perl='@' value='@' Tokenstr |fi".f(@| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( @
Lexem 6 Current token='s' perl='$a_ref1' value='a_ref1' Tokenstr |fi".f(s| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |fi".f(s)| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )
Lexem 8 Current token='.' perl='.' value=' + ' Tokenstr |fi".f(s).| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  + 
Lexem 9 Current token='"' perl=' != ' value='' != '' Tokenstr |fi".f(s)."| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '
Lexem 10 Current token='.' perl='.' value=' + ' Tokenstr |fi".f(s).".| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  + 
Lexem 11 Current token='f' perl='scalar' value='len' Tokenstr |fi".f(s).".f| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len
Lexem 12 Current token='(' perl='(' value='(' Tokenstr |fi".f(s).".f(| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len (
Lexem 13 Current token='@' perl='@' value='@' Tokenstr |fi".f(s).".f(@| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len ( @
Lexem 13 Current token='s' perl='$a_ref2' value='a_ref2' Tokenstr |fi".f(s).".f(s| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len ( a_ref2
Lexem 14 Current token=')' perl=')' value=')' Tokenstr |fi".f(s).".f(s)| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len ( a_ref2 )
check_ref(aeq, a_ref1) at 6
arg_type(scalar, 0) = a
scalar_reference_type(6) = a
check_ref(aeq, a_ref2) at 13
arg_type(scalar, 0) = a
scalar_reference_type(13) = a
expr_type(0, 14, aeq)
Lexem 0 Current token='f' perl='say' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='i' perl='STDERR' value='sys.stderr' Tokenstr |fi| translated: print sys.stderr
Lexem 2 Current token='"' perl='Assertion failed in aeq called from line $line' value='f"Assertion failed in aeq called from line {line}"' Tokenstr |fi"| translated: print sys.stderr f"Assertion failed in aeq called from line {line}"
expr_type(0, 2, aeq)
Lexem 0 Current token='f' perl='die' value='raise Die' Tokenstr |f| translated: raise Die
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |f(| translated: raise Die (
Lexem 2 Current token='s' perl='$' value='EVAL_ERROR' Tokenstr |f(s| translated: raise Die ( EVAL_ERROR
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |f(s)| translated: raise Die ( EVAL_ERROR )
check_ref(aeq, EVAL_ERROR) at 2
arg_type(die, 0) = S
scalar_reference_type(2) = S
merge_types(EVAL_ERROR, aeq, S)
merge_types: otype=u
expr_type(0, 3, aeq)
Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='t' perl='my' value='' Tokenstr |c(t| translated: for  ( 
Lexem 3 Current token='s' perl='$i' value='i' Tokenstr |c(ts| translated: for  (  i
Lexem 4 Current token='=' perl='=' value=':=' Tokenstr |c(ts=| translated: for  (  i :=
Lexem 5 Current token='d' perl='0' value='0' Tokenstr |c(ts=d| translated: for  (  i := 0
Lexem 6 Current token=';' perl=';' value=';' Tokenstr |c(ts=d;| translated: for  (  i := 0 ;
Lexem 7 Current token='s' perl='$i' value='i' Tokenstr |c(ts=d;s| translated: for  (  i := 0 ; i
Lexem 8 Current token='>' perl='<' value='<' Tokenstr |c(ts=d;s>| translated: for  (  i := 0 ; i <
Lexem 9 Current token='f' perl='scalar' value='len' Tokenstr |c(ts=d;s>f| translated: for  (  i := 0 ; i < len
Lexem 10 Current token='(' perl='(' value='(' Tokenstr |c(ts=d;s>f(| translated: for  (  i := 0 ; i < len (
Lexem 11 Current token='@' perl='@' value='@' Tokenstr |c(ts=d;s>f(@| translated: for  (  i := 0 ; i < len ( @
Lexem 11 Current token='s' perl='$a_ref1' value='a_ref1' Tokenstr |c(ts=d;s>f(s| translated: for  (  i := 0 ; i < len ( a_ref1
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |c(ts=d;s>f(s)| translated: for  (  i := 0 ; i < len ( a_ref1 )
Lexem 13 Current token=';' perl=';' value=';' Tokenstr |c(ts=d;s>f(s);| translated: for  (  i := 0 ; i < len ( a_ref1 ) ;
Lexem 14 Current token='s' perl='$i' value='i' Tokenstr |c(ts=d;s>f(s);s| translated: for  (  i := 0 ; i < len ( a_ref1 ) ; i
Lexem 15 Current token='^' perl='++' value='+=1' Tokenstr |c(ts=d;s>f(s);s^| translated: for  (  i := 0 ; i < len ( a_ref1 ) ; i +=1
Lexem 16 Current token=')' perl=')' value=')' Tokenstr |c(ts=d;s>f(s);s^)| translated: for  (  i := 0 ; i < len ( a_ref1 ) ; i +=1 )
check_ref(aeq, i) at 3
expr_type(5, 16, aeq)
merge_types(i, aeq, I)
check_ref(aeq, i) at 7
scalar_reference_type(7) = I
check_ref(aeq, a_ref1) at 11
arg_type(scalar, 0) = a
scalar_reference_type(11) = a
check_ref(aeq, i) at 14
merge_types(i, aeq, I)
merge_types: otype=I
expr_type(5, 16, aeq)
Lexem 0 Current token='C' perl='eval' value='try' Tokenstr |C| translated: try
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$a_ref1' value='a_ref1' Tokenstr |c(s| translated: assert ( a_ref1
Lexem 3 Current token='.' perl='->' value='.' Tokenstr |c(s.| translated: assert ( a_ref1 .
Lexem 3 Current token='(' perl='[' value='[' Tokenstr |c(s(| translated: assert ( a_ref1 [
Lexem 4 Current token='s' perl='$i' value='i' Tokenstr |c(s(s| translated: assert ( a_ref1 [ i
Lexem 5 Current token=')' perl=']' value=']' Tokenstr |c(s(s)| translated: assert ( a_ref1 [ i ]
Lexem 6 Current token='>' perl='eq' value='==' Tokenstr |c(s(s)>| translated: assert ( a_ref1 [ i ] ==
Lexem 7 Current token='s' perl='$a_ref2' value='a_ref2' Tokenstr |c(s(s)>s| translated: assert ( a_ref1 [ i ] == a_ref2
Lexem 8 Current token='.' perl='->' value='.' Tokenstr |c(s(s)>s.| translated: assert ( a_ref1 [ i ] == a_ref2 .
Lexem 8 Current token='(' perl='[' value='[' Tokenstr |c(s(s)>s(| translated: assert ( a_ref1 [ i ] == a_ref2 [
Lexem 9 Current token='s' perl='$i' value='i' Tokenstr |c(s(s)>s(s| translated: assert ( a_ref1 [ i ] == a_ref2 [ i
Lexem 10 Current token=')' perl=']' value=']' Tokenstr |c(s(s)>s(s)| translated: assert ( a_ref1 [ i ] == a_ref2 [ i ]
Lexem 11 Current token=')' perl=')' value=')' Tokenstr |c(s(s)>s(s))| translated: assert ( a_ref1 [ i ] == a_ref2 [ i ] )
check_ref(aeq, a_ref1) at 2
merge_types(a_ref1, aeq, a of u)
merge_types: otype=s
check_ref(aeq, i) at 4
scalar_reference_type(4) = I
check_ref(aeq, a_ref2) at 7
merge_types(a_ref2, aeq, a of u)
merge_types: otype=s
check_ref(aeq, i) at 9
scalar_reference_type(9) = I
Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' perl='$' value='EVAL_ERROR' Tokenstr |c(s| translated: if  ( EVAL_ERROR
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(s)| translated: if  ( EVAL_ERROR )
check_ref(aeq, EVAL_ERROR) at 2
scalar_reference_type(2) = u
Lexem 0 Current token='f' perl='say' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='i' perl='STDERR' value='sys.stderr' Tokenstr |fi| translated: print sys.stderr
Lexem 2 Current token='"' perl='\$a_ref1->[$i] ne \$a_ref2->[$i], $a_ref1->[$i] ne $a_ref2->[$i]' value='f"$a_ref1->[{i}] ne $a_ref2->[{i}], {a_ref1}->[{i}] ne {a_ref2}->[{i}]"' Tokenstr |fi"| translated: print sys.stderr f"$a_ref1->[{i}] ne $a_ref2->[{i}], {a_ref1}->[{i}] ne {a_ref2}->[{i}]"
expr_type(0, 2, aeq)
Lexem 0 Current token='f' perl='say' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='i' perl='STDERR' value='sys.stderr' Tokenstr |fi| translated: print sys.stderr
Lexem 2 Current token='"' perl='Assertion failed in aeq called from line $line' value='f"Assertion failed in aeq called from line {line}"' Tokenstr |fi"| translated: print sys.stderr f"Assertion failed in aeq called from line {line}"
expr_type(0, 2, aeq)
Lexem 0 Current token='f' perl='die' value='raise Die' Tokenstr |f| translated: raise Die
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |f(| translated: raise Die (
Lexem 2 Current token='s' perl='$' value='EVAL_ERROR' Tokenstr |f(s| translated: raise Die ( EVAL_ERROR
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |f(s)| translated: raise Die ( EVAL_ERROR )
check_ref(aeq, EVAL_ERROR) at 2
arg_type(die, 0) = S
scalar_reference_type(2) = S
expr_type(0, 3, aeq)
get_globals: switching back to 'main' at line 186
merge_types(aeq, main, m)
Lexem 0 Current token='k' perl='sub' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' perl='aeq_unordered' value='aeq_unordered' Tokenstr |ki| translated: def aeq_unordered
get_globals: switching to 'aeq_unordered' at line 188
expr_type(1, 1, aeq_unordered)
Lexem 0 Current token='s' perl='$a_ref1' value='a_ref1' Tokenstr |s| translated: a_ref1
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: a_ref1 =
Lexem 2 Current token='f' perl='shift' value='.pop(0)' Tokenstr |s=f| translated: a_ref1 = .pop(0)
check_ref(aeq_unordered, a_ref1) at 0
expr_type(2, 2, aeq_unordered)
merge_types(a_ref1, aeq_unordered, s)
expr_type(0, 2, aeq_unordered)
Lexem 0 Current token='s' perl='$a_ref2' value='a_ref2' Tokenstr |s| translated: a_ref2
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: a_ref2 =
Lexem 2 Current token='f' perl='shift' value='.pop(0)' Tokenstr |s=f| translated: a_ref2 = .pop(0)
check_ref(aeq_unordered, a_ref2) at 0
expr_type(2, 2, aeq_unordered)
merge_types(a_ref2, aeq_unordered, s)
expr_type(0, 2, aeq_unordered)
Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |t(| translated:  (
Lexem 2 Current token='s' perl='$package' value='package' Tokenstr |t(s| translated:  ( package
Lexem 3 Current token=',' perl=',' value=',' Tokenstr |t(s,| translated:  ( package ,
Lexem 4 Current token='s' perl='$filename' value='filename' Tokenstr |t(s,s| translated:  ( package , filename
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |t(s,s,| translated:  ( package , filename ,
Lexem 6 Current token='s' perl='$line' value='line' Tokenstr |t(s,s,s| translated:  ( package , filename , line
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |t(s,s,s)| translated:  ( package , filename , line )
Lexem 8 Current token='=' perl='=' value='=' Tokenstr |t(s,s,s)=| translated:  ( package , filename , line ) =
Lexem 9 Current token='f' perl='caller' value='caller' Tokenstr |t(s,s,s)=f| translated:  ( package , filename , line ) = caller
check_ref(aeq_unordered, package) at 2
expr_type(9, 9, aeq_unordered)
scalar_reference_type(2) = u
merge_types(package, aeq_unordered, u)
check_ref(aeq_unordered, filename) at 4
expr_type(9, 9, aeq_unordered)
scalar_reference_type(4) = u
merge_types(filename, aeq_unordered, u)
check_ref(aeq_unordered, line) at 6
expr_type(9, 9, aeq_unordered)
scalar_reference_type(6) = u
merge_types(line, aeq_unordered, u)
Lexem 0 Current token='C' perl='eval' value='try' Tokenstr |C| translated: try
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='scalar' value='len' Tokenstr |c(f| translated: assert ( len
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( len (
Lexem 4 Current token='@' perl='@' value='@' Tokenstr |c(f(@| translated: assert ( len ( @
Lexem 4 Current token='s' perl='$a_ref1' value='a_ref1' Tokenstr |c(f(s| translated: assert ( len ( a_ref1
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(f(s)| translated: assert ( len ( a_ref1 )
Lexem 6 Current token='>' perl='==' value='==' Tokenstr |c(f(s)>| translated: assert ( len ( a_ref1 ) ==
Lexem 7 Current token='f' perl='scalar' value='len' Tokenstr |c(f(s)>f| translated: assert ( len ( a_ref1 ) == len
Lexem 8 Current token='(' perl='(' value='(' Tokenstr |c(f(s)>f(| translated: assert ( len ( a_ref1 ) == len (
Lexem 9 Current token='@' perl='@' value='@' Tokenstr |c(f(s)>f(@| translated: assert ( len ( a_ref1 ) == len ( @
Lexem 9 Current token='s' perl='$a_ref2' value='a_ref2' Tokenstr |c(f(s)>f(s| translated: assert ( len ( a_ref1 ) == len ( a_ref2
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |c(f(s)>f(s)| translated: assert ( len ( a_ref1 ) == len ( a_ref2 )
Lexem 11 Current token=')' perl=')' value=')' Tokenstr |c(f(s)>f(s))| translated: assert ( len ( a_ref1 ) == len ( a_ref2 ) )
check_ref(aeq_unordered, a_ref1) at 4
arg_type(scalar, 0) = a
scalar_reference_type(4) = a
check_ref(aeq_unordered, a_ref2) at 9
arg_type(scalar, 0) = a
scalar_reference_type(9) = a
Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' perl='$' value='EVAL_ERROR' Tokenstr |c(s| translated: if  ( EVAL_ERROR
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(s)| translated: if  ( EVAL_ERROR )
check_ref(aeq_unordered, EVAL_ERROR) at 2
scalar_reference_type(2) = u
merge_types(EVAL_ERROR, aeq_unordered, u)
Lexem 0 Current token='f' perl='say' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='i' perl='STDERR' value='sys.stderr' Tokenstr |fi| translated: print sys.stderr
Lexem 2 Current token='"' perl='Assertion failed in aeq_unordered called from line $line' value='f"Assertion failed in aeq_unordered called from line {line}"' Tokenstr |fi"| translated: print sys.stderr f"Assertion failed in aeq_unordered called from line {line}"
expr_type(0, 2, aeq_unordered)
Lexem 0 Current token='f' perl='say' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='i' perl='STDERR' value='sys.stderr' Tokenstr |fi| translated: print sys.stderr
Lexem 2 Current token='"' perl='scalar(\@\$a_ref1) != scalar(\@\$a_ref2), ' value='f"scalar(@$a_ref1) != scalar(@$a_ref2), "' Tokenstr |fi"| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "
Lexem 3 Current token='.' perl='.' value=' + ' Tokenstr |fi".| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  + 
Lexem 4 Current token='f' perl='scalar' value='len' Tokenstr |fi".f| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len
Lexem 5 Current token='(' perl='(' value='(' Tokenstr |fi".f(| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len (
Lexem 6 Current token='@' perl='@' value='@' Tokenstr |fi".f(@| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( @
Lexem 6 Current token='s' perl='$a_ref1' value='a_ref1' Tokenstr |fi".f(s| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |fi".f(s)| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )
Lexem 8 Current token='.' perl='.' value=' + ' Tokenstr |fi".f(s).| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  + 
Lexem 9 Current token='"' perl=' != ' value='' != '' Tokenstr |fi".f(s)."| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '
Lexem 10 Current token='.' perl='.' value=' + ' Tokenstr |fi".f(s).".| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  + 
Lexem 11 Current token='f' perl='scalar' value='len' Tokenstr |fi".f(s).".f| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len
Lexem 12 Current token='(' perl='(' value='(' Tokenstr |fi".f(s).".f(| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len (
Lexem 13 Current token='@' perl='@' value='@' Tokenstr |fi".f(s).".f(@| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len ( @
Lexem 13 Current token='s' perl='$a_ref2' value='a_ref2' Tokenstr |fi".f(s).".f(s| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len ( a_ref2
Lexem 14 Current token=')' perl=')' value=')' Tokenstr |fi".f(s).".f(s)| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len ( a_ref2 )
check_ref(aeq_unordered, a_ref1) at 6
arg_type(scalar, 0) = a
scalar_reference_type(6) = a
check_ref(aeq_unordered, a_ref2) at 13
arg_type(scalar, 0) = a
scalar_reference_type(13) = a
expr_type(0, 14, aeq_unordered)
Lexem 0 Current token='f' perl='die' value='raise Die' Tokenstr |f| translated: raise Die
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |f(| translated: raise Die (
Lexem 2 Current token='s' perl='$' value='EVAL_ERROR' Tokenstr |f(s| translated: raise Die ( EVAL_ERROR
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |f(s)| translated: raise Die ( EVAL_ERROR )
check_ref(aeq_unordered, EVAL_ERROR) at 2
arg_type(die, 0) = S
scalar_reference_type(2) = S
merge_types(EVAL_ERROR, aeq_unordered, S)
merge_types: otype=u
expr_type(0, 3, aeq_unordered)
Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='t' perl='my' value='' Tokenstr |c(t| translated: for  ( 
Lexem 3 Current token='s' perl='$i' value='i' Tokenstr |c(ts| translated: for  (  i
Lexem 4 Current token='=' perl='=' value=':=' Tokenstr |c(ts=| translated: for  (  i :=
Lexem 5 Current token='d' perl='0' value='0' Tokenstr |c(ts=d| translated: for  (  i := 0
Lexem 6 Current token=';' perl=';' value=';' Tokenstr |c(ts=d;| translated: for  (  i := 0 ;
Lexem 7 Current token='s' perl='$i' value='i' Tokenstr |c(ts=d;s| translated: for  (  i := 0 ; i
Lexem 8 Current token='>' perl='<' value='<' Tokenstr |c(ts=d;s>| translated: for  (  i := 0 ; i <
Lexem 9 Current token='f' perl='scalar' value='len' Tokenstr |c(ts=d;s>f| translated: for  (  i := 0 ; i < len
Lexem 10 Current token='(' perl='(' value='(' Tokenstr |c(ts=d;s>f(| translated: for  (  i := 0 ; i < len (
Lexem 11 Current token='@' perl='@' value='@' Tokenstr |c(ts=d;s>f(@| translated: for  (  i := 0 ; i < len ( @
Lexem 11 Current token='s' perl='$a_ref1' value='a_ref1' Tokenstr |c(ts=d;s>f(s| translated: for  (  i := 0 ; i < len ( a_ref1
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |c(ts=d;s>f(s)| translated: for  (  i := 0 ; i < len ( a_ref1 )
Lexem 13 Current token=';' perl=';' value=';' Tokenstr |c(ts=d;s>f(s);| translated: for  (  i := 0 ; i < len ( a_ref1 ) ;
Lexem 14 Current token='s' perl='$i' value='i' Tokenstr |c(ts=d;s>f(s);s| translated: for  (  i := 0 ; i < len ( a_ref1 ) ; i
Lexem 15 Current token='^' perl='++' value='+=1' Tokenstr |c(ts=d;s>f(s);s^| translated: for  (  i := 0 ; i < len ( a_ref1 ) ; i +=1
Lexem 16 Current token=')' perl=')' value=')' Tokenstr |c(ts=d;s>f(s);s^)| translated: for  (  i := 0 ; i < len ( a_ref1 ) ; i +=1 )
check_ref(aeq_unordered, i) at 3
expr_type(5, 16, aeq_unordered)
merge_types(i, aeq_unordered, I)
check_ref(aeq_unordered, i) at 7
scalar_reference_type(7) = I
check_ref(aeq_unordered, a_ref1) at 11
arg_type(scalar, 0) = a
scalar_reference_type(11) = a
check_ref(aeq_unordered, i) at 14
merge_types(i, aeq_unordered, I)
merge_types: otype=I
expr_type(5, 16, aeq_unordered)
Lexem 0 Current token='C' perl='eval' value='try' Tokenstr |C| translated: try
Lexem 0 Current token='s' perl='$found' value='found' Tokenstr |s| translated: found
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: found =
Lexem 2 Current token='d' perl='0' value='0' Tokenstr |s=d| translated: found = 0
check_ref(aeq_unordered, found) at 0
expr_type(2, 2, aeq_unordered)
merge_types(found, aeq_unordered, I)
expr_type(0, 2, aeq_unordered)
Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='t' perl='my' value='' Tokenstr |c(t| translated: for  ( 
Lexem 3 Current token='s' perl='$j' value='j' Tokenstr |c(ts| translated: for  (  j
Lexem 4 Current token='=' perl='=' value=':=' Tokenstr |c(ts=| translated: for  (  j :=
Lexem 5 Current token='d' perl='0' value='0' Tokenstr |c(ts=d| translated: for  (  j := 0
Lexem 6 Current token=';' perl=';' value=';' Tokenstr |c(ts=d;| translated: for  (  j := 0 ;
Lexem 7 Current token='s' perl='$j' value='j' Tokenstr |c(ts=d;s| translated: for  (  j := 0 ; j
Lexem 8 Current token='>' perl='<' value='<' Tokenstr |c(ts=d;s>| translated: for  (  j := 0 ; j <
Lexem 9 Current token='f' perl='scalar' value='len' Tokenstr |c(ts=d;s>f| translated: for  (  j := 0 ; j < len
Lexem 10 Current token='(' perl='(' value='(' Tokenstr |c(ts=d;s>f(| translated: for  (  j := 0 ; j < len (
Lexem 11 Current token='@' perl='@' value='@' Tokenstr |c(ts=d;s>f(@| translated: for  (  j := 0 ; j < len ( @
Lexem 11 Current token='s' perl='$a_ref2' value='a_ref2' Tokenstr |c(ts=d;s>f(s| translated: for  (  j := 0 ; j < len ( a_ref2
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |c(ts=d;s>f(s)| translated: for  (  j := 0 ; j < len ( a_ref2 )
Lexem 13 Current token=';' perl=';' value=';' Tokenstr |c(ts=d;s>f(s);| translated: for  (  j := 0 ; j < len ( a_ref2 ) ;
Lexem 14 Current token='s' perl='$j' value='j' Tokenstr |c(ts=d;s>f(s);s| translated: for  (  j := 0 ; j < len ( a_ref2 ) ; j
Lexem 15 Current token='^' perl='++' value='+=1' Tokenstr |c(ts=d;s>f(s);s^| translated: for  (  j := 0 ; j < len ( a_ref2 ) ; j +=1
Lexem 16 Current token=')' perl=')' value=')' Tokenstr |c(ts=d;s>f(s);s^)| translated: for  (  j := 0 ; j < len ( a_ref2 ) ; j +=1 )
check_ref(aeq_unordered, j) at 3
expr_type(5, 16, aeq_unordered)
merge_types(j, aeq_unordered, I)
check_ref(aeq_unordered, j) at 7
scalar_reference_type(7) = I
check_ref(aeq_unordered, a_ref2) at 11
arg_type(scalar, 0) = a
scalar_reference_type(11) = a
check_ref(aeq_unordered, j) at 14
merge_types(j, aeq_unordered, I)
merge_types: otype=I
expr_type(5, 16, aeq_unordered)
Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' perl='$a_ref1' value='a_ref1' Tokenstr |c(s| translated: if  ( a_ref1
Lexem 3 Current token='(' perl='[' value='[' Tokenstr |c(s(| translated: if  ( a_ref1 [
Lexem 4 Current token='s' perl='$i' value='i' Tokenstr |c(s(s| translated: if  ( a_ref1 [ i
Lexem 5 Current token=')' perl=']' value=']' Tokenstr |c(s(s)| translated: if  ( a_ref1 [ i ]
Lexem 6 Current token='>' perl='eq' value='==' Tokenstr |c(s(s)>| translated: if  ( a_ref1 [ i ] ==
Lexem 7 Current token='s' perl='$a_ref2' value='a_ref2' Tokenstr |c(s(s)>s| translated: if  ( a_ref1 [ i ] == a_ref2
Lexem 8 Current token='(' perl='[' value='[' Tokenstr |c(s(s)>s(| translated: if  ( a_ref1 [ i ] == a_ref2 [
Lexem 9 Current token='s' perl='$j' value='j' Tokenstr |c(s(s)>s(s| translated: if  ( a_ref1 [ i ] == a_ref2 [ j
Lexem 10 Current token=')' perl=']' value=']' Tokenstr |c(s(s)>s(s)| translated: if  ( a_ref1 [ i ] == a_ref2 [ j ]
Lexem 11 Current token=')' perl=')' value=')' Tokenstr |c(s(s)>s(s))| translated: if  ( a_ref1 [ i ] == a_ref2 [ j ] )
check_ref(aeq_unordered, a_ref1) at 2
merge_types(a_ref1, aeq_unordered, a of u)
merge_types: otype=s
check_ref(aeq_unordered, i) at 4
scalar_reference_type(4) = I
check_ref(aeq_unordered, a_ref2) at 7
merge_types(a_ref2, aeq_unordered, a of u)
merge_types: otype=s
check_ref(aeq_unordered, j) at 9
scalar_reference_type(9) = I
Lexem 0 Current token='s' perl='$found' value='found' Tokenstr |s| translated: found
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: found =
Lexem 2 Current token='d' perl='1' value='1' Tokenstr |s=d| translated: found = 1
check_ref(aeq_unordered, found) at 0
expr_type(2, 2, aeq_unordered)
merge_types(found, aeq_unordered, I)
merge_types: otype=I
expr_type(0, 2, aeq_unordered)
Lexem 0 Current token='k' perl='last' value='break ' Tokenstr |k| translated: break 
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$found' value='found' Tokenstr |c(s| translated: assert ( found
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(s)| translated: assert ( found )
check_ref(aeq_unordered, found) at 2
scalar_reference_type(2) = u
Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' perl='$' value='EVAL_ERROR' Tokenstr |c(s| translated: if  ( EVAL_ERROR
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(s)| translated: if  ( EVAL_ERROR )
check_ref(aeq_unordered, EVAL_ERROR) at 2
scalar_reference_type(2) = u
Lexem 0 Current token='f' perl='say' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='i' perl='STDERR' value='sys.stderr' Tokenstr |fi| translated: print sys.stderr
Lexem 2 Current token='"' perl='\$a_ref1->[$i] not found in @{$a_ref2}' value='f"$a_ref1->[{i}] not found in @{{a_ref2}}"' Tokenstr |fi"| translated: print sys.stderr f"$a_ref1->[{i}] not found in @{{a_ref2}}"
expr_type(0, 2, aeq_unordered)
Lexem 0 Current token='f' perl='say' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='i' perl='STDERR' value='sys.stderr' Tokenstr |fi| translated: print sys.stderr
Lexem 2 Current token='"' perl='Assertion failed in aeq_unordered called from line $line' value='f"Assertion failed in aeq_unordered called from line {line}"' Tokenstr |fi"| translated: print sys.stderr f"Assertion failed in aeq_unordered called from line {line}"
expr_type(0, 2, aeq_unordered)
Lexem 0 Current token='f' perl='die' value='raise Die' Tokenstr |f| translated: raise Die
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |f(| translated: raise Die (
Lexem 2 Current token='s' perl='$' value='EVAL_ERROR' Tokenstr |f(s| translated: raise Die ( EVAL_ERROR
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |f(s)| translated: raise Die ( EVAL_ERROR )
check_ref(aeq_unordered, EVAL_ERROR) at 2
arg_type(die, 0) = S
scalar_reference_type(2) = S
expr_type(0, 3, aeq_unordered)
get_globals: switching back to 'main' at line 220
merge_types(aeq_unordered, main, m)
Lexem 0 Current token='k' perl='sub' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' perl='aeqi' value='aeqi' Tokenstr |ki| translated: def aeqi
get_globals: switching to 'aeqi' at line 222
expr_type(1, 1, aeqi)
Lexem 0 Current token='s' perl='$a_ref1' value='a_ref1' Tokenstr |s| translated: a_ref1
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: a_ref1 =
Lexem 2 Current token='f' perl='shift' value='.pop(0)' Tokenstr |s=f| translated: a_ref1 = .pop(0)
check_ref(aeqi, a_ref1) at 0
expr_type(2, 2, aeqi)
merge_types(a_ref1, aeqi, s)
expr_type(0, 2, aeqi)
Lexem 0 Current token='s' perl='$a_ref2' value='a_ref2' Tokenstr |s| translated: a_ref2
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: a_ref2 =
Lexem 2 Current token='f' perl='shift' value='.pop(0)' Tokenstr |s=f| translated: a_ref2 = .pop(0)
check_ref(aeqi, a_ref2) at 0
expr_type(2, 2, aeqi)
merge_types(a_ref2, aeqi, s)
expr_type(0, 2, aeqi)
Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |t(| translated:  (
Lexem 2 Current token='s' perl='$package' value='package' Tokenstr |t(s| translated:  ( package
Lexem 3 Current token=',' perl=',' value=',' Tokenstr |t(s,| translated:  ( package ,
Lexem 4 Current token='s' perl='$filename' value='filename' Tokenstr |t(s,s| translated:  ( package , filename
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |t(s,s,| translated:  ( package , filename ,
Lexem 6 Current token='s' perl='$line' value='line' Tokenstr |t(s,s,s| translated:  ( package , filename , line
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |t(s,s,s)| translated:  ( package , filename , line )
Lexem 8 Current token='=' perl='=' value='=' Tokenstr |t(s,s,s)=| translated:  ( package , filename , line ) =
Lexem 9 Current token='f' perl='caller' value='caller' Tokenstr |t(s,s,s)=f| translated:  ( package , filename , line ) = caller
check_ref(aeqi, package) at 2
expr_type(9, 9, aeqi)
scalar_reference_type(2) = u
merge_types(package, aeqi, u)
check_ref(aeqi, filename) at 4
expr_type(9, 9, aeqi)
scalar_reference_type(4) = u
merge_types(filename, aeqi, u)
check_ref(aeqi, line) at 6
expr_type(9, 9, aeqi)
scalar_reference_type(6) = u
merge_types(line, aeqi, u)
Lexem 0 Current token='C' perl='eval' value='try' Tokenstr |C| translated: try
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='scalar' value='len' Tokenstr |c(f| translated: assert ( len
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( len (
Lexem 4 Current token='@' perl='@' value='@' Tokenstr |c(f(@| translated: assert ( len ( @
Lexem 4 Current token='s' perl='$a_ref1' value='a_ref1' Tokenstr |c(f(s| translated: assert ( len ( a_ref1
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(f(s)| translated: assert ( len ( a_ref1 )
Lexem 6 Current token='>' perl='==' value='==' Tokenstr |c(f(s)>| translated: assert ( len ( a_ref1 ) ==
Lexem 7 Current token='f' perl='scalar' value='len' Tokenstr |c(f(s)>f| translated: assert ( len ( a_ref1 ) == len
Lexem 8 Current token='(' perl='(' value='(' Tokenstr |c(f(s)>f(| translated: assert ( len ( a_ref1 ) == len (
Lexem 9 Current token='@' perl='@' value='@' Tokenstr |c(f(s)>f(@| translated: assert ( len ( a_ref1 ) == len ( @
Lexem 9 Current token='s' perl='$a_ref2' value='a_ref2' Tokenstr |c(f(s)>f(s| translated: assert ( len ( a_ref1 ) == len ( a_ref2
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |c(f(s)>f(s)| translated: assert ( len ( a_ref1 ) == len ( a_ref2 )
Lexem 11 Current token=')' perl=')' value=')' Tokenstr |c(f(s)>f(s))| translated: assert ( len ( a_ref1 ) == len ( a_ref2 ) )
check_ref(aeqi, a_ref1) at 4
arg_type(scalar, 0) = a
scalar_reference_type(4) = a
check_ref(aeqi, a_ref2) at 9
arg_type(scalar, 0) = a
scalar_reference_type(9) = a
Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' perl='$' value='EVAL_ERROR' Tokenstr |c(s| translated: if  ( EVAL_ERROR
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(s)| translated: if  ( EVAL_ERROR )
check_ref(aeqi, EVAL_ERROR) at 2
scalar_reference_type(2) = u
merge_types(EVAL_ERROR, aeqi, u)
Lexem 0 Current token='f' perl='say' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='i' perl='STDERR' value='sys.stderr' Tokenstr |fi| translated: print sys.stderr
Lexem 2 Current token='"' perl='scalar(\@\$a_ref1) != scalar(\@\$a_ref2), ' value='f"scalar(@$a_ref1) != scalar(@$a_ref2), "' Tokenstr |fi"| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "
Lexem 3 Current token='.' perl='.' value=' + ' Tokenstr |fi".| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  + 
Lexem 4 Current token='f' perl='scalar' value='len' Tokenstr |fi".f| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len
Lexem 5 Current token='(' perl='(' value='(' Tokenstr |fi".f(| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len (
Lexem 6 Current token='@' perl='@' value='@' Tokenstr |fi".f(@| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( @
Lexem 6 Current token='s' perl='$a_ref1' value='a_ref1' Tokenstr |fi".f(s| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |fi".f(s)| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )
Lexem 8 Current token='.' perl='.' value=' + ' Tokenstr |fi".f(s).| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  + 
Lexem 9 Current token='"' perl=' != ' value='' != '' Tokenstr |fi".f(s)."| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '
Lexem 10 Current token='.' perl='.' value=' + ' Tokenstr |fi".f(s).".| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  + 
Lexem 11 Current token='f' perl='scalar' value='len' Tokenstr |fi".f(s).".f| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len
Lexem 12 Current token='(' perl='(' value='(' Tokenstr |fi".f(s).".f(| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len (
Lexem 13 Current token='@' perl='@' value='@' Tokenstr |fi".f(s).".f(@| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len ( @
Lexem 13 Current token='s' perl='$a_ref2' value='a_ref2' Tokenstr |fi".f(s).".f(s| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len ( a_ref2
Lexem 14 Current token=')' perl=')' value=')' Tokenstr |fi".f(s).".f(s)| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len ( a_ref2 )
check_ref(aeqi, a_ref1) at 6
arg_type(scalar, 0) = a
scalar_reference_type(6) = a
check_ref(aeqi, a_ref2) at 13
arg_type(scalar, 0) = a
scalar_reference_type(13) = a
expr_type(0, 14, aeqi)
Lexem 0 Current token='f' perl='say' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='i' perl='STDERR' value='sys.stderr' Tokenstr |fi| translated: print sys.stderr
Lexem 2 Current token='"' perl='Assertion failed in aeqi called from line $line' value='f"Assertion failed in aeqi called from line {line}"' Tokenstr |fi"| translated: print sys.stderr f"Assertion failed in aeqi called from line {line}"
expr_type(0, 2, aeqi)
Lexem 0 Current token='f' perl='die' value='raise Die' Tokenstr |f| translated: raise Die
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |f(| translated: raise Die (
Lexem 2 Current token='s' perl='$' value='EVAL_ERROR' Tokenstr |f(s| translated: raise Die ( EVAL_ERROR
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |f(s)| translated: raise Die ( EVAL_ERROR )
check_ref(aeqi, EVAL_ERROR) at 2
arg_type(die, 0) = S
scalar_reference_type(2) = S
merge_types(EVAL_ERROR, aeqi, S)
merge_types: otype=u
expr_type(0, 3, aeqi)
Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='t' perl='my' value='' Tokenstr |c(t| translated: for  ( 
Lexem 3 Current token='s' perl='$i' value='i' Tokenstr |c(ts| translated: for  (  i
Lexem 4 Current token='=' perl='=' value=':=' Tokenstr |c(ts=| translated: for  (  i :=
Lexem 5 Current token='d' perl='0' value='0' Tokenstr |c(ts=d| translated: for  (  i := 0
Lexem 6 Current token=';' perl=';' value=';' Tokenstr |c(ts=d;| translated: for  (  i := 0 ;
Lexem 7 Current token='s' perl='$i' value='i' Tokenstr |c(ts=d;s| translated: for  (  i := 0 ; i
Lexem 8 Current token='>' perl='<' value='<' Tokenstr |c(ts=d;s>| translated: for  (  i := 0 ; i <
Lexem 9 Current token='f' perl='scalar' value='len' Tokenstr |c(ts=d;s>f| translated: for  (  i := 0 ; i < len
Lexem 10 Current token='(' perl='(' value='(' Tokenstr |c(ts=d;s>f(| translated: for  (  i := 0 ; i < len (
Lexem 11 Current token='@' perl='@' value='@' Tokenstr |c(ts=d;s>f(@| translated: for  (  i := 0 ; i < len ( @
Lexem 11 Current token='s' perl='$a_ref1' value='a_ref1' Tokenstr |c(ts=d;s>f(s| translated: for  (  i := 0 ; i < len ( a_ref1
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |c(ts=d;s>f(s)| translated: for  (  i := 0 ; i < len ( a_ref1 )
Lexem 13 Current token=';' perl=';' value=';' Tokenstr |c(ts=d;s>f(s);| translated: for  (  i := 0 ; i < len ( a_ref1 ) ;
Lexem 14 Current token='s' perl='$i' value='i' Tokenstr |c(ts=d;s>f(s);s| translated: for  (  i := 0 ; i < len ( a_ref1 ) ; i
Lexem 15 Current token='^' perl='++' value='+=1' Tokenstr |c(ts=d;s>f(s);s^| translated: for  (  i := 0 ; i < len ( a_ref1 ) ; i +=1
Lexem 16 Current token=')' perl=')' value=')' Tokenstr |c(ts=d;s>f(s);s^)| translated: for  (  i := 0 ; i < len ( a_ref1 ) ; i +=1 )
check_ref(aeqi, i) at 3
expr_type(5, 16, aeqi)
merge_types(i, aeqi, I)
check_ref(aeqi, i) at 7
scalar_reference_type(7) = I
check_ref(aeqi, a_ref1) at 11
arg_type(scalar, 0) = a
scalar_reference_type(11) = a
check_ref(aeqi, i) at 14
merge_types(i, aeqi, I)
merge_types: otype=I
expr_type(5, 16, aeqi)
Lexem 0 Current token='C' perl='eval' value='try' Tokenstr |C| translated: try
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$a_ref1' value='a_ref1' Tokenstr |c(s| translated: assert ( a_ref1
Lexem 3 Current token='.' perl='->' value='.' Tokenstr |c(s.| translated: assert ( a_ref1 .
Lexem 3 Current token='(' perl='[' value='[' Tokenstr |c(s(| translated: assert ( a_ref1 [
Lexem 4 Current token='s' perl='$i' value='i' Tokenstr |c(s(s| translated: assert ( a_ref1 [ i
Lexem 5 Current token=')' perl=']' value=']' Tokenstr |c(s(s)| translated: assert ( a_ref1 [ i ]
Lexem 6 Current token='>' perl='==' value='==' Tokenstr |c(s(s)>| translated: assert ( a_ref1 [ i ] ==
Lexem 7 Current token='s' perl='$a_ref2' value='a_ref2' Tokenstr |c(s(s)>s| translated: assert ( a_ref1 [ i ] == a_ref2
Lexem 8 Current token='.' perl='->' value='.' Tokenstr |c(s(s)>s.| translated: assert ( a_ref1 [ i ] == a_ref2 .
Lexem 8 Current token='(' perl='[' value='[' Tokenstr |c(s(s)>s(| translated: assert ( a_ref1 [ i ] == a_ref2 [
Lexem 9 Current token='s' perl='$i' value='i' Tokenstr |c(s(s)>s(s| translated: assert ( a_ref1 [ i ] == a_ref2 [ i
Lexem 10 Current token=')' perl=']' value=']' Tokenstr |c(s(s)>s(s)| translated: assert ( a_ref1 [ i ] == a_ref2 [ i ]
Lexem 11 Current token=')' perl=')' value=')' Tokenstr |c(s(s)>s(s))| translated: assert ( a_ref1 [ i ] == a_ref2 [ i ] )
check_ref(aeqi, a_ref1) at 2
merge_types(a_ref1, aeqi, a of u)
merge_types: otype=s
check_ref(aeqi, i) at 4
scalar_reference_type(4) = I
check_ref(aeqi, a_ref2) at 7
merge_types(a_ref2, aeqi, a of u)
merge_types: otype=s
check_ref(aeqi, i) at 9
scalar_reference_type(9) = I
Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' perl='$' value='EVAL_ERROR' Tokenstr |c(s| translated: if  ( EVAL_ERROR
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(s)| translated: if  ( EVAL_ERROR )
check_ref(aeqi, EVAL_ERROR) at 2
scalar_reference_type(2) = u
Lexem 0 Current token='f' perl='say' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='i' perl='STDERR' value='sys.stderr' Tokenstr |fi| translated: print sys.stderr
Lexem 2 Current token='"' perl='\$a_ref1->[$i] ne \$a_ref2->[$i], $a_ref1->[$i] ne $a_ref2->[$i]' value='f"$a_ref1->[{i}] ne $a_ref2->[{i}], {a_ref1}->[{i}] ne {a_ref2}->[{i}]"' Tokenstr |fi"| translated: print sys.stderr f"$a_ref1->[{i}] ne $a_ref2->[{i}], {a_ref1}->[{i}] ne {a_ref2}->[{i}]"
expr_type(0, 2, aeqi)
Lexem 0 Current token='f' perl='say' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='i' perl='STDERR' value='sys.stderr' Tokenstr |fi| translated: print sys.stderr
Lexem 2 Current token='"' perl='Assertion failed in aeqi called from line $line' value='f"Assertion failed in aeqi called from line {line}"' Tokenstr |fi"| translated: print sys.stderr f"Assertion failed in aeqi called from line {line}"
expr_type(0, 2, aeqi)
Lexem 0 Current token='f' perl='die' value='raise Die' Tokenstr |f| translated: raise Die
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |f(| translated: raise Die (
Lexem 2 Current token='s' perl='$' value='EVAL_ERROR' Tokenstr |f(s| translated: raise Die ( EVAL_ERROR
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |f(s)| translated: raise Die ( EVAL_ERROR )
check_ref(aeqi, EVAL_ERROR) at 2
arg_type(die, 0) = S
scalar_reference_type(2) = S
expr_type(0, 3, aeqi)
get_globals: switching back to 'main' at line 246
merge_types(aeqi, main, m)
Lexem 0 Current token='f' perl='print' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='"' perl='$0 - test passed!\n' value='f"{__file__} - test passed!\n"' Tokenstr |f"| translated: print f"{__file__} - test passed!\n"
expr_type(0, 1, main)
VarSubMap = $VAR1 = {
  '_OPEN_MODE_MAP' => {
    'main' => '+'
  },
  'found' => {
    'aeq_unordered' => '+'
  },
  'tickets' => {
    'main' => '+'
  },
  'a_ref1' => {
    'aeqi' => '+',
    'aeq' => '+',
    'aeq_unordered' => '+'
  },
  'region' => {
    'main' => '+'
  },
  'id' => {
    'main' => '+'
  },
  '_DUP_MAP' => {
    'main' => '+'
  },
  'AUTODIE' => {
    'main' => '+'
  },
  'LIST_SEPARATOR' => {
    'main' => '+'
  },
  'j' => {
    'main' => '+'
  },
  'arr' => {
    'main' => '+'
  },
  'p' => {
    'main' => '+'
  },
  '_script_start' => {
    'main' => '+'
  },
  'TRACEBACK' => {
    'main' => '+'
  },
  'tkts' => {
    'main' => '+'
  },
  'file' => {
    'main' => '+'
  },
  'a_ref2' => {
    'aeq_unordered' => '+',
    'aeq' => '+',
    'aeqi' => '+'
  },
  'OS_ERROR' => {
    'main' => '+'
  }
};

VarType = $VAR1 = {
  'j' => {
    'main' => 's',
    'aeq_unordered' => 'I'
  },
  'p' => {
    'main' => 's'
  },
  'filename' => {
    'aeq_unordered' => 'u',
    'aeq' => 'u',
    'aeqi' => 'u'
  },
  '_script_start' => {
    'main' => 'I'
  },
  'hash' => {
    'main' => 'h of u'
  },
  'a_ref2' => {
    'aeq_unordered' => 'm',
    'aeq' => 'm',
    'aeqi' => 'm'
  },
  'OS_ERROR' => {
    'main' => 'S'
  },
  'package' => {
    'aeqi' => 'u',
    'aeq' => 'u',
    'aeq_unordered' => 'u'
  },
  'found' => {
    'aeq_unordered' => 'I'
  },
  'sys.argv' => {
    'main' => 'a of S'
  },
  'tickets' => {
    'main' => 'h of u'
  },
  'EVAL_ERROR' => {
    'aeq_unordered' => 'S',
    'main' => 'S',
    'aeqi' => 'S',
    'aeq' => 'S'
  },
  'a_ref1' => {
    'aeq' => 'm',
    'aeqi' => 'm',
    'aeq_unordered' => 'm'
  },
  'region' => {
    'main' => 's'
  },
  'files' => {
    'main' => 'a of u'
  },
  'tk' => {
    'main' => 'h of u'
  },
  'aeq' => {
    'main' => 'm'
  },
  'aeq_unordered' => {
    'main' => 'm'
  },
  'arr' => {
    'main' => 'u'
  },
  'result' => {
    'myFunc' => 'a of u'
  },
  'i' => {
    'aeq' => 'I',
    'aeqi' => 'I',
    'main' => 'I',
    'aeq_unordered' => 'I'
  },
  'tkts' => {
    'main' => 'u'
  },
  'file' => {
    'main' => 's'
  },
  'os.name' => {
    'main' => 'S'
  },
  'aeqi' => {
    'main' => 'm'
  },
  'khash' => {
    'main' => 'a of S'
  },
  'main' => {},
  'id' => {
    'main' => 's'
  },
  'line' => {
    'aeq_unordered' => 'u',
    'aeqi' => 'u',
    'aeq' => 'u'
  },
  'myFunc' => {
    'main' => 'u'
  },
  'os.environ' => {
    'main' => 'h of S'
  },
  'LIST_SEPARATOR' => {
    'main' => 'S'
  },
  '_d' => {
    'main' => 's'
  }
};

initialized = $VAR1 = {
  'aeq_unordered' => {
    'found' => 'I',
    'a_ref2' => 's',
    'j' => 'I',
    'a_ref1' => 's',
    'i' => 'I'
  },
  'myFunc' => {
    'result' => 'a of u'
  },
  'main' => {
    'arr' => 'u',
    'OS_ERROR' => 'S',
    'os.name' => 'S',
    'hash' => 'h of u',
    '_script_start' => 'I',
    'tkts' => 'u',
    'i' => 'I',
    'sys.argv' => 'a of S',
    'tickets' => 'h of u',
    'khash' => 'a of S',
    'tk' => 'u',
    'os.environ' => 'h of S',
    'LIST_SEPARATOR' => 'S',
    'EVAL_ERROR' => 'S',
    'files' => 'a of u'
  },
  'aeqi' => {
    'a_ref2' => 's',
    'a_ref1' => 's',
    'i' => 'I'
  },
  'aeq' => {
    'i' => 'I',
    'a_ref1' => 's',
    'a_ref2' => 's'
  }
};

NeedsInitializing = $VAR1 = {
  'main' => {
    'j' => 's',
    'p' => 's',
    'file' => 's',
    'region' => 's',
    'id' => 's',
    '_d' => 's'
  },
  'aeq' => {
    'line' => 'u',
    'EVAL_ERROR' => 'S',
    'package' => 'u',
    'filename' => 'u'
  },
  'aeqi' => {
    'filename' => 'u',
    'package' => 'u',
    'EVAL_ERROR' => 'S',
    'line' => 'u'
  },
  'aeq_unordered' => {
    'package' => 'u',
    'filename' => 'u',
    'line' => 'u',
    'EVAL_ERROR' => 'S'
  }
};


DETECTED GLOBAL VARIABLES:
	aeq_unordered: global a_ref1,a_ref2
	main: global region,id,j,p,file
	aeqi: global a_ref1,a_ref2
	aeq: global a_ref1,a_ref2

AUTO-INITIALIZED VARIABLES:
	main: 
j = None
p = None
file = None
region = None
id = None

List of local subroutines:
main aeqi aeq aeq_unordered myFunc
mkdir: cannot create directory /c/Users/Joe: File exists
cp: target 'Orost/Archive/pythonizer' is not a directory
cp: target 'Orost/Archive/Softpano.pm' is not a directory
cp: target 'Orost/Archive/Perlscan.pm' is not a directory
cp: target 'Orost/Archive/Pythonizer.pm' is not a directory
   1 | 0 |   |#!/usr/bin/python3 -u
   1 | 0 |   |# Generated by pythonizer 0.922 run by Joe Orost on Fri Dec 10 11:11:11 2021
   1 | 0 |   |# Test various forms of for and foreach loops
   2 | 0 |   |import sys,os,re,fcntl,math,fileinput,subprocess,inspect,collections.abc,argparse,glob,warnings,inspect,functools,signal,traceback,io,tempfile,atexit,calendar
   2 | 0 |   |import time as tm_py
   2 | 0 |   |AUTODIE = 0
   2 | 0 |   |TRACEBACK = 0
   2 | 0 |   |_script_start = tm_py.time()
   2 | 0 |   |_DUP_MAP = dict(STDIN=0, STDOUT=1, STDERR=2)
   2 | 0 |   |LIST_SEPARATOR = ' '
   2 | 0 |   |OS_ERROR = ''
   2 | 0 |   |_OPEN_MODE_MAP = {'<': 'r', '>': 'w', '+<': 'r+', '+>': 'w+', '>>': 'a', '+>>': 'a+', '|': '|-'}
   2 | 0 |   |class Die(Exception):
    pass
   2 | 0 |   |class EvalReturn(Exception):
    pass
   2 | 0 |   |
j = None
p = None
file = None
region = None
id = None

   2 | 0 |   |_args = sys.argv[1:]
Main loop, line=use Carp::Assert;


 === Line 2 Perl source:use Carp::Assert;===

Lexem 0 Current token='c' perl='use' value='NoTrans!' Tokenstr |c| translated: NoTrans!
Lexem 1 Current token='i' perl='Carp::Assert' value='Carp.Assert' Tokenstr |ci| translated: NoTrans! Carp.Assert

Line:    2 TokenStr: =|ci|= @ValPy: NoTrans! Carp.Assert
   2 | 0 |   |#SKIPPED: use Carp::Assert;
Main loop, line=my %hash = (k1=>'v1', k3=>'v3', k2=>'v2');


 === Line 3 Perl source:my %hash = (k1=>'v1', k3=>'v3', k2=>'v2');===

Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='h' perl='hash' value='hash' Tokenstr |th| translated:  hash
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |th=| translated:  hash =
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |th=(| translated:  hash = (
Lexem 4 Current token='i' perl='k1' value='k1' Tokenstr |th=(i| translated:  hash = ( k1
Lexem 5 Current token=':' perl='=>' value=': ' Tokenstr |th=(i:| translated:  hash = ( k1 : 
Lexem 6 Current token='"' perl='v1' value=''v1'' Tokenstr |th=(i:"| translated:  hash = ( k1 :  'v1'
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |th=(i:",| translated:  hash = ( k1 :  'v1' ,
Lexem 8 Current token='i' perl='k3' value='k3' Tokenstr |th=(i:",i| translated:  hash = ( k1 :  'v1' , k3
Lexem 9 Current token=':' perl='=>' value=': ' Tokenstr |th=(i:",i:| translated:  hash = ( k1 :  'v1' , k3 : 
Lexem 10 Current token='"' perl='v3' value=''v3'' Tokenstr |th=(i:",i:"| translated:  hash = ( k1 :  'v1' , k3 :  'v3'
Lexem 11 Current token=',' perl=',' value=',' Tokenstr |th=(i:",i:",| translated:  hash = ( k1 :  'v1' , k3 :  'v3' ,
Lexem 12 Current token='i' perl='k2' value='k2' Tokenstr |th=(i:",i:",i| translated:  hash = ( k1 :  'v1' , k3 :  'v3' , k2
Lexem 13 Current token=':' perl='=>' value=': ' Tokenstr |th=(i:",i:",i:| translated:  hash = ( k1 :  'v1' , k3 :  'v3' , k2 : 
Lexem 14 Current token='"' perl='v2' value=''v2'' Tokenstr |th=(i:",i:",i:"| translated:  hash = ( k1 :  'v1' , k3 :  'v3' , k2 :  'v2'
Lexem 15 Current token=')' perl=')' value=')' Tokenstr |th=(i:",i:",i:")| translated:  hash = ( k1 :  'v1' , k3 :  'v3' , k2 :  'v2' )

Line:    3 TokenStr: =|th=(i:",i:",i:")|= @ValPy:  hash = ( k1 :  'v1' , k3 :  'v3' , k2 :  'v2' )
Generated partial line hash = {
Generated partial line hash = {'k1'
Generated partial line hash = {'k1': 
Generated partial line hash = {'k1': 'v1'
Generated partial line hash = {'k1': 'v1',
Generated partial line hash = {'k1': 'v1','k3'
Generated partial line hash = {'k1': 'v1','k3': 
Generated partial line hash = {'k1': 'v1','k3': 'v3'
Generated partial line hash = {'k1': 'v1','k3': 'v3',
Generated partial line hash = {'k1': 'v1','k3': 'v3','k2'
Generated partial line hash = {'k1': 'v1','k3': 'v3','k2': 
Generated partial line hash = {'k1': 'v1','k3': 'v3','k2': 'v2'
Generated partial line hash = {'k1': 'v1','k3': 'v3','k2': 'v2'}
   4 | 0 |   |hash = {'k1': 'v1', 'k3': 'v3', 'k2': 'v2'}                                             #PL: my @khash = keys %hash;

Tokens: h=(i:",i:",i:") ValPy: 
Main loop, line=my @khash = keys %hash;


 === Line 4 Perl source:my @khash = keys %hash;===

Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@khash' value='khash' Tokenstr |ta| translated:  khash
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  khash =
Lexem 3 Current token='f' perl='keys' value='.keys()' Tokenstr |ta=f| translated:  khash = .keys()
Lexem 4 Current token='h' perl='hash' value='hash' Tokenstr |ta=fh| translated:  khash = .keys() hash

Line:    4 TokenStr: =|ta=fh|= @ValPy:  khash = .keys() hash
Generated partial line khash = list(
expression(2, 3, 0) =|a=fh|= @khash = keys hash

function(2, 3) =|a=fh|= @khash = keys hash

function start=3, end_pos=3, bracketed=0
expression(3, 3, 0) =|a=fh|= @khash = keys hash

Generated partial line khash = list(hash
expression returns 4
Generated partial line khash = list(hash.keys()
expression returns 4
Generated partial line khash = list(hash.keys())
   5 | 0 |   |khash = list(hash.keys())                                                               #PL: my @files = ('file1', 'file3', 'file2');

Tokens: a=fh ValPy: 
Main loop, line=my @files = ('file1', 'file3', 'file2');


 === Line 5 Perl source:my @files = ('file1', 'file3', 'file2');===

Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@files' value='files' Tokenstr |ta| translated:  files
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  files =
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |ta=(| translated:  files = (
Lexem 4 Current token='"' perl='file1' value=''file1'' Tokenstr |ta=("| translated:  files = ( 'file1'
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |ta=(",| translated:  files = ( 'file1' ,
Lexem 6 Current token='"' perl='file3' value=''file3'' Tokenstr |ta=(","| translated:  files = ( 'file1' , 'file3'
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |ta=(",",| translated:  files = ( 'file1' , 'file3' ,
Lexem 8 Current token='"' perl='file2' value=''file2'' Tokenstr |ta=(",","| translated:  files = ( 'file1' , 'file3' , 'file2'
Lexem 9 Current token=')' perl=')' value=')' Tokenstr |ta=(",",")| translated:  files = ( 'file1' , 'file3' , 'file2' )

Line:    5 TokenStr: =|ta=(",",")|= @ValPy:  files = ( 'file1' , 'file3' , 'file2' )
Generated partial line files = [
Generated partial line files = ['file1'
Generated partial line files = ['file1',
Generated partial line files = ['file1','file3'
Generated partial line files = ['file1','file3',
Generated partial line files = ['file1','file3','file2'
Generated partial line files = ['file1','file3','file2']
   6 | 0 |   |files = ['file1', 'file3', 'file2']                                                     #PL: my @arr = ();

Tokens: a=(",",") ValPy: 
Main loop, line=my @arr = ();


 === Line 6 Perl source:my @arr = ();===

Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |ta| translated:  arr
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  arr =
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |ta=(| translated:  arr = (
Lexem 4 Current token=')' perl=')' value=')' Tokenstr |ta=()| translated:  arr = ( )

Line:    6 TokenStr: =|ta=()|= @ValPy:  arr = ( )
Generated partial line arr = [
Generated partial line arr = []
   7 | 0 |   |arr = []                                                                                #PL: my %tickets = (t1=>'v1', t3=>'v3', t2=>'v2');

Tokens: a=() ValPy: 
Main loop, line=my %tickets = (t1=>'v1', t3=>'v3', t2=>'v2');


 === Line 7 Perl source:my %tickets = (t1=>'v1', t3=>'v3', t2=>'v2');===

Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='h' perl='tickets' value='tickets' Tokenstr |th| translated:  tickets
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |th=| translated:  tickets =
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |th=(| translated:  tickets = (
Lexem 4 Current token='i' perl='t1' value='t1' Tokenstr |th=(i| translated:  tickets = ( t1
Lexem 5 Current token=':' perl='=>' value=': ' Tokenstr |th=(i:| translated:  tickets = ( t1 : 
Lexem 6 Current token='"' perl='v1' value=''v1'' Tokenstr |th=(i:"| translated:  tickets = ( t1 :  'v1'
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |th=(i:",| translated:  tickets = ( t1 :  'v1' ,
Lexem 8 Current token='i' perl='t3' value='t3' Tokenstr |th=(i:",i| translated:  tickets = ( t1 :  'v1' , t3
Lexem 9 Current token=':' perl='=>' value=': ' Tokenstr |th=(i:",i:| translated:  tickets = ( t1 :  'v1' , t3 : 
Lexem 10 Current token='"' perl='v3' value=''v3'' Tokenstr |th=(i:",i:"| translated:  tickets = ( t1 :  'v1' , t3 :  'v3'
Lexem 11 Current token=',' perl=',' value=',' Tokenstr |th=(i:",i:",| translated:  tickets = ( t1 :  'v1' , t3 :  'v3' ,
Lexem 12 Current token='i' perl='t2' value='t2' Tokenstr |th=(i:",i:",i| translated:  tickets = ( t1 :  'v1' , t3 :  'v3' , t2
Lexem 13 Current token=':' perl='=>' value=': ' Tokenstr |th=(i:",i:",i:| translated:  tickets = ( t1 :  'v1' , t3 :  'v3' , t2 : 
Lexem 14 Current token='"' perl='v2' value=''v2'' Tokenstr |th=(i:",i:",i:"| translated:  tickets = ( t1 :  'v1' , t3 :  'v3' , t2 :  'v2'
Lexem 15 Current token=')' perl=')' value=')' Tokenstr |th=(i:",i:",i:")| translated:  tickets = ( t1 :  'v1' , t3 :  'v3' , t2 :  'v2' )

Line:    7 TokenStr: =|th=(i:",i:",i:")|= @ValPy:  tickets = ( t1 :  'v1' , t3 :  'v3' , t2 :  'v2' )
Generated partial line tickets = {
Generated partial line tickets = {'t1'
Generated partial line tickets = {'t1': 
Generated partial line tickets = {'t1': 'v1'
Generated partial line tickets = {'t1': 'v1',
Generated partial line tickets = {'t1': 'v1','t3'
Generated partial line tickets = {'t1': 'v1','t3': 
Generated partial line tickets = {'t1': 'v1','t3': 'v3'
Generated partial line tickets = {'t1': 'v1','t3': 'v3',
Generated partial line tickets = {'t1': 'v1','t3': 'v3','t2'
Generated partial line tickets = {'t1': 'v1','t3': 'v3','t2': 
Generated partial line tickets = {'t1': 'v1','t3': 'v3','t2': 'v2'
Generated partial line tickets = {'t1': 'v1','t3': 'v3','t2': 'v2'}
   8 | 0 |   |tickets = {'t1': 'v1', 't3': 'v3', 't2': 'v2'}                                          #PL: my @tkts = %tickets;

Tokens: h=(i:",i:",i:") ValPy: 
Main loop, line=my @tkts = %tickets;


 === Line 8 Perl source:my @tkts = %tickets;===

Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@tkts' value='tkts' Tokenstr |ta| translated:  tkts
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  tkts =
Lexem 3 Current token='h' perl='tickets' value='tickets' Tokenstr |ta=h| translated:  tkts = tickets

Line:    8 TokenStr: =|ta=h|= @ValPy:  tkts = tickets
Generated partial line tkts = list(functools.reduce(lambda x,y:x+y,tickets.items()))
   9 | 0 |   |tkts = list(functools.reduce(lambda x,y:x+y,tickets.items()))                           #PL: my %tk = @tkts;

Tokens: a=h ValPy: 
Main loop, line=my %tk = @tkts;


 === Line 9 Perl source:my %tk = @tkts;===

Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='h' perl='tk' value='tk' Tokenstr |th| translated:  tk
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |th=| translated:  tk =
Lexem 3 Current token='a' perl='@tkts' value='tkts' Tokenstr |th=a| translated:  tk = tkts

Line:    9 TokenStr: =|th=a|= @ValPy:  tk = tkts
Generated partial line tk = {tkts[_]:tkts[_+1] for _ in range(0,len(tkts),2)}
  10 | 0 |   |tk = {tkts[_]:tkts[_+1] for _ in range(0,len(tkts),2)}                                  #PL: aeq_unordered(\@tkts, ['t1', 't2', 't3', 'v1', 'v2', 'v3']);

Tokens: h=a ValPy: 
Main loop, line=aeq_unordered(\@tkts, ['t1', 't2', 't3', 'v1', 'v2', 'v3']);


 === Line 10 Perl source:aeq_unordered(\@tkts, ['t1', 't2', 't3', 'v1', 'v2', 'v3']);===

Lexem 0 Current token='i' perl='aeq_unordered' value='aeq_unordered' Tokenstr |i| translated: aeq_unordered
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeq_unordered (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeq_unordered ( 
Lexem 3 Current token='a' perl='@tkts' value='tkts' Tokenstr |i(\a| translated: aeq_unordered (  tkts
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeq_unordered (  tkts ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeq_unordered (  tkts , [
Lexem 6 Current token='"' perl='t1' value=''t1'' Tokenstr |i(\a,("| translated: aeq_unordered (  tkts , [ 't1'
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",| translated: aeq_unordered (  tkts , [ 't1' ,
Lexem 8 Current token='"' perl='t2' value=''t2'' Tokenstr |i(\a,(","| translated: aeq_unordered (  tkts , [ 't1' , 't2'
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",",| translated: aeq_unordered (  tkts , [ 't1' , 't2' ,
Lexem 10 Current token='"' perl='t3' value=''t3'' Tokenstr |i(\a,(",","| translated: aeq_unordered (  tkts , [ 't1' , 't2' , 't3'
Lexem 11 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",",",| translated: aeq_unordered (  tkts , [ 't1' , 't2' , 't3' ,
Lexem 12 Current token='"' perl='v1' value=''v1'' Tokenstr |i(\a,(",",","| translated: aeq_unordered (  tkts , [ 't1' , 't2' , 't3' , 'v1'
Lexem 13 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",",",",| translated: aeq_unordered (  tkts , [ 't1' , 't2' , 't3' , 'v1' ,
Lexem 14 Current token='"' perl='v2' value=''v2'' Tokenstr |i(\a,(",",",","| translated: aeq_unordered (  tkts , [ 't1' , 't2' , 't3' , 'v1' , 'v2'
Lexem 15 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",",",",",| translated: aeq_unordered (  tkts , [ 't1' , 't2' , 't3' , 'v1' , 'v2' ,
Lexem 16 Current token='"' perl='v3' value=''v3'' Tokenstr |i(\a,(",",",",","| translated: aeq_unordered (  tkts , [ 't1' , 't2' , 't3' , 'v1' , 'v2' , 'v3'
Lexem 17 Current token=')' perl=']' value=']' Tokenstr |i(\a,(",",",",",")| translated: aeq_unordered (  tkts , [ 't1' , 't2' , 't3' , 'v1' , 'v2' , 'v3' ]
Lexem 18 Current token=')' perl=')' value=')' Tokenstr |i(\a,(",",",",","))| translated: aeq_unordered (  tkts , [ 't1' , 't2' , 't3' , 'v1' , 'v2' , 'v3' ] )

Line:   10 TokenStr: =|i(\a,(",",",",","))|= @ValPy: aeq_unordered (  tkts , [ 't1' , 't2' , 't3' , 'v1' , 'v2' , 'v3' ] )
Generated partial line aeq_unordered
Generated partial line aeq_unordered([
expression(2, 17, -1) =|i(\a,(",",",",","))|= aeq_unordered ( \ @tkts , [ t1 , t2 , t3 , v1 , v2 , v3 ] )

Generated partial line aeq_unordered([
Generated partial line aeq_unordered([tkts
Generated partial line aeq_unordered([tkts,
Generated partial line aeq_unordered([tkts,[
expression(6, 16, 0) =|i(\a,(",",",",","))|= aeq_unordered ( \ @tkts , [ t1 , t2 , t3 , v1 , v2 , v3 ] )

Generated partial line aeq_unordered([tkts,['t1'
Generated partial line aeq_unordered([tkts,['t1',
Generated partial line aeq_unordered([tkts,['t1','t2'
Generated partial line aeq_unordered([tkts,['t1','t2',
Generated partial line aeq_unordered([tkts,['t1','t2','t3'
Generated partial line aeq_unordered([tkts,['t1','t2','t3',
Generated partial line aeq_unordered([tkts,['t1','t2','t3','v1'
Generated partial line aeq_unordered([tkts,['t1','t2','t3','v1',
Generated partial line aeq_unordered([tkts,['t1','t2','t3','v1','v2'
Generated partial line aeq_unordered([tkts,['t1','t2','t3','v1','v2',
Generated partial line aeq_unordered([tkts,['t1','t2','t3','v1','v2','v3'
expression returns 17
Generated partial line aeq_unordered([tkts,['t1','t2','t3','v1','v2','v3']
expression returns 18
Generated partial line aeq_unordered([tkts,['t1','t2','t3','v1','v2','v3']])
  11 | 0 |   |aeq_unordered([tkts, ['t1', 't2', 't3', 'v1', 'v2', 'v3']])                             #PL: assert(scalar(%tk) == 3 && $tk{t1} eq 'v1' && $tk{t2} eq 'v2' && $tk{t3} eq 'v3');

Tokens: i(\a,(",",",",",")) ValPy: 
Main loop, line=assert(scalar(%tk) == 3 && $tk{t1} eq 'v1' && $tk{t2} eq 'v2' && $tk{t3} eq 'v3');


 === Line 11 Perl source:assert(scalar(%tk) == 3 && $tk{t1} eq 'v1' && $tk{t2} eq 'v2' && $tk{t3} eq 'v3');===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='scalar' value='len' Tokenstr |c(f| translated: assert ( len
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( len (
Lexem 4 Current token='h' perl='tk' value='tk' Tokenstr |c(f(h| translated: assert ( len ( tk
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(f(h)| translated: assert ( len ( tk )
Lexem 6 Current token='>' perl='==' value='==' Tokenstr |c(f(h)>| translated: assert ( len ( tk ) ==
Lexem 7 Current token='d' perl='3' value='3' Tokenstr |c(f(h)>d| translated: assert ( len ( tk ) == 3
Lexem 8 Current token='0' perl='&&' value=' and ' Tokenstr |c(f(h)>d0| translated: assert ( len ( tk ) == 3  and 
Lexem 9 Current token='s' perl='$tk' value='tk' Tokenstr |c(f(h)>d0s| translated: assert ( len ( tk ) == 3  and  tk
Lexem 10 Current token='(' perl='{' value='[' Tokenstr |c(f(h)>d0s(| translated: assert ( len ( tk ) == 3  and  tk [
Lexem 11 Current token='i' perl='t1' value='t1' Tokenstr |c(f(h)>d0s(i| translated: assert ( len ( tk ) == 3  and  tk [ t1
Lexem 12 Current token=')' perl='}' value=']' Tokenstr |c(f(h)>d0s(")| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ]
Lexem 13 Current token='>' perl='eq' value='==' Tokenstr |c(f(h)>d0s(")>| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] ==
Lexem 14 Current token='"' perl='v1' value=''v1'' Tokenstr |c(f(h)>d0s(")>"| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'
Lexem 15 Current token='0' perl='&&' value=' and ' Tokenstr |c(f(h)>d0s(")>"0| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'  and 
Lexem 16 Current token='s' perl='$tk' value='tk' Tokenstr |c(f(h)>d0s(")>"0s| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'  and  tk
Lexem 17 Current token='(' perl='{' value='[' Tokenstr |c(f(h)>d0s(")>"0s(| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'  and  tk [
Lexem 18 Current token='i' perl='t2' value='t2' Tokenstr |c(f(h)>d0s(")>"0s(i| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'  and  tk [ t2
Lexem 19 Current token=')' perl='}' value=']' Tokenstr |c(f(h)>d0s(")>"0s(")| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'  and  tk [ 't2' ]
Lexem 20 Current token='>' perl='eq' value='==' Tokenstr |c(f(h)>d0s(")>"0s(")>| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'  and  tk [ 't2' ] ==
Lexem 21 Current token='"' perl='v2' value=''v2'' Tokenstr |c(f(h)>d0s(")>"0s(")>"| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'  and  tk [ 't2' ] == 'v2'
Lexem 22 Current token='0' perl='&&' value=' and ' Tokenstr |c(f(h)>d0s(")>"0s(")>"0| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'  and  tk [ 't2' ] == 'v2'  and 
Lexem 23 Current token='s' perl='$tk' value='tk' Tokenstr |c(f(h)>d0s(")>"0s(")>"0s| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'  and  tk [ 't2' ] == 'v2'  and  tk
Lexem 24 Current token='(' perl='{' value='[' Tokenstr |c(f(h)>d0s(")>"0s(")>"0s(| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'  and  tk [ 't2' ] == 'v2'  and  tk [
Lexem 25 Current token='i' perl='t3' value='t3' Tokenstr |c(f(h)>d0s(")>"0s(")>"0s(i| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'  and  tk [ 't2' ] == 'v2'  and  tk [ t3
Lexem 26 Current token=')' perl='}' value=']' Tokenstr |c(f(h)>d0s(")>"0s(")>"0s(")| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'  and  tk [ 't2' ] == 'v2'  and  tk [ 't3' ]
Lexem 27 Current token='>' perl='eq' value='==' Tokenstr |c(f(h)>d0s(")>"0s(")>"0s(")>| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'  and  tk [ 't2' ] == 'v2'  and  tk [ 't3' ] ==
Lexem 28 Current token='"' perl='v3' value=''v3'' Tokenstr |c(f(h)>d0s(")>"0s(")>"0s(")>"| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'  and  tk [ 't2' ] == 'v2'  and  tk [ 't3' ] == 'v3'
Lexem 29 Current token=')' perl=')' value=')' Tokenstr |c(f(h)>d0s(")>"0s(")>"0s(")>")| translated: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'  and  tk [ 't2' ] == 'v2'  and  tk [ 't3' ] == 'v3' )

Line:   11 TokenStr: =|c(f(h)>d0s(")>"0s(")>"0s(")>")|= @ValPy: assert ( len ( tk ) == 3  and  tk [ 't1' ] == 'v1'  and  tk [ 't2' ] == 'v2'  and  tk [ 't3' ] == 'v3' )
control(0) =|c(f(h)>d0s(")>"0s(")>"0s(")>")|= assert ( scalar ( tk ) == 3 && $tk { t1 } eq v1 && $tk { t2 } eq v2 && $tk { t3 } eq v3 )

control-parens removed, begin=0 start=1 =|cf(h)>d0s(")>"0s(")>"0s(")>"|= assert scalar ( tk ) == 3 && $tk { t1 } eq v1 && $tk { t2 } eq v2 && $tk { t3 } eq v3

Generated partial line assert
expression(1, 27, 0) =|cf(h)>d0s(")>"0s(")>"0s(")>"|= assert scalar ( tk ) == 3 && $tk { t1 } eq v1 && $tk { t2 } eq v2 && $tk { t3 } eq v3

function(1, 7) =|cf(h)>d0s(")>"0s(")>"0s(")>"|= assert scalar ( tk ) == 3 && $tk { t1 } eq v1 && $tk { t2 } eq v2 && $tk { t3 } eq v3

function start=3, end_pos=3, bracketed=1
Generated partial line assertlen
Generated partial line assertlen(
expression(3, 3, 0) =|cf(h)>d0s(")>"0s(")>"0s(")>"|= assert scalar ( tk ) == 3 && $tk { t1 } eq v1 && $tk { t2 } eq v2 && $tk { t3 } eq v3

Generated partial line assertlen(tk
expression returns 4
Generated partial line assertlen(tk)
Generated partial line assertlen(tk)==
Generated partial line assertlen(tk)==3
Generated partial line assertlen(tk)==3 and 
Generated partial line assertlen(tk)==3 and tk
Generated partial line assertlen(tk)==3 and tk.get(
expression(10, 10, 0) =|cf(h)>d0s(")>"0s(")>"0s(")>"|= assert scalar ( tk ) == 3 && $tk { t1 } eq v1 && $tk { t2 } eq v2 && $tk { t3 } eq v3

Generated partial line assertlen(tk)==3 and tk.get('t1'
expression returns 11
Generated partial line assertlen(tk)==3 and tk.get('t1')
Generated partial line assertlen(tk)==3 and tk.get('t1')==
Generated partial line assertlen(tk)==3 and tk.get('t1')=='v1'
Generated partial line assertlen(tk)==3 and tk.get('t1')=='v1' and 
Generated partial line assertlen(tk)==3 and tk.get('t1')=='v1' and tk
Generated partial line assertlen(tk)==3 and tk.get('t1')=='v1' and tk.get(
expression(17, 17, 0) =|cf(h)>d0s(")>"0s(")>"0s(")>"|= assert scalar ( tk ) == 3 && $tk { t1 } eq v1 && $tk { t2 } eq v2 && $tk { t3 } eq v3

Generated partial line assertlen(tk)==3 and tk.get('t1')=='v1' and tk.get('t2'
expression returns 18
Generated partial line assertlen(tk)==3 and tk.get('t1')=='v1' and tk.get('t2')
Generated partial line assertlen(tk)==3 and tk.get('t1')=='v1' and tk.get('t2')==
Generated partial line assertlen(tk)==3 and tk.get('t1')=='v1' and tk.get('t2')=='v2'
Generated partial line assertlen(tk)==3 and tk.get('t1')=='v1' and tk.get('t2')=='v2' and 
Generated partial line assertlen(tk)==3 and tk.get('t1')=='v1' and tk.get('t2')=='v2' and tk
Generated partial line assertlen(tk)==3 and tk.get('t1')=='v1' and tk.get('t2')=='v2' and tk.get(
expression(24, 24, 0) =|cf(h)>d0s(")>"0s(")>"0s(")>"|= assert scalar ( tk ) == 3 && $tk { t1 } eq v1 && $tk { t2 } eq v2 && $tk { t3 } eq v3

Generated partial line assertlen(tk)==3 and tk.get('t1')=='v1' and tk.get('t2')=='v2' and tk.get('t3'
expression returns 25
Generated partial line assertlen(tk)==3 and tk.get('t1')=='v1' and tk.get('t2')=='v2' and tk.get('t3')
Generated partial line assertlen(tk)==3 and tk.get('t1')=='v1' and tk.get('t2')=='v2' and tk.get('t3')==
Generated partial line assertlen(tk)==3 and tk.get('t1')=='v1' and tk.get('t2')=='v2' and tk.get('t3')=='v3'
expression returns 28
  12 | 0 |   |
  13 | 0 |   |assert len(tk) == 3 and tk.get('t1') == 'v1' and tk.get('t2') == 'v2' and tk.get('t3') == 'v3' #PL: foreach $p (keys %hash) {

Tokens: cf(h)>d0s(")>"0s(")>"0s(")>" ValPy: 
Main loop, line=foreach $p (keys %hash) {


 === Line 13 Perl source:foreach $p (keys %hash) {===

Lexem 0 Current token='c' perl='foreach' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='s' perl='$p' value='p' Tokenstr |cs| translated: for  p
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |cs(| translated: for  p (
Lexem 3 Current token='f' perl='keys' value='.keys()' Tokenstr |cs(f| translated: for  p ( .keys()
Lexem 4 Current token='h' perl='hash' value='hash' Tokenstr |cs(fh| translated: for  p ( .keys() hash
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |cs(fh)| translated: for  p ( .keys() hash )

Line:   13 TokenStr: =|cs(fh)|= @ValPy: for  p ( .keys() hash )
control(0) =|cs(fh)|= foreach $p ( keys hash )

Generated partial line for 
Generated partial line for p in 
Generated partial line for p in hash.keys()
Generated partial line for p in hash.keys():
  13 | 0 |   |for p in hash.keys():                                                                   #PL: 

Tokens: cs(fh) ValPy: 
Main loop, line={


 === Line 13 Perl source:{===


Line:   13 TokenStr: =|{|= @ValPy: {
Main loop, line=push @arr, $p;


 === Line 14 Perl source:push @arr, $p;===

Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$p' value='p' Tokenstr |fa,s| translated: .extend( arr , p

Line:   14 TokenStr: =|fa,s|= @ValPy: .extend( arr , p
function(0, 3) =|fa,s|= push @arr , $p

function start=1, end_pos=3, bracketed=0
push s

expression(1, 1, 0) =|fa,s|= push @arr , $p

Generated partial line arr
expression returns 2
Generated partial line arr.append(
expression(3, 3, 0) =|fa,s|= push @arr , $p

Generated partial line arr.append(p
expression returns 4
Generated partial line arr.append(p)
  15 | 1 |   |    arr.append(p)                                                                       #PL: 

Tokens: fa,s ValPy: 
Main loop, line=}


 === Line 15 Perl source:}===


Line:   15 TokenStr: =|}|= @ValPy: }
  15 | 1 |   |
Main loop, line=aeq_unordered(\@arr, \@khash);


 === Line 16 Perl source:aeq_unordered(\@arr, \@khash);===

Lexem 0 Current token='i' perl='aeq_unordered' value='aeq_unordered' Tokenstr |i| translated: aeq_unordered
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeq_unordered (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeq_unordered ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeq_unordered (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeq_unordered (  arr ,
Lexem 5 Current token='\' perl='\' value='' Tokenstr |i(\a,\| translated: aeq_unordered (  arr , 
Lexem 6 Current token='a' perl='@khash' value='khash' Tokenstr |i(\a,\a| translated: aeq_unordered (  arr ,  khash
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |i(\a,\a)| translated: aeq_unordered (  arr ,  khash )

Line:   16 TokenStr: =|i(\a,\a)|= @ValPy: aeq_unordered (  arr ,  khash )
Generated partial line aeq_unordered
Generated partial line aeq_unordered([
expression(2, 6, -1) =|i(\a,\a)|= aeq_unordered ( \ @arr , \ @khash )

Generated partial line aeq_unordered([
Generated partial line aeq_unordered([arr
Generated partial line aeq_unordered([arr,
Generated partial line aeq_unordered([arr,
Generated partial line aeq_unordered([arr,khash
expression returns 7
Generated partial line aeq_unordered([arr,khash])
  17 | 0 |   |
  18 | 0 |   |aeq_unordered([arr, khash])                                                             #PL: @arr = ();

Tokens: i(\a,\a) ValPy: 
Main loop, line=@arr = ();


 === Line 18 Perl source:@arr = ();===

Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )

Line:   18 TokenStr: =|a=()|= @ValPy: arr = ( )
Generated partial line arr = [
Generated partial line arr = []
  19 | 0 |   |arr = []                                                                                #PL: for $file ( @files ) {

Tokens: a=() ValPy: 
Main loop, line=for $file ( @files ) {


 === Line 19 Perl source:for $file ( @files ) {===

Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='s' perl='$file' value='file' Tokenstr |cs| translated: for  file
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |cs(| translated: for  file (
Lexem 3 Current token='a' perl='@files' value='files' Tokenstr |cs(a| translated: for  file ( files
Lexem 4 Current token=')' perl=')' value=')' Tokenstr |cs(a)| translated: for  file ( files )

Line:   19 TokenStr: =|cs(a)|= @ValPy: for  file ( files )
control(0) =|cs(a)|= for $file ( @files )

Generated partial line for 
Generated partial line for file in 
Generated partial line for file in files
Generated partial line for file in files:
  19 | 0 |   |for file in files:                                                                      #PL: 

Tokens: cs(a) ValPy: 
Main loop, line={


 === Line 19 Perl source:{===


Line:   19 TokenStr: =|{|= @ValPy: {
Main loop, line=push @arr, $file;


 === Line 20 Perl source:push @arr, $file;===

Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$file' value='file' Tokenstr |fa,s| translated: .extend( arr , file

Line:   20 TokenStr: =|fa,s|= @ValPy: .extend( arr , file
function(0, 3) =|fa,s|= push @arr , $file

function start=1, end_pos=3, bracketed=0
push s

expression(1, 1, 0) =|fa,s|= push @arr , $file

Generated partial line arr
expression returns 2
Generated partial line arr.append(
expression(3, 3, 0) =|fa,s|= push @arr , $file

Generated partial line arr.append(file
expression returns 4
Generated partial line arr.append(file)
  21 | 1 |   |    arr.append(file)                                                                    #PL: 

Tokens: fa,s ValPy: 
Main loop, line=}


 === Line 21 Perl source:}===


Line:   21 TokenStr: =|}|= @ValPy: }
  21 | 1 |   |
Main loop, line=aeq(\@files, \@arr);


 === Line 22 Perl source:aeq(\@files, \@arr);===

Lexem 0 Current token='i' perl='aeq' value='aeq' Tokenstr |i| translated: aeq
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeq (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeq ( 
Lexem 3 Current token='a' perl='@files' value='files' Tokenstr |i(\a| translated: aeq (  files
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeq (  files ,
Lexem 5 Current token='\' perl='\' value='' Tokenstr |i(\a,\| translated: aeq (  files , 
Lexem 6 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a,\a| translated: aeq (  files ,  arr
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |i(\a,\a)| translated: aeq (  files ,  arr )

Line:   22 TokenStr: =|i(\a,\a)|= @ValPy: aeq (  files ,  arr )
Generated partial line aeq
Generated partial line aeq([
expression(2, 6, -1) =|i(\a,\a)|= aeq ( \ @files , \ @arr )

Generated partial line aeq([
Generated partial line aeq([files
Generated partial line aeq([files,
Generated partial line aeq([files,
Generated partial line aeq([files,arr
expression returns 7
Generated partial line aeq([files,arr])
  23 | 0 |   |
  24 | 0 |   |aeq([files, arr])                                                                       #PL: @arr = ();

Tokens: i(\a,\a) ValPy: 
Main loop, line=@arr = ();


 === Line 24 Perl source:@arr = ();===

Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )

Line:   24 TokenStr: =|a=()|= @ValPy: arr = ( )
Generated partial line arr = [
Generated partial line arr = []
  25 | 0 |   |arr = []                                                                                #PL: for ( @files ) {

Tokens: a=() ValPy: 
Main loop, line=for ( @files ) {


 === Line 25 Perl source:for ( @files ) {===

Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='a' perl='@files' value='files' Tokenstr |c(a| translated: for  ( files
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(a)| translated: for  ( files )

Line:   25 TokenStr: =|c(a)|= @ValPy: for  ( files )
control(0) =|c(a)|= for ( @files )

control-parens removed, begin=0 start=1 =|ca|= for @files

Generated partial line for 
Generated partial line for _d in 
Generated partial line for _d in files
Generated partial line for _d in files:
  25 | 0 |   |for _d in files:                                                                        #PL: 

Tokens: c(a) ValPy: 
Main loop, line={


 === Line 25 Perl source:{===


Line:   25 TokenStr: =|{|= @ValPy: {
Main loop, line=push @arr, $_;


 === Line 26 Perl source:push @arr, $_;===

Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$_' value='_d' Tokenstr |fa,s| translated: .extend( arr , _d

Line:   26 TokenStr: =|fa,s|= @ValPy: .extend( arr , _d
function(0, 3) =|fa,s|= push @arr , $_

function start=1, end_pos=3, bracketed=0
push s

expression(1, 1, 0) =|fa,s|= push @arr , $_

Generated partial line arr
expression returns 2
Generated partial line arr.append(
expression(3, 3, 0) =|fa,s|= push @arr , $_

Generated partial line arr.append(_d
expression returns 4
Generated partial line arr.append(_d)
  27 | 1 |   |    arr.append(_d)                                                                      #PL: 

Tokens: fa,s ValPy: 
Main loop, line=}


 === Line 27 Perl source:}===


Line:   27 TokenStr: =|}|= @ValPy: }
  27 | 1 |   |
Main loop, line=aeq(\@files, \@arr);


 === Line 28 Perl source:aeq(\@files, \@arr);===

Lexem 0 Current token='i' perl='aeq' value='aeq' Tokenstr |i| translated: aeq
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeq (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeq ( 
Lexem 3 Current token='a' perl='@files' value='files' Tokenstr |i(\a| translated: aeq (  files
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeq (  files ,
Lexem 5 Current token='\' perl='\' value='' Tokenstr |i(\a,\| translated: aeq (  files , 
Lexem 6 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a,\a| translated: aeq (  files ,  arr
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |i(\a,\a)| translated: aeq (  files ,  arr )

Line:   28 TokenStr: =|i(\a,\a)|= @ValPy: aeq (  files ,  arr )
Generated partial line aeq
Generated partial line aeq([
expression(2, 6, -1) =|i(\a,\a)|= aeq ( \ @files , \ @arr )

Generated partial line aeq([
Generated partial line aeq([files
Generated partial line aeq([files,
Generated partial line aeq([files,
Generated partial line aeq([files,arr
expression returns 7
Generated partial line aeq([files,arr])
  29 | 0 |   |
  30 | 0 |   |aeq([files, arr])                                                                       #PL: @arr = ();

Tokens: i(\a,\a) ValPy: 
Main loop, line=@arr = ();


 === Line 30 Perl source:@arr = ();===

Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )

Line:   30 TokenStr: =|a=()|= @ValPy: arr = ( )
Generated partial line arr = [
Generated partial line arr = []
  31 | 0 |   |arr = []                                                                                #PL: for my $file ( @files ) {

Tokens: a=() ValPy: 
Main loop, line=for my $file ( @files ) {


 === Line 31 Perl source:for my $file ( @files ) {===

Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='s' perl='$file' value='file' Tokenstr |cs| translated: for  file
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |cs(| translated: for  file (
Lexem 3 Current token='a' perl='@files' value='files' Tokenstr |cs(a| translated: for  file ( files
Lexem 4 Current token=')' perl=')' value=')' Tokenstr |cs(a)| translated: for  file ( files )

Line:   31 TokenStr: =|cs(a)|= @ValPy: for  file ( files )
control(0) =|cs(a)|= for $file ( @files )

Generated partial line for 
Generated partial line for file in 
Generated partial line for file in files
Generated partial line for file in files:
  31 | 0 |   |for file in files:                                                                      #PL: 

Tokens: cs(a) ValPy: 
Main loop, line={


 === Line 31 Perl source:{===


Line:   31 TokenStr: =|{|= @ValPy: {
Main loop, line=push @arr, $file;


 === Line 32 Perl source:push @arr, $file;===

Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$file' value='file' Tokenstr |fa,s| translated: .extend( arr , file

Line:   32 TokenStr: =|fa,s|= @ValPy: .extend( arr , file
function(0, 3) =|fa,s|= push @arr , $file

function start=1, end_pos=3, bracketed=0
push s

expression(1, 1, 0) =|fa,s|= push @arr , $file

Generated partial line arr
expression returns 2
Generated partial line arr.append(
expression(3, 3, 0) =|fa,s|= push @arr , $file

Generated partial line arr.append(file
expression returns 4
Generated partial line arr.append(file)
  33 | 1 |   |    arr.append(file)                                                                    #PL: 

Tokens: fa,s ValPy: 
Main loop, line=}


 === Line 33 Perl source:}===


Line:   33 TokenStr: =|}|= @ValPy: }
  33 | 1 |   |
Main loop, line=aeq(\@files, \@arr);


 === Line 34 Perl source:aeq(\@files, \@arr);===

Lexem 0 Current token='i' perl='aeq' value='aeq' Tokenstr |i| translated: aeq
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeq (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeq ( 
Lexem 3 Current token='a' perl='@files' value='files' Tokenstr |i(\a| translated: aeq (  files
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeq (  files ,
Lexem 5 Current token='\' perl='\' value='' Tokenstr |i(\a,\| translated: aeq (  files , 
Lexem 6 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a,\a| translated: aeq (  files ,  arr
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |i(\a,\a)| translated: aeq (  files ,  arr )

Line:   34 TokenStr: =|i(\a,\a)|= @ValPy: aeq (  files ,  arr )
Generated partial line aeq
Generated partial line aeq([
expression(2, 6, -1) =|i(\a,\a)|= aeq ( \ @files , \ @arr )

Generated partial line aeq([
Generated partial line aeq([files
Generated partial line aeq([files,
Generated partial line aeq([files,
Generated partial line aeq([files,arr
expression returns 7
Generated partial line aeq([files,arr])
  35 | 0 |   |
  36 | 0 |   |aeq([files, arr])                                                                       #PL: @arr = ();

Tokens: i(\a,\a) ValPy: 
Main loop, line=@arr = ();


 === Line 36 Perl source:@arr = ();===

Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )

Line:   36 TokenStr: =|a=()|= @ValPy: arr = ( )
Generated partial line arr = [
Generated partial line arr = []
  37 | 0 |   |arr = []                                                                                #PL: foreach $file ( @files ) {

Tokens: a=() ValPy: 
Main loop, line=foreach $file ( @files ) {


 === Line 37 Perl source:foreach $file ( @files ) {===

Lexem 0 Current token='c' perl='foreach' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='s' perl='$file' value='file' Tokenstr |cs| translated: for  file
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |cs(| translated: for  file (
Lexem 3 Current token='a' perl='@files' value='files' Tokenstr |cs(a| translated: for  file ( files
Lexem 4 Current token=')' perl=')' value=')' Tokenstr |cs(a)| translated: for  file ( files )

Line:   37 TokenStr: =|cs(a)|= @ValPy: for  file ( files )
control(0) =|cs(a)|= foreach $file ( @files )

Generated partial line for 
Generated partial line for file in 
Generated partial line for file in files
Generated partial line for file in files:
  37 | 0 |   |for file in files:                                                                      #PL: 

Tokens: cs(a) ValPy: 
Main loop, line={


 === Line 37 Perl source:{===


Line:   37 TokenStr: =|{|= @ValPy: {
Main loop, line=push @arr, $file;


 === Line 38 Perl source:push @arr, $file;===

Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$file' value='file' Tokenstr |fa,s| translated: .extend( arr , file

Line:   38 TokenStr: =|fa,s|= @ValPy: .extend( arr , file
function(0, 3) =|fa,s|= push @arr , $file

function start=1, end_pos=3, bracketed=0
push s

expression(1, 1, 0) =|fa,s|= push @arr , $file

Generated partial line arr
expression returns 2
Generated partial line arr.append(
expression(3, 3, 0) =|fa,s|= push @arr , $file

Generated partial line arr.append(file
expression returns 4
Generated partial line arr.append(file)
  39 | 1 |   |    arr.append(file)                                                                    #PL: 

Tokens: fa,s ValPy: 
Main loop, line=}


 === Line 39 Perl source:}===


Line:   39 TokenStr: =|}|= @ValPy: }
  39 | 1 |   |
Main loop, line=aeq(\@files, \@arr);


 === Line 40 Perl source:aeq(\@files, \@arr);===

Lexem 0 Current token='i' perl='aeq' value='aeq' Tokenstr |i| translated: aeq
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeq (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeq ( 
Lexem 3 Current token='a' perl='@files' value='files' Tokenstr |i(\a| translated: aeq (  files
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeq (  files ,
Lexem 5 Current token='\' perl='\' value='' Tokenstr |i(\a,\| translated: aeq (  files , 
Lexem 6 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a,\a| translated: aeq (  files ,  arr
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |i(\a,\a)| translated: aeq (  files ,  arr )

Line:   40 TokenStr: =|i(\a,\a)|= @ValPy: aeq (  files ,  arr )
Generated partial line aeq
Generated partial line aeq([
expression(2, 6, -1) =|i(\a,\a)|= aeq ( \ @files , \ @arr )

Generated partial line aeq([
Generated partial line aeq([files
Generated partial line aeq([files,
Generated partial line aeq([files,
Generated partial line aeq([files,arr
expression returns 7
Generated partial line aeq([files,arr])
  41 | 0 |   |
  42 | 0 |   |aeq([files, arr])                                                                       #PL: @arr = ();

Tokens: i(\a,\a) ValPy: 
Main loop, line=@arr = ();


 === Line 42 Perl source:@arr = ();===

Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )

Line:   42 TokenStr: =|a=()|= @ValPy: arr = ( )
Generated partial line arr = [
Generated partial line arr = []
  43 | 0 |   |arr = []                                                                                #PL: for ( my $i = 5; $i >= 0; $i-- ) {

Tokens: a=() ValPy: 
Main loop, line=for ( my $i = 5; $i >= 0; $i-- ) {


 === Line 43 Perl source:for ( my $i = 5; $i >= 0; $i-- ) {===

Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='s' perl='$i' value='i' Tokenstr |c(s| translated: for  ( i
Lexem 3 Current token='=' perl='=' value=':=' Tokenstr |c(s=| translated: for  ( i :=
Lexem 4 Current token='d' perl='5' value='5' Tokenstr |c(s=d| translated: for  ( i := 5
Lexem 5 Current token=';' perl=';' value=';' Tokenstr |c(s=d;| translated: for  ( i := 5 ;
Lexem 6 Current token='s' perl='$i' value='i' Tokenstr |c(s=d;s| translated: for  ( i := 5 ; i
Lexem 7 Current token='>' perl='>=' value='>=' Tokenstr |c(s=d;s>| translated: for  ( i := 5 ; i >=
Lexem 8 Current token='d' perl='0' value='0' Tokenstr |c(s=d;s>d| translated: for  ( i := 5 ; i >= 0
Lexem 9 Current token=';' perl=';' value=';' Tokenstr |c(s=d;s>d;| translated: for  ( i := 5 ; i >= 0 ;
Lexem 10 Current token='s' perl='$i' value='i' Tokenstr |c(s=d;s>d;s| translated: for  ( i := 5 ; i >= 0 ; i
Lexem 11 Current token='^' perl='--' value='-=1' Tokenstr |c(s=d;s>d;s^| translated: for  ( i := 5 ; i >= 0 ; i -=1
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |c(s=d;s>d;s^)| translated: for  ( i := 5 ; i >= 0 ; i -=1 )

Line:   43 TokenStr: =|c(s=d;s>d;s^)|= @ValPy: for  ( i := 5 ; i >= 0 ; i -=1 )
handle_incr_decr(0, 11, 12) with --, pre_op=0, lvalue_start=10, lvalue_end=10 = 9
control(0) =|c(s=d;s>d;((s=s-d)+d))|= for ( $i = 5 ; $i >= 0 ; ( ( $i = $i - 1 ) + 1 ) )

control-parens removed, begin=0 start=1 =|cs=d;s>d;((s=s-d)+d)|= for $i = 5 ; $i >= 0 ; ( ( $i = $i - 1 ) + 1 )

Generated partial line for 
Generated partial line for i
Generated partial line for iin range(
Generated partial line for iin range(5
Generated partial line for iin range(5,
Generated partial line for iin range(5,0
Generated partial line for iin range(5,0-1
Generated partial line for iin range(5,0-1,-1):
  43 | 0 |   |for i in range(5, 0-1,-1):                                                              #PL: 

Tokens: cs=d;s>d;((s=s-d)+d) ValPy: 
Main loop, line={


 === Line 43 Perl source:{===


Line:   43 TokenStr: =|{|= @ValPy: {
Main loop, line=push @arr, $i;


 === Line 44 Perl source:push @arr, $i;===

Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$i' value='i' Tokenstr |fa,s| translated: .extend( arr , i

Line:   44 TokenStr: =|fa,s|= @ValPy: .extend( arr , i
function(0, 3) =|fa,s|= push @arr , $i

function start=1, end_pos=3, bracketed=0
push s

expression(1, 1, 0) =|fa,s|= push @arr , $i

Generated partial line arr
expression returns 2
Generated partial line arr.append(
expression(3, 3, 0) =|fa,s|= push @arr , $i

Generated partial line arr.append(i
expression returns 4
Generated partial line arr.append(i)
  45 | 1 |   |    arr.append(i)                                                                       #PL: 

Tokens: fa,s ValPy: 
Main loop, line=}


 === Line 45 Perl source:}===


Line:   45 TokenStr: =|}|= @ValPy: }
  45 | 1 |   |
Main loop, line=aeqi(\@arr, [5,4,3,2,1,0]);


 === Line 46 Perl source:aeqi(\@arr, [5,4,3,2,1,0]);===

Lexem 0 Current token='i' perl='aeqi' value='aeqi' Tokenstr |i| translated: aeqi
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeqi (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeqi ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeqi (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeqi (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeqi (  arr , [
Lexem 6 Current token='d' perl='5' value='5' Tokenstr |i(\a,(d| translated: aeqi (  arr , [ 5
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,| translated: aeqi (  arr , [ 5 ,
Lexem 8 Current token='d' perl='4' value='4' Tokenstr |i(\a,(d,d| translated: aeqi (  arr , [ 5 , 4
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,| translated: aeqi (  arr , [ 5 , 4 ,
Lexem 10 Current token='d' perl='3' value='3' Tokenstr |i(\a,(d,d,d| translated: aeqi (  arr , [ 5 , 4 , 3
Lexem 11 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,d,| translated: aeqi (  arr , [ 5 , 4 , 3 ,
Lexem 12 Current token='d' perl='2' value='2' Tokenstr |i(\a,(d,d,d,d| translated: aeqi (  arr , [ 5 , 4 , 3 , 2
Lexem 13 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,d,d,| translated: aeqi (  arr , [ 5 , 4 , 3 , 2 ,
Lexem 14 Current token='d' perl='1' value='1' Tokenstr |i(\a,(d,d,d,d,d| translated: aeqi (  arr , [ 5 , 4 , 3 , 2 , 1
Lexem 15 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,d,d,d,| translated: aeqi (  arr , [ 5 , 4 , 3 , 2 , 1 ,
Lexem 16 Current token='d' perl='0' value='0' Tokenstr |i(\a,(d,d,d,d,d,d| translated: aeqi (  arr , [ 5 , 4 , 3 , 2 , 1 , 0
Lexem 17 Current token=')' perl=']' value=']' Tokenstr |i(\a,(d,d,d,d,d,d)| translated: aeqi (  arr , [ 5 , 4 , 3 , 2 , 1 , 0 ]
Lexem 18 Current token=')' perl=')' value=')' Tokenstr |i(\a,(d,d,d,d,d,d))| translated: aeqi (  arr , [ 5 , 4 , 3 , 2 , 1 , 0 ] )

Line:   46 TokenStr: =|i(\a,(d,d,d,d,d,d))|= @ValPy: aeqi (  arr , [ 5 , 4 , 3 , 2 , 1 , 0 ] )
Generated partial line aeqi
Generated partial line aeqi([
expression(2, 17, -1) =|i(\a,(d,d,d,d,d,d))|= aeqi ( \ @arr , [ 5 , 4 , 3 , 2 , 1 , 0 ] )

Generated partial line aeqi([
Generated partial line aeqi([arr
Generated partial line aeqi([arr,
Generated partial line aeqi([arr,[
expression(6, 16, 0) =|i(\a,(d,d,d,d,d,d))|= aeqi ( \ @arr , [ 5 , 4 , 3 , 2 , 1 , 0 ] )

Generated partial line aeqi([arr,[5
Generated partial line aeqi([arr,[5,
Generated partial line aeqi([arr,[5,4
Generated partial line aeqi([arr,[5,4,
Generated partial line aeqi([arr,[5,4,3
Generated partial line aeqi([arr,[5,4,3,
Generated partial line aeqi([arr,[5,4,3,2
Generated partial line aeqi([arr,[5,4,3,2,
Generated partial line aeqi([arr,[5,4,3,2,1
Generated partial line aeqi([arr,[5,4,3,2,1,
Generated partial line aeqi([arr,[5,4,3,2,1,0
expression returns 17
Generated partial line aeqi([arr,[5,4,3,2,1,0]
expression returns 18
Generated partial line aeqi([arr,[5,4,3,2,1,0]])
  47 | 0 |   |
  48 | 0 |   |aeqi([arr, [5, 4, 3, 2, 1, 0]])                                                         #PL: @arr = ();

Tokens: i(\a,(d,d,d,d,d,d)) ValPy: 
Main loop, line=@arr = ();


 === Line 48 Perl source:@arr = ();===

Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )

Line:   48 TokenStr: =|a=()|= @ValPy: arr = ( )
Generated partial line arr = [
Generated partial line arr = []
  49 | 0 |   |arr = []                                                                                #PL: for ( my $i = 5; $i > 0; $i-- ) {

Tokens: a=() ValPy: 
Main loop, line=for ( my $i = 5; $i > 0; $i-- ) {


 === Line 49 Perl source:for ( my $i = 5; $i > 0; $i-- ) {===

Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='s' perl='$i' value='i' Tokenstr |c(s| translated: for  ( i
Lexem 3 Current token='=' perl='=' value=':=' Tokenstr |c(s=| translated: for  ( i :=
Lexem 4 Current token='d' perl='5' value='5' Tokenstr |c(s=d| translated: for  ( i := 5
Lexem 5 Current token=';' perl=';' value=';' Tokenstr |c(s=d;| translated: for  ( i := 5 ;
Lexem 6 Current token='s' perl='$i' value='i' Tokenstr |c(s=d;s| translated: for  ( i := 5 ; i
Lexem 7 Current token='>' perl='>' value='>' Tokenstr |c(s=d;s>| translated: for  ( i := 5 ; i >
Lexem 8 Current token='d' perl='0' value='0' Tokenstr |c(s=d;s>d| translated: for  ( i := 5 ; i > 0
Lexem 9 Current token=';' perl=';' value=';' Tokenstr |c(s=d;s>d;| translated: for  ( i := 5 ; i > 0 ;
Lexem 10 Current token='s' perl='$i' value='i' Tokenstr |c(s=d;s>d;s| translated: for  ( i := 5 ; i > 0 ; i
Lexem 11 Current token='^' perl='--' value='-=1' Tokenstr |c(s=d;s>d;s^| translated: for  ( i := 5 ; i > 0 ; i -=1
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |c(s=d;s>d;s^)| translated: for  ( i := 5 ; i > 0 ; i -=1 )

Line:   49 TokenStr: =|c(s=d;s>d;s^)|= @ValPy: for  ( i := 5 ; i > 0 ; i -=1 )
handle_incr_decr(0, 11, 12) with --, pre_op=0, lvalue_start=10, lvalue_end=10 = 9
control(0) =|c(s=d;s>d;((s=s-d)+d))|= for ( $i = 5 ; $i > 0 ; ( ( $i = $i - 1 ) + 1 ) )

control-parens removed, begin=0 start=1 =|cs=d;s>d;((s=s-d)+d)|= for $i = 5 ; $i > 0 ; ( ( $i = $i - 1 ) + 1 )

Generated partial line for 
Generated partial line for i
Generated partial line for iin range(
Generated partial line for iin range(5
Generated partial line for iin range(5,
Generated partial line for iin range(5,0
Generated partial line for iin range(5,0,-1):
  49 | 0 |   |for i in range(5, 0,-1):                                                                #PL: 

Tokens: cs=d;s>d;((s=s-d)+d) ValPy: 
Main loop, line={


 === Line 49 Perl source:{===


Line:   49 TokenStr: =|{|= @ValPy: {
Main loop, line=push @arr, $i;


 === Line 50 Perl source:push @arr, $i;===

Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$i' value='i' Tokenstr |fa,s| translated: .extend( arr , i

Line:   50 TokenStr: =|fa,s|= @ValPy: .extend( arr , i
function(0, 3) =|fa,s|= push @arr , $i

function start=1, end_pos=3, bracketed=0
push s

expression(1, 1, 0) =|fa,s|= push @arr , $i

Generated partial line arr
expression returns 2
Generated partial line arr.append(
expression(3, 3, 0) =|fa,s|= push @arr , $i

Generated partial line arr.append(i
expression returns 4
Generated partial line arr.append(i)
  51 | 1 |   |    arr.append(i)                                                                       #PL: 

Tokens: fa,s ValPy: 
Main loop, line=}


 === Line 51 Perl source:}===


Line:   51 TokenStr: =|}|= @ValPy: }
  51 | 1 |   |
Main loop, line=aeqi(\@arr, [5,4,3,2,1]);


 === Line 52 Perl source:aeqi(\@arr, [5,4,3,2,1]);===

Lexem 0 Current token='i' perl='aeqi' value='aeqi' Tokenstr |i| translated: aeqi
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeqi (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeqi ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeqi (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeqi (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeqi (  arr , [
Lexem 6 Current token='d' perl='5' value='5' Tokenstr |i(\a,(d| translated: aeqi (  arr , [ 5
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,| translated: aeqi (  arr , [ 5 ,
Lexem 8 Current token='d' perl='4' value='4' Tokenstr |i(\a,(d,d| translated: aeqi (  arr , [ 5 , 4
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,| translated: aeqi (  arr , [ 5 , 4 ,
Lexem 10 Current token='d' perl='3' value='3' Tokenstr |i(\a,(d,d,d| translated: aeqi (  arr , [ 5 , 4 , 3
Lexem 11 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,d,| translated: aeqi (  arr , [ 5 , 4 , 3 ,
Lexem 12 Current token='d' perl='2' value='2' Tokenstr |i(\a,(d,d,d,d| translated: aeqi (  arr , [ 5 , 4 , 3 , 2
Lexem 13 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,d,d,| translated: aeqi (  arr , [ 5 , 4 , 3 , 2 ,
Lexem 14 Current token='d' perl='1' value='1' Tokenstr |i(\a,(d,d,d,d,d| translated: aeqi (  arr , [ 5 , 4 , 3 , 2 , 1
Lexem 15 Current token=')' perl=']' value=']' Tokenstr |i(\a,(d,d,d,d,d)| translated: aeqi (  arr , [ 5 , 4 , 3 , 2 , 1 ]
Lexem 16 Current token=')' perl=')' value=')' Tokenstr |i(\a,(d,d,d,d,d))| translated: aeqi (  arr , [ 5 , 4 , 3 , 2 , 1 ] )

Line:   52 TokenStr: =|i(\a,(d,d,d,d,d))|= @ValPy: aeqi (  arr , [ 5 , 4 , 3 , 2 , 1 ] )
Generated partial line aeqi
Generated partial line aeqi([
expression(2, 15, -1) =|i(\a,(d,d,d,d,d))|= aeqi ( \ @arr , [ 5 , 4 , 3 , 2 , 1 ] )

Generated partial line aeqi([
Generated partial line aeqi([arr
Generated partial line aeqi([arr,
Generated partial line aeqi([arr,[
expression(6, 14, 0) =|i(\a,(d,d,d,d,d))|= aeqi ( \ @arr , [ 5 , 4 , 3 , 2 , 1 ] )

Generated partial line aeqi([arr,[5
Generated partial line aeqi([arr,[5,
Generated partial line aeqi([arr,[5,4
Generated partial line aeqi([arr,[5,4,
Generated partial line aeqi([arr,[5,4,3
Generated partial line aeqi([arr,[5,4,3,
Generated partial line aeqi([arr,[5,4,3,2
Generated partial line aeqi([arr,[5,4,3,2,
Generated partial line aeqi([arr,[5,4,3,2,1
expression returns 15
Generated partial line aeqi([arr,[5,4,3,2,1]
expression returns 16
Generated partial line aeqi([arr,[5,4,3,2,1]])
  53 | 0 |   |
  54 | 0 |   |aeqi([arr, [5, 4, 3, 2, 1]])                                                            #PL: @arr = ();

Tokens: i(\a,(d,d,d,d,d)) ValPy: 
Main loop, line=@arr = ();


 === Line 54 Perl source:@arr = ();===

Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )

Line:   54 TokenStr: =|a=()|= @ValPy: arr = ( )
Generated partial line arr = [
Generated partial line arr = []
  55 | 0 |   |arr = []                                                                                #PL: for ( my $i = 0; $i < 5; $i++ ) {

Tokens: a=() ValPy: 
Main loop, line=for ( my $i = 0; $i < 5; $i++ ) {


 === Line 55 Perl source:for ( my $i = 0; $i < 5; $i++ ) {===

Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='s' perl='$i' value='i' Tokenstr |c(s| translated: for  ( i
Lexem 3 Current token='=' perl='=' value=':=' Tokenstr |c(s=| translated: for  ( i :=
Lexem 4 Current token='d' perl='0' value='0' Tokenstr |c(s=d| translated: for  ( i := 0
Lexem 5 Current token=';' perl=';' value=';' Tokenstr |c(s=d;| translated: for  ( i := 0 ;
Lexem 6 Current token='s' perl='$i' value='i' Tokenstr |c(s=d;s| translated: for  ( i := 0 ; i
Lexem 7 Current token='>' perl='<' value='<' Tokenstr |c(s=d;s>| translated: for  ( i := 0 ; i <
Lexem 8 Current token='d' perl='5' value='5' Tokenstr |c(s=d;s>d| translated: for  ( i := 0 ; i < 5
Lexem 9 Current token=';' perl=';' value=';' Tokenstr |c(s=d;s>d;| translated: for  ( i := 0 ; i < 5 ;
Lexem 10 Current token='s' perl='$i' value='i' Tokenstr |c(s=d;s>d;s| translated: for  ( i := 0 ; i < 5 ; i
Lexem 11 Current token='^' perl='++' value='+=1' Tokenstr |c(s=d;s>d;s^| translated: for  ( i := 0 ; i < 5 ; i +=1
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |c(s=d;s>d;s^)| translated: for  ( i := 0 ; i < 5 ; i +=1 )

Line:   55 TokenStr: =|c(s=d;s>d;s^)|= @ValPy: for  ( i := 0 ; i < 5 ; i +=1 )
handle_incr_decr(0, 11, 12) with ++, pre_op=0, lvalue_start=10, lvalue_end=10 = 9
control(0) =|c(s=d;s>d;((s=s+d)-d))|= for ( $i = 0 ; $i < 5 ; ( ( $i = $i + 1 ) - 1 ) )

control-parens removed, begin=0 start=1 =|cs=d;s>d;((s=s+d)-d)|= for $i = 0 ; $i < 5 ; ( ( $i = $i + 1 ) - 1 )

Generated partial line for 
Generated partial line for i
Generated partial line for iin range(
Generated partial line for iin range(0
Generated partial line for iin range(0,
Generated partial line for iin range(0,5
Generated partial line for iin range(0,5):
  55 | 0 |   |for i in range(0, 5):                                                                   #PL: 

Tokens: cs=d;s>d;((s=s+d)-d) ValPy: 
Main loop, line={


 === Line 55 Perl source:{===


Line:   55 TokenStr: =|{|= @ValPy: {
Main loop, line=push @arr, $i;


 === Line 56 Perl source:push @arr, $i;===

Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$i' value='i' Tokenstr |fa,s| translated: .extend( arr , i

Line:   56 TokenStr: =|fa,s|= @ValPy: .extend( arr , i
function(0, 3) =|fa,s|= push @arr , $i

function start=1, end_pos=3, bracketed=0
push s

expression(1, 1, 0) =|fa,s|= push @arr , $i

Generated partial line arr
expression returns 2
Generated partial line arr.append(
expression(3, 3, 0) =|fa,s|= push @arr , $i

Generated partial line arr.append(i
expression returns 4
Generated partial line arr.append(i)
  57 | 1 |   |    arr.append(i)                                                                       #PL: 

Tokens: fa,s ValPy: 
Main loop, line=}


 === Line 57 Perl source:}===


Line:   57 TokenStr: =|}|= @ValPy: }
  57 | 1 |   |
Main loop, line=aeqi(\@arr, [0,1,2,3,4]);


 === Line 58 Perl source:aeqi(\@arr, [0,1,2,3,4]);===

Lexem 0 Current token='i' perl='aeqi' value='aeqi' Tokenstr |i| translated: aeqi
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeqi (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeqi ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeqi (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeqi (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeqi (  arr , [
Lexem 6 Current token='d' perl='0' value='0' Tokenstr |i(\a,(d| translated: aeqi (  arr , [ 0
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,| translated: aeqi (  arr , [ 0 ,
Lexem 8 Current token='d' perl='1' value='1' Tokenstr |i(\a,(d,d| translated: aeqi (  arr , [ 0 , 1
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,| translated: aeqi (  arr , [ 0 , 1 ,
Lexem 10 Current token='d' perl='2' value='2' Tokenstr |i(\a,(d,d,d| translated: aeqi (  arr , [ 0 , 1 , 2
Lexem 11 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,d,| translated: aeqi (  arr , [ 0 , 1 , 2 ,
Lexem 12 Current token='d' perl='3' value='3' Tokenstr |i(\a,(d,d,d,d| translated: aeqi (  arr , [ 0 , 1 , 2 , 3
Lexem 13 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,d,d,| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 ,
Lexem 14 Current token='d' perl='4' value='4' Tokenstr |i(\a,(d,d,d,d,d| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4
Lexem 15 Current token=')' perl=']' value=']' Tokenstr |i(\a,(d,d,d,d,d)| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4 ]
Lexem 16 Current token=')' perl=')' value=')' Tokenstr |i(\a,(d,d,d,d,d))| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4 ] )

Line:   58 TokenStr: =|i(\a,(d,d,d,d,d))|= @ValPy: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4 ] )
Generated partial line aeqi
Generated partial line aeqi([
expression(2, 15, -1) =|i(\a,(d,d,d,d,d))|= aeqi ( \ @arr , [ 0 , 1 , 2 , 3 , 4 ] )

Generated partial line aeqi([
Generated partial line aeqi([arr
Generated partial line aeqi([arr,
Generated partial line aeqi([arr,[
expression(6, 14, 0) =|i(\a,(d,d,d,d,d))|= aeqi ( \ @arr , [ 0 , 1 , 2 , 3 , 4 ] )

Generated partial line aeqi([arr,[0
Generated partial line aeqi([arr,[0,
Generated partial line aeqi([arr,[0,1
Generated partial line aeqi([arr,[0,1,
Generated partial line aeqi([arr,[0,1,2
Generated partial line aeqi([arr,[0,1,2,
Generated partial line aeqi([arr,[0,1,2,3
Generated partial line aeqi([arr,[0,1,2,3,
Generated partial line aeqi([arr,[0,1,2,3,4
expression returns 15
Generated partial line aeqi([arr,[0,1,2,3,4]
expression returns 16
Generated partial line aeqi([arr,[0,1,2,3,4]])
  59 | 0 |   |
  60 | 0 |   |aeqi([arr, [0, 1, 2, 3, 4]])                                                            #PL: @arr = ();

Tokens: i(\a,(d,d,d,d,d)) ValPy: 
Main loop, line=@arr = ();


 === Line 60 Perl source:@arr = ();===

Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )

Line:   60 TokenStr: =|a=()|= @ValPy: arr = ( )
Generated partial line arr = [
Generated partial line arr = []
  61 | 0 |   |arr = []                                                                                #PL: for ( my $i = 0; $i <= 5; $i++ ) {

Tokens: a=() ValPy: 
Main loop, line=for ( my $i = 0; $i <= 5; $i++ ) {


 === Line 61 Perl source:for ( my $i = 0; $i <= 5; $i++ ) {===

Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='s' perl='$i' value='i' Tokenstr |c(s| translated: for  ( i
Lexem 3 Current token='=' perl='=' value=':=' Tokenstr |c(s=| translated: for  ( i :=
Lexem 4 Current token='d' perl='0' value='0' Tokenstr |c(s=d| translated: for  ( i := 0
Lexem 5 Current token=';' perl=';' value=';' Tokenstr |c(s=d;| translated: for  ( i := 0 ;
Lexem 6 Current token='s' perl='$i' value='i' Tokenstr |c(s=d;s| translated: for  ( i := 0 ; i
Lexem 7 Current token='>' perl='<=' value='<=' Tokenstr |c(s=d;s>| translated: for  ( i := 0 ; i <=
Lexem 8 Current token='d' perl='5' value='5' Tokenstr |c(s=d;s>d| translated: for  ( i := 0 ; i <= 5
Lexem 9 Current token=';' perl=';' value=';' Tokenstr |c(s=d;s>d;| translated: for  ( i := 0 ; i <= 5 ;
Lexem 10 Current token='s' perl='$i' value='i' Tokenstr |c(s=d;s>d;s| translated: for  ( i := 0 ; i <= 5 ; i
Lexem 11 Current token='^' perl='++' value='+=1' Tokenstr |c(s=d;s>d;s^| translated: for  ( i := 0 ; i <= 5 ; i +=1
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |c(s=d;s>d;s^)| translated: for  ( i := 0 ; i <= 5 ; i +=1 )

Line:   61 TokenStr: =|c(s=d;s>d;s^)|= @ValPy: for  ( i := 0 ; i <= 5 ; i +=1 )
handle_incr_decr(0, 11, 12) with ++, pre_op=0, lvalue_start=10, lvalue_end=10 = 9
control(0) =|c(s=d;s>d;((s=s+d)-d))|= for ( $i = 0 ; $i <= 5 ; ( ( $i = $i + 1 ) - 1 ) )

control-parens removed, begin=0 start=1 =|cs=d;s>d;((s=s+d)-d)|= for $i = 0 ; $i <= 5 ; ( ( $i = $i + 1 ) - 1 )

Generated partial line for 
Generated partial line for i
Generated partial line for iin range(
Generated partial line for iin range(0
Generated partial line for iin range(0,
Generated partial line for iin range(0,5
Generated partial line for iin range(0,5+1
Generated partial line for iin range(0,5+1):
  61 | 0 |   |for i in range(0, 5+1):                                                                 #PL: 

Tokens: cs=d;s>d;((s=s+d)-d) ValPy: 
Main loop, line={


 === Line 61 Perl source:{===


Line:   61 TokenStr: =|{|= @ValPy: {
Main loop, line=push @arr, $i;


 === Line 62 Perl source:push @arr, $i;===

Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$i' value='i' Tokenstr |fa,s| translated: .extend( arr , i

Line:   62 TokenStr: =|fa,s|= @ValPy: .extend( arr , i
function(0, 3) =|fa,s|= push @arr , $i

function start=1, end_pos=3, bracketed=0
push s

expression(1, 1, 0) =|fa,s|= push @arr , $i

Generated partial line arr
expression returns 2
Generated partial line arr.append(
expression(3, 3, 0) =|fa,s|= push @arr , $i

Generated partial line arr.append(i
expression returns 4
Generated partial line arr.append(i)
  63 | 1 |   |    arr.append(i)                                                                       #PL: 

Tokens: fa,s ValPy: 
Main loop, line=}


 === Line 63 Perl source:}===


Line:   63 TokenStr: =|}|= @ValPy: }
  63 | 1 |   |
Main loop, line=aeqi(\@arr, [0,1,2,3,4,5]);


 === Line 64 Perl source:aeqi(\@arr, [0,1,2,3,4,5]);===

Lexem 0 Current token='i' perl='aeqi' value='aeqi' Tokenstr |i| translated: aeqi
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeqi (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeqi ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeqi (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeqi (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeqi (  arr , [
Lexem 6 Current token='d' perl='0' value='0' Tokenstr |i(\a,(d| translated: aeqi (  arr , [ 0
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,| translated: aeqi (  arr , [ 0 ,
Lexem 8 Current token='d' perl='1' value='1' Tokenstr |i(\a,(d,d| translated: aeqi (  arr , [ 0 , 1
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,| translated: aeqi (  arr , [ 0 , 1 ,
Lexem 10 Current token='d' perl='2' value='2' Tokenstr |i(\a,(d,d,d| translated: aeqi (  arr , [ 0 , 1 , 2
Lexem 11 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,d,| translated: aeqi (  arr , [ 0 , 1 , 2 ,
Lexem 12 Current token='d' perl='3' value='3' Tokenstr |i(\a,(d,d,d,d| translated: aeqi (  arr , [ 0 , 1 , 2 , 3
Lexem 13 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,d,d,| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 ,
Lexem 14 Current token='d' perl='4' value='4' Tokenstr |i(\a,(d,d,d,d,d| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4
Lexem 15 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,d,d,d,| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4 ,
Lexem 16 Current token='d' perl='5' value='5' Tokenstr |i(\a,(d,d,d,d,d,d| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4 , 5
Lexem 17 Current token=')' perl=']' value=']' Tokenstr |i(\a,(d,d,d,d,d,d)| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4 , 5 ]
Lexem 18 Current token=')' perl=')' value=')' Tokenstr |i(\a,(d,d,d,d,d,d))| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4 , 5 ] )

Line:   64 TokenStr: =|i(\a,(d,d,d,d,d,d))|= @ValPy: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4 , 5 ] )
Generated partial line aeqi
Generated partial line aeqi([
expression(2, 17, -1) =|i(\a,(d,d,d,d,d,d))|= aeqi ( \ @arr , [ 0 , 1 , 2 , 3 , 4 , 5 ] )

Generated partial line aeqi([
Generated partial line aeqi([arr
Generated partial line aeqi([arr,
Generated partial line aeqi([arr,[
expression(6, 16, 0) =|i(\a,(d,d,d,d,d,d))|= aeqi ( \ @arr , [ 0 , 1 , 2 , 3 , 4 , 5 ] )

Generated partial line aeqi([arr,[0
Generated partial line aeqi([arr,[0,
Generated partial line aeqi([arr,[0,1
Generated partial line aeqi([arr,[0,1,
Generated partial line aeqi([arr,[0,1,2
Generated partial line aeqi([arr,[0,1,2,
Generated partial line aeqi([arr,[0,1,2,3
Generated partial line aeqi([arr,[0,1,2,3,
Generated partial line aeqi([arr,[0,1,2,3,4
Generated partial line aeqi([arr,[0,1,2,3,4,
Generated partial line aeqi([arr,[0,1,2,3,4,5
expression returns 17
Generated partial line aeqi([arr,[0,1,2,3,4,5]
expression returns 18
Generated partial line aeqi([arr,[0,1,2,3,4,5]])
  65 | 0 |   |
  66 | 0 |   |aeqi([arr, [0, 1, 2, 3, 4, 5]])                                                         #PL: @arr = ();

Tokens: i(\a,(d,d,d,d,d,d)) ValPy: 
Main loop, line=@arr = ();


 === Line 66 Perl source:@arr = ();===

Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )

Line:   66 TokenStr: =|a=()|= @ValPy: arr = ( )
Generated partial line arr = [
Generated partial line arr = []
  67 | 0 |   |arr = []                                                                                #PL: foreach $j ( 0 .. 4 ) {

Tokens: a=() ValPy: 
Main loop, line=foreach $j ( 0 .. 4 ) {


 === Line 67 Perl source:foreach $j ( 0 .. 4 ) {===

Lexem 0 Current token='c' perl='foreach' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='s' perl='$j' value='j' Tokenstr |cs| translated: for  j
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |cs(| translated: for  j (
Lexem 3 Current token='d' perl='0' value='0' Tokenstr |cs(d| translated: for  j ( 0
Lexem 4 Current token='r' perl='..' value='..' Tokenstr |cs(dr| translated: for  j ( 0 ..
Lexem 5 Current token='d' perl='4' value='4' Tokenstr |cs(drd| translated: for  j ( 0 .. 4
Lexem 6 Current token=')' perl=')' value=')' Tokenstr |cs(drd)| translated: for  j ( 0 .. 4 )

Line:   67 TokenStr: =|cs(drd)|= @ValPy: for  j ( 0 .. 4 )
control(0) =|cs(drd)|= foreach $j ( 0 .. 4 )

Generated partial line for 
Generated partial line for j in 
Generated partial line for j in range(
expression(3, 3, 0) =|cs(drd)|= foreach $j ( 0 .. 4 )

Generated partial line for j in range(0
expression returns 4
Generated partial line for j in range(0,
expression(5, 5, 0) =|cs(drd)|= foreach $j ( 0 .. 4 )

Generated partial line for j in range(0,4
expression returns 6
Generated partial line for j in range(0,4+1)
Generated partial line for j in range(0,4+1):
  67 | 0 |   |for j in range(0, 4+1):                                                                 #PL: 

Tokens: cs(drd) ValPy: 
Main loop, line={


 === Line 67 Perl source:{===


Line:   67 TokenStr: =|{|= @ValPy: {
Main loop, line=push @arr, $j;


 === Line 68 Perl source:push @arr, $j;===

Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$j' value='j' Tokenstr |fa,s| translated: .extend( arr , j

Line:   68 TokenStr: =|fa,s|= @ValPy: .extend( arr , j
function(0, 3) =|fa,s|= push @arr , $j

function start=1, end_pos=3, bracketed=0
push s

expression(1, 1, 0) =|fa,s|= push @arr , $j

Generated partial line arr
expression returns 2
Generated partial line arr.append(
expression(3, 3, 0) =|fa,s|= push @arr , $j

Generated partial line arr.append(j
expression returns 4
Generated partial line arr.append(j)
  69 | 1 |   |    arr.append(j)                                                                       #PL: 

Tokens: fa,s ValPy: 
Main loop, line=}


 === Line 69 Perl source:}===


Line:   69 TokenStr: =|}|= @ValPy: }
  69 | 1 |   |
Main loop, line=aeqi(\@arr, [0,1,2,3,4]);


 === Line 70 Perl source:aeqi(\@arr, [0,1,2,3,4]);===

Lexem 0 Current token='i' perl='aeqi' value='aeqi' Tokenstr |i| translated: aeqi
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeqi (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeqi ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeqi (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeqi (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeqi (  arr , [
Lexem 6 Current token='d' perl='0' value='0' Tokenstr |i(\a,(d| translated: aeqi (  arr , [ 0
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,| translated: aeqi (  arr , [ 0 ,
Lexem 8 Current token='d' perl='1' value='1' Tokenstr |i(\a,(d,d| translated: aeqi (  arr , [ 0 , 1
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,| translated: aeqi (  arr , [ 0 , 1 ,
Lexem 10 Current token='d' perl='2' value='2' Tokenstr |i(\a,(d,d,d| translated: aeqi (  arr , [ 0 , 1 , 2
Lexem 11 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,d,| translated: aeqi (  arr , [ 0 , 1 , 2 ,
Lexem 12 Current token='d' perl='3' value='3' Tokenstr |i(\a,(d,d,d,d| translated: aeqi (  arr , [ 0 , 1 , 2 , 3
Lexem 13 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,d,d,| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 ,
Lexem 14 Current token='d' perl='4' value='4' Tokenstr |i(\a,(d,d,d,d,d| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4
Lexem 15 Current token=')' perl=']' value=']' Tokenstr |i(\a,(d,d,d,d,d)| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4 ]
Lexem 16 Current token=')' perl=')' value=')' Tokenstr |i(\a,(d,d,d,d,d))| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4 ] )

Line:   70 TokenStr: =|i(\a,(d,d,d,d,d))|= @ValPy: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4 ] )
Generated partial line aeqi
Generated partial line aeqi([
expression(2, 15, -1) =|i(\a,(d,d,d,d,d))|= aeqi ( \ @arr , [ 0 , 1 , 2 , 3 , 4 ] )

Generated partial line aeqi([
Generated partial line aeqi([arr
Generated partial line aeqi([arr,
Generated partial line aeqi([arr,[
expression(6, 14, 0) =|i(\a,(d,d,d,d,d))|= aeqi ( \ @arr , [ 0 , 1 , 2 , 3 , 4 ] )

Generated partial line aeqi([arr,[0
Generated partial line aeqi([arr,[0,
Generated partial line aeqi([arr,[0,1
Generated partial line aeqi([arr,[0,1,
Generated partial line aeqi([arr,[0,1,2
Generated partial line aeqi([arr,[0,1,2,
Generated partial line aeqi([arr,[0,1,2,3
Generated partial line aeqi([arr,[0,1,2,3,
Generated partial line aeqi([arr,[0,1,2,3,4
expression returns 15
Generated partial line aeqi([arr,[0,1,2,3,4]
expression returns 16
Generated partial line aeqi([arr,[0,1,2,3,4]])
  71 | 0 |   |
  72 | 0 |   |aeqi([arr, [0, 1, 2, 3, 4]])                                                            #PL: @arr = ();

Tokens: i(\a,(d,d,d,d,d)) ValPy: 
Main loop, line=@arr = ();


 === Line 72 Perl source:@arr = ();===

Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )

Line:   72 TokenStr: =|a=()|= @ValPy: arr = ( )
Generated partial line arr = [
Generated partial line arr = []
  73 | 0 |   |arr = []                                                                                #PL: for ( 0 .. 4 ) {

Tokens: a=() ValPy: 
Main loop, line=for ( 0 .. 4 ) {


 === Line 73 Perl source:for ( 0 .. 4 ) {===

Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='d' perl='0' value='0' Tokenstr |c(d| translated: for  ( 0
Lexem 3 Current token='r' perl='..' value='..' Tokenstr |c(dr| translated: for  ( 0 ..
Lexem 4 Current token='d' perl='4' value='4' Tokenstr |c(drd| translated: for  ( 0 .. 4
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(drd)| translated: for  ( 0 .. 4 )

Line:   73 TokenStr: =|c(drd)|= @ValPy: for  ( 0 .. 4 )
control(0) =|c(drd)|= for ( 0 .. 4 )

control-parens removed, begin=0 start=1 =|cdrd|= for 0 .. 4

Generated partial line for 
Generated partial line for _d in 
Generated partial line for _d in range(
expression(1, 1, 0) =|cdrd|= for 0 .. 4

Generated partial line for _d in range(0
expression returns 2
Generated partial line for _d in range(0,
expression(3, 3, 0) =|cdrd|= for 0 .. 4

Generated partial line for _d in range(0,4
expression returns 4
Generated partial line for _d in range(0,4+1)
Generated partial line for _d in range(0,4+1):
  73 | 0 |   |for _d in range(0, 4+1):                                                                #PL: 

Tokens: cdrd ValPy: 
Main loop, line={


 === Line 73 Perl source:{===


Line:   73 TokenStr: =|{|= @ValPy: {
Main loop, line=push @arr, $_;


 === Line 74 Perl source:push @arr, $_;===

Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$_' value='_d' Tokenstr |fa,s| translated: .extend( arr , _d

Line:   74 TokenStr: =|fa,s|= @ValPy: .extend( arr , _d
function(0, 3) =|fa,s|= push @arr , $_

function start=1, end_pos=3, bracketed=0
push s

expression(1, 1, 0) =|fa,s|= push @arr , $_

Generated partial line arr
expression returns 2
Generated partial line arr.append(
expression(3, 3, 0) =|fa,s|= push @arr , $_

Generated partial line arr.append(_d
expression returns 4
Generated partial line arr.append(_d)
  75 | 1 |   |    arr.append(_d)                                                                      #PL: 

Tokens: fa,s ValPy: 
Main loop, line=}


 === Line 75 Perl source:}===


Line:   75 TokenStr: =|}|= @ValPy: }
  75 | 1 |   |
Main loop, line=aeqi(\@arr, [0,1,2,3,4]);


 === Line 76 Perl source:aeqi(\@arr, [0,1,2,3,4]);===

Lexem 0 Current token='i' perl='aeqi' value='aeqi' Tokenstr |i| translated: aeqi
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeqi (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeqi ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeqi (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeqi (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeqi (  arr , [
Lexem 6 Current token='d' perl='0' value='0' Tokenstr |i(\a,(d| translated: aeqi (  arr , [ 0
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,| translated: aeqi (  arr , [ 0 ,
Lexem 8 Current token='d' perl='1' value='1' Tokenstr |i(\a,(d,d| translated: aeqi (  arr , [ 0 , 1
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,| translated: aeqi (  arr , [ 0 , 1 ,
Lexem 10 Current token='d' perl='2' value='2' Tokenstr |i(\a,(d,d,d| translated: aeqi (  arr , [ 0 , 1 , 2
Lexem 11 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,d,| translated: aeqi (  arr , [ 0 , 1 , 2 ,
Lexem 12 Current token='d' perl='3' value='3' Tokenstr |i(\a,(d,d,d,d| translated: aeqi (  arr , [ 0 , 1 , 2 , 3
Lexem 13 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,d,d,| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 ,
Lexem 14 Current token='d' perl='4' value='4' Tokenstr |i(\a,(d,d,d,d,d| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4
Lexem 15 Current token=')' perl=']' value=']' Tokenstr |i(\a,(d,d,d,d,d)| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4 ]
Lexem 16 Current token=')' perl=')' value=')' Tokenstr |i(\a,(d,d,d,d,d))| translated: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4 ] )

Line:   76 TokenStr: =|i(\a,(d,d,d,d,d))|= @ValPy: aeqi (  arr , [ 0 , 1 , 2 , 3 , 4 ] )
Generated partial line aeqi
Generated partial line aeqi([
expression(2, 15, -1) =|i(\a,(d,d,d,d,d))|= aeqi ( \ @arr , [ 0 , 1 , 2 , 3 , 4 ] )

Generated partial line aeqi([
Generated partial line aeqi([arr
Generated partial line aeqi([arr,
Generated partial line aeqi([arr,[
expression(6, 14, 0) =|i(\a,(d,d,d,d,d))|= aeqi ( \ @arr , [ 0 , 1 , 2 , 3 , 4 ] )

Generated partial line aeqi([arr,[0
Generated partial line aeqi([arr,[0,
Generated partial line aeqi([arr,[0,1
Generated partial line aeqi([arr,[0,1,
Generated partial line aeqi([arr,[0,1,2
Generated partial line aeqi([arr,[0,1,2,
Generated partial line aeqi([arr,[0,1,2,3
Generated partial line aeqi([arr,[0,1,2,3,
Generated partial line aeqi([arr,[0,1,2,3,4
expression returns 15
Generated partial line aeqi([arr,[0,1,2,3,4]
expression returns 16
Generated partial line aeqi([arr,[0,1,2,3,4]])
  77 | 0 |   |
  78 | 0 |   |aeqi([arr, [0, 1, 2, 3, 4]])                                                            #PL: @arr = ();

Tokens: i(\a,(d,d,d,d,d)) ValPy: 
Main loop, line=@arr = ();


 === Line 78 Perl source:@arr = ();===

Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )

Line:   78 TokenStr: =|a=()|= @ValPy: arr = ( )
Generated partial line arr = [
Generated partial line arr = []
  79 | 0 |   |arr = []                                                                                #PL: foreach $i ( 2, 4, 16, 64 ) {

Tokens: a=() ValPy: 
Main loop, line=foreach $i ( 2, 4, 16, 64 ) {


 === Line 79 Perl source:foreach $i ( 2, 4, 16, 64 ) {===

Lexem 0 Current token='c' perl='foreach' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='s' perl='$i' value='i' Tokenstr |cs| translated: for  i
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |cs(| translated: for  i (
Lexem 3 Current token='d' perl='2' value='2' Tokenstr |cs(d| translated: for  i ( 2
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |cs(d,| translated: for  i ( 2 ,
Lexem 5 Current token='d' perl='4' value='4' Tokenstr |cs(d,d| translated: for  i ( 2 , 4
Lexem 6 Current token=',' perl=',' value=',' Tokenstr |cs(d,d,| translated: for  i ( 2 , 4 ,
Lexem 7 Current token='d' perl='16' value='16' Tokenstr |cs(d,d,d| translated: for  i ( 2 , 4 , 16
Lexem 8 Current token=',' perl=',' value=',' Tokenstr |cs(d,d,d,| translated: for  i ( 2 , 4 , 16 ,
Lexem 9 Current token='d' perl='64' value='64' Tokenstr |cs(d,d,d,d| translated: for  i ( 2 , 4 , 16 , 64
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |cs(d,d,d,d)| translated: for  i ( 2 , 4 , 16 , 64 )

Line:   79 TokenStr: =|cs(d,d,d,d)|= @ValPy: for  i ( 2 , 4 , 16 , 64 )
control(0) =|cs(d,d,d,d)|= foreach $i ( 2 , 4 , 16 , 64 )

Generated partial line for 
Generated partial line for i in 
Generated partial line for i in [2,4,16,64]
Generated partial line for i in [2,4,16,64]:
  79 | 0 |   |for i in [2,4,16,64]:                                                                   #PL: 

Tokens: cs(d,d,d,d) ValPy: 
Main loop, line={


 === Line 79 Perl source:{===


Line:   79 TokenStr: =|{|= @ValPy: {
Main loop, line=push @arr, $i;


 === Line 80 Perl source:push @arr, $i;===

Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$i' value='i' Tokenstr |fa,s| translated: .extend( arr , i

Line:   80 TokenStr: =|fa,s|= @ValPy: .extend( arr , i
function(0, 3) =|fa,s|= push @arr , $i

function start=1, end_pos=3, bracketed=0
push s

expression(1, 1, 0) =|fa,s|= push @arr , $i

Generated partial line arr
expression returns 2
Generated partial line arr.append(
expression(3, 3, 0) =|fa,s|= push @arr , $i

Generated partial line arr.append(i
expression returns 4
Generated partial line arr.append(i)
  81 | 1 |   |    arr.append(i)                                                                       #PL: 

Tokens: fa,s ValPy: 
Main loop, line=}


 === Line 81 Perl source:}===


Line:   81 TokenStr: =|}|= @ValPy: }
  81 | 1 |   |
Main loop, line=aeqi(\@arr, [2,4,16,64]);


 === Line 82 Perl source:aeqi(\@arr, [2,4,16,64]);===

Lexem 0 Current token='i' perl='aeqi' value='aeqi' Tokenstr |i| translated: aeqi
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeqi (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeqi ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeqi (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeqi (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeqi (  arr , [
Lexem 6 Current token='d' perl='2' value='2' Tokenstr |i(\a,(d| translated: aeqi (  arr , [ 2
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,| translated: aeqi (  arr , [ 2 ,
Lexem 8 Current token='d' perl='4' value='4' Tokenstr |i(\a,(d,d| translated: aeqi (  arr , [ 2 , 4
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,| translated: aeqi (  arr , [ 2 , 4 ,
Lexem 10 Current token='d' perl='16' value='16' Tokenstr |i(\a,(d,d,d| translated: aeqi (  arr , [ 2 , 4 , 16
Lexem 11 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,d,| translated: aeqi (  arr , [ 2 , 4 , 16 ,
Lexem 12 Current token='d' perl='64' value='64' Tokenstr |i(\a,(d,d,d,d| translated: aeqi (  arr , [ 2 , 4 , 16 , 64
Lexem 13 Current token=')' perl=']' value=']' Tokenstr |i(\a,(d,d,d,d)| translated: aeqi (  arr , [ 2 , 4 , 16 , 64 ]
Lexem 14 Current token=')' perl=')' value=')' Tokenstr |i(\a,(d,d,d,d))| translated: aeqi (  arr , [ 2 , 4 , 16 , 64 ] )

Line:   82 TokenStr: =|i(\a,(d,d,d,d))|= @ValPy: aeqi (  arr , [ 2 , 4 , 16 , 64 ] )
Generated partial line aeqi
Generated partial line aeqi([
expression(2, 13, -1) =|i(\a,(d,d,d,d))|= aeqi ( \ @arr , [ 2 , 4 , 16 , 64 ] )

Generated partial line aeqi([
Generated partial line aeqi([arr
Generated partial line aeqi([arr,
Generated partial line aeqi([arr,[
expression(6, 12, 0) =|i(\a,(d,d,d,d))|= aeqi ( \ @arr , [ 2 , 4 , 16 , 64 ] )

Generated partial line aeqi([arr,[2
Generated partial line aeqi([arr,[2,
Generated partial line aeqi([arr,[2,4
Generated partial line aeqi([arr,[2,4,
Generated partial line aeqi([arr,[2,4,16
Generated partial line aeqi([arr,[2,4,16,
Generated partial line aeqi([arr,[2,4,16,64
expression returns 13
Generated partial line aeqi([arr,[2,4,16,64]
expression returns 14
Generated partial line aeqi([arr,[2,4,16,64]])
  83 | 0 |   |
  84 | 0 |   |aeqi([arr, [2, 4, 16, 64]])                                                             #PL: @arr = ();

Tokens: i(\a,(d,d,d,d)) ValPy: 
Main loop, line=@arr = ();


 === Line 84 Perl source:@arr = ();===

Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )

Line:   84 TokenStr: =|a=()|= @ValPy: arr = ( )
Generated partial line arr = [
Generated partial line arr = []
  85 | 0 |   |arr = []                                                                                #PL: for my $j ( 2, 4, 16 ) {

Tokens: a=() ValPy: 
Main loop, line=for my $j ( 2, 4, 16 ) {


 === Line 85 Perl source:for my $j ( 2, 4, 16 ) {===

Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='s' perl='$j' value='j' Tokenstr |cs| translated: for  j
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |cs(| translated: for  j (
Lexem 3 Current token='d' perl='2' value='2' Tokenstr |cs(d| translated: for  j ( 2
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |cs(d,| translated: for  j ( 2 ,
Lexem 5 Current token='d' perl='4' value='4' Tokenstr |cs(d,d| translated: for  j ( 2 , 4
Lexem 6 Current token=',' perl=',' value=',' Tokenstr |cs(d,d,| translated: for  j ( 2 , 4 ,
Lexem 7 Current token='d' perl='16' value='16' Tokenstr |cs(d,d,d| translated: for  j ( 2 , 4 , 16
Lexem 8 Current token=')' perl=')' value=')' Tokenstr |cs(d,d,d)| translated: for  j ( 2 , 4 , 16 )

Line:   85 TokenStr: =|cs(d,d,d)|= @ValPy: for  j ( 2 , 4 , 16 )
control(0) =|cs(d,d,d)|= for $j ( 2 , 4 , 16 )

Generated partial line for 
Generated partial line for j in 
Generated partial line for j in [2,4,16]
Generated partial line for j in [2,4,16]:
  85 | 0 |   |for j in [2,4,16]:                                                                      #PL: 

Tokens: cs(d,d,d) ValPy: 
Main loop, line={


 === Line 85 Perl source:{===


Line:   85 TokenStr: =|{|= @ValPy: {
Main loop, line=push @arr, $j;


 === Line 86 Perl source:push @arr, $j;===

Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$j' value='j' Tokenstr |fa,s| translated: .extend( arr , j

Line:   86 TokenStr: =|fa,s|= @ValPy: .extend( arr , j
function(0, 3) =|fa,s|= push @arr , $j

function start=1, end_pos=3, bracketed=0
push s

expression(1, 1, 0) =|fa,s|= push @arr , $j

Generated partial line arr
expression returns 2
Generated partial line arr.append(
expression(3, 3, 0) =|fa,s|= push @arr , $j

Generated partial line arr.append(j
expression returns 4
Generated partial line arr.append(j)
  87 | 1 |   |    arr.append(j)                                                                       #PL: 

Tokens: fa,s ValPy: 
Main loop, line=}


 === Line 87 Perl source:}===


Line:   87 TokenStr: =|}|= @ValPy: }
  87 | 1 |   |
Main loop, line=aeqi(\@arr, [2,4,16]);


 === Line 88 Perl source:aeqi(\@arr, [2,4,16]);===

Lexem 0 Current token='i' perl='aeqi' value='aeqi' Tokenstr |i| translated: aeqi
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeqi (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeqi ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeqi (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeqi (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeqi (  arr , [
Lexem 6 Current token='d' perl='2' value='2' Tokenstr |i(\a,(d| translated: aeqi (  arr , [ 2
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,| translated: aeqi (  arr , [ 2 ,
Lexem 8 Current token='d' perl='4' value='4' Tokenstr |i(\a,(d,d| translated: aeqi (  arr , [ 2 , 4
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,| translated: aeqi (  arr , [ 2 , 4 ,
Lexem 10 Current token='d' perl='16' value='16' Tokenstr |i(\a,(d,d,d| translated: aeqi (  arr , [ 2 , 4 , 16
Lexem 11 Current token=')' perl=']' value=']' Tokenstr |i(\a,(d,d,d)| translated: aeqi (  arr , [ 2 , 4 , 16 ]
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |i(\a,(d,d,d))| translated: aeqi (  arr , [ 2 , 4 , 16 ] )

Line:   88 TokenStr: =|i(\a,(d,d,d))|= @ValPy: aeqi (  arr , [ 2 , 4 , 16 ] )
Generated partial line aeqi
Generated partial line aeqi([
expression(2, 11, -1) =|i(\a,(d,d,d))|= aeqi ( \ @arr , [ 2 , 4 , 16 ] )

Generated partial line aeqi([
Generated partial line aeqi([arr
Generated partial line aeqi([arr,
Generated partial line aeqi([arr,[
expression(6, 10, 0) =|i(\a,(d,d,d))|= aeqi ( \ @arr , [ 2 , 4 , 16 ] )

Generated partial line aeqi([arr,[2
Generated partial line aeqi([arr,[2,
Generated partial line aeqi([arr,[2,4
Generated partial line aeqi([arr,[2,4,
Generated partial line aeqi([arr,[2,4,16
expression returns 11
Generated partial line aeqi([arr,[2,4,16]
expression returns 12
Generated partial line aeqi([arr,[2,4,16]])
  89 | 0 |   |
  90 | 0 |   |aeqi([arr, [2, 4, 16]])                                                                 #PL: @arr = ();

Tokens: i(\a,(d,d,d)) ValPy: 
Main loop, line=@arr = ();


 === Line 90 Perl source:@arr = ();===

Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )

Line:   90 TokenStr: =|a=()|= @ValPy: arr = ( )
Generated partial line arr = [
Generated partial line arr = []
  91 | 0 |   |arr = []                                                                                #PL: for ( 3, 6, 9 ) {

Tokens: a=() ValPy: 
Main loop, line=for ( 3, 6, 9 ) {


 === Line 91 Perl source:for ( 3, 6, 9 ) {===

Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='d' perl='3' value='3' Tokenstr |c(d| translated: for  ( 3
Lexem 3 Current token=',' perl=',' value=',' Tokenstr |c(d,| translated: for  ( 3 ,
Lexem 4 Current token='d' perl='6' value='6' Tokenstr |c(d,d| translated: for  ( 3 , 6
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |c(d,d,| translated: for  ( 3 , 6 ,
Lexem 6 Current token='d' perl='9' value='9' Tokenstr |c(d,d,d| translated: for  ( 3 , 6 , 9
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |c(d,d,d)| translated: for  ( 3 , 6 , 9 )

Line:   91 TokenStr: =|c(d,d,d)|= @ValPy: for  ( 3 , 6 , 9 )
control(0) =|c(d,d,d)|= for ( 3 , 6 , 9 )

control-parens removed, begin=0 start=1 =|cd,d,d|= for 3 , 6 , 9

Generated partial line for 
Generated partial line for _d in 
Generated partial line for _d in (
expression(1, 5, 0) =|cd,d,d|= for 3 , 6 , 9

Generated partial line for _d in (3
Generated partial line for _d in (3,
Generated partial line for _d in (3,6
Generated partial line for _d in (3,6,
Generated partial line for _d in (3,6,9
expression returns 6
Generated partial line for _d in (3,6,9)
Generated partial line for _d in (3,6,9):
  91 | 0 |   |for _d in (3, 6, 9):                                                                    #PL: 

Tokens: cd,d,d ValPy: 
Main loop, line={


 === Line 91 Perl source:{===


Line:   91 TokenStr: =|{|= @ValPy: {
Main loop, line=push @arr, $_;


 === Line 92 Perl source:push @arr, $_;===

Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$_' value='_d' Tokenstr |fa,s| translated: .extend( arr , _d

Line:   92 TokenStr: =|fa,s|= @ValPy: .extend( arr , _d
function(0, 3) =|fa,s|= push @arr , $_

function start=1, end_pos=3, bracketed=0
push s

expression(1, 1, 0) =|fa,s|= push @arr , $_

Generated partial line arr
expression returns 2
Generated partial line arr.append(
expression(3, 3, 0) =|fa,s|= push @arr , $_

Generated partial line arr.append(_d
expression returns 4
Generated partial line arr.append(_d)
  93 | 1 |   |    arr.append(_d)                                                                      #PL: 

Tokens: fa,s ValPy: 
Main loop, line=}


 === Line 93 Perl source:}===


Line:   93 TokenStr: =|}|= @ValPy: }
  93 | 1 |   |
Main loop, line=aeqi(\@arr, [3,6,9]);


 === Line 94 Perl source:aeqi(\@arr, [3,6,9]);===

Lexem 0 Current token='i' perl='aeqi' value='aeqi' Tokenstr |i| translated: aeqi
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeqi (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeqi ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeqi (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeqi (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeqi (  arr , [
Lexem 6 Current token='d' perl='3' value='3' Tokenstr |i(\a,(d| translated: aeqi (  arr , [ 3
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,| translated: aeqi (  arr , [ 3 ,
Lexem 8 Current token='d' perl='6' value='6' Tokenstr |i(\a,(d,d| translated: aeqi (  arr , [ 3 , 6
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(d,d,| translated: aeqi (  arr , [ 3 , 6 ,
Lexem 10 Current token='d' perl='9' value='9' Tokenstr |i(\a,(d,d,d| translated: aeqi (  arr , [ 3 , 6 , 9
Lexem 11 Current token=')' perl=']' value=']' Tokenstr |i(\a,(d,d,d)| translated: aeqi (  arr , [ 3 , 6 , 9 ]
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |i(\a,(d,d,d))| translated: aeqi (  arr , [ 3 , 6 , 9 ] )

Line:   94 TokenStr: =|i(\a,(d,d,d))|= @ValPy: aeqi (  arr , [ 3 , 6 , 9 ] )
Generated partial line aeqi
Generated partial line aeqi([
expression(2, 11, -1) =|i(\a,(d,d,d))|= aeqi ( \ @arr , [ 3 , 6 , 9 ] )

Generated partial line aeqi([
Generated partial line aeqi([arr
Generated partial line aeqi([arr,
Generated partial line aeqi([arr,[
expression(6, 10, 0) =|i(\a,(d,d,d))|= aeqi ( \ @arr , [ 3 , 6 , 9 ] )

Generated partial line aeqi([arr,[3
Generated partial line aeqi([arr,[3,
Generated partial line aeqi([arr,[3,6
Generated partial line aeqi([arr,[3,6,
Generated partial line aeqi([arr,[3,6,9
expression returns 11
Generated partial line aeqi([arr,[3,6,9]
expression returns 12
Generated partial line aeqi([arr,[3,6,9]])
  95 | 0 |   |
  96 | 0 |   |aeqi([arr, [3, 6, 9]])                                                                  #PL: sub myFunc{

Tokens: i(\a,(d,d,d)) ValPy: 
Main loop, line=sub myFunc{


 === Line 96 Perl source:sub myFunc{===

Lexem 0 Current token='k' perl='sub' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' perl='myFunc' value='myFunc' Tokenstr |ki| translated: def myFunc

Line:   96 TokenStr: =|ki|= @ValPy: def myFunc
Generated partial line defmyFunc(_args):
  96 | 0 |   |def myFunc(_args):                                                                      #PL: 

Tokens: ki ValPy: 
Main loop, line={


 === Line 96 Perl source:{===


Line:   96 TokenStr: =|{|= @ValPy: {
Main loop, line=my @result = ('a', 'c', 'b');


 === Line 97 Perl source:my @result = ('a', 'c', 'b');===

Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@result' value='result' Tokenstr |ta| translated:  result
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  result =
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |ta=(| translated:  result = (
Lexem 4 Current token='"' perl='a' value=''a'' Tokenstr |ta=("| translated:  result = ( 'a'
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |ta=(",| translated:  result = ( 'a' ,
Lexem 6 Current token='"' perl='c' value=''c'' Tokenstr |ta=(","| translated:  result = ( 'a' , 'c'
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |ta=(",",| translated:  result = ( 'a' , 'c' ,
Lexem 8 Current token='"' perl='b' value=''b'' Tokenstr |ta=(",","| translated:  result = ( 'a' , 'c' , 'b'
Lexem 9 Current token=')' perl=')' value=')' Tokenstr |ta=(",",")| translated:  result = ( 'a' , 'c' , 'b' )

Line:   97 TokenStr: =|ta=(",",")|= @ValPy:  result = ( 'a' , 'c' , 'b' )
Generated partial line result = [
Generated partial line result = ['a'
Generated partial line result = ['a',
Generated partial line result = ['a','c'
Generated partial line result = ['a','c',
Generated partial line result = ['a','c','b'
Generated partial line result = ['a','c','b']
  98 | 1 |   |    result = ['a', 'c', 'b']                                                            #PL: return \@result;

Tokens: a=(",",") ValPy: 
Main loop, line=return \@result;


 === Line 98 Perl source:return \@result;===

Lexem 0 Current token='k' perl='return' value='return' Tokenstr |k| translated: return
Lexem 1 Current token='\' perl='\' value='' Tokenstr |k\| translated: return 
Lexem 2 Current token='a' perl='@result' value='result' Tokenstr |k\a| translated: return  result

Line:   98 TokenStr: =|k\a|= @ValPy: return  result
Generated partial line return
expression(1, 2, 0) =|k\a|= return \ @result

Generated partial line return
Generated partial line returnresult
expression returns 3
  99 | 1 |   |    return result                                                                       #PL: 

Tokens: k\a ValPy: 
Main loop, line=}


 === Line 99 Perl source:}===


Line:   99 TokenStr: =|}|= @ValPy: }
initialize_globals_for_state_vars: 
  99 | 0 |   |
 100 | 0 |   |
Main loop, line=@arr = ();


 === Line 101 Perl source:@arr = ();===

Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )

Line:  101 TokenStr: =|a=()|= @ValPy: arr = ( )
Generated partial line arr = [
Generated partial line arr = []
 102 | 0 |   |arr = []                                                                                #PL: for ( @{myFunc()} ) {

Tokens: a=() ValPy: 
Main loop, line=for ( @{myFunc()} ) {


 === Line 102 Perl source:for ( @{myFunc()} ) {===

Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='@' perl='@' value='@' Tokenstr |c(@| translated: for  ( @
Lexem 3 Current token='(' perl='{' value='[' Tokenstr |c(@(| translated: for  ( @ [
Lexem 4 Current token='i' perl='myFunc' value='myFunc' Tokenstr |c(@(i| translated: for  ( @ [ myFunc
Lexem 5 Current token='(' perl='(' value='(' Tokenstr |c(@(i(| translated: for  ( @ [ myFunc (
Lexem 6 Current token=')' perl=')' value=')' Tokenstr |c(@(i()| translated: for  ( @ [ myFunc ( )
Lexem 7 Current token=')' perl='}' value=']' Tokenstr |c(@(i())| translated: for  ( @ [ myFunc ( ) ]
Lexem 8 Current token=')' perl=')' value=')' Tokenstr |c(@(i()))| translated: for  ( @ [ myFunc ( ) ] )

Line:  102 TokenStr: =|c(@(i()))|= @ValPy: for  ( @ [ myFunc ( ) ] )
control(0) =|c(i())|= for ( myFunc ( ) )

control-parens removed, begin=0 start=1 =|ci()|= for myFunc ( )

Generated partial line for 
Generated partial line for _d in 
Generated partial line for _d in (
expression(1, 3, 0) =|ci()|= for myFunc ( )

Generated partial line for _d in (myFunc
Generated partial line for _d in (myFunc([
Generated partial line for _d in (myFunc([])
expression returns 4
Generated partial line for _d in (myFunc([]))
Generated partial line for _d in (myFunc([])):
 102 | 0 |   |for _d in (myFunc([])):                                                                 #PL: 

Tokens: ci() ValPy: 
Main loop, line={


 === Line 102 Perl source:{===


Line:  102 TokenStr: =|{|= @ValPy: {
Main loop, line=push @arr, $_;


 === Line 103 Perl source:push @arr, $_;===

Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$_' value='_d' Tokenstr |fa,s| translated: .extend( arr , _d

Line:  103 TokenStr: =|fa,s|= @ValPy: .extend( arr , _d
function(0, 3) =|fa,s|= push @arr , $_

function start=1, end_pos=3, bracketed=0
push s

expression(1, 1, 0) =|fa,s|= push @arr , $_

Generated partial line arr
expression returns 2
Generated partial line arr.append(
expression(3, 3, 0) =|fa,s|= push @arr , $_

Generated partial line arr.append(_d
expression returns 4
Generated partial line arr.append(_d)
 104 | 1 |   |    arr.append(_d)                                                                      #PL: 

Tokens: fa,s ValPy: 
Main loop, line=}


 === Line 104 Perl source:}===


Line:  104 TokenStr: =|}|= @ValPy: }
initialize_globals_for_state_vars: 
 104 | 0 |   |
Main loop, line=aeq(\@arr, ['a','c','b']);


 === Line 105 Perl source:aeq(\@arr, ['a','c','b']);===

Lexem 0 Current token='i' perl='aeq' value='aeq' Tokenstr |i| translated: aeq
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeq (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeq ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeq (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeq (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeq (  arr , [
Lexem 6 Current token='"' perl='a' value=''a'' Tokenstr |i(\a,("| translated: aeq (  arr , [ 'a'
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",| translated: aeq (  arr , [ 'a' ,
Lexem 8 Current token='"' perl='c' value=''c'' Tokenstr |i(\a,(","| translated: aeq (  arr , [ 'a' , 'c'
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",",| translated: aeq (  arr , [ 'a' , 'c' ,
Lexem 10 Current token='"' perl='b' value=''b'' Tokenstr |i(\a,(",","| translated: aeq (  arr , [ 'a' , 'c' , 'b'
Lexem 11 Current token=')' perl=']' value=']' Tokenstr |i(\a,(",",")| translated: aeq (  arr , [ 'a' , 'c' , 'b' ]
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |i(\a,(",","))| translated: aeq (  arr , [ 'a' , 'c' , 'b' ] )

Line:  105 TokenStr: =|i(\a,(",","))|= @ValPy: aeq (  arr , [ 'a' , 'c' , 'b' ] )
Generated partial line aeq
Generated partial line aeq([
expression(2, 11, -1) =|i(\a,(",","))|= aeq ( \ @arr , [ a , c , b ] )

Generated partial line aeq([
Generated partial line aeq([arr
Generated partial line aeq([arr,
Generated partial line aeq([arr,[
expression(6, 10, 0) =|i(\a,(",","))|= aeq ( \ @arr , [ a , c , b ] )

Generated partial line aeq([arr,['a'
Generated partial line aeq([arr,['a',
Generated partial line aeq([arr,['a','c'
Generated partial line aeq([arr,['a','c',
Generated partial line aeq([arr,['a','c','b'
expression returns 11
Generated partial line aeq([arr,['a','c','b']
expression returns 12
Generated partial line aeq([arr,['a','c','b']])
 106 | 0 |   |
 107 | 0 |   |aeq([arr, ['a', 'c', 'b']])                                                             #PL: @arr = ();

Tokens: i(\a,(",",")) ValPy: 
Main loop, line=@arr = ();


 === Line 107 Perl source:@arr = ();===

Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )

Line:  107 TokenStr: =|a=()|= @ValPy: arr = ( )
Generated partial line arr = [
Generated partial line arr = []
 108 | 0 |   |arr = []                                                                                #PL: for ( sort @{myFunc()} ) {

Tokens: a=() ValPy: 
Main loop, line=for ( sort @{myFunc()} ) {


 === Line 108 Perl source:for ( sort @{myFunc()} ) {===

Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='f' perl='sort' value='sorted' Tokenstr |c(f| translated: for  ( sorted
Lexem 3 Current token='@' perl='@' value='@' Tokenstr |c(f@| translated: for  ( sorted @
Lexem 4 Current token='(' perl='{' value='[' Tokenstr |c(f@(| translated: for  ( sorted @ [
Lexem 5 Current token='i' perl='myFunc' value='myFunc' Tokenstr |c(f@(i| translated: for  ( sorted @ [ myFunc
Lexem 6 Current token='(' perl='(' value='(' Tokenstr |c(f@(i(| translated: for  ( sorted @ [ myFunc (
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |c(f@(i()| translated: for  ( sorted @ [ myFunc ( )
Lexem 8 Current token=')' perl='}' value=']' Tokenstr |c(f@(i())| translated: for  ( sorted @ [ myFunc ( ) ]
Lexem 9 Current token=')' perl=')' value=')' Tokenstr |c(f@(i()))| translated: for  ( sorted @ [ myFunc ( ) ] )

Line:  108 TokenStr: =|c(f@(i()))|= @ValPy: for  ( sorted @ [ myFunc ( ) ] )
control(0) =|c(fi())|= for ( sort myFunc ( ) )

control-parens removed, begin=0 start=1 =|cfi()|= for sort myFunc ( )

Generated partial line for 
Generated partial line for _d in 
expression(2, 5, 0) =|c(fi()|= for ( sort myFunc ( )

function(2, 5) =|c(fi()|= for ( sort myFunc ( )

function start=3, end_pos=5, bracketed=0
Generated partial line for _d in sorted
Generated partial line for _d in sorted(
expression(3, 5, 0) =|c(fi()|= for ( sort myFunc ( )

Generated partial line for _d in sorted(myFunc
Generated partial line for _d in sorted(myFunc([
Generated partial line for _d in sorted(myFunc([])
expression returns 6
Generated partial line for _d in sorted(myFunc([]))
expression returns 6
Generated partial line for _d in sorted(myFunc([])):
 108 | 0 |   |for _d in sorted(myFunc([])):                                                           #PL: 

Tokens: c(fi() ValPy: 
Main loop, line={


 === Line 108 Perl source:{===


Line:  108 TokenStr: =|{|= @ValPy: {
Main loop, line=push @arr, $_;


 === Line 109 Perl source:push @arr, $_;===

Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$_' value='_d' Tokenstr |fa,s| translated: .extend( arr , _d

Line:  109 TokenStr: =|fa,s|= @ValPy: .extend( arr , _d
function(0, 3) =|fa,s|= push @arr , $_

function start=1, end_pos=3, bracketed=0
push s

expression(1, 1, 0) =|fa,s|= push @arr , $_

Generated partial line arr
expression returns 2
Generated partial line arr.append(
expression(3, 3, 0) =|fa,s|= push @arr , $_

Generated partial line arr.append(_d
expression returns 4
Generated partial line arr.append(_d)
 110 | 1 |   |    arr.append(_d)                                                                      #PL: 

Tokens: fa,s ValPy: 
Main loop, line=}


 === Line 110 Perl source:}===


Line:  110 TokenStr: =|}|= @ValPy: }
initialize_globals_for_state_vars: 
 110 | 0 |   |
Main loop, line=aeq(\@arr, ['a','b','c']);


 === Line 111 Perl source:aeq(\@arr, ['a','b','c']);===

Lexem 0 Current token='i' perl='aeq' value='aeq' Tokenstr |i| translated: aeq
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeq (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeq ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeq (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeq (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeq (  arr , [
Lexem 6 Current token='"' perl='a' value=''a'' Tokenstr |i(\a,("| translated: aeq (  arr , [ 'a'
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",| translated: aeq (  arr , [ 'a' ,
Lexem 8 Current token='"' perl='b' value=''b'' Tokenstr |i(\a,(","| translated: aeq (  arr , [ 'a' , 'b'
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",",| translated: aeq (  arr , [ 'a' , 'b' ,
Lexem 10 Current token='"' perl='c' value=''c'' Tokenstr |i(\a,(",","| translated: aeq (  arr , [ 'a' , 'b' , 'c'
Lexem 11 Current token=')' perl=']' value=']' Tokenstr |i(\a,(",",")| translated: aeq (  arr , [ 'a' , 'b' , 'c' ]
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |i(\a,(",","))| translated: aeq (  arr , [ 'a' , 'b' , 'c' ] )

Line:  111 TokenStr: =|i(\a,(",","))|= @ValPy: aeq (  arr , [ 'a' , 'b' , 'c' ] )
Generated partial line aeq
Generated partial line aeq([
expression(2, 11, -1) =|i(\a,(",","))|= aeq ( \ @arr , [ a , b , c ] )

Generated partial line aeq([
Generated partial line aeq([arr
Generated partial line aeq([arr,
Generated partial line aeq([arr,[
expression(6, 10, 0) =|i(\a,(",","))|= aeq ( \ @arr , [ a , b , c ] )

Generated partial line aeq([arr,['a'
Generated partial line aeq([arr,['a',
Generated partial line aeq([arr,['a','b'
Generated partial line aeq([arr,['a','b',
Generated partial line aeq([arr,['a','b','c'
expression returns 11
Generated partial line aeq([arr,['a','b','c']
expression returns 12
Generated partial line aeq([arr,['a','b','c']])
 112 | 0 |   |
 113 | 0 |   |aeq([arr, ['a', 'b', 'c']])                                                             #PL: @arr = ();

Tokens: i(\a,(",",")) ValPy: 
Main loop, line=@arr = ();


 === Line 113 Perl source:@arr = ();===

Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )

Line:  113 TokenStr: =|a=()|= @ValPy: arr = ( )
Generated partial line arr = [
Generated partial line arr = []
 114 | 0 |   |arr = []                                                                                #PL: foreach $region (A, ABC, D, EF) {

Tokens: a=() ValPy: 
Main loop, line=foreach $region (A, ABC, D, EF) {


 === Line 114 Perl source:foreach $region (A, ABC, D, EF) {===

Lexem 0 Current token='c' perl='foreach' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='s' perl='$region' value='region' Tokenstr |cs| translated: for  region
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |cs(| translated: for  region (
Lexem 3 Current token='i' perl='A' value='A' Tokenstr |cs(i| translated: for  region ( A
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |cs(i,| translated: for  region ( A ,
Lexem 5 Current token='i' perl='ABC' value='ABC' Tokenstr |cs(i,i| translated: for  region ( A , ABC
Lexem 6 Current token=',' perl=',' value=',' Tokenstr |cs(i,i,| translated: for  region ( A , ABC ,
Lexem 7 Current token='i' perl='D' value='D' Tokenstr |cs(i,i,i| translated: for  region ( A , ABC , D
Lexem 8 Current token=',' perl=',' value=',' Tokenstr |cs(i,i,i,| translated: for  region ( A , ABC , D ,
Lexem 9 Current token='i' perl='EF' value='EF' Tokenstr |cs(i,i,i,i| translated: for  region ( A , ABC , D , EF
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |cs(i,i,i,i)| translated: for  region ( A , ABC , D , EF )

Line:  114 TokenStr: =|cs(i,i,i,i)|= @ValPy: for  region ( A , ABC , D , EF )
control(0) =|cs(i,i,i,i)|= foreach $region ( A , ABC , D , EF )

Generated partial line for 
Generated partial line for region in 
expression(2, 10, 0) =|cs(i,i,i,i)|= foreach $region ( A , ABC , D , EF )

Generated partial line for region in (
expression(3, 9, 0) =|cs(i,i,i,i)|= foreach $region ( A , ABC , D , EF )

Generated partial line for region in ('A'
Generated partial line for region in ('A',
Generated partial line for region in ('A','ABC'
Generated partial line for region in ('A','ABC',
Generated partial line for region in ('A','ABC','D'
Generated partial line for region in ('A','ABC','D',
Generated partial line for region in ('A','ABC','D','EF'
expression returns 10
Generated partial line for region in ('A','ABC','D','EF')
expression returns 11
Generated partial line for region in ('A','ABC','D','EF'):
 114 | 0 |   |for region in ('A', 'ABC', 'D', 'EF'):                                                  #PL: 

Tokens: cs(i,i,i,i) ValPy: 
Main loop, line={


 === Line 114 Perl source:{===


Line:  114 TokenStr: =|{|= @ValPy: {
Main loop, line=push @arr, $region;


 === Line 115 Perl source:push @arr, $region;===

Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$region' value='region' Tokenstr |fa,s| translated: .extend( arr , region

Line:  115 TokenStr: =|fa,s|= @ValPy: .extend( arr , region
function(0, 3) =|fa,s|= push @arr , $region

function start=1, end_pos=3, bracketed=0
push s

expression(1, 1, 0) =|fa,s|= push @arr , $region

Generated partial line arr
expression returns 2
Generated partial line arr.append(
expression(3, 3, 0) =|fa,s|= push @arr , $region

Generated partial line arr.append(region
expression returns 4
Generated partial line arr.append(region)
 116 | 1 |   |    arr.append(region)                                                                  #PL: 

Tokens: fa,s ValPy: 
Main loop, line=}


 === Line 116 Perl source:}===


Line:  116 TokenStr: =|}|= @ValPy: }
initialize_globals_for_state_vars: 
 116 | 0 |   |
Main loop, line=aeqi(\@arr, [A,ABC,D,EF]);


 === Line 117 Perl source:aeqi(\@arr, [A,ABC,D,EF]);===

Lexem 0 Current token='i' perl='aeqi' value='aeqi' Tokenstr |i| translated: aeqi
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeqi (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeqi ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeqi (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeqi (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeqi (  arr , [
Lexem 6 Current token='i' perl='A' value='A' Tokenstr |i(\a,(i| translated: aeqi (  arr , [ A
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(i,| translated: aeqi (  arr , [ A ,
Lexem 8 Current token='i' perl='ABC' value='ABC' Tokenstr |i(\a,(i,i| translated: aeqi (  arr , [ A , ABC
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(i,i,| translated: aeqi (  arr , [ A , ABC ,
Lexem 10 Current token='i' perl='D' value='D' Tokenstr |i(\a,(i,i,i| translated: aeqi (  arr , [ A , ABC , D
Lexem 11 Current token=',' perl=',' value=',' Tokenstr |i(\a,(i,i,i,| translated: aeqi (  arr , [ A , ABC , D ,
Lexem 12 Current token='i' perl='EF' value='EF' Tokenstr |i(\a,(i,i,i,i| translated: aeqi (  arr , [ A , ABC , D , EF
Lexem 13 Current token=')' perl=']' value=']' Tokenstr |i(\a,(i,i,i,i)| translated: aeqi (  arr , [ A , ABC , D , EF ]
Lexem 14 Current token=')' perl=')' value=')' Tokenstr |i(\a,(i,i,i,i))| translated: aeqi (  arr , [ A , ABC , D , EF ] )

Line:  117 TokenStr: =|i(\a,(i,i,i,i))|= @ValPy: aeqi (  arr , [ A , ABC , D , EF ] )
Generated partial line aeqi
Generated partial line aeqi([
expression(2, 13, -1) =|i(\a,(i,i,i,i))|= aeqi ( \ @arr , [ A , ABC , D , EF ] )

Generated partial line aeqi([
Generated partial line aeqi([arr
Generated partial line aeqi([arr,
Generated partial line aeqi([arr,[
expression(6, 12, 0) =|i(\a,(i,i,i,i))|= aeqi ( \ @arr , [ A , ABC , D , EF ] )

Generated partial line aeqi([arr,['A'
Generated partial line aeqi([arr,['A',
Generated partial line aeqi([arr,['A','ABC'
Generated partial line aeqi([arr,['A','ABC',
Generated partial line aeqi([arr,['A','ABC','D'
Generated partial line aeqi([arr,['A','ABC','D',
Generated partial line aeqi([arr,['A','ABC','D','EF'
expression returns 13
Generated partial line aeqi([arr,['A','ABC','D','EF']
expression returns 14
Generated partial line aeqi([arr,['A','ABC','D','EF']])
 118 | 0 |   |
 119 | 0 |   |aeqi([arr, ['A', 'ABC', 'D', 'EF']])                                                    #PL: @arr = ();

Tokens: i(\a,(i,i,i,i)) ValPy: 
Main loop, line=@arr = ();


 === Line 119 Perl source:@arr = ();===

Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )

Line:  119 TokenStr: =|a=()|= @ValPy: arr = ( )
Generated partial line arr = [
Generated partial line arr = []
 120 | 0 |   |arr = []                                                                                #PL: foreach $id (keys %tickets)

Tokens: a=() ValPy: 
Main loop, line=foreach $id (keys %tickets)


 === Line 120 Perl source:foreach $id (keys %tickets)===

Lexem 0 Current token='c' perl='foreach' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='s' perl='$id' value='id' Tokenstr |cs| translated: for  id
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |cs(| translated: for  id (
Lexem 3 Current token='f' perl='keys' value='.keys()' Tokenstr |cs(f| translated: for  id ( .keys()
Lexem 4 Current token='h' perl='tickets' value='tickets' Tokenstr |cs(fh| translated: for  id ( .keys() tickets
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |cs(fh)| translated: for  id ( .keys() tickets )

Line:  121 TokenStr: =|cs(fh)|= @ValPy: for  id ( .keys() tickets )
control(0) =|cs(fh)|= foreach $id ( keys tickets )

Generated partial line for 
Generated partial line for id in 
Generated partial line for id in tickets.keys()
Generated partial line for id in tickets.keys():
 121 | 0 |   |for id in tickets.keys():                                                               #PL: 

Tokens: cs(fh) ValPy: 
Main loop, line={


 === Line 121 Perl source:{===


Line:  121 TokenStr: =|{|= @ValPy: {
Main loop, line=push @arr, $id;


 === Line 122 Perl source:push @arr, $id;===

Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$id' value='id' Tokenstr |fa,s| translated: .extend( arr , id

Line:  122 TokenStr: =|fa,s|= @ValPy: .extend( arr , id
function(0, 3) =|fa,s|= push @arr , $id

function start=1, end_pos=3, bracketed=0
push s

expression(1, 1, 0) =|fa,s|= push @arr , $id

Generated partial line arr
expression returns 2
Generated partial line arr.append(
expression(3, 3, 0) =|fa,s|= push @arr , $id

Generated partial line arr.append(id
expression returns 4
Generated partial line arr.append(id)
 123 | 1 |   |    arr.append(id)                                                                      #PL: 

Tokens: fa,s ValPy: 
Main loop, line=}


 === Line 123 Perl source:}===


Line:  123 TokenStr: =|}|= @ValPy: }
initialize_globals_for_state_vars: 
 123 | 0 |   |
Main loop, line=aeq_unordered(\@arr, ['t1', 't2', 't3']);


 === Line 124 Perl source:aeq_unordered(\@arr, ['t1', 't2', 't3']);===

Lexem 0 Current token='i' perl='aeq_unordered' value='aeq_unordered' Tokenstr |i| translated: aeq_unordered
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeq_unordered (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeq_unordered ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeq_unordered (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeq_unordered (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeq_unordered (  arr , [
Lexem 6 Current token='"' perl='t1' value=''t1'' Tokenstr |i(\a,("| translated: aeq_unordered (  arr , [ 't1'
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",| translated: aeq_unordered (  arr , [ 't1' ,
Lexem 8 Current token='"' perl='t2' value=''t2'' Tokenstr |i(\a,(","| translated: aeq_unordered (  arr , [ 't1' , 't2'
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",",| translated: aeq_unordered (  arr , [ 't1' , 't2' ,
Lexem 10 Current token='"' perl='t3' value=''t3'' Tokenstr |i(\a,(",","| translated: aeq_unordered (  arr , [ 't1' , 't2' , 't3'
Lexem 11 Current token=')' perl=']' value=']' Tokenstr |i(\a,(",",")| translated: aeq_unordered (  arr , [ 't1' , 't2' , 't3' ]
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |i(\a,(",","))| translated: aeq_unordered (  arr , [ 't1' , 't2' , 't3' ] )

Line:  124 TokenStr: =|i(\a,(",","))|= @ValPy: aeq_unordered (  arr , [ 't1' , 't2' , 't3' ] )
Generated partial line aeq_unordered
Generated partial line aeq_unordered([
expression(2, 11, -1) =|i(\a,(",","))|= aeq_unordered ( \ @arr , [ t1 , t2 , t3 ] )

Generated partial line aeq_unordered([
Generated partial line aeq_unordered([arr
Generated partial line aeq_unordered([arr,
Generated partial line aeq_unordered([arr,[
expression(6, 10, 0) =|i(\a,(",","))|= aeq_unordered ( \ @arr , [ t1 , t2 , t3 ] )

Generated partial line aeq_unordered([arr,['t1'
Generated partial line aeq_unordered([arr,['t1',
Generated partial line aeq_unordered([arr,['t1','t2'
Generated partial line aeq_unordered([arr,['t1','t2',
Generated partial line aeq_unordered([arr,['t1','t2','t3'
expression returns 11
Generated partial line aeq_unordered([arr,['t1','t2','t3']
expression returns 12
Generated partial line aeq_unordered([arr,['t1','t2','t3']])
 125 | 0 |   |aeq_unordered([arr, ['t1', 't2', 't3']])                                                #PL: @arr = ();

Tokens: i(\a,(",",")) ValPy: 
Main loop, line=@arr = ();


 === Line 125 Perl source:@arr = ();===

Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )

Line:  125 TokenStr: =|a=()|= @ValPy: arr = ( )
Generated partial line arr = [
Generated partial line arr = []
 126 | 0 |   |
 127 | 0 |   |arr = []                                                                                #PL: foreach $id (%tickets)

Tokens: a=() ValPy: 
Main loop, line=foreach $id (%tickets)


 === Line 127 Perl source:foreach $id (%tickets)===

Lexem 0 Current token='c' perl='foreach' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='s' perl='$id' value='id' Tokenstr |cs| translated: for  id
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |cs(| translated: for  id (
Lexem 3 Current token='h' perl='tickets' value='tickets' Tokenstr |cs(h| translated: for  id ( tickets
Lexem 4 Current token=')' perl=')' value=')' Tokenstr |cs(h)| translated: for  id ( tickets )

Line:  128 TokenStr: =|cs(h)|= @ValPy: for  id ( tickets )
control(0) =|cs(h)|= foreach $id ( tickets )

Generated partial line for 
Generated partial line for id in 
Generated partial line for id in functools.reduce(lambda x,y:x+y,tickets.items())
Generated partial line for id in functools.reduce(lambda x,y:x+y,tickets.items()):
 128 | 0 |   |for id in functools.reduce(lambda x,y:x+y,tickets.items()):                             #PL: 

Tokens: cs(h) ValPy: 
Main loop, line={


 === Line 128 Perl source:{===


Line:  128 TokenStr: =|{|= @ValPy: {
Main loop, line=push @arr, $id;


 === Line 129 Perl source:push @arr, $id;===

Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$id' value='id' Tokenstr |fa,s| translated: .extend( arr , id

Line:  129 TokenStr: =|fa,s|= @ValPy: .extend( arr , id
function(0, 3) =|fa,s|= push @arr , $id

function start=1, end_pos=3, bracketed=0
push s

expression(1, 1, 0) =|fa,s|= push @arr , $id

Generated partial line arr
expression returns 2
Generated partial line arr.append(
expression(3, 3, 0) =|fa,s|= push @arr , $id

Generated partial line arr.append(id
expression returns 4
Generated partial line arr.append(id)
 130 | 1 |   |    arr.append(id)                                                                      #PL: 

Tokens: fa,s ValPy: 
Main loop, line=}


 === Line 130 Perl source:}===


Line:  130 TokenStr: =|}|= @ValPy: }
initialize_globals_for_state_vars: 
 130 | 0 |   |
Main loop, line=aeq_unordered(\@arr, \@tkts);


 === Line 131 Perl source:aeq_unordered(\@arr, \@tkts);===

Lexem 0 Current token='i' perl='aeq_unordered' value='aeq_unordered' Tokenstr |i| translated: aeq_unordered
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeq_unordered (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeq_unordered ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeq_unordered (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeq_unordered (  arr ,
Lexem 5 Current token='\' perl='\' value='' Tokenstr |i(\a,\| translated: aeq_unordered (  arr , 
Lexem 6 Current token='a' perl='@tkts' value='tkts' Tokenstr |i(\a,\a| translated: aeq_unordered (  arr ,  tkts
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |i(\a,\a)| translated: aeq_unordered (  arr ,  tkts )

Line:  131 TokenStr: =|i(\a,\a)|= @ValPy: aeq_unordered (  arr ,  tkts )
Generated partial line aeq_unordered
Generated partial line aeq_unordered([
expression(2, 6, -1) =|i(\a,\a)|= aeq_unordered ( \ @arr , \ @tkts )

Generated partial line aeq_unordered([
Generated partial line aeq_unordered([arr
Generated partial line aeq_unordered([arr,
Generated partial line aeq_unordered([arr,
Generated partial line aeq_unordered([arr,tkts
expression returns 7
Generated partial line aeq_unordered([arr,tkts])
 132 | 0 |   |
 133 | 0 |   |aeq_unordered([arr, tkts])                                                              #PL: @arr = ();

Tokens: i(\a,\a) ValPy: 
Main loop, line=@arr = ();


 === Line 133 Perl source:@arr = ();===

Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )

Line:  133 TokenStr: =|a=()|= @ValPy: arr = ( )
Generated partial line arr = [
Generated partial line arr = []
 134 | 0 |   |arr = []                                                                                #PL: foreach $id (sort values %tickets)

Tokens: a=() ValPy: 
Main loop, line=foreach $id (sort values %tickets)


 === Line 134 Perl source:foreach $id (sort values %tickets)===

Lexem 0 Current token='c' perl='foreach' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='s' perl='$id' value='id' Tokenstr |cs| translated: for  id
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |cs(| translated: for  id (
Lexem 3 Current token='f' perl='sort' value='sorted' Tokenstr |cs(f| translated: for  id ( sorted
Lexem 4 Current token='f' perl='values' value='.values()' Tokenstr |cs(ff| translated: for  id ( sorted .values()
Lexem 5 Current token='h' perl='tickets' value='tickets' Tokenstr |cs(ffh| translated: for  id ( sorted .values() tickets
Lexem 6 Current token=')' perl=')' value=')' Tokenstr |cs(ffh)| translated: for  id ( sorted .values() tickets )

Line:  135 TokenStr: =|cs(ffh)|= @ValPy: for  id ( sorted .values() tickets )
control(0) =|cs(ffh)|= foreach $id ( sort values tickets )

Generated partial line for 
Generated partial line for id in 
expression(3, 5, 0) =|cs(ffh|= foreach $id ( sort values tickets

function(3, 5) =|cs(ffh|= foreach $id ( sort values tickets

function start=4, end_pos=5, bracketed=0
Generated partial line for id in sorted
Generated partial line for id in sorted(
expression(4, 5, 0) =|cs(ffh|= foreach $id ( sort values tickets

function(4, 5) =|cs(ffh|= foreach $id ( sort values tickets

function start=5, end_pos=5, bracketed=0
expression(5, 5, 0) =|cs(ffh|= foreach $id ( sort values tickets

Generated partial line for id in sorted(tickets
expression returns 6
Generated partial line for id in sorted(tickets.values()
expression returns 6
Generated partial line for id in sorted(tickets.values())
expression returns 6
Generated partial line for id in sorted(tickets.values()):
 135 | 0 |   |for id in sorted(tickets.values()):                                                     #PL: 

Tokens: cs(ffh ValPy: 
Main loop, line={


 === Line 135 Perl source:{===


Line:  135 TokenStr: =|{|= @ValPy: {
Main loop, line=push @arr, $id;


 === Line 136 Perl source:push @arr, $id;===

Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$id' value='id' Tokenstr |fa,s| translated: .extend( arr , id

Line:  136 TokenStr: =|fa,s|= @ValPy: .extend( arr , id
function(0, 3) =|fa,s|= push @arr , $id

function start=1, end_pos=3, bracketed=0
push s

expression(1, 1, 0) =|fa,s|= push @arr , $id

Generated partial line arr
expression returns 2
Generated partial line arr.append(
expression(3, 3, 0) =|fa,s|= push @arr , $id

Generated partial line arr.append(id
expression returns 4
Generated partial line arr.append(id)
 137 | 1 |   |    arr.append(id)                                                                      #PL: 

Tokens: fa,s ValPy: 
Main loop, line=}


 === Line 137 Perl source:}===


Line:  137 TokenStr: =|}|= @ValPy: }
initialize_globals_for_state_vars: 
 137 | 0 |   |
Main loop, line=aeq(\@arr, ['v1', 'v2', 'v3']);


 === Line 138 Perl source:aeq(\@arr, ['v1', 'v2', 'v3']);===

Lexem 0 Current token='i' perl='aeq' value='aeq' Tokenstr |i| translated: aeq
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeq (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeq ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeq (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeq (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeq (  arr , [
Lexem 6 Current token='"' perl='v1' value=''v1'' Tokenstr |i(\a,("| translated: aeq (  arr , [ 'v1'
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",| translated: aeq (  arr , [ 'v1' ,
Lexem 8 Current token='"' perl='v2' value=''v2'' Tokenstr |i(\a,(","| translated: aeq (  arr , [ 'v1' , 'v2'
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",",| translated: aeq (  arr , [ 'v1' , 'v2' ,
Lexem 10 Current token='"' perl='v3' value=''v3'' Tokenstr |i(\a,(",","| translated: aeq (  arr , [ 'v1' , 'v2' , 'v3'
Lexem 11 Current token=')' perl=']' value=']' Tokenstr |i(\a,(",",")| translated: aeq (  arr , [ 'v1' , 'v2' , 'v3' ]
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |i(\a,(",","))| translated: aeq (  arr , [ 'v1' , 'v2' , 'v3' ] )

Line:  138 TokenStr: =|i(\a,(",","))|= @ValPy: aeq (  arr , [ 'v1' , 'v2' , 'v3' ] )
Generated partial line aeq
Generated partial line aeq([
expression(2, 11, -1) =|i(\a,(",","))|= aeq ( \ @arr , [ v1 , v2 , v3 ] )

Generated partial line aeq([
Generated partial line aeq([arr
Generated partial line aeq([arr,
Generated partial line aeq([arr,[
expression(6, 10, 0) =|i(\a,(",","))|= aeq ( \ @arr , [ v1 , v2 , v3 ] )

Generated partial line aeq([arr,['v1'
Generated partial line aeq([arr,['v1',
Generated partial line aeq([arr,['v1','v2'
Generated partial line aeq([arr,['v1','v2',
Generated partial line aeq([arr,['v1','v2','v3'
expression returns 11
Generated partial line aeq([arr,['v1','v2','v3']
expression returns 12
Generated partial line aeq([arr,['v1','v2','v3']])
 139 | 0 |   |
 140 | 0 |   |
 141 | 0 |   |aeq([arr, ['v1', 'v2', 'v3']])                                                          #PL: @arr = ();

Tokens: i(\a,(",",")) ValPy: 
Main loop, line=@arr = ();


 === Line 141 Perl source:@arr = ();===

Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )

Line:  141 TokenStr: =|a=()|= @ValPy: arr = ( )
Generated partial line arr = [
Generated partial line arr = []
 142 | 0 |   |arr = []                                                                                #PL: foreach $id (reverse sort keys %tickets)

Tokens: a=() ValPy: 
Main loop, line=foreach $id (reverse sort keys %tickets)


 === Line 142 Perl source:foreach $id (reverse sort keys %tickets)===

Lexem 0 Current token='c' perl='foreach' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='s' perl='$id' value='id' Tokenstr |cs| translated: for  id
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |cs(| translated: for  id (
Lexem 3 Current token='f' perl='reverse' value='[::-1]' Tokenstr |cs(f| translated: for  id ( [::-1]
Lexem 4 Current token='f' perl='sort' value='sorted' Tokenstr |cs(ff| translated: for  id ( [::-1] sorted
Lexem 5 Current token='f' perl='keys' value='.keys()' Tokenstr |cs(fff| translated: for  id ( [::-1] sorted .keys()
Lexem 6 Current token='h' perl='tickets' value='tickets' Tokenstr |cs(fffh| translated: for  id ( [::-1] sorted .keys() tickets
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |cs(fffh)| translated: for  id ( [::-1] sorted .keys() tickets )

Line:  143 TokenStr: =|cs(fffh)|= @ValPy: for  id ( [::-1] sorted .keys() tickets )
control(0) =|cs(fffh)|= foreach $id ( reverse sort keys tickets )

Generated partial line for 
Generated partial line for id in 
expression(3, 6, 0) =|cs(fffh|= foreach $id ( reverse sort keys tickets

function(3, 6) =|cs(fffh|= foreach $id ( reverse sort keys tickets

function start=4, end_pos=6, bracketed=0
Generated partial line for id in (
expression(4, 6, 0) =|cs(fffh|= foreach $id ( reverse sort keys tickets

function(4, 6) =|cs(fffh|= foreach $id ( reverse sort keys tickets

function start=5, end_pos=6, bracketed=0
Generated partial line for id in (sorted
Generated partial line for id in (sorted(
expression(5, 6, 0) =|cs(fffh|= foreach $id ( reverse sort keys tickets

function(5, 6) =|cs(fffh|= foreach $id ( reverse sort keys tickets

function start=6, end_pos=6, bracketed=0
expression(6, 6, 0) =|cs(fffh|= foreach $id ( reverse sort keys tickets

Generated partial line for id in (sorted(tickets
expression returns 7
Generated partial line for id in (sorted(tickets.keys()
expression returns 7
Generated partial line for id in (sorted(tickets.keys())
expression returns 7
Generated partial line for id in (sorted(tickets.keys()))
Generated partial line for id in (sorted(tickets.keys()))[::-1]
expression returns 7
Generated partial line for id in (sorted(tickets.keys()))[::-1]:
 143 | 0 |   |for id in (sorted(tickets.keys()))[::-1]:                                               #PL: 

Tokens: cs(fffh ValPy: 
Main loop, line={


 === Line 143 Perl source:{===


Line:  143 TokenStr: =|{|= @ValPy: {
Main loop, line=push @arr, $id;


 === Line 144 Perl source:push @arr, $id;===

Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$id' value='id' Tokenstr |fa,s| translated: .extend( arr , id

Line:  144 TokenStr: =|fa,s|= @ValPy: .extend( arr , id
function(0, 3) =|fa,s|= push @arr , $id

function start=1, end_pos=3, bracketed=0
push s

expression(1, 1, 0) =|fa,s|= push @arr , $id

Generated partial line arr
expression returns 2
Generated partial line arr.append(
expression(3, 3, 0) =|fa,s|= push @arr , $id

Generated partial line arr.append(id
expression returns 4
Generated partial line arr.append(id)
 145 | 1 |   |    arr.append(id)                                                                      #PL: 

Tokens: fa,s ValPy: 
Main loop, line=}


 === Line 145 Perl source:}===


Line:  145 TokenStr: =|}|= @ValPy: }
initialize_globals_for_state_vars: 
 145 | 0 |   |
Main loop, line=aeq(\@arr, ['t3', 't2', 't1']);


 === Line 146 Perl source:aeq(\@arr, ['t3', 't2', 't1']);===

Lexem 0 Current token='i' perl='aeq' value='aeq' Tokenstr |i| translated: aeq
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeq (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeq ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeq (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeq (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeq (  arr , [
Lexem 6 Current token='"' perl='t3' value=''t3'' Tokenstr |i(\a,("| translated: aeq (  arr , [ 't3'
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",| translated: aeq (  arr , [ 't3' ,
Lexem 8 Current token='"' perl='t2' value=''t2'' Tokenstr |i(\a,(","| translated: aeq (  arr , [ 't3' , 't2'
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",",| translated: aeq (  arr , [ 't3' , 't2' ,
Lexem 10 Current token='"' perl='t1' value=''t1'' Tokenstr |i(\a,(",","| translated: aeq (  arr , [ 't3' , 't2' , 't1'
Lexem 11 Current token=')' perl=']' value=']' Tokenstr |i(\a,(",",")| translated: aeq (  arr , [ 't3' , 't2' , 't1' ]
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |i(\a,(",","))| translated: aeq (  arr , [ 't3' , 't2' , 't1' ] )

Line:  146 TokenStr: =|i(\a,(",","))|= @ValPy: aeq (  arr , [ 't3' , 't2' , 't1' ] )
Generated partial line aeq
Generated partial line aeq([
expression(2, 11, -1) =|i(\a,(",","))|= aeq ( \ @arr , [ t3 , t2 , t1 ] )

Generated partial line aeq([
Generated partial line aeq([arr
Generated partial line aeq([arr,
Generated partial line aeq([arr,[
expression(6, 10, 0) =|i(\a,(",","))|= aeq ( \ @arr , [ t3 , t2 , t1 ] )

Generated partial line aeq([arr,['t3'
Generated partial line aeq([arr,['t3',
Generated partial line aeq([arr,['t3','t2'
Generated partial line aeq([arr,['t3','t2',
Generated partial line aeq([arr,['t3','t2','t1'
expression returns 11
Generated partial line aeq([arr,['t3','t2','t1']
expression returns 12
Generated partial line aeq([arr,['t3','t2','t1']])
 147 | 0 |   |
 148 | 0 |   |aeq([arr, ['t3', 't2', 't1']])                                                          #PL: @arr = ();

Tokens: i(\a,(",",")) ValPy: 
Main loop, line=@arr = ();


 === Line 148 Perl source:@arr = ();===

Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )

Line:  148 TokenStr: =|a=()|= @ValPy: arr = ( )
Generated partial line arr = [
Generated partial line arr = []
 149 | 0 |   |arr = []                                                                                #PL: foreach $id (sort keys %tickets)

Tokens: a=() ValPy: 
Main loop, line=foreach $id (sort keys %tickets)


 === Line 149 Perl source:foreach $id (sort keys %tickets)===

Lexem 0 Current token='c' perl='foreach' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='s' perl='$id' value='id' Tokenstr |cs| translated: for  id
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |cs(| translated: for  id (
Lexem 3 Current token='f' perl='sort' value='sorted' Tokenstr |cs(f| translated: for  id ( sorted
Lexem 4 Current token='f' perl='keys' value='.keys()' Tokenstr |cs(ff| translated: for  id ( sorted .keys()
Lexem 5 Current token='h' perl='tickets' value='tickets' Tokenstr |cs(ffh| translated: for  id ( sorted .keys() tickets
Lexem 6 Current token=')' perl=')' value=')' Tokenstr |cs(ffh)| translated: for  id ( sorted .keys() tickets )

Line:  150 TokenStr: =|cs(ffh)|= @ValPy: for  id ( sorted .keys() tickets )
control(0) =|cs(ffh)|= foreach $id ( sort keys tickets )

Generated partial line for 
Generated partial line for id in 
expression(3, 5, 0) =|cs(ffh|= foreach $id ( sort keys tickets

function(3, 5) =|cs(ffh|= foreach $id ( sort keys tickets

function start=4, end_pos=5, bracketed=0
Generated partial line for id in sorted
Generated partial line for id in sorted(
expression(4, 5, 0) =|cs(ffh|= foreach $id ( sort keys tickets

function(4, 5) =|cs(ffh|= foreach $id ( sort keys tickets

function start=5, end_pos=5, bracketed=0
expression(5, 5, 0) =|cs(ffh|= foreach $id ( sort keys tickets

Generated partial line for id in sorted(tickets
expression returns 6
Generated partial line for id in sorted(tickets.keys()
expression returns 6
Generated partial line for id in sorted(tickets.keys())
expression returns 6
Generated partial line for id in sorted(tickets.keys()):
 150 | 0 |   |for id in sorted(tickets.keys()):                                                       #PL: 

Tokens: cs(ffh ValPy: 
Main loop, line={


 === Line 150 Perl source:{===


Line:  150 TokenStr: =|{|= @ValPy: {
Main loop, line=push @arr, $id;


 === Line 151 Perl source:push @arr, $id;===

Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$id' value='id' Tokenstr |fa,s| translated: .extend( arr , id

Line:  151 TokenStr: =|fa,s|= @ValPy: .extend( arr , id
function(0, 3) =|fa,s|= push @arr , $id

function start=1, end_pos=3, bracketed=0
push s

expression(1, 1, 0) =|fa,s|= push @arr , $id

Generated partial line arr
expression returns 2
Generated partial line arr.append(
expression(3, 3, 0) =|fa,s|= push @arr , $id

Generated partial line arr.append(id
expression returns 4
Generated partial line arr.append(id)
 152 | 1 |   |    arr.append(id)                                                                      #PL: 

Tokens: fa,s ValPy: 
Main loop, line=}


 === Line 152 Perl source:}===


Line:  152 TokenStr: =|}|= @ValPy: }
initialize_globals_for_state_vars: 
 152 | 0 |   |
Main loop, line=aeq(\@arr, ['t1', 't2', 't3']);


 === Line 153 Perl source:aeq(\@arr, ['t1', 't2', 't3']);===

Lexem 0 Current token='i' perl='aeq' value='aeq' Tokenstr |i| translated: aeq
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeq (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeq ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeq (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeq (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeq (  arr , [
Lexem 6 Current token='"' perl='t1' value=''t1'' Tokenstr |i(\a,("| translated: aeq (  arr , [ 't1'
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",| translated: aeq (  arr , [ 't1' ,
Lexem 8 Current token='"' perl='t2' value=''t2'' Tokenstr |i(\a,(","| translated: aeq (  arr , [ 't1' , 't2'
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",",| translated: aeq (  arr , [ 't1' , 't2' ,
Lexem 10 Current token='"' perl='t3' value=''t3'' Tokenstr |i(\a,(",","| translated: aeq (  arr , [ 't1' , 't2' , 't3'
Lexem 11 Current token=')' perl=']' value=']' Tokenstr |i(\a,(",",")| translated: aeq (  arr , [ 't1' , 't2' , 't3' ]
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |i(\a,(",","))| translated: aeq (  arr , [ 't1' , 't2' , 't3' ] )

Line:  153 TokenStr: =|i(\a,(",","))|= @ValPy: aeq (  arr , [ 't1' , 't2' , 't3' ] )
Generated partial line aeq
Generated partial line aeq([
expression(2, 11, -1) =|i(\a,(",","))|= aeq ( \ @arr , [ t1 , t2 , t3 ] )

Generated partial line aeq([
Generated partial line aeq([arr
Generated partial line aeq([arr,
Generated partial line aeq([arr,[
expression(6, 10, 0) =|i(\a,(",","))|= aeq ( \ @arr , [ t1 , t2 , t3 ] )

Generated partial line aeq([arr,['t1'
Generated partial line aeq([arr,['t1',
Generated partial line aeq([arr,['t1','t2'
Generated partial line aeq([arr,['t1','t2',
Generated partial line aeq([arr,['t1','t2','t3'
expression returns 11
Generated partial line aeq([arr,['t1','t2','t3']
expression returns 12
Generated partial line aeq([arr,['t1','t2','t3']])
 154 | 0 |   |
 155 | 0 |   |aeq([arr, ['t1', 't2', 't3']])                                                          #PL: @arr = ();

Tokens: i(\a,(",",")) ValPy: 
Main loop, line=@arr = ();


 === Line 155 Perl source:@arr = ();===

Lexem 0 Current token='a' perl='@arr' value='arr' Tokenstr |a| translated: arr
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: arr =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: arr = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |a=()| translated: arr = ( )

Line:  155 TokenStr: =|a=()|= @ValPy: arr = ( )
Generated partial line arr = [
Generated partial line arr = []
 156 | 0 |   |arr = []                                                                                #PL: foreach $id (sort %tickets)

Tokens: a=() ValPy: 
Main loop, line=foreach $id (sort %tickets)


 === Line 156 Perl source:foreach $id (sort %tickets)===

Lexem 0 Current token='c' perl='foreach' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='s' perl='$id' value='id' Tokenstr |cs| translated: for  id
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |cs(| translated: for  id (
Lexem 3 Current token='f' perl='sort' value='sorted' Tokenstr |cs(f| translated: for  id ( sorted
Lexem 4 Current token='h' perl='tickets' value='tickets' Tokenstr |cs(fh| translated: for  id ( sorted tickets
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |cs(fh)| translated: for  id ( sorted tickets )

Line:  157 TokenStr: =|cs(fh)|= @ValPy: for  id ( sorted tickets )
control(0) =|cs(fh)|= foreach $id ( sort tickets )

Generated partial line for 
Generated partial line for id in 
Generated partial line for id in sorted(list(functools.reduce(lambda x,y:x+y,tickets.items())))
Generated partial line for id in sorted(list(functools.reduce(lambda x,y:x+y,tickets.items()))):
 157 | 0 |   |for id in sorted(list(functools.reduce(lambda x,y:x+y,tickets.items()))):               #PL: 

Tokens: cs(fh) ValPy: 
Main loop, line={


 === Line 157 Perl source:{===


Line:  157 TokenStr: =|{|= @ValPy: {
Main loop, line=push @arr, $id;


 === Line 158 Perl source:push @arr, $id;===

Lexem 0 Current token='f' perl='push' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='a' perl='@arr' value='arr' Tokenstr |fa| translated: .extend( arr
Lexem 2 Current token=',' perl=',' value=',' Tokenstr |fa,| translated: .extend( arr ,
Lexem 3 Current token='s' perl='$id' value='id' Tokenstr |fa,s| translated: .extend( arr , id

Line:  158 TokenStr: =|fa,s|= @ValPy: .extend( arr , id
function(0, 3) =|fa,s|= push @arr , $id

function start=1, end_pos=3, bracketed=0
push s

expression(1, 1, 0) =|fa,s|= push @arr , $id

Generated partial line arr
expression returns 2
Generated partial line arr.append(
expression(3, 3, 0) =|fa,s|= push @arr , $id

Generated partial line arr.append(id
expression returns 4
Generated partial line arr.append(id)
 159 | 1 |   |    arr.append(id)                                                                      #PL: 

Tokens: fa,s ValPy: 
Main loop, line=}


 === Line 159 Perl source:}===


Line:  159 TokenStr: =|}|= @ValPy: }
initialize_globals_for_state_vars: 
 159 | 0 |   |
Main loop, line=aeq(\@arr, ['t1', 't2', 't3', 'v1', 'v2', 'v3']);


 === Line 160 Perl source:aeq(\@arr, ['t1', 't2', 't3', 'v1', 'v2', 'v3']);===

Lexem 0 Current token='i' perl='aeq' value='aeq' Tokenstr |i| translated: aeq
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |i(| translated: aeq (
Lexem 2 Current token='\' perl='\' value='' Tokenstr |i(\| translated: aeq ( 
Lexem 3 Current token='a' perl='@arr' value='arr' Tokenstr |i(\a| translated: aeq (  arr
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |i(\a,| translated: aeq (  arr ,
Lexem 5 Current token='(' perl='[' value='[' Tokenstr |i(\a,(| translated: aeq (  arr , [
Lexem 6 Current token='"' perl='t1' value=''t1'' Tokenstr |i(\a,("| translated: aeq (  arr , [ 't1'
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",| translated: aeq (  arr , [ 't1' ,
Lexem 8 Current token='"' perl='t2' value=''t2'' Tokenstr |i(\a,(","| translated: aeq (  arr , [ 't1' , 't2'
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",",| translated: aeq (  arr , [ 't1' , 't2' ,
Lexem 10 Current token='"' perl='t3' value=''t3'' Tokenstr |i(\a,(",","| translated: aeq (  arr , [ 't1' , 't2' , 't3'
Lexem 11 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",",",| translated: aeq (  arr , [ 't1' , 't2' , 't3' ,
Lexem 12 Current token='"' perl='v1' value=''v1'' Tokenstr |i(\a,(",",","| translated: aeq (  arr , [ 't1' , 't2' , 't3' , 'v1'
Lexem 13 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",",",",| translated: aeq (  arr , [ 't1' , 't2' , 't3' , 'v1' ,
Lexem 14 Current token='"' perl='v2' value=''v2'' Tokenstr |i(\a,(",",",","| translated: aeq (  arr , [ 't1' , 't2' , 't3' , 'v1' , 'v2'
Lexem 15 Current token=',' perl=',' value=',' Tokenstr |i(\a,(",",",",",| translated: aeq (  arr , [ 't1' , 't2' , 't3' , 'v1' , 'v2' ,
Lexem 16 Current token='"' perl='v3' value=''v3'' Tokenstr |i(\a,(",",",",","| translated: aeq (  arr , [ 't1' , 't2' , 't3' , 'v1' , 'v2' , 'v3'
Lexem 17 Current token=')' perl=']' value=']' Tokenstr |i(\a,(",",",",",")| translated: aeq (  arr , [ 't1' , 't2' , 't3' , 'v1' , 'v2' , 'v3' ]
Lexem 18 Current token=')' perl=')' value=')' Tokenstr |i(\a,(",",",",","))| translated: aeq (  arr , [ 't1' , 't2' , 't3' , 'v1' , 'v2' , 'v3' ] )

Line:  160 TokenStr: =|i(\a,(",",",",","))|= @ValPy: aeq (  arr , [ 't1' , 't2' , 't3' , 'v1' , 'v2' , 'v3' ] )
Generated partial line aeq
Generated partial line aeq([
expression(2, 17, -1) =|i(\a,(",",",",","))|= aeq ( \ @arr , [ t1 , t2 , t3 , v1 , v2 , v3 ] )

Generated partial line aeq([
Generated partial line aeq([arr
Generated partial line aeq([arr,
Generated partial line aeq([arr,[
expression(6, 16, 0) =|i(\a,(",",",",","))|= aeq ( \ @arr , [ t1 , t2 , t3 , v1 , v2 , v3 ] )

Generated partial line aeq([arr,['t1'
Generated partial line aeq([arr,['t1',
Generated partial line aeq([arr,['t1','t2'
Generated partial line aeq([arr,['t1','t2',
Generated partial line aeq([arr,['t1','t2','t3'
Generated partial line aeq([arr,['t1','t2','t3',
Generated partial line aeq([arr,['t1','t2','t3','v1'
Generated partial line aeq([arr,['t1','t2','t3','v1',
Generated partial line aeq([arr,['t1','t2','t3','v1','v2'
Generated partial line aeq([arr,['t1','t2','t3','v1','v2',
Generated partial line aeq([arr,['t1','t2','t3','v1','v2','v3'
expression returns 17
Generated partial line aeq([arr,['t1','t2','t3','v1','v2','v3']
expression returns 18
Generated partial line aeq([arr,['t1','t2','t3','v1','v2','v3']])
 161 | 0 |   |
 162 | 0 |   |aeq([arr, ['t1', 't2', 't3', 'v1', 'v2', 'v3']])                                        #PL: sub aeq {

Tokens: i(\a,(",",",",",")) ValPy: 
Main loop, line=sub aeq {


 === Line 162 Perl source:sub aeq {===

Lexem 0 Current token='k' perl='sub' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' perl='aeq' value='aeq' Tokenstr |ki| translated: def aeq

Line:  162 TokenStr: =|ki|= @ValPy: def aeq
Generated partial line defaeq(_args):
 162 | 0 |   |def aeq(_args):                                                                         #PL: sub aeq {

Tokens: ki ValPy: 
 162 | 1 |   |    global a_ref1,a_ref2                                                                #PL: sub aeq {
Main loop, line={


 === Line 162 Perl source:{===


Line:  162 TokenStr: =|{|= @ValPy: {
Main loop, line=$a_ref1 = shift;


 === Line 163 Perl source:$a_ref1 = shift;===

Lexem 0 Current token='s' perl='$a_ref1' value='a_ref1' Tokenstr |s| translated: a_ref1
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: a_ref1 =
Lexem 2 Current token='f' perl='shift' value='.pop(0)' Tokenstr |s=f| translated: a_ref1 = .pop(0)

Line:  163 TokenStr: =|s=f|= @ValPy: a_ref1 = .pop(0)
assignment(0, 2) =|s=f|= $a_ref1 = shift

Generated partial line a_ref1
Generated partial line a_ref1=
assign, ValClass[limit] = f, ValPy=.pop(0), ValPerl=shift

function(2, 2) =|s=f|= $a_ref1 = shift

function start=3, end_pos=2, bracketed=-1
Generated partial line a_ref1=(_args.pop(0) if _args else None)
 164 | 1 |   |    a_ref1 = (_args.pop(0) if _args else None)                                          #PL: $a_ref2 = shift;

Tokens: s=f ValPy: 
Main loop, line=$a_ref2 = shift;


 === Line 164 Perl source:$a_ref2 = shift;===

Lexem 0 Current token='s' perl='$a_ref2' value='a_ref2' Tokenstr |s| translated: a_ref2
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: a_ref2 =
Lexem 2 Current token='f' perl='shift' value='.pop(0)' Tokenstr |s=f| translated: a_ref2 = .pop(0)

Line:  164 TokenStr: =|s=f|= @ValPy: a_ref2 = .pop(0)
assignment(0, 2) =|s=f|= $a_ref2 = shift

Generated partial line a_ref2
Generated partial line a_ref2=
assign, ValClass[limit] = f, ValPy=.pop(0), ValPerl=shift

function(2, 2) =|s=f|= $a_ref2 = shift

function start=3, end_pos=2, bracketed=-1
Generated partial line a_ref2=(_args.pop(0) if _args else None)
 165 | 1 |   |
 166 | 1 |   |    a_ref2 = (_args.pop(0) if _args else None)                                          #PL: my ($package, $filename, $line) = caller;

Tokens: s=f ValPy: 
Main loop, line=my ($package, $filename, $line) = caller;


 === Line 166 Perl source:my ($package, $filename, $line) = caller;===

Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |t(| translated:  (
Lexem 2 Current token='s' perl='$package' value='package' Tokenstr |t(s| translated:  ( package
Lexem 3 Current token=',' perl=',' value=',' Tokenstr |t(s,| translated:  ( package ,
Lexem 4 Current token='s' perl='$filename' value='filename' Tokenstr |t(s,s| translated:  ( package , filename
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |t(s,s,| translated:  ( package , filename ,
Lexem 6 Current token='s' perl='$line' value='line' Tokenstr |t(s,s,s| translated:  ( package , filename , line
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |t(s,s,s)| translated:  ( package , filename , line )
Lexem 8 Current token='=' perl='=' value='=' Tokenstr |t(s,s,s)=| translated:  ( package , filename , line ) =
Lexem 9 Current token='f' perl='caller' value='caller' Tokenstr |t(s,s,s)=f| translated:  ( package , filename , line ) = caller

Line:  166 TokenStr: =|t(s,s,s)=f|= @ValPy:  ( package , filename , line ) = caller
assignment(1, 9) =|t(s,s,s)=f|= my ( $package , $filename , $line ) = caller

Generated partial line [
Generated partial line [package
Generated partial line [package,filename
Generated partial line [package,filename,line
Generated partial line [package,filename,line]
Generated partial line [package,filename,line]=
Generated partial line [package,filename,line]=_list_of_n(
assign, ValClass[limit] = f, ValPy=caller, ValPerl=caller

function(9, 9) =|t(s,s,s)=f|= my ( $package , $filename , $line ) = caller

function start=10, end_pos=9, bracketed=-1
Generated partial line [package,filename,line]=_list_of_n(['main',__file__,sys._getframe(1).f_lineno]
Generated partial line [package,filename,line]=_list_of_n(['main',__file__,sys._getframe(1).f_lineno], 3)
 167 | 1 |   |
 168 | 1 |   |    [package,filename,line] = _list_of_n(['main',__file__,sys._getframe(1).f_lineno], 3) #PL: eval {

Tokens: t(s,s,s)=f ValPy: 
Main loop, line=eval {


 === Line 168 Perl source:eval {===

Lexem 0 Current token='C' perl='eval' value='try' Tokenstr |C| translated: try

Line:  168 TokenStr: =|C|= @ValPy: try
 168 | 1 |   |    try:                                                                                #PL: eval {

Tokens: C ValPy: 
eval_stack=HASH(0x800776a50), eval_nest=1
Main loop, line={


 === Line 168 Perl source:{===


Line:  168 TokenStr: =|{|= @ValPy: {
eval_stack=HASH(0x800776a50), eval_nest=1
Main loop, line=assert(scalar(@$a_ref1) == scalar(@$a_ref2));


 === Line 169 Perl source:assert(scalar(@$a_ref1) == scalar(@$a_ref2));===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='scalar' value='len' Tokenstr |c(f| translated: assert ( len
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( len (
Lexem 4 Current token='@' perl='@' value='@' Tokenstr |c(f(@| translated: assert ( len ( @
Lexem 4 Current token='s' perl='$a_ref1' value='a_ref1' Tokenstr |c(f(s| translated: assert ( len ( a_ref1
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(f(s)| translated: assert ( len ( a_ref1 )
Lexem 6 Current token='>' perl='==' value='==' Tokenstr |c(f(s)>| translated: assert ( len ( a_ref1 ) ==
Lexem 7 Current token='f' perl='scalar' value='len' Tokenstr |c(f(s)>f| translated: assert ( len ( a_ref1 ) == len
Lexem 8 Current token='(' perl='(' value='(' Tokenstr |c(f(s)>f(| translated: assert ( len ( a_ref1 ) == len (
Lexem 9 Current token='@' perl='@' value='@' Tokenstr |c(f(s)>f(@| translated: assert ( len ( a_ref1 ) == len ( @
Lexem 9 Current token='s' perl='$a_ref2' value='a_ref2' Tokenstr |c(f(s)>f(s| translated: assert ( len ( a_ref1 ) == len ( a_ref2
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |c(f(s)>f(s)| translated: assert ( len ( a_ref1 ) == len ( a_ref2 )
Lexem 11 Current token=')' perl=')' value=')' Tokenstr |c(f(s)>f(s))| translated: assert ( len ( a_ref1 ) == len ( a_ref2 ) )

Line:  169 TokenStr: =|c(f(s)>f(s))|= @ValPy: assert ( len ( a_ref1 ) == len ( a_ref2 ) )
control(0) =|c(f(s)>f(s))|= assert ( scalar ( $a_ref1 ) == scalar ( $a_ref2 ) )

control-parens removed, begin=0 start=1 =|cf(s)>f(s)|= assert scalar ( $a_ref1 ) == scalar ( $a_ref2 )

Generated partial line assert
expression(1, 9, 0) =|cf(s)>f(s)|= assert scalar ( $a_ref1 ) == scalar ( $a_ref2 )

function(1, 9) =|cf(s)>f(s)|= assert scalar ( $a_ref1 ) == scalar ( $a_ref2 )

function start=3, end_pos=3, bracketed=1
Generated partial line assertlen
Generated partial line assertlen(
expression(3, 3, 0) =|cf(s)>f(s)|= assert scalar ( $a_ref1 ) == scalar ( $a_ref2 )

Generated partial line assertlen(a_ref1
expression returns 4
Generated partial line assertlen(a_ref1)
Generated partial line assertlen(a_ref1)==
function(6, 9) =|cf(s)>f(s)|= assert scalar ( $a_ref1 ) == scalar ( $a_ref2 )

function start=8, end_pos=8, bracketed=1
Generated partial line assertlen(a_ref1)==len
Generated partial line assertlen(a_ref1)==len(
expression(8, 8, 0) =|cf(s)>f(s)|= assert scalar ( $a_ref1 ) == scalar ( $a_ref2 )

Generated partial line assertlen(a_ref1)==len(a_ref2
expression returns 9
Generated partial line assertlen(a_ref1)==len(a_ref2)
expression returns 10
 170 | 2 |   |        assert len(a_ref1) == len(a_ref2)                                               #PL: };

Tokens: cf(s)>f(s) ValPy: 
eval_stack=HASH(0x800776a50), eval_nest=1
Main loop, line=};


 === Line 170 Perl source:};===


Line:  170 TokenStr: =|}|= @ValPy: }
eval_stack=HASH(0x800776a50), eval_nest=1
 170 | 2 |   |        EVAL_ERROR = None                                                               #PL: ;

Tokens: } ValPy: 
 170 | 1 |   |    except Exception as _e:                                                             #PL: ;

Tokens: } ValPy: 
 170 | 2 |   |        EVAL_ERROR = _exc(_e)                                                           #PL: ;

Tokens: } ValPy: 
Main loop, line=;


 === Line 170 Perl source:;===


Line:  170 TokenStr: =||= @ValPy: 
 170 | 1 |   |    pass                                                                                #PL: ;

Tokens:  ValPy: 
Main loop, line=if($@) {


 === Line 171 Perl source:if($@) {===

Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' perl='$' value='EVAL_ERROR' Tokenstr |c(s| translated: if  ( EVAL_ERROR
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(s)| translated: if  ( EVAL_ERROR )

Line:  171 TokenStr: =|c(s)|= @ValPy: if  ( EVAL_ERROR )
control(0) =|c(s)|= if ( $ )

control-parens removed, begin=0 start=1 =|cs|= if $

Generated partial line if 
expression(1, 1, 0) =|cs|= if $

Generated partial line if EVAL_ERROR
expression returns 2
Generated partial line if EVAL_ERROR:
 171 | 1 |   |    if EVAL_ERROR:                                                                      #PL: 

Tokens: cs ValPy: 
Main loop, line={


 === Line 171 Perl source:{===


Line:  171 TokenStr: =|{|= @ValPy: {
Main loop, line=say STDERR "scalar(\@\$a_ref1) != scalar(\@\$a_ref2), ".scalar(@$a_ref1)." != ".scalar(@$a_ref2);


 === Line 172 Perl source:say STDERR "scalar(\@\$a_ref1) != scalar(\@\$a_ref2), ".scalar(@$a_ref1)." != ".scalar(@$a_ref2);===

Lexem 0 Current token='f' perl='say' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='i' perl='STDERR' value='sys.stderr' Tokenstr |fi| translated: print sys.stderr
Lexem 2 Current token='"' perl='scalar(\@\$a_ref1) != scalar(\@\$a_ref2), ' value='f"scalar(@$a_ref1) != scalar(@$a_ref2), "' Tokenstr |fi"| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "
Lexem 3 Current token='.' perl='.' value=' + ' Tokenstr |fi".| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  + 
Lexem 4 Current token='f' perl='scalar' value='len' Tokenstr |fi".f| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len
Lexem 5 Current token='(' perl='(' value='(' Tokenstr |fi".f(| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len (
Lexem 6 Current token='@' perl='@' value='@' Tokenstr |fi".f(@| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( @
Lexem 6 Current token='s' perl='$a_ref1' value='a_ref1' Tokenstr |fi".f(s| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |fi".f(s)| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )
Lexem 8 Current token='.' perl='.' value=' + ' Tokenstr |fi".f(s).| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  + 
Lexem 9 Current token='"' perl=' != ' value='' != '' Tokenstr |fi".f(s)."| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '
Lexem 10 Current token='.' perl='.' value=' + ' Tokenstr |fi".f(s).".| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  + 
Lexem 11 Current token='f' perl='scalar' value='len' Tokenstr |fi".f(s).".f| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len
Lexem 12 Current token='(' perl='(' value='(' Tokenstr |fi".f(s).".f(| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len (
Lexem 13 Current token='@' perl='@' value='@' Tokenstr |fi".f(s).".f(@| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len ( @
Lexem 13 Current token='s' perl='$a_ref2' value='a_ref2' Tokenstr |fi".f(s).".f(s| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len ( a_ref2
Lexem 14 Current token=')' perl=')' value=')' Tokenstr |fi".f(s).".f(s)| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len ( a_ref2 )

Line:  172 TokenStr: =|fi".f(s).".f(s)|= @ValPy: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len ( a_ref2 )
fix_string_catentation2 i=3, j=8

fix_string_catentation2 i=13, j=18

Generated partial line print(
print3(0) start=0, handle=sys.stderr, k=2, end_pos=20

expression(2, 20, 0) =|fi".f(f(s)).".f(f(s))|= say STDERR scalar(\@\$a_ref1) != scalar(\@\$a_ref2),  . str ( scalar ( $a_ref1 ) ) .  !=  . str ( scalar ( $a_ref2 ) )

Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), "
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + 
function(4, 20) =|fi".f(f(s)).".f(f(s))|= say STDERR scalar(\@\$a_ref1) != scalar(\@\$a_ref2),  . str ( scalar ( $a_ref1 ) ) .  !=  . str ( scalar ( $a_ref2 ) )

function start=6, end_pos=9, bracketed=1
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(
expression(6, 9, 0) =|fi".f(f(s)).".f(f(s))|= say STDERR scalar(\@\$a_ref1) != scalar(\@\$a_ref2),  . str ( scalar ( $a_ref1 ) ) .  !=  . str ( scalar ( $a_ref2 ) )

function(6, 9) =|fi".f(f(s)).".f(f(s))|= say STDERR scalar(\@\$a_ref1) != scalar(\@\$a_ref2),  . str ( scalar ( $a_ref1 ) ) .  !=  . str ( scalar ( $a_ref2 ) )

function start=8, end_pos=8, bracketed=1
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(
expression(8, 8, 0) =|fi".f(f(s)).".f(f(s))|= say STDERR scalar(\@\$a_ref1) != scalar(\@\$a_ref2),  . str ( scalar ( $a_ref1 ) ) .  !=  . str ( scalar ( $a_ref2 ) )

Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1
expression returns 9
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)
expression returns 10
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1))
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + 
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != '
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + 
function(14, 20) =|fi".f(f(s)).".f(f(s))|= say STDERR scalar(\@\$a_ref1) != scalar(\@\$a_ref2),  . str ( scalar ( $a_ref1 ) ) .  !=  . str ( scalar ( $a_ref2 ) )

function start=16, end_pos=19, bracketed=1
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + str
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + str(
expression(16, 19, 0) =|fi".f(f(s)).".f(f(s))|= say STDERR scalar(\@\$a_ref1) != scalar(\@\$a_ref2),  . str ( scalar ( $a_ref1 ) ) .  !=  . str ( scalar ( $a_ref2 ) )

function(16, 19) =|fi".f(f(s)).".f(f(s))|= say STDERR scalar(\@\$a_ref1) != scalar(\@\$a_ref2),  . str ( scalar ( $a_ref1 ) ) .  !=  . str ( scalar ( $a_ref2 ) )

function start=18, end_pos=18, bracketed=1
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + str(len
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + str(len(
expression(18, 18, 0) =|fi".f(f(s)).".f(f(s))|= say STDERR scalar(\@\$a_ref1) != scalar(\@\$a_ref2),  . str ( scalar ( $a_ref1 ) ) .  !=  . str ( scalar ( $a_ref2 ) )

Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + str(len(a_ref2
expression returns 19
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + str(len(a_ref2)
expression returns 20
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + str(len(a_ref2))
expression returns 21
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + str(len(a_ref2)),file=sys.stderr
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + str(len(a_ref2)),file=sys.stderr)
 173 | 2 |   |        print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + str(len(a_ref2)),file=sys.stderr) #PL: say STDERR "Assertion failed in aeq called from line $line";

Tokens: fi".f(f(s)).".f(f(s)) ValPy: 
Main loop, line=say STDERR "Assertion failed in aeq called from line $line";


 === Line 173 Perl source:say STDERR "Assertion failed in aeq called from line $line";===

Lexem 0 Current token='f' perl='say' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='i' perl='STDERR' value='sys.stderr' Tokenstr |fi| translated: print sys.stderr
Lexem 2 Current token='"' perl='Assertion failed in aeq called from line $line' value='f"Assertion failed in aeq called from line {line}"' Tokenstr |fi"| translated: print sys.stderr f"Assertion failed in aeq called from line {line}"

Line:  173 TokenStr: =|fi"|= @ValPy: print sys.stderr f"Assertion failed in aeq called from line {line}"
Generated partial line print(
print3(0) start=0, handle=sys.stderr, k=2, end_pos=2

expression(2, 2, 0) =|fi"|= say STDERR Assertion failed in aeq called from line $line

Generated partial line print(f"Assertion failed in aeq called from line {line}"
expression returns 3
Generated partial line print(f"Assertion failed in aeq called from line {line}",file=sys.stderr
Generated partial line print(f"Assertion failed in aeq called from line {line}",file=sys.stderr)
 174 | 2 |   |        print(f"Assertion failed in aeq called from line {line}",file=sys.stderr)       #PL: die($@);

Tokens: fi" ValPy: 
Main loop, line=die($@);


 === Line 174 Perl source:die($@);===

Lexem 0 Current token='f' perl='die' value='raise Die' Tokenstr |f| translated: raise Die
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |f(| translated: raise Die (
Lexem 2 Current token='s' perl='$' value='EVAL_ERROR' Tokenstr |f(s| translated: raise Die ( EVAL_ERROR
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |f(s)| translated: raise Die ( EVAL_ERROR )

Line:  174 TokenStr: =|f(s)|= @ValPy: raise Die ( EVAL_ERROR )
function(0, 3) =|f(s)|= die ( $ )

function start=2, end_pos=2, bracketed=1
Generated partial line raise Die
Generated partial line raise Die(
expression(2, 2, 0) =|f(s)|= die ( $ )

Generated partial line raise Die(EVAL_ERROR
expression returns 3
Generated partial line raise Die(EVAL_ERROR)
 175 | 2 |   |        raise Die(EVAL_ERROR)                                                           #PL: 

Tokens: f(s) ValPy: 
Main loop, line=}


 === Line 175 Perl source:}===


Line:  175 TokenStr: =|}|= @ValPy: }
 175 | 2 |   |
Main loop, line=for(my $i = 0; $i < scalar(@$a_ref1); $i++) {


 === Line 176 Perl source:for(my $i = 0; $i < scalar(@$a_ref1); $i++) {===

Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='s' perl='$i' value='i' Tokenstr |c(s| translated: for  ( i
Lexem 3 Current token='=' perl='=' value=':=' Tokenstr |c(s=| translated: for  ( i :=
Lexem 4 Current token='d' perl='0' value='0' Tokenstr |c(s=d| translated: for  ( i := 0
Lexem 5 Current token=';' perl=';' value=';' Tokenstr |c(s=d;| translated: for  ( i := 0 ;
Lexem 6 Current token='s' perl='$i' value='i' Tokenstr |c(s=d;s| translated: for  ( i := 0 ; i
Lexem 7 Current token='>' perl='<' value='<' Tokenstr |c(s=d;s>| translated: for  ( i := 0 ; i <
Lexem 8 Current token='f' perl='scalar' value='len' Tokenstr |c(s=d;s>f| translated: for  ( i := 0 ; i < len
Lexem 9 Current token='(' perl='(' value='(' Tokenstr |c(s=d;s>f(| translated: for  ( i := 0 ; i < len (
Lexem 10 Current token='@' perl='@' value='@' Tokenstr |c(s=d;s>f(@| translated: for  ( i := 0 ; i < len ( @
Lexem 10 Current token='s' perl='$a_ref1' value='a_ref1' Tokenstr |c(s=d;s>f(s| translated: for  ( i := 0 ; i < len ( a_ref1
Lexem 11 Current token=')' perl=')' value=')' Tokenstr |c(s=d;s>f(s)| translated: for  ( i := 0 ; i < len ( a_ref1 )
Lexem 12 Current token=';' perl=';' value=';' Tokenstr |c(s=d;s>f(s);| translated: for  ( i := 0 ; i < len ( a_ref1 ) ;
Lexem 13 Current token='s' perl='$i' value='i' Tokenstr |c(s=d;s>f(s);s| translated: for  ( i := 0 ; i < len ( a_ref1 ) ; i
Lexem 14 Current token='^' perl='++' value='+=1' Tokenstr |c(s=d;s>f(s);s^| translated: for  ( i := 0 ; i < len ( a_ref1 ) ; i +=1
Lexem 15 Current token=')' perl=')' value=')' Tokenstr |c(s=d;s>f(s);s^)| translated: for  ( i := 0 ; i < len ( a_ref1 ) ; i +=1 )

Line:  176 TokenStr: =|c(s=d;s>f(s);s^)|= @ValPy: for  ( i := 0 ; i < len ( a_ref1 ) ; i +=1 )
handle_incr_decr(0, 14, 15) with ++, pre_op=0, lvalue_start=13, lvalue_end=13 = 9
control(0) =|c(s=d;s>f(s);((s=s+d)-d))|= for ( $i = 0 ; $i < scalar ( $a_ref1 ) ; ( ( $i = $i + 1 ) - 1 ) )

control-parens removed, begin=0 start=1 =|cs=d;s>f(s);((s=s+d)-d)|= for $i = 0 ; $i < scalar ( $a_ref1 ) ; ( ( $i = $i + 1 ) - 1 )

Generated partial line for 
Generated partial line for i
Generated partial line for iin range(
Generated partial line for iin range(0
Generated partial line for iin range(0,
expression(7, 10, 0) =|cs=d;s>f(s);((s=s+d)-d)|= for $i = 0 ; $i < scalar ( $a_ref1 ) ; ( ( $i = $i + 1 ) - 1 )

function(7, 10) =|cs=d;s>f(s);((s=s+d)-d)|= for $i = 0 ; $i < scalar ( $a_ref1 ) ; ( ( $i = $i + 1 ) - 1 )

function start=9, end_pos=9, bracketed=1
Generated partial line for iin range(0,len
Generated partial line for iin range(0,len(
expression(9, 9, 0) =|cs=d;s>f(s);((s=s+d)-d)|= for $i = 0 ; $i < scalar ( $a_ref1 ) ; ( ( $i = $i + 1 ) - 1 )

Generated partial line for iin range(0,len(a_ref1
expression returns 10
Generated partial line for iin range(0,len(a_ref1)
expression returns 11
Generated partial line for iin range(0,len(a_ref1)):
 176 | 1 |   |    for i in range(0, len(a_ref1)):                                                     #PL: 

Tokens: cs=d;s>f(s);((s=s+d)-d) ValPy: 
Main loop, line={


 === Line 176 Perl source:{===


Line:  176 TokenStr: =|{|= @ValPy: {
Main loop, line=eval {


 === Line 177 Perl source:eval {===

Lexem 0 Current token='C' perl='eval' value='try' Tokenstr |C| translated: try

Line:  177 TokenStr: =|C|= @ValPy: try
 177 | 2 |   |        try:                                                                            #PL: eval {

Tokens: C ValPy: 
eval_stack=HASH(0x80076e460), eval_nest=2
Main loop, line={


 === Line 177 Perl source:{===


Line:  177 TokenStr: =|{|= @ValPy: {
eval_stack=HASH(0x80076e460), eval_nest=2
Main loop, line=assert($a_ref1->[$i] eq $a_ref2->[$i]);


 === Line 178 Perl source:assert($a_ref1->[$i] eq $a_ref2->[$i]);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$a_ref1' value='a_ref1' Tokenstr |c(s| translated: assert ( a_ref1
Lexem 3 Current token='.' perl='->' value='.' Tokenstr |c(s.| translated: assert ( a_ref1 .
Lexem 3 Current token='(' perl='[' value='[' Tokenstr |c(s(| translated: assert ( a_ref1 [
Lexem 4 Current token='s' perl='$i' value='i' Tokenstr |c(s(s| translated: assert ( a_ref1 [ i
Lexem 5 Current token=')' perl=']' value=']' Tokenstr |c(s(s)| translated: assert ( a_ref1 [ i ]
Lexem 6 Current token='>' perl='eq' value='==' Tokenstr |c(s(s)>| translated: assert ( a_ref1 [ i ] ==
Lexem 7 Current token='s' perl='$a_ref2' value='a_ref2' Tokenstr |c(s(s)>s| translated: assert ( a_ref1 [ i ] == a_ref2
Lexem 8 Current token='.' perl='->' value='.' Tokenstr |c(s(s)>s.| translated: assert ( a_ref1 [ i ] == a_ref2 .
Lexem 8 Current token='(' perl='[' value='[' Tokenstr |c(s(s)>s(| translated: assert ( a_ref1 [ i ] == a_ref2 [
Lexem 9 Current token='s' perl='$i' value='i' Tokenstr |c(s(s)>s(s| translated: assert ( a_ref1 [ i ] == a_ref2 [ i
Lexem 10 Current token=')' perl=']' value=']' Tokenstr |c(s(s)>s(s)| translated: assert ( a_ref1 [ i ] == a_ref2 [ i ]
Lexem 11 Current token=')' perl=')' value=')' Tokenstr |c(s(s)>s(s))| translated: assert ( a_ref1 [ i ] == a_ref2 [ i ] )

Line:  178 TokenStr: =|c(s(s)>s(s))|= @ValPy: assert ( a_ref1 [ i ] == a_ref2 [ i ] )
control(0) =|c(s(s)>s(s))|= assert ( $a_ref1 [ $i ] eq $a_ref2 [ $i ] )

control-parens removed, begin=0 start=1 =|cs(s)>s(s)|= assert $a_ref1 [ $i ] eq $a_ref2 [ $i ]

Generated partial line assert
expression(1, 9, 0) =|cs(s)>s(s)|= assert $a_ref1 [ $i ] eq $a_ref2 [ $i ]

Generated partial line asserta_ref1
Generated partial line asserta_ref1[
expression(3, 3, 0) =|cs(s)>s(s)|= assert $a_ref1 [ $i ] eq $a_ref2 [ $i ]

Generated partial line asserta_ref1[i
expression returns 4
Generated partial line asserta_ref1[i]
Generated partial line asserta_ref1[i]==
Generated partial line asserta_ref1[i]==a_ref2
Generated partial line asserta_ref1[i]==a_ref2[
expression(8, 8, 0) =|cs(s)>s(s)|= assert $a_ref1 [ $i ] eq $a_ref2 [ $i ]

Generated partial line asserta_ref1[i]==a_ref2[i
expression returns 9
Generated partial line asserta_ref1[i]==a_ref2[i]
expression returns 10
 179 | 3 |   |            assert a_ref1[i] == a_ref2[i]                                               #PL: };

Tokens: cs(s)>s(s) ValPy: 
eval_stack=HASH(0x80076e460), eval_nest=2
Main loop, line=};


 === Line 179 Perl source:};===


Line:  179 TokenStr: =|}|= @ValPy: }
eval_stack=HASH(0x80076e460), eval_nest=2
 179 | 3 |   |            EVAL_ERROR = None                                                           #PL: ;

Tokens: } ValPy: 
 179 | 2 |   |        except Exception as _e:                                                         #PL: ;

Tokens: } ValPy: 
 179 | 3 |   |            EVAL_ERROR = _exc(_e)                                                       #PL: ;

Tokens: } ValPy: 
Main loop, line=;


 === Line 179 Perl source:;===


Line:  179 TokenStr: =||= @ValPy: 
 179 | 2 |   |        pass                                                                            #PL: ;

Tokens:  ValPy: 
Main loop, line=if($@) {


 === Line 180 Perl source:if($@) {===

Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' perl='$' value='EVAL_ERROR' Tokenstr |c(s| translated: if  ( EVAL_ERROR
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(s)| translated: if  ( EVAL_ERROR )

Line:  180 TokenStr: =|c(s)|= @ValPy: if  ( EVAL_ERROR )
control(0) =|c(s)|= if ( $ )

control-parens removed, begin=0 start=1 =|cs|= if $

Generated partial line if 
expression(1, 1, 0) =|cs|= if $

Generated partial line if EVAL_ERROR
expression returns 2
Generated partial line if EVAL_ERROR:
 180 | 2 |   |        if EVAL_ERROR:                                                                  #PL: 

Tokens: cs ValPy: 
Main loop, line={


 === Line 180 Perl source:{===


Line:  180 TokenStr: =|{|= @ValPy: {
Main loop, line=say STDERR "\$a_ref1->[$i] ne \$a_ref2->[$i], $a_ref1->[$i] ne $a_ref2->[$i]";


 === Line 181 Perl source:say STDERR "\$a_ref1->[$i] ne \$a_ref2->[$i], $a_ref1->[$i] ne $a_ref2->[$i]";===

Lexem 0 Current token='f' perl='say' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='i' perl='STDERR' value='sys.stderr' Tokenstr |fi| translated: print sys.stderr
Lexem 2 Current token='"' perl='\$a_ref1->[$i] ne \$a_ref2->[$i], $a_ref1->[$i] ne $a_ref2->[$i]' value='f"$a_ref1->[{i}] ne $a_ref2->[{i}], {a_ref1}->[{i}] ne {a_ref2}->[{i}]"' Tokenstr |fi"| translated: print sys.stderr f"$a_ref1->[{i}] ne $a_ref2->[{i}], {a_ref1}->[{i}] ne {a_ref2}->[{i}]"

Line:  181 TokenStr: =|fi"|= @ValPy: print sys.stderr f"$a_ref1->[{i}] ne $a_ref2->[{i}], {a_ref1}->[{i}] ne {a_ref2}->[{i}]"
Generated partial line print(
print3(0) start=0, handle=sys.stderr, k=2, end_pos=2

expression(2, 2, 0) =|fi"|= say STDERR \$a_ref1->[$i] ne \$a_ref2->[$i], $a_ref1->[$i] ne $a_ref2->[$i]

Generated partial line print(f"$a_ref1->[{i}] ne $a_ref2->[{i}], {a_ref1}->[{i}] ne {a_ref2}->[{i}]"
expression returns 3
Generated partial line print(f"$a_ref1->[{i}] ne $a_ref2->[{i}], {a_ref1}->[{i}] ne {a_ref2}->[{i}]",file=sys.stderr
Generated partial line print(f"$a_ref1->[{i}] ne $a_ref2->[{i}], {a_ref1}->[{i}] ne {a_ref2}->[{i}]",file=sys.stderr)
 182 | 3 |   |            print(f"$a_ref1->[{i}] ne $a_ref2->[{i}], {a_ref1}->[{i}] ne {a_ref2}->[{i}]",file=sys.stderr) #PL: say STDERR "Assertion failed in aeq called from line $line";

Tokens: fi" ValPy: 
Main loop, line=say STDERR "Assertion failed in aeq called from line $line";


 === Line 182 Perl source:say STDERR "Assertion failed in aeq called from line $line";===

Lexem 0 Current token='f' perl='say' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='i' perl='STDERR' value='sys.stderr' Tokenstr |fi| translated: print sys.stderr
Lexem 2 Current token='"' perl='Assertion failed in aeq called from line $line' value='f"Assertion failed in aeq called from line {line}"' Tokenstr |fi"| translated: print sys.stderr f"Assertion failed in aeq called from line {line}"

Line:  182 TokenStr: =|fi"|= @ValPy: print sys.stderr f"Assertion failed in aeq called from line {line}"
Generated partial line print(
print3(0) start=0, handle=sys.stderr, k=2, end_pos=2

expression(2, 2, 0) =|fi"|= say STDERR Assertion failed in aeq called from line $line

Generated partial line print(f"Assertion failed in aeq called from line {line}"
expression returns 3
Generated partial line print(f"Assertion failed in aeq called from line {line}",file=sys.stderr
Generated partial line print(f"Assertion failed in aeq called from line {line}",file=sys.stderr)
 183 | 3 |   |            print(f"Assertion failed in aeq called from line {line}",file=sys.stderr)   #PL: die($@);

Tokens: fi" ValPy: 
Main loop, line=die($@);


 === Line 183 Perl source:die($@);===

Lexem 0 Current token='f' perl='die' value='raise Die' Tokenstr |f| translated: raise Die
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |f(| translated: raise Die (
Lexem 2 Current token='s' perl='$' value='EVAL_ERROR' Tokenstr |f(s| translated: raise Die ( EVAL_ERROR
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |f(s)| translated: raise Die ( EVAL_ERROR )

Line:  183 TokenStr: =|f(s)|= @ValPy: raise Die ( EVAL_ERROR )
function(0, 3) =|f(s)|= die ( $ )

function start=2, end_pos=2, bracketed=1
Generated partial line raise Die
Generated partial line raise Die(
expression(2, 2, 0) =|f(s)|= die ( $ )

Generated partial line raise Die(EVAL_ERROR
expression returns 3
Generated partial line raise Die(EVAL_ERROR)
 184 | 3 |   |            raise Die(EVAL_ERROR)                                                       #PL: 

Tokens: f(s) ValPy: 
Main loop, line=}


 === Line 184 Perl source:}===


Line:  184 TokenStr: =|}|= @ValPy: }
 184 | 3 |   |
Main loop, line=}


 === Line 185 Perl source:}===


Line:  185 TokenStr: =|}|= @ValPy: }
 185 | 2 |   |
Main loop, line=}


 === Line 186 Perl source:}===


Line:  186 TokenStr: =|}|= @ValPy: }
initialize_globals_for_state_vars: 
 186 | 0 |   |
 187 | 0 |   |
Main loop, line=sub aeq_unordered {


 === Line 188 Perl source:sub aeq_unordered {===

Lexem 0 Current token='k' perl='sub' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' perl='aeq_unordered' value='aeq_unordered' Tokenstr |ki| translated: def aeq_unordered

Line:  188 TokenStr: =|ki|= @ValPy: def aeq_unordered
Generated partial line defaeq_unordered(_args):
 188 | 0 |   |def aeq_unordered(_args):                                                               #PL: sub aeq_unordered {

Tokens: ki ValPy: 
 188 | 1 |   |    global a_ref1,a_ref2                                                                #PL: sub aeq_unordered {
Main loop, line={


 === Line 188 Perl source:{===


Line:  188 TokenStr: =|{|= @ValPy: {
 189 | 0 |   |# check if a_ref1 eq a_ref2 in any order
Main loop, line=$a_ref1 = shift;


 === Line 190 Perl source:$a_ref1 = shift;===

Lexem 0 Current token='s' perl='$a_ref1' value='a_ref1' Tokenstr |s| translated: a_ref1
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: a_ref1 =
Lexem 2 Current token='f' perl='shift' value='.pop(0)' Tokenstr |s=f| translated: a_ref1 = .pop(0)

Line:  190 TokenStr: =|s=f|= @ValPy: a_ref1 = .pop(0)
assignment(0, 2) =|s=f|= $a_ref1 = shift

Generated partial line a_ref1
Generated partial line a_ref1=
assign, ValClass[limit] = f, ValPy=.pop(0), ValPerl=shift

function(2, 2) =|s=f|= $a_ref1 = shift

function start=3, end_pos=2, bracketed=-1
Generated partial line a_ref1=(_args.pop(0) if _args else None)
 191 | 1 |   |    a_ref1 = (_args.pop(0) if _args else None)                                          #PL: $a_ref2 = shift;

Tokens: s=f ValPy: 
Main loop, line=$a_ref2 = shift;


 === Line 191 Perl source:$a_ref2 = shift;===

Lexem 0 Current token='s' perl='$a_ref2' value='a_ref2' Tokenstr |s| translated: a_ref2
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: a_ref2 =
Lexem 2 Current token='f' perl='shift' value='.pop(0)' Tokenstr |s=f| translated: a_ref2 = .pop(0)

Line:  191 TokenStr: =|s=f|= @ValPy: a_ref2 = .pop(0)
assignment(0, 2) =|s=f|= $a_ref2 = shift

Generated partial line a_ref2
Generated partial line a_ref2=
assign, ValClass[limit] = f, ValPy=.pop(0), ValPerl=shift

function(2, 2) =|s=f|= $a_ref2 = shift

function start=3, end_pos=2, bracketed=-1
Generated partial line a_ref2=(_args.pop(0) if _args else None)
 192 | 1 |   |
 193 | 1 |   |    a_ref2 = (_args.pop(0) if _args else None)                                          #PL: my ($package, $filename, $line) = caller;

Tokens: s=f ValPy: 
Main loop, line=my ($package, $filename, $line) = caller;


 === Line 193 Perl source:my ($package, $filename, $line) = caller;===

Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |t(| translated:  (
Lexem 2 Current token='s' perl='$package' value='package' Tokenstr |t(s| translated:  ( package
Lexem 3 Current token=',' perl=',' value=',' Tokenstr |t(s,| translated:  ( package ,
Lexem 4 Current token='s' perl='$filename' value='filename' Tokenstr |t(s,s| translated:  ( package , filename
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |t(s,s,| translated:  ( package , filename ,
Lexem 6 Current token='s' perl='$line' value='line' Tokenstr |t(s,s,s| translated:  ( package , filename , line
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |t(s,s,s)| translated:  ( package , filename , line )
Lexem 8 Current token='=' perl='=' value='=' Tokenstr |t(s,s,s)=| translated:  ( package , filename , line ) =
Lexem 9 Current token='f' perl='caller' value='caller' Tokenstr |t(s,s,s)=f| translated:  ( package , filename , line ) = caller

Line:  193 TokenStr: =|t(s,s,s)=f|= @ValPy:  ( package , filename , line ) = caller
assignment(1, 9) =|t(s,s,s)=f|= my ( $package , $filename , $line ) = caller

Generated partial line [
Generated partial line [package
Generated partial line [package,filename
Generated partial line [package,filename,line
Generated partial line [package,filename,line]
Generated partial line [package,filename,line]=
Generated partial line [package,filename,line]=_list_of_n(
assign, ValClass[limit] = f, ValPy=caller, ValPerl=caller

function(9, 9) =|t(s,s,s)=f|= my ( $package , $filename , $line ) = caller

function start=10, end_pos=9, bracketed=-1
Generated partial line [package,filename,line]=_list_of_n(['main',__file__,sys._getframe(1).f_lineno]
Generated partial line [package,filename,line]=_list_of_n(['main',__file__,sys._getframe(1).f_lineno], 3)
 194 | 1 |   |
 195 | 1 |   |    [package,filename,line] = _list_of_n(['main',__file__,sys._getframe(1).f_lineno], 3) #PL: eval {

Tokens: t(s,s,s)=f ValPy: 
Main loop, line=eval {


 === Line 195 Perl source:eval {===

Lexem 0 Current token='C' perl='eval' value='try' Tokenstr |C| translated: try

Line:  195 TokenStr: =|C|= @ValPy: try
 195 | 1 |   |    try:                                                                                #PL: eval {

Tokens: C ValPy: 
eval_stack=HASH(0x800776fc0), eval_nest=1
Main loop, line={


 === Line 195 Perl source:{===


Line:  195 TokenStr: =|{|= @ValPy: {
eval_stack=HASH(0x800776fc0), eval_nest=1
Main loop, line=assert(scalar(@$a_ref1) == scalar(@$a_ref2));


 === Line 196 Perl source:assert(scalar(@$a_ref1) == scalar(@$a_ref2));===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='scalar' value='len' Tokenstr |c(f| translated: assert ( len
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( len (
Lexem 4 Current token='@' perl='@' value='@' Tokenstr |c(f(@| translated: assert ( len ( @
Lexem 4 Current token='s' perl='$a_ref1' value='a_ref1' Tokenstr |c(f(s| translated: assert ( len ( a_ref1
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(f(s)| translated: assert ( len ( a_ref1 )
Lexem 6 Current token='>' perl='==' value='==' Tokenstr |c(f(s)>| translated: assert ( len ( a_ref1 ) ==
Lexem 7 Current token='f' perl='scalar' value='len' Tokenstr |c(f(s)>f| translated: assert ( len ( a_ref1 ) == len
Lexem 8 Current token='(' perl='(' value='(' Tokenstr |c(f(s)>f(| translated: assert ( len ( a_ref1 ) == len (
Lexem 9 Current token='@' perl='@' value='@' Tokenstr |c(f(s)>f(@| translated: assert ( len ( a_ref1 ) == len ( @
Lexem 9 Current token='s' perl='$a_ref2' value='a_ref2' Tokenstr |c(f(s)>f(s| translated: assert ( len ( a_ref1 ) == len ( a_ref2
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |c(f(s)>f(s)| translated: assert ( len ( a_ref1 ) == len ( a_ref2 )
Lexem 11 Current token=')' perl=')' value=')' Tokenstr |c(f(s)>f(s))| translated: assert ( len ( a_ref1 ) == len ( a_ref2 ) )

Line:  196 TokenStr: =|c(f(s)>f(s))|= @ValPy: assert ( len ( a_ref1 ) == len ( a_ref2 ) )
control(0) =|c(f(s)>f(s))|= assert ( scalar ( $a_ref1 ) == scalar ( $a_ref2 ) )

control-parens removed, begin=0 start=1 =|cf(s)>f(s)|= assert scalar ( $a_ref1 ) == scalar ( $a_ref2 )

Generated partial line assert
expression(1, 9, 0) =|cf(s)>f(s)|= assert scalar ( $a_ref1 ) == scalar ( $a_ref2 )

function(1, 9) =|cf(s)>f(s)|= assert scalar ( $a_ref1 ) == scalar ( $a_ref2 )

function start=3, end_pos=3, bracketed=1
Generated partial line assertlen
Generated partial line assertlen(
expression(3, 3, 0) =|cf(s)>f(s)|= assert scalar ( $a_ref1 ) == scalar ( $a_ref2 )

Generated partial line assertlen(a_ref1
expression returns 4
Generated partial line assertlen(a_ref1)
Generated partial line assertlen(a_ref1)==
function(6, 9) =|cf(s)>f(s)|= assert scalar ( $a_ref1 ) == scalar ( $a_ref2 )

function start=8, end_pos=8, bracketed=1
Generated partial line assertlen(a_ref1)==len
Generated partial line assertlen(a_ref1)==len(
expression(8, 8, 0) =|cf(s)>f(s)|= assert scalar ( $a_ref1 ) == scalar ( $a_ref2 )

Generated partial line assertlen(a_ref1)==len(a_ref2
expression returns 9
Generated partial line assertlen(a_ref1)==len(a_ref2)
expression returns 10
 197 | 2 |   |        assert len(a_ref1) == len(a_ref2)                                               #PL: };

Tokens: cf(s)>f(s) ValPy: 
eval_stack=HASH(0x800776fc0), eval_nest=1
Main loop, line=};


 === Line 197 Perl source:};===


Line:  197 TokenStr: =|}|= @ValPy: }
eval_stack=HASH(0x800776fc0), eval_nest=1
 197 | 2 |   |        EVAL_ERROR = None                                                               #PL: ;

Tokens: } ValPy: 
 197 | 1 |   |    except Exception as _e:                                                             #PL: ;

Tokens: } ValPy: 
 197 | 2 |   |        EVAL_ERROR = _exc(_e)                                                           #PL: ;

Tokens: } ValPy: 
Main loop, line=;


 === Line 197 Perl source:;===


Line:  197 TokenStr: =||= @ValPy: 
 197 | 1 |   |    pass                                                                                #PL: ;

Tokens:  ValPy: 
Main loop, line=if($@) {


 === Line 198 Perl source:if($@) {===

Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' perl='$' value='EVAL_ERROR' Tokenstr |c(s| translated: if  ( EVAL_ERROR
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(s)| translated: if  ( EVAL_ERROR )

Line:  198 TokenStr: =|c(s)|= @ValPy: if  ( EVAL_ERROR )
control(0) =|c(s)|= if ( $ )

control-parens removed, begin=0 start=1 =|cs|= if $

Generated partial line if 
expression(1, 1, 0) =|cs|= if $

Generated partial line if EVAL_ERROR
expression returns 2
Generated partial line if EVAL_ERROR:
 198 | 1 |   |    if EVAL_ERROR:                                                                      #PL: 

Tokens: cs ValPy: 
Main loop, line={


 === Line 198 Perl source:{===


Line:  198 TokenStr: =|{|= @ValPy: {
Main loop, line=say STDERR "Assertion failed in aeq_unordered called from line $line";


 === Line 199 Perl source:say STDERR "Assertion failed in aeq_unordered called from line $line";===

Lexem 0 Current token='f' perl='say' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='i' perl='STDERR' value='sys.stderr' Tokenstr |fi| translated: print sys.stderr
Lexem 2 Current token='"' perl='Assertion failed in aeq_unordered called from line $line' value='f"Assertion failed in aeq_unordered called from line {line}"' Tokenstr |fi"| translated: print sys.stderr f"Assertion failed in aeq_unordered called from line {line}"

Line:  199 TokenStr: =|fi"|= @ValPy: print sys.stderr f"Assertion failed in aeq_unordered called from line {line}"
Generated partial line print(
print3(0) start=0, handle=sys.stderr, k=2, end_pos=2

expression(2, 2, 0) =|fi"|= say STDERR Assertion failed in aeq_unordered called from line $line

Generated partial line print(f"Assertion failed in aeq_unordered called from line {line}"
expression returns 3
Generated partial line print(f"Assertion failed in aeq_unordered called from line {line}",file=sys.stderr
Generated partial line print(f"Assertion failed in aeq_unordered called from line {line}",file=sys.stderr)
 200 | 2 |   |        print(f"Assertion failed in aeq_unordered called from line {line}",file=sys.stderr)
                                                                                                      #PL: say STDERR "scalar(\@\$a_ref1) != scalar(\@\$a_ref2), ".scalar(@$a_ref1)." != ".scalar(
                                                                                                      #+ : @$a_ref2);

Tokens: fi" ValPy: 
Main loop, line=say STDERR "scalar(\@\$a_ref1) != scalar(\@\$a_ref2), ".scalar(@$a_ref1)." != ".scalar(@$a_ref2);


 === Line 200 Perl source:say STDERR "scalar(\@\$a_ref1) != scalar(\@\$a_ref2), ".scalar(@$a_ref1)." != ".scalar(@$a_ref2);===

Lexem 0 Current token='f' perl='say' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='i' perl='STDERR' value='sys.stderr' Tokenstr |fi| translated: print sys.stderr
Lexem 2 Current token='"' perl='scalar(\@\$a_ref1) != scalar(\@\$a_ref2), ' value='f"scalar(@$a_ref1) != scalar(@$a_ref2), "' Tokenstr |fi"| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "
Lexem 3 Current token='.' perl='.' value=' + ' Tokenstr |fi".| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  + 
Lexem 4 Current token='f' perl='scalar' value='len' Tokenstr |fi".f| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len
Lexem 5 Current token='(' perl='(' value='(' Tokenstr |fi".f(| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len (
Lexem 6 Current token='@' perl='@' value='@' Tokenstr |fi".f(@| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( @
Lexem 6 Current token='s' perl='$a_ref1' value='a_ref1' Tokenstr |fi".f(s| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |fi".f(s)| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )
Lexem 8 Current token='.' perl='.' value=' + ' Tokenstr |fi".f(s).| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  + 
Lexem 9 Current token='"' perl=' != ' value='' != '' Tokenstr |fi".f(s)."| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '
Lexem 10 Current token='.' perl='.' value=' + ' Tokenstr |fi".f(s).".| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  + 
Lexem 11 Current token='f' perl='scalar' value='len' Tokenstr |fi".f(s).".f| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len
Lexem 12 Current token='(' perl='(' value='(' Tokenstr |fi".f(s).".f(| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len (
Lexem 13 Current token='@' perl='@' value='@' Tokenstr |fi".f(s).".f(@| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len ( @
Lexem 13 Current token='s' perl='$a_ref2' value='a_ref2' Tokenstr |fi".f(s).".f(s| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len ( a_ref2
Lexem 14 Current token=')' perl=')' value=')' Tokenstr |fi".f(s).".f(s)| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len ( a_ref2 )

Line:  200 TokenStr: =|fi".f(s).".f(s)|= @ValPy: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len ( a_ref2 )
fix_string_catentation2 i=3, j=8

fix_string_catentation2 i=13, j=18

Generated partial line print(
print3(0) start=0, handle=sys.stderr, k=2, end_pos=20

expression(2, 20, 0) =|fi".f(f(s)).".f(f(s))|= say STDERR scalar(\@\$a_ref1) != scalar(\@\$a_ref2),  . str ( scalar ( $a_ref1 ) ) .  !=  . str ( scalar ( $a_ref2 ) )

Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), "
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + 
function(4, 20) =|fi".f(f(s)).".f(f(s))|= say STDERR scalar(\@\$a_ref1) != scalar(\@\$a_ref2),  . str ( scalar ( $a_ref1 ) ) .  !=  . str ( scalar ( $a_ref2 ) )

function start=6, end_pos=9, bracketed=1
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(
expression(6, 9, 0) =|fi".f(f(s)).".f(f(s))|= say STDERR scalar(\@\$a_ref1) != scalar(\@\$a_ref2),  . str ( scalar ( $a_ref1 ) ) .  !=  . str ( scalar ( $a_ref2 ) )

function(6, 9) =|fi".f(f(s)).".f(f(s))|= say STDERR scalar(\@\$a_ref1) != scalar(\@\$a_ref2),  . str ( scalar ( $a_ref1 ) ) .  !=  . str ( scalar ( $a_ref2 ) )

function start=8, end_pos=8, bracketed=1
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(
expression(8, 8, 0) =|fi".f(f(s)).".f(f(s))|= say STDERR scalar(\@\$a_ref1) != scalar(\@\$a_ref2),  . str ( scalar ( $a_ref1 ) ) .  !=  . str ( scalar ( $a_ref2 ) )

Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1
expression returns 9
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)
expression returns 10
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1))
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + 
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != '
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + 
function(14, 20) =|fi".f(f(s)).".f(f(s))|= say STDERR scalar(\@\$a_ref1) != scalar(\@\$a_ref2),  . str ( scalar ( $a_ref1 ) ) .  !=  . str ( scalar ( $a_ref2 ) )

function start=16, end_pos=19, bracketed=1
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + str
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + str(
expression(16, 19, 0) =|fi".f(f(s)).".f(f(s))|= say STDERR scalar(\@\$a_ref1) != scalar(\@\$a_ref2),  . str ( scalar ( $a_ref1 ) ) .  !=  . str ( scalar ( $a_ref2 ) )

function(16, 19) =|fi".f(f(s)).".f(f(s))|= say STDERR scalar(\@\$a_ref1) != scalar(\@\$a_ref2),  . str ( scalar ( $a_ref1 ) ) .  !=  . str ( scalar ( $a_ref2 ) )

function start=18, end_pos=18, bracketed=1
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + str(len
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + str(len(
expression(18, 18, 0) =|fi".f(f(s)).".f(f(s))|= say STDERR scalar(\@\$a_ref1) != scalar(\@\$a_ref2),  . str ( scalar ( $a_ref1 ) ) .  !=  . str ( scalar ( $a_ref2 ) )

Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + str(len(a_ref2
expression returns 19
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + str(len(a_ref2)
expression returns 20
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + str(len(a_ref2))
expression returns 21
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + str(len(a_ref2)),file=sys.stderr
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + str(len(a_ref2)),file=sys.stderr)
 201 | 2 |   |        print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + str(len(a_ref2)),file=sys.stderr) #PL: die($@);

Tokens: fi".f(f(s)).".f(f(s)) ValPy: 
Main loop, line=die($@);


 === Line 201 Perl source:die($@);===

Lexem 0 Current token='f' perl='die' value='raise Die' Tokenstr |f| translated: raise Die
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |f(| translated: raise Die (
Lexem 2 Current token='s' perl='$' value='EVAL_ERROR' Tokenstr |f(s| translated: raise Die ( EVAL_ERROR
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |f(s)| translated: raise Die ( EVAL_ERROR )

Line:  201 TokenStr: =|f(s)|= @ValPy: raise Die ( EVAL_ERROR )
function(0, 3) =|f(s)|= die ( $ )

function start=2, end_pos=2, bracketed=1
Generated partial line raise Die
Generated partial line raise Die(
expression(2, 2, 0) =|f(s)|= die ( $ )

Generated partial line raise Die(EVAL_ERROR
expression returns 3
Generated partial line raise Die(EVAL_ERROR)
 202 | 2 |   |        raise Die(EVAL_ERROR)                                                           #PL: 

Tokens: f(s) ValPy: 
Main loop, line=}


 === Line 202 Perl source:}===


Line:  202 TokenStr: =|}|= @ValPy: }
 202 | 2 |   |
Main loop, line=for(my $i = 0; $i < scalar(@$a_ref1); $i++) {


 === Line 203 Perl source:for(my $i = 0; $i < scalar(@$a_ref1); $i++) {===

Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='s' perl='$i' value='i' Tokenstr |c(s| translated: for  ( i
Lexem 3 Current token='=' perl='=' value=':=' Tokenstr |c(s=| translated: for  ( i :=
Lexem 4 Current token='d' perl='0' value='0' Tokenstr |c(s=d| translated: for  ( i := 0
Lexem 5 Current token=';' perl=';' value=';' Tokenstr |c(s=d;| translated: for  ( i := 0 ;
Lexem 6 Current token='s' perl='$i' value='i' Tokenstr |c(s=d;s| translated: for  ( i := 0 ; i
Lexem 7 Current token='>' perl='<' value='<' Tokenstr |c(s=d;s>| translated: for  ( i := 0 ; i <
Lexem 8 Current token='f' perl='scalar' value='len' Tokenstr |c(s=d;s>f| translated: for  ( i := 0 ; i < len
Lexem 9 Current token='(' perl='(' value='(' Tokenstr |c(s=d;s>f(| translated: for  ( i := 0 ; i < len (
Lexem 10 Current token='@' perl='@' value='@' Tokenstr |c(s=d;s>f(@| translated: for  ( i := 0 ; i < len ( @
Lexem 10 Current token='s' perl='$a_ref1' value='a_ref1' Tokenstr |c(s=d;s>f(s| translated: for  ( i := 0 ; i < len ( a_ref1
Lexem 11 Current token=')' perl=')' value=')' Tokenstr |c(s=d;s>f(s)| translated: for  ( i := 0 ; i < len ( a_ref1 )
Lexem 12 Current token=';' perl=';' value=';' Tokenstr |c(s=d;s>f(s);| translated: for  ( i := 0 ; i < len ( a_ref1 ) ;
Lexem 13 Current token='s' perl='$i' value='i' Tokenstr |c(s=d;s>f(s);s| translated: for  ( i := 0 ; i < len ( a_ref1 ) ; i
Lexem 14 Current token='^' perl='++' value='+=1' Tokenstr |c(s=d;s>f(s);s^| translated: for  ( i := 0 ; i < len ( a_ref1 ) ; i +=1
Lexem 15 Current token=')' perl=')' value=')' Tokenstr |c(s=d;s>f(s);s^)| translated: for  ( i := 0 ; i < len ( a_ref1 ) ; i +=1 )

Line:  203 TokenStr: =|c(s=d;s>f(s);s^)|= @ValPy: for  ( i := 0 ; i < len ( a_ref1 ) ; i +=1 )
handle_incr_decr(0, 14, 15) with ++, pre_op=0, lvalue_start=13, lvalue_end=13 = 9
control(0) =|c(s=d;s>f(s);((s=s+d)-d))|= for ( $i = 0 ; $i < scalar ( $a_ref1 ) ; ( ( $i = $i + 1 ) - 1 ) )

control-parens removed, begin=0 start=1 =|cs=d;s>f(s);((s=s+d)-d)|= for $i = 0 ; $i < scalar ( $a_ref1 ) ; ( ( $i = $i + 1 ) - 1 )

Generated partial line for 
Generated partial line for i
Generated partial line for iin range(
Generated partial line for iin range(0
Generated partial line for iin range(0,
expression(7, 10, 0) =|cs=d;s>f(s);((s=s+d)-d)|= for $i = 0 ; $i < scalar ( $a_ref1 ) ; ( ( $i = $i + 1 ) - 1 )

function(7, 10) =|cs=d;s>f(s);((s=s+d)-d)|= for $i = 0 ; $i < scalar ( $a_ref1 ) ; ( ( $i = $i + 1 ) - 1 )

function start=9, end_pos=9, bracketed=1
Generated partial line for iin range(0,len
Generated partial line for iin range(0,len(
expression(9, 9, 0) =|cs=d;s>f(s);((s=s+d)-d)|= for $i = 0 ; $i < scalar ( $a_ref1 ) ; ( ( $i = $i + 1 ) - 1 )

Generated partial line for iin range(0,len(a_ref1
expression returns 10
Generated partial line for iin range(0,len(a_ref1)
expression returns 11
Generated partial line for iin range(0,len(a_ref1)):
 203 | 1 |   |    for i in range(0, len(a_ref1)):                                                     #PL: 

Tokens: cs=d;s>f(s);((s=s+d)-d) ValPy: 
Main loop, line={


 === Line 203 Perl source:{===


Line:  203 TokenStr: =|{|= @ValPy: {
Main loop, line=eval {


 === Line 204 Perl source:eval {===

Lexem 0 Current token='C' perl='eval' value='try' Tokenstr |C| translated: try

Line:  204 TokenStr: =|C|= @ValPy: try
 204 | 2 |   |        try:                                                                            #PL: eval {

Tokens: C ValPy: 
eval_stack=HASH(0x800776ed0), eval_nest=2
Main loop, line={


 === Line 204 Perl source:{===


Line:  204 TokenStr: =|{|= @ValPy: {
eval_stack=HASH(0x800776ed0), eval_nest=2
Main loop, line=$found = 0;


 === Line 205 Perl source:$found = 0;===

Lexem 0 Current token='s' perl='$found' value='found' Tokenstr |s| translated: found
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: found =
Lexem 2 Current token='d' perl='0' value='0' Tokenstr |s=d| translated: found = 0

Line:  205 TokenStr: =|s=d|= @ValPy: found = 0
assignment(0, 2) =|s=d|= $found = 0

Generated partial line found
Generated partial line found=
assign, ValClass[limit] = d, ValPy=0, ValPerl=0

Generated partial line found=0
 206 | 3 |   |            found = 0                                                                   #PL: for(my $j = 0; $j < scalar(@$a_ref2); $j++) {

Tokens: s=d ValPy: 
eval_stack=HASH(0x800776ed0), eval_nest=2
Main loop, line=for(my $j = 0; $j < scalar(@$a_ref2); $j++) {


 === Line 206 Perl source:for(my $j = 0; $j < scalar(@$a_ref2); $j++) {===

Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='s' perl='$j' value='j' Tokenstr |c(s| translated: for  ( j
Lexem 3 Current token='=' perl='=' value=':=' Tokenstr |c(s=| translated: for  ( j :=
Lexem 4 Current token='d' perl='0' value='0' Tokenstr |c(s=d| translated: for  ( j := 0
Lexem 5 Current token=';' perl=';' value=';' Tokenstr |c(s=d;| translated: for  ( j := 0 ;
Lexem 6 Current token='s' perl='$j' value='j' Tokenstr |c(s=d;s| translated: for  ( j := 0 ; j
Lexem 7 Current token='>' perl='<' value='<' Tokenstr |c(s=d;s>| translated: for  ( j := 0 ; j <
Lexem 8 Current token='f' perl='scalar' value='len' Tokenstr |c(s=d;s>f| translated: for  ( j := 0 ; j < len
Lexem 9 Current token='(' perl='(' value='(' Tokenstr |c(s=d;s>f(| translated: for  ( j := 0 ; j < len (
Lexem 10 Current token='@' perl='@' value='@' Tokenstr |c(s=d;s>f(@| translated: for  ( j := 0 ; j < len ( @
Lexem 10 Current token='s' perl='$a_ref2' value='a_ref2' Tokenstr |c(s=d;s>f(s| translated: for  ( j := 0 ; j < len ( a_ref2
Lexem 11 Current token=')' perl=')' value=')' Tokenstr |c(s=d;s>f(s)| translated: for  ( j := 0 ; j < len ( a_ref2 )
Lexem 12 Current token=';' perl=';' value=';' Tokenstr |c(s=d;s>f(s);| translated: for  ( j := 0 ; j < len ( a_ref2 ) ;
Lexem 13 Current token='s' perl='$j' value='j' Tokenstr |c(s=d;s>f(s);s| translated: for  ( j := 0 ; j < len ( a_ref2 ) ; j
Lexem 14 Current token='^' perl='++' value='+=1' Tokenstr |c(s=d;s>f(s);s^| translated: for  ( j := 0 ; j < len ( a_ref2 ) ; j +=1
Lexem 15 Current token=')' perl=')' value=')' Tokenstr |c(s=d;s>f(s);s^)| translated: for  ( j := 0 ; j < len ( a_ref2 ) ; j +=1 )

Line:  206 TokenStr: =|c(s=d;s>f(s);s^)|= @ValPy: for  ( j := 0 ; j < len ( a_ref2 ) ; j +=1 )
handle_incr_decr(0, 14, 15) with ++, pre_op=0, lvalue_start=13, lvalue_end=13 = 9
control(0) =|c(s=d;s>f(s);((s=s+d)-d))|= for ( $j = 0 ; $j < scalar ( $a_ref2 ) ; ( ( $j = $j + 1 ) - 1 ) )

control-parens removed, begin=0 start=1 =|cs=d;s>f(s);((s=s+d)-d)|= for $j = 0 ; $j < scalar ( $a_ref2 ) ; ( ( $j = $j + 1 ) - 1 )

Generated partial line for 
Generated partial line for j
Generated partial line for jin range(
Generated partial line for jin range(0
Generated partial line for jin range(0,
expression(7, 10, 0) =|cs=d;s>f(s);((s=s+d)-d)|= for $j = 0 ; $j < scalar ( $a_ref2 ) ; ( ( $j = $j + 1 ) - 1 )

function(7, 10) =|cs=d;s>f(s);((s=s+d)-d)|= for $j = 0 ; $j < scalar ( $a_ref2 ) ; ( ( $j = $j + 1 ) - 1 )

function start=9, end_pos=9, bracketed=1
Generated partial line for jin range(0,len
Generated partial line for jin range(0,len(
expression(9, 9, 0) =|cs=d;s>f(s);((s=s+d)-d)|= for $j = 0 ; $j < scalar ( $a_ref2 ) ; ( ( $j = $j + 1 ) - 1 )

Generated partial line for jin range(0,len(a_ref2
expression returns 10
Generated partial line for jin range(0,len(a_ref2)
expression returns 11
Generated partial line for jin range(0,len(a_ref2)):
 206 | 3 |   |            for j in range(0, len(a_ref2)):                                             #PL: 

Tokens: cs=d;s>f(s);((s=s+d)-d) ValPy: 
eval_stack=HASH(0x800776ed0), eval_nest=2
Main loop, line={


 === Line 206 Perl source:{===


Line:  206 TokenStr: =|{|= @ValPy: {
eval_stack=HASH(0x800776ed0), eval_nest=2
Main loop, line=if($a_ref1[$i] eq $a_ref2[$j]) {


 === Line 207 Perl source:if($a_ref1[$i] eq $a_ref2[$j]) {===

Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' perl='$a_ref1' value='a_ref1' Tokenstr |c(s| translated: if  ( a_ref1
Lexem 3 Current token='(' perl='[' value='[' Tokenstr |c(s(| translated: if  ( a_ref1 [
Lexem 4 Current token='s' perl='$i' value='i' Tokenstr |c(s(s| translated: if  ( a_ref1 [ i
Lexem 5 Current token=')' perl=']' value=']' Tokenstr |c(s(s)| translated: if  ( a_ref1 [ i ]
Lexem 6 Current token='>' perl='eq' value='==' Tokenstr |c(s(s)>| translated: if  ( a_ref1 [ i ] ==
Lexem 7 Current token='s' perl='$a_ref2' value='a_ref2' Tokenstr |c(s(s)>s| translated: if  ( a_ref1 [ i ] == a_ref2
Lexem 8 Current token='(' perl='[' value='[' Tokenstr |c(s(s)>s(| translated: if  ( a_ref1 [ i ] == a_ref2 [
Lexem 9 Current token='s' perl='$j' value='j' Tokenstr |c(s(s)>s(s| translated: if  ( a_ref1 [ i ] == a_ref2 [ j
Lexem 10 Current token=')' perl=']' value=']' Tokenstr |c(s(s)>s(s)| translated: if  ( a_ref1 [ i ] == a_ref2 [ j ]
Lexem 11 Current token=')' perl=')' value=')' Tokenstr |c(s(s)>s(s))| translated: if  ( a_ref1 [ i ] == a_ref2 [ j ] )

Line:  207 TokenStr: =|c(s(s)>s(s))|= @ValPy: if  ( a_ref1 [ i ] == a_ref2 [ j ] )
control(0) =|c(s(s)>s(s))|= if ( $a_ref1 [ $i ] eq $a_ref2 [ $j ] )

control-parens removed, begin=0 start=1 =|cs(s)>s(s)|= if $a_ref1 [ $i ] eq $a_ref2 [ $j ]

Generated partial line if 
expression(1, 9, 0) =|cs(s)>s(s)|= if $a_ref1 [ $i ] eq $a_ref2 [ $j ]

Generated partial line if a_ref1
Generated partial line if a_ref1[
expression(3, 3, 0) =|cs(s)>s(s)|= if $a_ref1 [ $i ] eq $a_ref2 [ $j ]

Generated partial line if a_ref1[i
expression returns 4
Generated partial line if a_ref1[i]
Generated partial line if a_ref1[i]==
Generated partial line if a_ref1[i]==a_ref2
Generated partial line if a_ref1[i]==a_ref2[
expression(8, 8, 0) =|cs(s)>s(s)|= if $a_ref1 [ $i ] eq $a_ref2 [ $j ]

Generated partial line if a_ref1[i]==a_ref2[j
expression returns 9
Generated partial line if a_ref1[i]==a_ref2[j]
expression returns 10
Generated partial line if a_ref1[i]==a_ref2[j]:
 207 | 4 |   |                if a_ref1[i] == a_ref2[j]:                                              #PL: 

Tokens: cs(s)>s(s) ValPy: 
eval_stack=HASH(0x800776ed0), eval_nest=2
Main loop, line={


 === Line 207 Perl source:{===


Line:  207 TokenStr: =|{|= @ValPy: {
eval_stack=HASH(0x800776ed0), eval_nest=2
Main loop, line=$found = 1;


 === Line 208 Perl source:$found = 1;===

Lexem 0 Current token='s' perl='$found' value='found' Tokenstr |s| translated: found
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: found =
Lexem 2 Current token='d' perl='1' value='1' Tokenstr |s=d| translated: found = 1

Line:  208 TokenStr: =|s=d|= @ValPy: found = 1
assignment(0, 2) =|s=d|= $found = 1

Generated partial line found
Generated partial line found=
assign, ValClass[limit] = d, ValPy=1, ValPerl=1

Generated partial line found=1
 209 | 5 |   |                    found = 1                                                           #PL: last;

Tokens: s=d ValPy: 
eval_stack=HASH(0x800776ed0), eval_nest=2
Main loop, line=last;


 === Line 209 Perl source:last;===

Lexem 0 Current token='k' perl='last' value='break ' Tokenstr |k| translated: break 

Line:  209 TokenStr: =|k|= @ValPy: break 
Generated partial line break 
 210 | 5 |   |                    break                                                               #PL: 

Tokens: k ValPy: 
eval_stack=HASH(0x800776ed0), eval_nest=2
Main loop, line=}


 === Line 210 Perl source:}===


Line:  210 TokenStr: =|}|= @ValPy: }
 210 | 5 |   |
eval_stack=HASH(0x800776ed0), eval_nest=2
Main loop, line=}


 === Line 211 Perl source:}===


Line:  211 TokenStr: =|}|= @ValPy: }
 211 | 4 |   |
eval_stack=HASH(0x800776ed0), eval_nest=2
Main loop, line=assert($found);


 === Line 212 Perl source:assert($found);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$found' value='found' Tokenstr |c(s| translated: assert ( found
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(s)| translated: assert ( found )

Line:  212 TokenStr: =|c(s)|= @ValPy: assert ( found )
control(0) =|c(s)|= assert ( $found )

control-parens removed, begin=0 start=1 =|cs|= assert $found

Generated partial line assert
expression(1, 1, 0) =|cs|= assert $found

Generated partial line assertfound
expression returns 2
 213 | 3 |   |            assert found                                                                #PL: };

Tokens: cs ValPy: 
eval_stack=HASH(0x800776ed0), eval_nest=2
Main loop, line=};


 === Line 213 Perl source:};===


Line:  213 TokenStr: =|}|= @ValPy: }
eval_stack=HASH(0x800776ed0), eval_nest=2
 213 | 3 |   |            EVAL_ERROR = None                                                           #PL: ;

Tokens: } ValPy: 
 213 | 2 |   |        except Exception as _e:                                                         #PL: ;

Tokens: } ValPy: 
 213 | 3 |   |            EVAL_ERROR = _exc(_e)                                                       #PL: ;

Tokens: } ValPy: 
Main loop, line=;


 === Line 213 Perl source:;===


Line:  213 TokenStr: =||= @ValPy: 
 213 | 2 |   |        pass                                                                            #PL: ;

Tokens:  ValPy: 
Main loop, line=if($@) {


 === Line 214 Perl source:if($@) {===

Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' perl='$' value='EVAL_ERROR' Tokenstr |c(s| translated: if  ( EVAL_ERROR
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(s)| translated: if  ( EVAL_ERROR )

Line:  214 TokenStr: =|c(s)|= @ValPy: if  ( EVAL_ERROR )
control(0) =|c(s)|= if ( $ )

control-parens removed, begin=0 start=1 =|cs|= if $

Generated partial line if 
expression(1, 1, 0) =|cs|= if $

Generated partial line if EVAL_ERROR
expression returns 2
Generated partial line if EVAL_ERROR:
 214 | 2 |   |        if EVAL_ERROR:                                                                  #PL: 

Tokens: cs ValPy: 
Main loop, line={


 === Line 214 Perl source:{===


Line:  214 TokenStr: =|{|= @ValPy: {
Main loop, line=say STDERR "\$a_ref1->[$i] not found in @{$a_ref2}";


 === Line 215 Perl source:say STDERR "\$a_ref1->[$i] not found in @{$a_ref2}";===

Lexem 0 Current token='f' perl='say' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='i' perl='STDERR' value='sys.stderr' Tokenstr |fi| translated: print sys.stderr
Lexem 2 Current token='"' perl='\$a_ref1->[$i] not found in @{$a_ref2}' value='f"$a_ref1->[{i}] not found in @{{a_ref2}}"' Tokenstr |fi"| translated: print sys.stderr f"$a_ref1->[{i}] not found in @{{a_ref2}}"

Line:  215 TokenStr: =|fi"|= @ValPy: print sys.stderr f"$a_ref1->[{i}] not found in @{{a_ref2}}"
Generated partial line print(
print3(0) start=0, handle=sys.stderr, k=2, end_pos=2

expression(2, 2, 0) =|fi"|= say STDERR \$a_ref1->[$i] not found in @{$a_ref2}

Generated partial line print(f"$a_ref1->[{i}] not found in @{{a_ref2}}"
expression returns 3
Generated partial line print(f"$a_ref1->[{i}] not found in @{{a_ref2}}",file=sys.stderr
Generated partial line print(f"$a_ref1->[{i}] not found in @{{a_ref2}}",file=sys.stderr)
 216 | 3 |   |            print(f"$a_ref1->[{i}] not found in @{{a_ref2}}",file=sys.stderr)           #PL: say STDERR "Assertion failed in aeq_unordered called from line $line";

Tokens: fi" ValPy: 
Main loop, line=say STDERR "Assertion failed in aeq_unordered called from line $line";


 === Line 216 Perl source:say STDERR "Assertion failed in aeq_unordered called from line $line";===

Lexem 0 Current token='f' perl='say' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='i' perl='STDERR' value='sys.stderr' Tokenstr |fi| translated: print sys.stderr
Lexem 2 Current token='"' perl='Assertion failed in aeq_unordered called from line $line' value='f"Assertion failed in aeq_unordered called from line {line}"' Tokenstr |fi"| translated: print sys.stderr f"Assertion failed in aeq_unordered called from line {line}"

Line:  216 TokenStr: =|fi"|= @ValPy: print sys.stderr f"Assertion failed in aeq_unordered called from line {line}"
Generated partial line print(
print3(0) start=0, handle=sys.stderr, k=2, end_pos=2

expression(2, 2, 0) =|fi"|= say STDERR Assertion failed in aeq_unordered called from line $line

Generated partial line print(f"Assertion failed in aeq_unordered called from line {line}"
expression returns 3
Generated partial line print(f"Assertion failed in aeq_unordered called from line {line}",file=sys.stderr
Generated partial line print(f"Assertion failed in aeq_unordered called from line {line}",file=sys.stderr)
 217 | 3 |   |            print(f"Assertion failed in aeq_unordered called from line {line}",file=sys.stderr) #PL: die($@);

Tokens: fi" ValPy: 
Main loop, line=die($@);


 === Line 217 Perl source:die($@);===

Lexem 0 Current token='f' perl='die' value='raise Die' Tokenstr |f| translated: raise Die
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |f(| translated: raise Die (
Lexem 2 Current token='s' perl='$' value='EVAL_ERROR' Tokenstr |f(s| translated: raise Die ( EVAL_ERROR
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |f(s)| translated: raise Die ( EVAL_ERROR )

Line:  217 TokenStr: =|f(s)|= @ValPy: raise Die ( EVAL_ERROR )
function(0, 3) =|f(s)|= die ( $ )

function start=2, end_pos=2, bracketed=1
Generated partial line raise Die
Generated partial line raise Die(
expression(2, 2, 0) =|f(s)|= die ( $ )

Generated partial line raise Die(EVAL_ERROR
expression returns 3
Generated partial line raise Die(EVAL_ERROR)
 218 | 3 |   |            raise Die(EVAL_ERROR)                                                       #PL: 

Tokens: f(s) ValPy: 
Main loop, line=}


 === Line 218 Perl source:}===


Line:  218 TokenStr: =|}|= @ValPy: }
 218 | 3 |   |
Main loop, line=}


 === Line 219 Perl source:}===


Line:  219 TokenStr: =|}|= @ValPy: }
 219 | 2 |   |
Main loop, line=}


 === Line 220 Perl source:}===


Line:  220 TokenStr: =|}|= @ValPy: }
initialize_globals_for_state_vars: 
 220 | 0 |   |
 221 | 0 |   |
Main loop, line=sub aeqi {


 === Line 222 Perl source:sub aeqi {===

Lexem 0 Current token='k' perl='sub' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' perl='aeqi' value='aeqi' Tokenstr |ki| translated: def aeqi

Line:  222 TokenStr: =|ki|= @ValPy: def aeqi
Generated partial line defaeqi(_args):
 222 | 0 |   |def aeqi(_args):                                                                        #PL: sub aeqi {

Tokens: ki ValPy: 
 222 | 1 |   |    global a_ref1,a_ref2                                                                #PL: sub aeqi {
Main loop, line={


 === Line 222 Perl source:{===


Line:  222 TokenStr: =|{|= @ValPy: {
Main loop, line=$a_ref1 = shift;


 === Line 223 Perl source:$a_ref1 = shift;===

Lexem 0 Current token='s' perl='$a_ref1' value='a_ref1' Tokenstr |s| translated: a_ref1
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: a_ref1 =
Lexem 2 Current token='f' perl='shift' value='.pop(0)' Tokenstr |s=f| translated: a_ref1 = .pop(0)

Line:  223 TokenStr: =|s=f|= @ValPy: a_ref1 = .pop(0)
assignment(0, 2) =|s=f|= $a_ref1 = shift

Generated partial line a_ref1
Generated partial line a_ref1=
assign, ValClass[limit] = f, ValPy=.pop(0), ValPerl=shift

function(2, 2) =|s=f|= $a_ref1 = shift

function start=3, end_pos=2, bracketed=-1
Generated partial line a_ref1=(_args.pop(0) if _args else None)
 224 | 1 |   |    a_ref1 = (_args.pop(0) if _args else None)                                          #PL: $a_ref2 = shift;

Tokens: s=f ValPy: 
Main loop, line=$a_ref2 = shift;


 === Line 224 Perl source:$a_ref2 = shift;===

Lexem 0 Current token='s' perl='$a_ref2' value='a_ref2' Tokenstr |s| translated: a_ref2
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: a_ref2 =
Lexem 2 Current token='f' perl='shift' value='.pop(0)' Tokenstr |s=f| translated: a_ref2 = .pop(0)

Line:  224 TokenStr: =|s=f|= @ValPy: a_ref2 = .pop(0)
assignment(0, 2) =|s=f|= $a_ref2 = shift

Generated partial line a_ref2
Generated partial line a_ref2=
assign, ValClass[limit] = f, ValPy=.pop(0), ValPerl=shift

function(2, 2) =|s=f|= $a_ref2 = shift

function start=3, end_pos=2, bracketed=-1
Generated partial line a_ref2=(_args.pop(0) if _args else None)
 225 | 1 |   |
 226 | 1 |   |    a_ref2 = (_args.pop(0) if _args else None)                                          #PL: my ($package, $filename, $line) = caller;

Tokens: s=f ValPy: 
Main loop, line=my ($package, $filename, $line) = caller;


 === Line 226 Perl source:my ($package, $filename, $line) = caller;===

Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |t(| translated:  (
Lexem 2 Current token='s' perl='$package' value='package' Tokenstr |t(s| translated:  ( package
Lexem 3 Current token=',' perl=',' value=',' Tokenstr |t(s,| translated:  ( package ,
Lexem 4 Current token='s' perl='$filename' value='filename' Tokenstr |t(s,s| translated:  ( package , filename
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |t(s,s,| translated:  ( package , filename ,
Lexem 6 Current token='s' perl='$line' value='line' Tokenstr |t(s,s,s| translated:  ( package , filename , line
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |t(s,s,s)| translated:  ( package , filename , line )
Lexem 8 Current token='=' perl='=' value='=' Tokenstr |t(s,s,s)=| translated:  ( package , filename , line ) =
Lexem 9 Current token='f' perl='caller' value='caller' Tokenstr |t(s,s,s)=f| translated:  ( package , filename , line ) = caller

Line:  226 TokenStr: =|t(s,s,s)=f|= @ValPy:  ( package , filename , line ) = caller
assignment(1, 9) =|t(s,s,s)=f|= my ( $package , $filename , $line ) = caller

Generated partial line [
Generated partial line [package
Generated partial line [package,filename
Generated partial line [package,filename,line
Generated partial line [package,filename,line]
Generated partial line [package,filename,line]=
Generated partial line [package,filename,line]=_list_of_n(
assign, ValClass[limit] = f, ValPy=caller, ValPerl=caller

function(9, 9) =|t(s,s,s)=f|= my ( $package , $filename , $line ) = caller

function start=10, end_pos=9, bracketed=-1
Generated partial line [package,filename,line]=_list_of_n(['main',__file__,sys._getframe(1).f_lineno]
Generated partial line [package,filename,line]=_list_of_n(['main',__file__,sys._getframe(1).f_lineno], 3)
 227 | 1 |   |
 228 | 1 |   |    [package,filename,line] = _list_of_n(['main',__file__,sys._getframe(1).f_lineno], 3) #PL: eval {

Tokens: t(s,s,s)=f ValPy: 
Main loop, line=eval {


 === Line 228 Perl source:eval {===

Lexem 0 Current token='C' perl='eval' value='try' Tokenstr |C| translated: try

Line:  228 TokenStr: =|C|= @ValPy: try
 228 | 1 |   |    try:                                                                                #PL: eval {

Tokens: C ValPy: 
eval_stack=HASH(0x800776e58), eval_nest=1
Main loop, line={


 === Line 228 Perl source:{===


Line:  228 TokenStr: =|{|= @ValPy: {
eval_stack=HASH(0x800776e58), eval_nest=1
Main loop, line=assert(scalar(@$a_ref1) == scalar(@$a_ref2));


 === Line 229 Perl source:assert(scalar(@$a_ref1) == scalar(@$a_ref2));===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='scalar' value='len' Tokenstr |c(f| translated: assert ( len
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( len (
Lexem 4 Current token='@' perl='@' value='@' Tokenstr |c(f(@| translated: assert ( len ( @
Lexem 4 Current token='s' perl='$a_ref1' value='a_ref1' Tokenstr |c(f(s| translated: assert ( len ( a_ref1
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(f(s)| translated: assert ( len ( a_ref1 )
Lexem 6 Current token='>' perl='==' value='==' Tokenstr |c(f(s)>| translated: assert ( len ( a_ref1 ) ==
Lexem 7 Current token='f' perl='scalar' value='len' Tokenstr |c(f(s)>f| translated: assert ( len ( a_ref1 ) == len
Lexem 8 Current token='(' perl='(' value='(' Tokenstr |c(f(s)>f(| translated: assert ( len ( a_ref1 ) == len (
Lexem 9 Current token='@' perl='@' value='@' Tokenstr |c(f(s)>f(@| translated: assert ( len ( a_ref1 ) == len ( @
Lexem 9 Current token='s' perl='$a_ref2' value='a_ref2' Tokenstr |c(f(s)>f(s| translated: assert ( len ( a_ref1 ) == len ( a_ref2
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |c(f(s)>f(s)| translated: assert ( len ( a_ref1 ) == len ( a_ref2 )
Lexem 11 Current token=')' perl=')' value=')' Tokenstr |c(f(s)>f(s))| translated: assert ( len ( a_ref1 ) == len ( a_ref2 ) )

Line:  229 TokenStr: =|c(f(s)>f(s))|= @ValPy: assert ( len ( a_ref1 ) == len ( a_ref2 ) )
control(0) =|c(f(s)>f(s))|= assert ( scalar ( $a_ref1 ) == scalar ( $a_ref2 ) )

control-parens removed, begin=0 start=1 =|cf(s)>f(s)|= assert scalar ( $a_ref1 ) == scalar ( $a_ref2 )

Generated partial line assert
expression(1, 9, 0) =|cf(s)>f(s)|= assert scalar ( $a_ref1 ) == scalar ( $a_ref2 )

function(1, 9) =|cf(s)>f(s)|= assert scalar ( $a_ref1 ) == scalar ( $a_ref2 )

function start=3, end_pos=3, bracketed=1
Generated partial line assertlen
Generated partial line assertlen(
expression(3, 3, 0) =|cf(s)>f(s)|= assert scalar ( $a_ref1 ) == scalar ( $a_ref2 )

Generated partial line assertlen(a_ref1
expression returns 4
Generated partial line assertlen(a_ref1)
Generated partial line assertlen(a_ref1)==
function(6, 9) =|cf(s)>f(s)|= assert scalar ( $a_ref1 ) == scalar ( $a_ref2 )

function start=8, end_pos=8, bracketed=1
Generated partial line assertlen(a_ref1)==len
Generated partial line assertlen(a_ref1)==len(
expression(8, 8, 0) =|cf(s)>f(s)|= assert scalar ( $a_ref1 ) == scalar ( $a_ref2 )

Generated partial line assertlen(a_ref1)==len(a_ref2
expression returns 9
Generated partial line assertlen(a_ref1)==len(a_ref2)
expression returns 10
 230 | 2 |   |        assert len(a_ref1) == len(a_ref2)                                               #PL: };

Tokens: cf(s)>f(s) ValPy: 
eval_stack=HASH(0x800776e58), eval_nest=1
Main loop, line=};


 === Line 230 Perl source:};===


Line:  230 TokenStr: =|}|= @ValPy: }
eval_stack=HASH(0x800776e58), eval_nest=1
 230 | 2 |   |        EVAL_ERROR = None                                                               #PL: ;

Tokens: } ValPy: 
 230 | 1 |   |    except Exception as _e:                                                             #PL: ;

Tokens: } ValPy: 
 230 | 2 |   |        EVAL_ERROR = _exc(_e)                                                           #PL: ;

Tokens: } ValPy: 
Main loop, line=;


 === Line 230 Perl source:;===


Line:  230 TokenStr: =||= @ValPy: 
 230 | 1 |   |    pass                                                                                #PL: ;

Tokens:  ValPy: 
Main loop, line=if($@) {


 === Line 231 Perl source:if($@) {===

Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' perl='$' value='EVAL_ERROR' Tokenstr |c(s| translated: if  ( EVAL_ERROR
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(s)| translated: if  ( EVAL_ERROR )

Line:  231 TokenStr: =|c(s)|= @ValPy: if  ( EVAL_ERROR )
control(0) =|c(s)|= if ( $ )

control-parens removed, begin=0 start=1 =|cs|= if $

Generated partial line if 
expression(1, 1, 0) =|cs|= if $

Generated partial line if EVAL_ERROR
expression returns 2
Generated partial line if EVAL_ERROR:
 231 | 1 |   |    if EVAL_ERROR:                                                                      #PL: 

Tokens: cs ValPy: 
Main loop, line={


 === Line 231 Perl source:{===


Line:  231 TokenStr: =|{|= @ValPy: {
Main loop, line=say STDERR "scalar(\@\$a_ref1) != scalar(\@\$a_ref2), ".scalar(@$a_ref1)." != ".scalar(@$a_ref2);


 === Line 232 Perl source:say STDERR "scalar(\@\$a_ref1) != scalar(\@\$a_ref2), ".scalar(@$a_ref1)." != ".scalar(@$a_ref2);===

Lexem 0 Current token='f' perl='say' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='i' perl='STDERR' value='sys.stderr' Tokenstr |fi| translated: print sys.stderr
Lexem 2 Current token='"' perl='scalar(\@\$a_ref1) != scalar(\@\$a_ref2), ' value='f"scalar(@$a_ref1) != scalar(@$a_ref2), "' Tokenstr |fi"| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "
Lexem 3 Current token='.' perl='.' value=' + ' Tokenstr |fi".| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  + 
Lexem 4 Current token='f' perl='scalar' value='len' Tokenstr |fi".f| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len
Lexem 5 Current token='(' perl='(' value='(' Tokenstr |fi".f(| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len (
Lexem 6 Current token='@' perl='@' value='@' Tokenstr |fi".f(@| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( @
Lexem 6 Current token='s' perl='$a_ref1' value='a_ref1' Tokenstr |fi".f(s| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |fi".f(s)| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )
Lexem 8 Current token='.' perl='.' value=' + ' Tokenstr |fi".f(s).| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  + 
Lexem 9 Current token='"' perl=' != ' value='' != '' Tokenstr |fi".f(s)."| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '
Lexem 10 Current token='.' perl='.' value=' + ' Tokenstr |fi".f(s).".| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  + 
Lexem 11 Current token='f' perl='scalar' value='len' Tokenstr |fi".f(s).".f| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len
Lexem 12 Current token='(' perl='(' value='(' Tokenstr |fi".f(s).".f(| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len (
Lexem 13 Current token='@' perl='@' value='@' Tokenstr |fi".f(s).".f(@| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len ( @
Lexem 13 Current token='s' perl='$a_ref2' value='a_ref2' Tokenstr |fi".f(s).".f(s| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len ( a_ref2
Lexem 14 Current token=')' perl=')' value=')' Tokenstr |fi".f(s).".f(s)| translated: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len ( a_ref2 )

Line:  232 TokenStr: =|fi".f(s).".f(s)|= @ValPy: print sys.stderr f"scalar(@$a_ref1) != scalar(@$a_ref2), "  +  len ( a_ref1 )  +  ' != '  +  len ( a_ref2 )
fix_string_catentation2 i=3, j=8

fix_string_catentation2 i=13, j=18

Generated partial line print(
print3(0) start=0, handle=sys.stderr, k=2, end_pos=20

expression(2, 20, 0) =|fi".f(f(s)).".f(f(s))|= say STDERR scalar(\@\$a_ref1) != scalar(\@\$a_ref2),  . str ( scalar ( $a_ref1 ) ) .  !=  . str ( scalar ( $a_ref2 ) )

Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), "
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + 
function(4, 20) =|fi".f(f(s)).".f(f(s))|= say STDERR scalar(\@\$a_ref1) != scalar(\@\$a_ref2),  . str ( scalar ( $a_ref1 ) ) .  !=  . str ( scalar ( $a_ref2 ) )

function start=6, end_pos=9, bracketed=1
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(
expression(6, 9, 0) =|fi".f(f(s)).".f(f(s))|= say STDERR scalar(\@\$a_ref1) != scalar(\@\$a_ref2),  . str ( scalar ( $a_ref1 ) ) .  !=  . str ( scalar ( $a_ref2 ) )

function(6, 9) =|fi".f(f(s)).".f(f(s))|= say STDERR scalar(\@\$a_ref1) != scalar(\@\$a_ref2),  . str ( scalar ( $a_ref1 ) ) .  !=  . str ( scalar ( $a_ref2 ) )

function start=8, end_pos=8, bracketed=1
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(
expression(8, 8, 0) =|fi".f(f(s)).".f(f(s))|= say STDERR scalar(\@\$a_ref1) != scalar(\@\$a_ref2),  . str ( scalar ( $a_ref1 ) ) .  !=  . str ( scalar ( $a_ref2 ) )

Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1
expression returns 9
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)
expression returns 10
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1))
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + 
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != '
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + 
function(14, 20) =|fi".f(f(s)).".f(f(s))|= say STDERR scalar(\@\$a_ref1) != scalar(\@\$a_ref2),  . str ( scalar ( $a_ref1 ) ) .  !=  . str ( scalar ( $a_ref2 ) )

function start=16, end_pos=19, bracketed=1
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + str
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + str(
expression(16, 19, 0) =|fi".f(f(s)).".f(f(s))|= say STDERR scalar(\@\$a_ref1) != scalar(\@\$a_ref2),  . str ( scalar ( $a_ref1 ) ) .  !=  . str ( scalar ( $a_ref2 ) )

function(16, 19) =|fi".f(f(s)).".f(f(s))|= say STDERR scalar(\@\$a_ref1) != scalar(\@\$a_ref2),  . str ( scalar ( $a_ref1 ) ) .  !=  . str ( scalar ( $a_ref2 ) )

function start=18, end_pos=18, bracketed=1
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + str(len
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + str(len(
expression(18, 18, 0) =|fi".f(f(s)).".f(f(s))|= say STDERR scalar(\@\$a_ref1) != scalar(\@\$a_ref2),  . str ( scalar ( $a_ref1 ) ) .  !=  . str ( scalar ( $a_ref2 ) )

Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + str(len(a_ref2
expression returns 19
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + str(len(a_ref2)
expression returns 20
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + str(len(a_ref2))
expression returns 21
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + str(len(a_ref2)),file=sys.stderr
Generated partial line print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + str(len(a_ref2)),file=sys.stderr)
 233 | 2 |   |        print(f"scalar(@$a_ref1) != scalar(@$a_ref2), " + str(len(a_ref1)) + ' != ' + str(len(a_ref2)),file=sys.stderr) #PL: say STDERR "Assertion failed in aeqi called from line $line";

Tokens: fi".f(f(s)).".f(f(s)) ValPy: 
Main loop, line=say STDERR "Assertion failed in aeqi called from line $line";


 === Line 233 Perl source:say STDERR "Assertion failed in aeqi called from line $line";===

Lexem 0 Current token='f' perl='say' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='i' perl='STDERR' value='sys.stderr' Tokenstr |fi| translated: print sys.stderr
Lexem 2 Current token='"' perl='Assertion failed in aeqi called from line $line' value='f"Assertion failed in aeqi called from line {line}"' Tokenstr |fi"| translated: print sys.stderr f"Assertion failed in aeqi called from line {line}"

Line:  233 TokenStr: =|fi"|= @ValPy: print sys.stderr f"Assertion failed in aeqi called from line {line}"
Generated partial line print(
print3(0) start=0, handle=sys.stderr, k=2, end_pos=2

expression(2, 2, 0) =|fi"|= say STDERR Assertion failed in aeqi called from line $line

Generated partial line print(f"Assertion failed in aeqi called from line {line}"
expression returns 3
Generated partial line print(f"Assertion failed in aeqi called from line {line}",file=sys.stderr
Generated partial line print(f"Assertion failed in aeqi called from line {line}",file=sys.stderr)
 234 | 2 |   |        print(f"Assertion failed in aeqi called from line {line}",file=sys.stderr)      #PL: die($@);

Tokens: fi" ValPy: 
Main loop, line=die($@);


 === Line 234 Perl source:die($@);===

Lexem 0 Current token='f' perl='die' value='raise Die' Tokenstr |f| translated: raise Die
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |f(| translated: raise Die (
Lexem 2 Current token='s' perl='$' value='EVAL_ERROR' Tokenstr |f(s| translated: raise Die ( EVAL_ERROR
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |f(s)| translated: raise Die ( EVAL_ERROR )

Line:  234 TokenStr: =|f(s)|= @ValPy: raise Die ( EVAL_ERROR )
function(0, 3) =|f(s)|= die ( $ )

function start=2, end_pos=2, bracketed=1
Generated partial line raise Die
Generated partial line raise Die(
expression(2, 2, 0) =|f(s)|= die ( $ )

Generated partial line raise Die(EVAL_ERROR
expression returns 3
Generated partial line raise Die(EVAL_ERROR)
 235 | 2 |   |        raise Die(EVAL_ERROR)                                                           #PL: 

Tokens: f(s) ValPy: 
Main loop, line=}


 === Line 235 Perl source:}===


Line:  235 TokenStr: =|}|= @ValPy: }
 235 | 2 |   |
Main loop, line=for(my $i = 0; $i < scalar(@$a_ref1); $i++) {


 === Line 236 Perl source:for(my $i = 0; $i < scalar(@$a_ref1); $i++) {===

Lexem 0 Current token='c' perl='for' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='s' perl='$i' value='i' Tokenstr |c(s| translated: for  ( i
Lexem 3 Current token='=' perl='=' value=':=' Tokenstr |c(s=| translated: for  ( i :=
Lexem 4 Current token='d' perl='0' value='0' Tokenstr |c(s=d| translated: for  ( i := 0
Lexem 5 Current token=';' perl=';' value=';' Tokenstr |c(s=d;| translated: for  ( i := 0 ;
Lexem 6 Current token='s' perl='$i' value='i' Tokenstr |c(s=d;s| translated: for  ( i := 0 ; i
Lexem 7 Current token='>' perl='<' value='<' Tokenstr |c(s=d;s>| translated: for  ( i := 0 ; i <
Lexem 8 Current token='f' perl='scalar' value='len' Tokenstr |c(s=d;s>f| translated: for  ( i := 0 ; i < len
Lexem 9 Current token='(' perl='(' value='(' Tokenstr |c(s=d;s>f(| translated: for  ( i := 0 ; i < len (
Lexem 10 Current token='@' perl='@' value='@' Tokenstr |c(s=d;s>f(@| translated: for  ( i := 0 ; i < len ( @
Lexem 10 Current token='s' perl='$a_ref1' value='a_ref1' Tokenstr |c(s=d;s>f(s| translated: for  ( i := 0 ; i < len ( a_ref1
Lexem 11 Current token=')' perl=')' value=')' Tokenstr |c(s=d;s>f(s)| translated: for  ( i := 0 ; i < len ( a_ref1 )
Lexem 12 Current token=';' perl=';' value=';' Tokenstr |c(s=d;s>f(s);| translated: for  ( i := 0 ; i < len ( a_ref1 ) ;
Lexem 13 Current token='s' perl='$i' value='i' Tokenstr |c(s=d;s>f(s);s| translated: for  ( i := 0 ; i < len ( a_ref1 ) ; i
Lexem 14 Current token='^' perl='++' value='+=1' Tokenstr |c(s=d;s>f(s);s^| translated: for  ( i := 0 ; i < len ( a_ref1 ) ; i +=1
Lexem 15 Current token=')' perl=')' value=')' Tokenstr |c(s=d;s>f(s);s^)| translated: for  ( i := 0 ; i < len ( a_ref1 ) ; i +=1 )

Line:  236 TokenStr: =|c(s=d;s>f(s);s^)|= @ValPy: for  ( i := 0 ; i < len ( a_ref1 ) ; i +=1 )
handle_incr_decr(0, 14, 15) with ++, pre_op=0, lvalue_start=13, lvalue_end=13 = 9
control(0) =|c(s=d;s>f(s);((s=s+d)-d))|= for ( $i = 0 ; $i < scalar ( $a_ref1 ) ; ( ( $i = $i + 1 ) - 1 ) )

control-parens removed, begin=0 start=1 =|cs=d;s>f(s);((s=s+d)-d)|= for $i = 0 ; $i < scalar ( $a_ref1 ) ; ( ( $i = $i + 1 ) - 1 )

Generated partial line for 
Generated partial line for i
Generated partial line for iin range(
Generated partial line for iin range(0
Generated partial line for iin range(0,
expression(7, 10, 0) =|cs=d;s>f(s);((s=s+d)-d)|= for $i = 0 ; $i < scalar ( $a_ref1 ) ; ( ( $i = $i + 1 ) - 1 )

function(7, 10) =|cs=d;s>f(s);((s=s+d)-d)|= for $i = 0 ; $i < scalar ( $a_ref1 ) ; ( ( $i = $i + 1 ) - 1 )

function start=9, end_pos=9, bracketed=1
Generated partial line for iin range(0,len
Generated partial line for iin range(0,len(
expression(9, 9, 0) =|cs=d;s>f(s);((s=s+d)-d)|= for $i = 0 ; $i < scalar ( $a_ref1 ) ; ( ( $i = $i + 1 ) - 1 )

Generated partial line for iin range(0,len(a_ref1
expression returns 10
Generated partial line for iin range(0,len(a_ref1)
expression returns 11
Generated partial line for iin range(0,len(a_ref1)):
 236 | 1 |   |    for i in range(0, len(a_ref1)):                                                     #PL: 

Tokens: cs=d;s>f(s);((s=s+d)-d) ValPy: 
Main loop, line={


 === Line 236 Perl source:{===


Line:  236 TokenStr: =|{|= @ValPy: {
Main loop, line=eval {


 === Line 237 Perl source:eval {===

Lexem 0 Current token='C' perl='eval' value='try' Tokenstr |C| translated: try

Line:  237 TokenStr: =|C|= @ValPy: try
 237 | 2 |   |        try:                                                                            #PL: eval {

Tokens: C ValPy: 
eval_stack=HASH(0x800776b70), eval_nest=2
Main loop, line={


 === Line 237 Perl source:{===


Line:  237 TokenStr: =|{|= @ValPy: {
eval_stack=HASH(0x800776b70), eval_nest=2
Main loop, line=assert($a_ref1->[$i] == $a_ref2->[$i]);


 === Line 238 Perl source:assert($a_ref1->[$i] == $a_ref2->[$i]);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$a_ref1' value='a_ref1' Tokenstr |c(s| translated: assert ( a_ref1
Lexem 3 Current token='.' perl='->' value='.' Tokenstr |c(s.| translated: assert ( a_ref1 .
Lexem 3 Current token='(' perl='[' value='[' Tokenstr |c(s(| translated: assert ( a_ref1 [
Lexem 4 Current token='s' perl='$i' value='i' Tokenstr |c(s(s| translated: assert ( a_ref1 [ i
Lexem 5 Current token=')' perl=']' value=']' Tokenstr |c(s(s)| translated: assert ( a_ref1 [ i ]
Lexem 6 Current token='>' perl='==' value='==' Tokenstr |c(s(s)>| translated: assert ( a_ref1 [ i ] ==
Lexem 7 Current token='s' perl='$a_ref2' value='a_ref2' Tokenstr |c(s(s)>s| translated: assert ( a_ref1 [ i ] == a_ref2
Lexem 8 Current token='.' perl='->' value='.' Tokenstr |c(s(s)>s.| translated: assert ( a_ref1 [ i ] == a_ref2 .
Lexem 8 Current token='(' perl='[' value='[' Tokenstr |c(s(s)>s(| translated: assert ( a_ref1 [ i ] == a_ref2 [
Lexem 9 Current token='s' perl='$i' value='i' Tokenstr |c(s(s)>s(s| translated: assert ( a_ref1 [ i ] == a_ref2 [ i
Lexem 10 Current token=')' perl=']' value=']' Tokenstr |c(s(s)>s(s)| translated: assert ( a_ref1 [ i ] == a_ref2 [ i ]
Lexem 11 Current token=')' perl=')' value=')' Tokenstr |c(s(s)>s(s))| translated: assert ( a_ref1 [ i ] == a_ref2 [ i ] )

Line:  238 TokenStr: =|c(s(s)>s(s))|= @ValPy: assert ( a_ref1 [ i ] == a_ref2 [ i ] )
control(0) =|c(s(s)>s(s))|= assert ( $a_ref1 [ $i ] == $a_ref2 [ $i ] )

control-parens removed, begin=0 start=1 =|cs(s)>s(s)|= assert $a_ref1 [ $i ] == $a_ref2 [ $i ]

Generated partial line assert
expression(1, 9, 0) =|cs(s)>s(s)|= assert $a_ref1 [ $i ] == $a_ref2 [ $i ]

Generated partial line asserta_ref1
Generated partial line asserta_ref1[
expression(3, 3, 0) =|cs(s)>s(s)|= assert $a_ref1 [ $i ] == $a_ref2 [ $i ]

Generated partial line asserta_ref1[i
expression returns 4
Generated partial line asserta_ref1[i]
Generated partial line asserta_ref1[i]==
Generated partial line asserta_ref1[i]==a_ref2
Generated partial line asserta_ref1[i]==a_ref2[
expression(8, 8, 0) =|cs(s)>s(s)|= assert $a_ref1 [ $i ] == $a_ref2 [ $i ]

Generated partial line asserta_ref1[i]==a_ref2[i
expression returns 9
Generated partial line asserta_ref1[i]==a_ref2[i]
expression returns 10
 239 | 3 |   |            assert a_ref1[i] == a_ref2[i]                                               #PL: };

Tokens: cs(s)>s(s) ValPy: 
eval_stack=HASH(0x800776b70), eval_nest=2
Main loop, line=};


 === Line 239 Perl source:};===


Line:  239 TokenStr: =|}|= @ValPy: }
eval_stack=HASH(0x800776b70), eval_nest=2
 239 | 3 |   |            EVAL_ERROR = None                                                           #PL: ;

Tokens: } ValPy: 
 239 | 2 |   |        except Exception as _e:                                                         #PL: ;

Tokens: } ValPy: 
 239 | 3 |   |            EVAL_ERROR = _exc(_e)                                                       #PL: ;

Tokens: } ValPy: 
Main loop, line=;


 === Line 239 Perl source:;===


Line:  239 TokenStr: =||= @ValPy: 
 239 | 2 |   |        pass                                                                            #PL: ;

Tokens:  ValPy: 
Main loop, line=if($@) {


 === Line 240 Perl source:if($@) {===

Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' perl='$' value='EVAL_ERROR' Tokenstr |c(s| translated: if  ( EVAL_ERROR
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(s)| translated: if  ( EVAL_ERROR )

Line:  240 TokenStr: =|c(s)|= @ValPy: if  ( EVAL_ERROR )
control(0) =|c(s)|= if ( $ )

control-parens removed, begin=0 start=1 =|cs|= if $

Generated partial line if 
expression(1, 1, 0) =|cs|= if $

Generated partial line if EVAL_ERROR
expression returns 2
Generated partial line if EVAL_ERROR:
 240 | 2 |   |        if EVAL_ERROR:                                                                  #PL: 

Tokens: cs ValPy: 
Main loop, line={


 === Line 240 Perl source:{===


Line:  240 TokenStr: =|{|= @ValPy: {
Main loop, line=say STDERR "\$a_ref1->[$i] ne \$a_ref2->[$i], $a_ref1->[$i] ne $a_ref2->[$i]";


 === Line 241 Perl source:say STDERR "\$a_ref1->[$i] ne \$a_ref2->[$i], $a_ref1->[$i] ne $a_ref2->[$i]";===

Lexem 0 Current token='f' perl='say' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='i' perl='STDERR' value='sys.stderr' Tokenstr |fi| translated: print sys.stderr
Lexem 2 Current token='"' perl='\$a_ref1->[$i] ne \$a_ref2->[$i], $a_ref1->[$i] ne $a_ref2->[$i]' value='f"$a_ref1->[{i}] ne $a_ref2->[{i}], {a_ref1}->[{i}] ne {a_ref2}->[{i}]"' Tokenstr |fi"| translated: print sys.stderr f"$a_ref1->[{i}] ne $a_ref2->[{i}], {a_ref1}->[{i}] ne {a_ref2}->[{i}]"

Line:  241 TokenStr: =|fi"|= @ValPy: print sys.stderr f"$a_ref1->[{i}] ne $a_ref2->[{i}], {a_ref1}->[{i}] ne {a_ref2}->[{i}]"
Generated partial line print(
print3(0) start=0, handle=sys.stderr, k=2, end_pos=2

expression(2, 2, 0) =|fi"|= say STDERR \$a_ref1->[$i] ne \$a_ref2->[$i], $a_ref1->[$i] ne $a_ref2->[$i]

Generated partial line print(f"$a_ref1->[{i}] ne $a_ref2->[{i}], {a_ref1}->[{i}] ne {a_ref2}->[{i}]"
expression returns 3
Generated partial line print(f"$a_ref1->[{i}] ne $a_ref2->[{i}], {a_ref1}->[{i}] ne {a_ref2}->[{i}]",file=sys.stderr
Generated partial line print(f"$a_ref1->[{i}] ne $a_ref2->[{i}], {a_ref1}->[{i}] ne {a_ref2}->[{i}]",file=sys.stderr)
 242 | 3 |   |            print(f"$a_ref1->[{i}] ne $a_ref2->[{i}], {a_ref1}->[{i}] ne {a_ref2}->[{i}]",file=sys.stderr) #PL: say STDERR "Assertion failed in aeqi called from line $line";

Tokens: fi" ValPy: 
Main loop, line=say STDERR "Assertion failed in aeqi called from line $line";


 === Line 242 Perl source:say STDERR "Assertion failed in aeqi called from line $line";===

Lexem 0 Current token='f' perl='say' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='i' perl='STDERR' value='sys.stderr' Tokenstr |fi| translated: print sys.stderr
Lexem 2 Current token='"' perl='Assertion failed in aeqi called from line $line' value='f"Assertion failed in aeqi called from line {line}"' Tokenstr |fi"| translated: print sys.stderr f"Assertion failed in aeqi called from line {line}"

Line:  242 TokenStr: =|fi"|= @ValPy: print sys.stderr f"Assertion failed in aeqi called from line {line}"
Generated partial line print(
print3(0) start=0, handle=sys.stderr, k=2, end_pos=2

expression(2, 2, 0) =|fi"|= say STDERR Assertion failed in aeqi called from line $line

Generated partial line print(f"Assertion failed in aeqi called from line {line}"
expression returns 3
Generated partial line print(f"Assertion failed in aeqi called from line {line}",file=sys.stderr
Generated partial line print(f"Assertion failed in aeqi called from line {line}",file=sys.stderr)
 243 | 3 |   |            print(f"Assertion failed in aeqi called from line {line}",file=sys.stderr)  #PL: die($@);

Tokens: fi" ValPy: 
Main loop, line=die($@);


 === Line 243 Perl source:die($@);===

Lexem 0 Current token='f' perl='die' value='raise Die' Tokenstr |f| translated: raise Die
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |f(| translated: raise Die (
Lexem 2 Current token='s' perl='$' value='EVAL_ERROR' Tokenstr |f(s| translated: raise Die ( EVAL_ERROR
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |f(s)| translated: raise Die ( EVAL_ERROR )

Line:  243 TokenStr: =|f(s)|= @ValPy: raise Die ( EVAL_ERROR )
function(0, 3) =|f(s)|= die ( $ )

function start=2, end_pos=2, bracketed=1
Generated partial line raise Die
Generated partial line raise Die(
expression(2, 2, 0) =|f(s)|= die ( $ )

Generated partial line raise Die(EVAL_ERROR
expression returns 3
Generated partial line raise Die(EVAL_ERROR)
 244 | 3 |   |            raise Die(EVAL_ERROR)                                                       #PL: 

Tokens: f(s) ValPy: 
Main loop, line=}


 === Line 244 Perl source:}===


Line:  244 TokenStr: =|}|= @ValPy: }
 244 | 3 |   |
Main loop, line=}


 === Line 245 Perl source:}===


Line:  245 TokenStr: =|}|= @ValPy: }
 245 | 2 |   |
Main loop, line=}


 === Line 246 Perl source:}===


Line:  246 TokenStr: =|}|= @ValPy: }
initialize_globals_for_state_vars: 
 246 | 0 |   |
 247 | 0 |   |
Main loop, line=print "$0 - test passed!\n";


 === Line 248 Perl source:print "$0 - test passed!\n";===

Lexem 0 Current token='f' perl='print' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='"' perl='$0 - test passed!\n' value='f"{__file__} - test passed!\n"' Tokenstr |f"| translated: print f"{__file__} - test passed!\n"

Line:  248 TokenStr: =|f"|= @ValPy: print f"{__file__} - test passed!\n"
Generated partial line print(
print3(0) start=0, handle=, k=1, end_pos=1

expression(1, 1, 0) =|f"|= print $0 - test passed!\n

Generated partial line print(f"{__file__} - test passed!\n"
expression returns 2
Generated partial line print(f"{__file__} - test passed!")
 248 | 0 |   |print(f"{__file__} - test passed!")                                                     #PL: print "$0 - test passed!\n";

Tokens: f" ValPy: 
initialize_globals_for_state_vars: 
ERROR STATISTICS:  W: 1


 [Softpano-W317]:  Debug flag is set to 5


