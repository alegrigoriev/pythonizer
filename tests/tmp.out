 [Softpano-W317]:  Debug flag is set to 5


PYTHONIZER: Fuzzy translator of Python to Perl. Version 0.923 (mtime 211212_1740) Started at 21/12/12 18:32

Logs are at /tmp/Pythonizer/pythonizer.211212_1832.log. Type -h for help.
=============================================================================================================
Results of transcription are written to the file  issue_66.py
=========================================================================================================================

Lexem 0 Current token='c' perl='use' value='NoTrans!' Tokenstr |c| translated: NoTrans!
Lexem 1 Current token='i' perl='Carp::Assert' value='Carp.Assert' Tokenstr |ci| translated: NoTrans! Carp.Assert
Lexem 0 Current token='k' perl='sub' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' perl='THISFILE' value='THISFILE' Tokenstr |ki| translated: def THISFILE
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |ki(| translated: def THISFILE (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |ki()| translated: def THISFILE ( )
enter_block at line 3, prior nesting_level=0, ValPerl=sub THISFILE ( ) {
nesting_info=is_loop  level 0 is_sub 1 lno 3 in_loop 0 is_eval  type def in_sub 1 cur_sub THISFILE
get_globals: switching to 'THISFILE' at line 3
expr_type(1, 3, THISFILE)
Lexem 0 Current token='"' perl='issue_66.pl' value=''issue_66.pl'' Tokenstr |"| translated: 'issue_66.pl'
exit_block at line 3, prior nesting_level=1
expr_type(0, 0, THISFILE)
exit_block at line 3, prior nesting_level=0
ERROR: exit_block at line 3, prior nesting_level=0 <<<<
get_globals: switching back to 'main' at line 3
merge_types(THISFILE, main, S)
Lexem 0 Current token='s' perl='$count' value='count' Tokenstr |s| translated: count
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: count =
Lexem 2 Current token='d' perl='0' value='0' Tokenstr |s=d| translated: count = 0
check_ref(main, count) at 0
expr_type(2, 2, main)
merge_types(count, main, I)
expr_type(0, 2, main)
Lexem 0 Current token='c' perl='while' value='while' Tokenstr |c| translated: while
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: while (
Lexem 2 Current token='g' perl='*.pl' value='glob.glob('*.pl')' Tokenstr |c(g| translated: while ( glob.glob('*.pl')
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(g)| translated: while ( glob.glob('*.pl') )
enter_block at line 5, prior nesting_level=0, ValPerl=while ( *.pl ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 5.
nesting_info=cur_sub  is_eval  type while in_sub 0 in_loop 1 lno 5 is_sub  is_loop 1 level 0
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='q' perl='^issue' value='re.search(r'^issue',_d)' Tokenstr |c(q| translated: assert ( re.search(r'^issue',_d)
Lexem 3 Current token='0' perl='or' value='or' Tokenstr |c(q0| translated: assert ( re.search(r'^issue',_d) or
Lexem 4 Current token='q' perl='^test' value='re.search(r'^test',_d)' Tokenstr |c(q0q| translated: assert ( re.search(r'^issue',_d) or re.search(r'^test',_d)
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(q0q)| translated: assert ( re.search(r'^issue',_d) or re.search(r'^test',_d) )
Lexem 0 Current token='s' perl='$count' value='count' Tokenstr |s| translated: count
Lexem 1 Current token='^' perl='++' value='+=1' Tokenstr |s^| translated: count +=1
check_ref(main, count) at 0
merge_types(count, main, I)
merge_types: otype=I
expr_type(0, 1, main)
Lexem 0 Current token='k' perl='last' value='break' Tokenstr |k| translated: break
exit_block at line 9, prior nesting_level=1
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$count' value='count' Tokenstr |c(s| translated: assert ( count
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(s)| translated: assert ( count )
check_ref(main, count) at 2
scalar_reference_type(2) = u
Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='s' perl='$pat' value='pat' Tokenstr |ts| translated:  pat
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ts=| translated:  pat =
Lexem 3 Current token='"' perl='*.pl' value=''*.pl'' Tokenstr |ts="| translated:  pat = '*.pl'
check_ref(main, pat) at 1
expr_type(3, 3, main)
merge_types(pat, main, S)
Lexem 0 Current token='s' perl='$count' value='count' Tokenstr |s| translated: count
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: count =
Lexem 2 Current token='d' perl='0' value='0' Tokenstr |s=d| translated: count = 0
check_ref(main, count) at 0
expr_type(2, 2, main)
merge_types(count, main, I)
merge_types: otype=I
expr_type(0, 2, main)
Lexem 0 Current token='c' perl='while' value='while' Tokenstr |c| translated: while
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: while (
Lexem 2 Current token='g' perl='$pat ' value='glob.glob(f"{pat}")' Tokenstr |c(g| translated: while ( glob.glob(f"{pat}")
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(g)| translated: while ( glob.glob(f"{pat}") )
enter_block at line 14, prior nesting_level=0, ValPerl=while ( $pat  ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 14.
nesting_info=level 0 is_loop 1 is_sub  in_loop 1 cur_sub  is_eval  type while in_sub 0 lno 14
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='q' perl='^issue' value='re.search(r'^issue',_d)' Tokenstr |c(q| translated: assert ( re.search(r'^issue',_d)
Lexem 3 Current token='0' perl='or' value='or' Tokenstr |c(q0| translated: assert ( re.search(r'^issue',_d) or
Lexem 4 Current token='q' perl='^test' value='re.search(r'^test',_d)' Tokenstr |c(q0q| translated: assert ( re.search(r'^issue',_d) or re.search(r'^test',_d)
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(q0q)| translated: assert ( re.search(r'^issue',_d) or re.search(r'^test',_d) )
Lexem 0 Current token='s' perl='$count' value='count' Tokenstr |s| translated: count
Lexem 1 Current token='^' perl='++' value='+=1' Tokenstr |s^| translated: count +=1
check_ref(main, count) at 0
merge_types(count, main, I)
merge_types: otype=I
expr_type(0, 1, main)
Lexem 0 Current token='k' perl='last' value='break' Tokenstr |k| translated: break
exit_block at line 18, prior nesting_level=1
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$count' value='count' Tokenstr |c(s| translated: assert ( count
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(s)| translated: assert ( count )
check_ref(main, count) at 2
scalar_reference_type(2) = u
Lexem 0 Current token='s' perl='$count' value='count' Tokenstr |s| translated: count
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: count =
Lexem 2 Current token='d' perl='0' value='0' Tokenstr |s=d| translated: count = 0
check_ref(main, count) at 0
expr_type(2, 2, main)
merge_types(count, main, I)
merge_types: otype=I
expr_type(0, 2, main)
Lexem 0 Current token='c' perl='while' value='while' Tokenstr |c| translated: while
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: while (
Lexem 2 Current token='g' perl='${pat}' value='glob.glob(f"{pat}")' Tokenstr |c(g| translated: while ( glob.glob(f"{pat}")
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(g)| translated: while ( glob.glob(f"{pat}") )
enter_block at line 22, prior nesting_level=0, ValPerl=while ( ${pat} ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 22.
nesting_info=in_loop 1 type while in_sub 0 is_eval  cur_sub  lno 22 is_loop 1 level 0 is_sub 
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='q' perl='^issue' value='re.search(r'^issue',_d)' Tokenstr |c(q| translated: assert ( re.search(r'^issue',_d)
Lexem 3 Current token='0' perl='or' value='or' Tokenstr |c(q0| translated: assert ( re.search(r'^issue',_d) or
Lexem 4 Current token='q' perl='^test' value='re.search(r'^test',_d)' Tokenstr |c(q0q| translated: assert ( re.search(r'^issue',_d) or re.search(r'^test',_d)
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(q0q)| translated: assert ( re.search(r'^issue',_d) or re.search(r'^test',_d) )
Lexem 0 Current token='s' perl='$count' value='count' Tokenstr |s| translated: count
Lexem 1 Current token='^' perl='++' value='+=1' Tokenstr |s^| translated: count +=1
check_ref(main, count) at 0
merge_types(count, main, I)
merge_types: otype=I
expr_type(0, 1, main)
Lexem 0 Current token='k' perl='last' value='break' Tokenstr |k| translated: break
exit_block at line 26, prior nesting_level=1
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$count' value='count' Tokenstr |c(s| translated: assert ( count
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(s)| translated: assert ( count )
check_ref(main, count) at 2
scalar_reference_type(2) = u
Lexem 0 Current token='s' perl='$count' value='count' Tokenstr |s| translated: count
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: count =
Lexem 2 Current token='d' perl='0' value='0' Tokenstr |s=d| translated: count = 0
check_ref(main, count) at 0
expr_type(2, 2, main)
merge_types(count, main, I)
merge_types: otype=I
expr_type(0, 2, main)
Lexem 0 Current token='h' perl='options' value='options' Tokenstr |h| translated: options
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |h=| translated: options =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |h=(| translated: options = (
Lexem 3 Current token='i' perl='extra' value='extra' Tokenstr |h=(i| translated: options = ( extra
Lexem 4 Current token=':' perl='=>' value=': ' Tokenstr |h=(i:| translated: options = ( extra : 
Lexem 5 Current token='"' perl='.' value=''.'' Tokenstr |h=(i:"| translated: options = ( extra :  '.'
Lexem 6 Current token=')' perl=')' value=')' Tokenstr |h=(i:")| translated: options = ( extra :  '.' )
check_ref(main, options) at 0
expr_type(2, 6, main)
expr_type(3, 5, main)
merge_types(options, main, S)
expr_type(0, 6, main)
Lexem 0 Current token='c' perl='while' value='while' Tokenstr |c| translated: while
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: while (
Lexem 2 Current token='g' perl='$options{extra}/*.pl' value='glob.glob(f"{options.get('extra','')}/*.pl")' Tokenstr |c(g| translated: while ( glob.glob(f"{options.get('extra','')}/*.pl")
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(g)| translated: while ( glob.glob(f"{options.get('extra','')}/*.pl") )
enter_block at line 31, prior nesting_level=0, ValPerl=while ( $options{extra}/*.pl ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 31.
nesting_info=is_sub  is_loop 1 level 0 in_sub 0 type while is_eval  cur_sub  in_loop 1 lno 31
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='q' perl='issue' value='re.search(r'issue',_d)' Tokenstr |c(q| translated: assert ( re.search(r'issue',_d)
Lexem 3 Current token='0' perl='or' value='or' Tokenstr |c(q0| translated: assert ( re.search(r'issue',_d) or
Lexem 4 Current token='q' perl='test' value='re.search(r'test',_d)' Tokenstr |c(q0q| translated: assert ( re.search(r'issue',_d) or re.search(r'test',_d)
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(q0q)| translated: assert ( re.search(r'issue',_d) or re.search(r'test',_d) )
Lexem 0 Current token='s' perl='$count' value='count' Tokenstr |s| translated: count
Lexem 1 Current token='^' perl='++' value='+=1' Tokenstr |s^| translated: count +=1
check_ref(main, count) at 0
merge_types(count, main, I)
merge_types: otype=I
expr_type(0, 1, main)
Lexem 0 Current token='k' perl='last' value='break' Tokenstr |k| translated: break
exit_block at line 35, prior nesting_level=1
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$count' value='count' Tokenstr |c(s| translated: assert ( count
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(s)| translated: assert ( count )
check_ref(main, count) at 2
scalar_reference_type(2) = u
Lexem 0 Current token='s' perl='$count' value='count' Tokenstr |s| translated: count
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: count =
Lexem 2 Current token='d' perl='0' value='0' Tokenstr |s=d| translated: count = 0
check_ref(main, count) at 0
expr_type(2, 2, main)
merge_types(count, main, I)
merge_types: otype=I
expr_type(0, 2, main)
Lexem 0 Current token='c' perl='while' value='while' Tokenstr |c| translated: while
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: while (
Lexem 2 Current token='g' perl='*' value='glob.glob('*')' Tokenstr |c(g| translated: while ( glob.glob('*')
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(g)| translated: while ( glob.glob('*') )
enter_block at line 39, prior nesting_level=0, ValPerl=while ( * ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 39.
nesting_info=lno 39 in_sub 0 is_eval  type while cur_sub  in_loop 1 is_sub  level 0 is_loop 1
Lexem 0 Current token='k' perl='next' value='continue' Tokenstr |k| translated: continue
Lexem 1 Current token='c' perl='if' value='if ' Tokenstr |kc| translated: continue if 
Lexem 2 Current token='!' perl='not' value='not' Tokenstr |kc!| translated: continue if  not
Lexem 3 Current token='q' perl='\.pl$' value='re.search(r'\.pl$',_d)' Tokenstr |kc!q| translated: continue if  not re.search(r'\.pl$',_d)
expr_type(1, 3, main)
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='q' perl='^issue' value='re.search(r'^issue',_d)' Tokenstr |c(q| translated: assert ( re.search(r'^issue',_d)
Lexem 3 Current token='0' perl='or' value='or' Tokenstr |c(q0| translated: assert ( re.search(r'^issue',_d) or
Lexem 4 Current token='q' perl='^test' value='re.search(r'^test',_d)' Tokenstr |c(q0q| translated: assert ( re.search(r'^issue',_d) or re.search(r'^test',_d)
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(q0q)| translated: assert ( re.search(r'^issue',_d) or re.search(r'^test',_d) )
Lexem 0 Current token='s' perl='$count' value='count' Tokenstr |s| translated: count
Lexem 1 Current token='^' perl='++' value='+=1' Tokenstr |s^| translated: count +=1
check_ref(main, count) at 0
merge_types(count, main, I)
merge_types: otype=I
expr_type(0, 1, main)
Lexem 0 Current token='k' perl='last' value='break' Tokenstr |k| translated: break
exit_block at line 44, prior nesting_level=1
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$count' value='count' Tokenstr |c(s| translated: assert ( count
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(s)| translated: assert ( count )
check_ref(main, count) at 2
scalar_reference_type(2) = u
Lexem 0 Current token='s' perl='$i' value='i' Tokenstr |s| translated: i
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: i =
Lexem 2 Current token='d' perl='10' value='10' Tokenstr |s=d| translated: i = 10
check_ref(main, i) at 0
expr_type(2, 2, main)
merge_types(i, main, I)
expr_type(0, 2, main)
Lexem 0 Current token='s' perl='$j' value='j' Tokenstr |s| translated: j
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: j =
Lexem 2 Current token='d' perl='20' value='20' Tokenstr |s=d| translated: j = 20
check_ref(main, j) at 0
expr_type(2, 2, main)
merge_types(j, main, I)
expr_type(0, 2, main)
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$i' value='i' Tokenstr |c(s| translated: assert ( i
Lexem 3 Current token='>' perl='<' value='<' Tokenstr |c(s>| translated: assert ( i <
Lexem 4 Current token='d' perl='11' value='11' Tokenstr |c(s>d| translated: assert ( i < 11
Lexem 5 Current token='0' perl='&&' value=' and ' Tokenstr |c(s>d0| translated: assert ( i < 11  and 
Lexem 6 Current token='s' perl='$j' value='j' Tokenstr |c(s>d0s| translated: assert ( i < 11  and  j
Lexem 7 Current token='>' perl='>' value='>' Tokenstr |c(s>d0s>| translated: assert ( i < 11  and  j >
Lexem 8 Current token='d' perl='19' value='19' Tokenstr |c(s>d0s>d| translated: assert ( i < 11  and  j > 19
Lexem 9 Current token=')' perl=')' value=')' Tokenstr |c(s>d0s>d)| translated: assert ( i < 11  and  j > 19 )
check_ref(main, i) at 2
scalar_reference_type(2) = I
check_ref(main, j) at 6
scalar_reference_type(6) = I
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |c((| translated: assert ( (
Lexem 3 Current token='s' perl='$i' value='i' Tokenstr |c((s| translated: assert ( ( i
Lexem 4 Current token='>' perl='<=>' value='_spaceship' Tokenstr |c((s>| translated: assert ( ( i _spaceship
Lexem 5 Current token='s' perl='$j' value='j' Tokenstr |c((s>s| translated: assert ( ( i _spaceship j
Lexem 6 Current token=')' perl=')' value=')' Tokenstr |c((s>s)| translated: assert ( ( i _spaceship j )
Lexem 7 Current token='>' perl='==' value='==' Tokenstr |c((s>s)>| translated: assert ( ( i _spaceship j ) ==
Lexem 8 Current token='-' perl='-' value='-' Tokenstr |c((s>s)>-| translated: assert ( ( i _spaceship j ) == -
Lexem 9 Current token='d' perl='1' value='1' Tokenstr |c((s>s)>-d| translated: assert ( ( i _spaceship j ) == - 1
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |c((s>s)>-d)| translated: assert ( ( i _spaceship j ) == - 1 )
check_ref(main, i) at 3
scalar_reference_type(3) = I
check_ref(main, j) at 5
scalar_reference_type(5) = I
Lexem 0 Current token='f' perl='open' value='open' Tokenstr |f| translated: open
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |f(| translated: open (
Lexem 2 Current token='i' perl='FD' value='FD' Tokenstr |f(i| translated: open ( FD
Lexem 3 Current token=',' perl=',' value=',' Tokenstr |f(i,| translated: open ( FD ,
Lexem 4 Current token='i' perl='THISFILE' value='THISFILE' Tokenstr |f(i,i| translated: open ( FD , THISFILE
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |f(i,i)| translated: open ( FD , THISFILE )
expr_type(0, 5, main)
Lexem 0 Current token='c' perl='while' value='while' Tokenstr |c| translated: while
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: while (
Lexem 3 Current token='i' perl='<FD>' value='next(_dia, None)' Tokenstr |Wc(i| translated: with fileinput.input("<FD>",openhook=lambda _,__:FD) as _dia: while ( next(_dia, None)
Lexem 4 Current token=')' perl=')' value=')' Tokenstr |Wc(i)| translated: with fileinput.input("<FD>",openhook=lambda _,__:FD) as _dia: while ( next(_dia, None) )
enter_block at line 54, prior nesting_level=0, ValPerl=<FD> while ( <FD> ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 54.
nesting_info=in_loop 1 cur_sub  is_eval  type while in_sub 0 lno 54 is_loop 1 level 0 is_sub 
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$_' value='_d' Tokenstr |c(s| translated: assert ( _d
Lexem 3 Current token='~' perl='=~' value='' Tokenstr |c(s~| translated: assert ( _d 
Lexem 4 Current token='q' perl='issue 66' value='re.search(r'issue 66',' Tokenstr |c(s~q| translated: assert ( _d  re.search(r'issue 66',
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(s~q)| translated: assert ( _d  re.search(r'issue 66', )
Lexem 6 Current token='c' perl='if' value='if ' Tokenstr |c(s~q)c| translated: assert ( _d  re.search(r'issue 66', ) if 
Lexem 7 Current token='(' perl='(' value='(' Tokenstr |c(s~q)c(| translated: assert ( _d  re.search(r'issue 66', ) if  (
Lexem 8 Current token='s' perl='$' value='fileinput.lineno()' Tokenstr |c(s~q)c(s| translated: assert ( _d  re.search(r'issue 66', ) if  ( fileinput.lineno()
Lexem 9 Current token='>' perl='eq' value='==' Tokenstr |c(s~q)c(s>| translated: assert ( _d  re.search(r'issue 66', ) if  ( fileinput.lineno() ==
Lexem 10 Current token='d' perl='1' value='1' Tokenstr |c(s~q)c(s>d| translated: assert ( _d  re.search(r'issue 66', ) if  ( fileinput.lineno() == 1
Lexem 11 Current token=')' perl=')' value=')' Tokenstr |c(s~q)c(s>d)| translated: assert ( _d  re.search(r'issue 66', ) if  ( fileinput.lineno() == 1 )
check_ref(main, _d) at 2
scalar_reference_type(2) = u
merge_types(_d, main, u)
check_ref(main, fileinput.lineno()) at 8
scalar_reference_type(8) = S
merge_types(fileinput.lineno(), main, S)
Lexem 0 Current token='k' perl='last' value='break' Tokenstr |k| translated: break
exit_block at line 57, prior nesting_level=1
Lexem 0 Current token='f' perl='close' value='.close()' Tokenstr |f| translated: .close()
Lexem 1 Current token='i' perl='FD' value='FD' Tokenstr |fi| translated: .close() FD
expr_type(0, 1, main)
Lexem 0 Current token='f' perl='open' value='open' Tokenstr |f| translated: open
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |f(| translated: open (
Lexem 2 Current token='s' perl='$fd' value='fd' Tokenstr |f(s| translated: open ( fd
Lexem 3 Current token=',' perl=',' value=',' Tokenstr |f(s,| translated: open ( fd ,
Lexem 4 Current token='"' perl='<' value=''<'' Tokenstr |f(s,"| translated: open ( fd , '<'
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |f(s,",| translated: open ( fd , '<' ,
Lexem 6 Current token='i' perl='THISFILE' value='THISFILE' Tokenstr |f(s,",i| translated: open ( fd , '<' , THISFILE
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |f(s,",i)| translated: open ( fd , '<' , THISFILE )
check_ref(main, fd) at 2
merge_types(fd, main, H)
expr_type(0, 7, main)
Lexem 0 Current token='c' perl='while' value='while' Tokenstr |c| translated: while
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: while (
Lexem 3 Current token='i' perl='<$fd>' value='next(_dia, None)' Tokenstr |Wc(i| translated: with fileinput.input("<fd>",openhook=lambda _,__:fd) as _dia: while ( next(_dia, None)
Lexem 4 Current token=')' perl=')' value=')' Tokenstr |Wc(i)| translated: with fileinput.input("<fd>",openhook=lambda _,__:fd) as _dia: while ( next(_dia, None) )
enter_block at line 60, prior nesting_level=0, ValPerl=<fd> while ( <$fd> ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 60.
nesting_info=in_sub 0 is_eval  type while cur_sub  in_loop 1 lno 60 is_sub  is_loop 1 level 0
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$_' value='_d' Tokenstr |c(s| translated: assert ( _d
Lexem 3 Current token='~' perl='=~' value='' Tokenstr |c(s~| translated: assert ( _d 
Lexem 4 Current token='q' perl='issue 66' value='re.search(r'issue 66',' Tokenstr |c(s~q| translated: assert ( _d  re.search(r'issue 66',
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(s~q)| translated: assert ( _d  re.search(r'issue 66', )
Lexem 6 Current token='c' perl='if' value='if ' Tokenstr |c(s~q)c| translated: assert ( _d  re.search(r'issue 66', ) if 
Lexem 7 Current token='(' perl='(' value='(' Tokenstr |c(s~q)c(| translated: assert ( _d  re.search(r'issue 66', ) if  (
Lexem 8 Current token='s' perl='$' value='fileinput.lineno()' Tokenstr |c(s~q)c(s| translated: assert ( _d  re.search(r'issue 66', ) if  ( fileinput.lineno()
Lexem 9 Current token='>' perl='eq' value='==' Tokenstr |c(s~q)c(s>| translated: assert ( _d  re.search(r'issue 66', ) if  ( fileinput.lineno() ==
Lexem 10 Current token='d' perl='1' value='1' Tokenstr |c(s~q)c(s>d| translated: assert ( _d  re.search(r'issue 66', ) if  ( fileinput.lineno() == 1
Lexem 11 Current token=')' perl=')' value=')' Tokenstr |c(s~q)c(s>d)| translated: assert ( _d  re.search(r'issue 66', ) if  ( fileinput.lineno() == 1 )
check_ref(main, _d) at 2
scalar_reference_type(2) = u
merge_types(_d, main, u)
merge_types: otype=u
check_ref(main, fileinput.lineno()) at 8
scalar_reference_type(8) = S
Lexem 0 Current token='k' perl='last' value='break' Tokenstr |k| translated: break
exit_block at line 63, prior nesting_level=1
Lexem 0 Current token='a' perl='@ARGV' value='sys.argv[1:]' Tokenstr |a| translated: sys.argv[1:]
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: sys.argv[1:] =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: sys.argv[1:] = (
Lexem 3 Current token='i' perl='THISFILE' value='THISFILE' Tokenstr |a=(i| translated: sys.argv[1:] = ( THISFILE
Lexem 4 Current token=')' perl=')' value=')' Tokenstr |a=(i)| translated: sys.argv[1:] = ( THISFILE )
check_ref(main, sys.argv[1:]) at 0
expr_type(2, 4, main)
expr_type(3, 3, main)
merge_types(sys.argv[1:], main, S)
expr_type(0, 4, main)
Lexem 0 Current token='s' perl='$did_one' value='did_one' Tokenstr |s| translated: did_one
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: did_one =
Lexem 2 Current token='d' perl='0' value='0' Tokenstr |s=d| translated: did_one = 0
check_ref(main, did_one) at 0
expr_type(2, 2, main)
merge_types(did_one, main, I)
expr_type(0, 2, main)
Lexem 0 Current token='c' perl='while' value='while' Tokenstr |c| translated: while
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: while (
Lexem 3 Current token='i' perl='<>' value='next(_dia, None)' Tokenstr |Wc(i| translated: with fileinput.input() as _dia: while ( next(_dia, None)
Lexem 4 Current token=')' perl=')' value=')' Tokenstr |Wc(i)| translated: with fileinput.input() as _dia: while ( next(_dia, None) )
enter_block at line 81, prior nesting_level=0, ValPerl=<> while ( <> ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 81.
nesting_info=level 0 is_loop 1 is_sub  in_loop 1 in_sub 0 type while is_eval  cur_sub  lno 81
Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' perl='$' value='fileinput.lineno()' Tokenstr |c(s| translated: if  ( fileinput.lineno()
Lexem 3 Current token='>' perl='eq' value='==' Tokenstr |c(s>| translated: if  ( fileinput.lineno() ==
Lexem 4 Current token='d' perl='1' value='1' Tokenstr |c(s>d| translated: if  ( fileinput.lineno() == 1
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(s>d)| translated: if  ( fileinput.lineno() == 1 )
enter_block at line 82, prior nesting_level=1, ValPerl=if ( $ eq 1 ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 82.
nesting_info=is_sub  level 1 is_loop  type if  is_eval  in_sub 0 cur_sub  in_loop 1 lno 82
check_ref(main, fileinput.lineno()) at 2
scalar_reference_type(2) = S
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$_' value='_d' Tokenstr |c(s| translated: assert ( _d
Lexem 3 Current token='~' perl='=~' value='' Tokenstr |c(s~| translated: assert ( _d 
Lexem 4 Current token='q' perl='issue 66' value='re.search(r'issue 66',' Tokenstr |c(s~q| translated: assert ( _d  re.search(r'issue 66',
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(s~q)| translated: assert ( _d  re.search(r'issue 66', )
Lexem 6 Current token='c' perl='if' value='if ' Tokenstr |c(s~q)c| translated: assert ( _d  re.search(r'issue 66', ) if 
Lexem 7 Current token='(' perl='(' value='(' Tokenstr |c(s~q)c(| translated: assert ( _d  re.search(r'issue 66', ) if  (
Lexem 8 Current token='s' perl='$' value='fileinput.lineno()' Tokenstr |c(s~q)c(s| translated: assert ( _d  re.search(r'issue 66', ) if  ( fileinput.lineno()
Lexem 9 Current token='>' perl='eq' value='==' Tokenstr |c(s~q)c(s>| translated: assert ( _d  re.search(r'issue 66', ) if  ( fileinput.lineno() ==
Lexem 10 Current token='d' perl='1' value='1' Tokenstr |c(s~q)c(s>d| translated: assert ( _d  re.search(r'issue 66', ) if  ( fileinput.lineno() == 1
Lexem 11 Current token=')' perl=')' value=')' Tokenstr |c(s~q)c(s>d)| translated: assert ( _d  re.search(r'issue 66', ) if  ( fileinput.lineno() == 1 )
check_ref(main, _d) at 2
scalar_reference_type(2) = u
merge_types(_d, main, u)
merge_types: otype=u
check_ref(main, fileinput.lineno()) at 8
scalar_reference_type(8) = S
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$ARGV' value='fileinput.filename()' Tokenstr |c(s| translated: assert ( fileinput.filename()
Lexem 3 Current token='~' perl='=~' value='' Tokenstr |c(s~| translated: assert ( fileinput.filename() 
Lexem 4 Current token='q' perl='issue_66.pl' value='re.search(r'issue_66.pl',' Tokenstr |c(s~q| translated: assert ( fileinput.filename()  re.search(r'issue_66.pl',
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(s~q)| translated: assert ( fileinput.filename()  re.search(r'issue_66.pl', )
check_ref(main, fileinput.filename()) at 2
scalar_reference_type(2) = u
merge_types(fileinput.filename(), main, u)
exit_block at line 85, prior nesting_level=2
Lexem 0 Current token='s' perl='$did_one' value='did_one' Tokenstr |s| translated: did_one
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: did_one =
Lexem 2 Current token='d' perl='1' value='1' Tokenstr |s=d| translated: did_one = 1
check_ref(main, did_one) at 0
expr_type(2, 2, main)
merge_types(did_one, main, I)
merge_types: otype=I
expr_type(0, 2, main)
Lexem 0 Current token='k' perl='last' value='break' Tokenstr |k| translated: break
exit_block at line 88, prior nesting_level=1
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$did_one' value='did_one' Tokenstr |c(s| translated: assert ( did_one
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(s)| translated: assert ( did_one )
check_ref(main, did_one) at 2
scalar_reference_type(2) = u
Lexem 0 Current token='a' perl='@ARGV' value='sys.argv[1:]' Tokenstr |a| translated: sys.argv[1:]
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: sys.argv[1:] =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: sys.argv[1:] = (
Lexem 3 Current token='i' perl='THISFILE' value='THISFILE' Tokenstr |a=(i| translated: sys.argv[1:] = ( THISFILE
Lexem 4 Current token=')' perl=')' value=')' Tokenstr |a=(i)| translated: sys.argv[1:] = ( THISFILE )
check_ref(main, sys.argv[1:]) at 0
expr_type(2, 4, main)
expr_type(3, 3, main)
merge_types(sys.argv[1:], main, S)
merge_types: otype=S
expr_type(0, 4, main)
Lexem 0 Current token='s' perl='$did_one' value='did_one' Tokenstr |s| translated: did_one
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: did_one =
Lexem 2 Current token='d' perl='0' value='0' Tokenstr |s=d| translated: did_one = 0
check_ref(main, did_one) at 0
expr_type(2, 2, main)
merge_types(did_one, main, I)
merge_types: otype=I
expr_type(0, 2, main)
Lexem 0 Current token='c' perl='while' value='while' Tokenstr |c| translated: while
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: while (
Lexem 3 Current token='i' perl='<' value='next(_dia, None)' Tokenstr |Wc(i| translated: with fileinput.input() as _dia: while ( next(_dia, None)
Lexem 4 Current token=')' perl=')' value=')' Tokenstr |Wc(i)| translated: with fileinput.input() as _dia: while ( next(_dia, None) )
enter_block at line 92, prior nesting_level=0, ValPerl=<> while ( < ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 92.
nesting_info=lno 92 in_sub 0 is_eval  type while cur_sub  in_loop 1 is_sub  level 0 is_loop 1
Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' perl='$' value='fileinput.lineno()' Tokenstr |c(s| translated: if  ( fileinput.lineno()
Lexem 3 Current token='>' perl='eq' value='==' Tokenstr |c(s>| translated: if  ( fileinput.lineno() ==
Lexem 4 Current token='d' perl='1' value='1' Tokenstr |c(s>d| translated: if  ( fileinput.lineno() == 1
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(s>d)| translated: if  ( fileinput.lineno() == 1 )
enter_block at line 93, prior nesting_level=1, ValPerl=if ( $ eq 1 ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 93.
nesting_info=lno 93 in_loop 1 cur_sub  is_eval  in_sub 0 type if  level 1 is_loop  is_sub 
check_ref(main, fileinput.lineno()) at 2
scalar_reference_type(2) = S
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$_' value='_d' Tokenstr |c(s| translated: assert ( _d
Lexem 3 Current token='~' perl='=~' value='' Tokenstr |c(s~| translated: assert ( _d 
Lexem 4 Current token='q' perl='issue 66' value='re.search(r'issue 66',' Tokenstr |c(s~q| translated: assert ( _d  re.search(r'issue 66',
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(s~q)| translated: assert ( _d  re.search(r'issue 66', )
Lexem 6 Current token='c' perl='if' value='if ' Tokenstr |c(s~q)c| translated: assert ( _d  re.search(r'issue 66', ) if 
Lexem 7 Current token='(' perl='(' value='(' Tokenstr |c(s~q)c(| translated: assert ( _d  re.search(r'issue 66', ) if  (
Lexem 8 Current token='s' perl='$' value='fileinput.lineno()' Tokenstr |c(s~q)c(s| translated: assert ( _d  re.search(r'issue 66', ) if  ( fileinput.lineno()
Lexem 9 Current token='>' perl='eq' value='==' Tokenstr |c(s~q)c(s>| translated: assert ( _d  re.search(r'issue 66', ) if  ( fileinput.lineno() ==
Lexem 10 Current token='d' perl='1' value='1' Tokenstr |c(s~q)c(s>d| translated: assert ( _d  re.search(r'issue 66', ) if  ( fileinput.lineno() == 1
Lexem 11 Current token=')' perl=')' value=')' Tokenstr |c(s~q)c(s>d)| translated: assert ( _d  re.search(r'issue 66', ) if  ( fileinput.lineno() == 1 )
check_ref(main, _d) at 2
scalar_reference_type(2) = u
merge_types(_d, main, u)
merge_types: otype=u
check_ref(main, fileinput.lineno()) at 8
scalar_reference_type(8) = S
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$ARGV' value='fileinput.filename()' Tokenstr |c(s| translated: assert ( fileinput.filename()
Lexem 3 Current token='~' perl='=~' value='' Tokenstr |c(s~| translated: assert ( fileinput.filename() 
Lexem 4 Current token='q' perl='issue_66.pl' value='re.search(r'issue_66.pl',' Tokenstr |c(s~q| translated: assert ( fileinput.filename()  re.search(r'issue_66.pl',
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(s~q)| translated: assert ( fileinput.filename()  re.search(r'issue_66.pl', )
check_ref(main, fileinput.filename()) at 2
scalar_reference_type(2) = u
merge_types(fileinput.filename(), main, u)
merge_types: otype=u
exit_block at line 96, prior nesting_level=2
Lexem 0 Current token='s' perl='$did_one' value='did_one' Tokenstr |s| translated: did_one
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: did_one =
Lexem 2 Current token='d' perl='1' value='1' Tokenstr |s=d| translated: did_one = 1
check_ref(main, did_one) at 0
expr_type(2, 2, main)
merge_types(did_one, main, I)
merge_types: otype=I
expr_type(0, 2, main)
Lexem 0 Current token='k' perl='last' value='break' Tokenstr |k| translated: break
exit_block at line 99, prior nesting_level=1
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$did_one' value='did_one' Tokenstr |c(s| translated: assert ( did_one
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(s)| translated: assert ( did_one )
check_ref(main, did_one) at 2
scalar_reference_type(2) = u
Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' perl='0' value='__file__' Tokenstr |c(s| translated: if  ( __file__
Lexem 3 Current token='>' perl='eq' value='==' Tokenstr |c(s>| translated: if  ( __file__ ==
Lexem 4 Current token='"' perl='issue_66.py' value=''issue_66.py'' Tokenstr |c(s>"| translated: if  ( __file__ == 'issue_66.py'
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(s>")| translated: if  ( __file__ == 'issue_66.py' )
enter_block at line 101, prior nesting_level=0, ValPerl=if ( 0 eq issue_66.py ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 101.
nesting_info=in_loop 0 cur_sub  is_eval  type if  in_sub 0 lno 101 is_loop  level 0 is_sub 
check_ref(main, __file__) at 2
scalar_reference_type(2) = S
merge_types(__file__, main, S)
Lexem 0 Current token='f' perl='open' value='open' Tokenstr |f| translated: open
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |f(| translated: open (
Lexem 2 Current token='i' perl='SOURCE' value='SOURCE' Tokenstr |f(i| translated: open ( SOURCE
Lexem 3 Current token=',' perl=',' value=',' Tokenstr |f(i,| translated: open ( SOURCE ,
Lexem 4 Current token='"' perl='<' value=''<'' Tokenstr |f(i,"| translated: open ( SOURCE , '<'
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |f(i,",| translated: open ( SOURCE , '<' ,
Lexem 6 Current token='"' perl='issue_66.py' value=''issue_66.py'' Tokenstr |f(i,","| translated: open ( SOURCE , '<' , 'issue_66.py'
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |f(i,",")| translated: open ( SOURCE , '<' , 'issue_66.py' )
expr_type(0, 7, main)
Lexem 0 Current token='s' perl='$found_start' value='found_start' Tokenstr |s| translated: found_start
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: found_start =
Lexem 2 Current token='d' perl='0' value='0' Tokenstr |s=d| translated: found_start = 0
check_ref(main, found_start) at 0
expr_type(2, 2, main)
merge_types(found_start, main, I)
expr_type(0, 2, main)
Lexem 0 Current token='s' perl='$with' value='with_' Tokenstr |s| translated: with_
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: with_ =
Lexem 2 Current token='d' perl='0' value='0' Tokenstr |s=d| translated: with_ = 0
check_ref(main, with_) at 0
expr_type(2, 2, main)
merge_types(with_, main, I)
expr_type(0, 2, main)
Lexem 0 Current token='s' perl='$while' value='while_' Tokenstr |s| translated: while_
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: while_ =
Lexem 2 Current token='d' perl='0' value='0' Tokenstr |s=d| translated: while_ = 0
check_ref(main, while_) at 0
expr_type(2, 2, main)
merge_types(while_, main, I)
expr_type(0, 2, main)
Lexem 0 Current token='c' perl='while' value='while' Tokenstr |c| translated: while
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: while (
Lexem 3 Current token='i' perl='<SOURCE>' value='next(_dia, None)' Tokenstr |Wc(i| translated: with fileinput.input("<SOURCE>",openhook=lambda _,__:SOURCE) as _dia: while ( next(_dia, None)
Lexem 4 Current token=')' perl=')' value=')' Tokenstr |Wc(i)| translated: with fileinput.input("<SOURCE>",openhook=lambda _,__:SOURCE) as _dia: while ( next(_dia, None) )
enter_block at line 107, prior nesting_level=1, ValPerl=<SOURCE> while ( <SOURCE> ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 107.
nesting_info=lno 107 cur_sub  type while is_eval  in_sub 0 in_loop 1 is_sub  level 1 is_loop 1
Lexem 0 Current token='s' perl='$found_start' value='found_start' Tokenstr |s| translated: found_start
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: found_start =
Lexem 2 Current token='d' perl='1' value='1' Tokenstr |s=d| translated: found_start = 1
Lexem 3 Current token='c' perl='if' value='if ' Tokenstr |s=dc| translated: found_start = 1 if 
Lexem 4 Current token='(' perl='(' value='(' Tokenstr |s=dc(| translated: found_start = 1 if  (
Lexem 5 Current token='f' perl='substr' value='' Tokenstr |s=dc(f| translated: found_start = 1 if  ( 
Lexem 6 Current token='(' perl='(' value='(' Tokenstr |s=dc(f(| translated: found_start = 1 if  (  (
Lexem 7 Current token='s' perl='$_' value='_d' Tokenstr |s=dc(f(s| translated: found_start = 1 if  (  ( _d
Lexem 8 Current token=',' perl=',' value=',' Tokenstr |s=dc(f(s,| translated: found_start = 1 if  (  ( _d ,
Lexem 9 Current token='d' perl='0' value='0' Tokenstr |s=dc(f(s,d| translated: found_start = 1 if  (  ( _d , 0
Lexem 10 Current token=',' perl=',' value=',' Tokenstr |s=dc(f(s,d,| translated: found_start = 1 if  (  ( _d , 0 ,
Lexem 11 Current token='d' perl='6' value='6' Tokenstr |s=dc(f(s,d,d| translated: found_start = 1 if  (  ( _d , 0 , 6
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |s=dc(f(s,d,d)| translated: found_start = 1 if  (  ( _d , 0 , 6 )
Lexem 13 Current token='>' perl='eq' value='==' Tokenstr |s=dc(f(s,d,d)>| translated: found_start = 1 if  (  ( _d , 0 , 6 ) ==
Lexem 14 Current token='"' perl='######' value=''######'' Tokenstr |s=dc(f(s,d,d)>"| translated: found_start = 1 if  (  ( _d , 0 , 6 ) == '######'
Lexem 15 Current token=')' perl=')' value=')' Tokenstr |s=dc(f(s,d,d)>")| translated: found_start = 1 if  (  ( _d , 0 , 6 ) == '######' )
check_ref(main, found_start) at 0
expr_type(2, 15, main)
merge_types(found_start, main, u)
merge_types: otype=I
check_ref(main, _d) at 7
arg_type(substr, 0) = S
scalar_reference_type(7) = S
merge_types(_d, main, S)
merge_types: otype=u
expr_type(0, 15, main)
Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' perl='$found_start' value='found_start' Tokenstr |c(s| translated: if  ( found_start
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(s)| translated: if  ( found_start )
enter_block at line 109, prior nesting_level=2, ValPerl=if ( $found_start ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 109.
nesting_info=level 2 is_loop  is_sub  lno 109 in_loop 1 is_eval  in_sub 0 type if  cur_sub 
check_ref(main, found_start) at 2
scalar_reference_type(2) = u
Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='q' perl='^    with' value='re.search(r'^    with',_d)' Tokenstr |c(q| translated: if  ( re.search(r'^    with',_d)
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(q)| translated: if  ( re.search(r'^    with',_d) )
enter_block at line 110, prior nesting_level=3, ValPerl=if ( ^    with ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 110.
nesting_info=lno 110 is_eval  type if  in_sub 0 cur_sub  in_loop 1 is_sub  level 3 is_loop 
Lexem 0 Current token='s' perl='$with' value='with_' Tokenstr |s| translated: with_
Lexem 1 Current token='^' perl='++' value='+=1' Tokenstr |s^| translated: with_ +=1
check_ref(main, with_) at 0
merge_types(with_, main, I)
merge_types: otype=I
expr_type(0, 1, main)
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='index' value='.find' Tokenstr |c(f| translated: assert ( .find
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( .find (
Lexem 4 Current token='s' perl='$_' value='_d' Tokenstr |c(f(s| translated: assert ( .find ( _d
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |c(f(s,| translated: assert ( .find ( _d ,
Lexem 6 Current token='"' perl='fileinput.input('-') as _dia:' value='"fileinput.input('-') as _dia:"' Tokenstr |c(f(s,"| translated: assert ( .find ( _d , "fileinput.input('-') as _dia:"
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |c(f(s,")| translated: assert ( .find ( _d , "fileinput.input('-') as _dia:" )
Lexem 8 Current token='>' perl='>' value='>' Tokenstr |c(f(s,")>| translated: assert ( .find ( _d , "fileinput.input('-') as _dia:" ) >
Lexem 9 Current token='d' perl='0' value='0' Tokenstr |c(f(s,")>d| translated: assert ( .find ( _d , "fileinput.input('-') as _dia:" ) > 0
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |c(f(s,")>d)| translated: assert ( .find ( _d , "fileinput.input('-') as _dia:" ) > 0 )
check_ref(main, _d) at 4
arg_type(index, 0) = S
scalar_reference_type(4) = S
exit_block at line 113, prior nesting_level=4
Lexem 0 Current token='C' perl='elsif' value='elif ' Tokenstr |C| translated: elif 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |C(| translated: elif  (
Lexem 2 Current token='q' perl='^        while' value='re.search(r'^        while',_d)' Tokenstr |C(q| translated: elif  ( re.search(r'^        while',_d)
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |C(q)| translated: elif  ( re.search(r'^        while',_d) )
enter_block at line 113, prior nesting_level=3, ValPerl=elsif ( ^        while ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 113.
nesting_info=is_sub  is_loop  level 3 lno 113 type elif  is_eval  in_sub 0 cur_sub  in_loop 1
Lexem 0 Current token='s' perl='$while' value='while_' Tokenstr |s| translated: while_
Lexem 1 Current token='^' perl='++' value='+=1' Tokenstr |s^| translated: while_ +=1
check_ref(main, while_) at 0
merge_types(while_, main, I)
merge_types: otype=I
expr_type(0, 1, main)
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='index' value='.find' Tokenstr |c(f| translated: assert ( .find
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( .find (
Lexem 4 Current token='s' perl='$_' value='_d' Tokenstr |c(f(s| translated: assert ( .find ( _d
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |c(f(s,| translated: assert ( .find ( _d ,
Lexem 6 Current token='"' perl='(_d:=next(_dia, None)):' value=''(_d:=next(_dia, None)):'' Tokenstr |c(f(s,"| translated: assert ( .find ( _d , '(_d:=next(_dia, None)):'
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |c(f(s,")| translated: assert ( .find ( _d , '(_d:=next(_dia, None)):' )
Lexem 8 Current token='>' perl='>' value='>' Tokenstr |c(f(s,")>| translated: assert ( .find ( _d , '(_d:=next(_dia, None)):' ) >
Lexem 9 Current token='d' perl='0' value='0' Tokenstr |c(f(s,")>d| translated: assert ( .find ( _d , '(_d:=next(_dia, None)):' ) > 0
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |c(f(s,")>d)| translated: assert ( .find ( _d , '(_d:=next(_dia, None)):' ) > 0 )
Lexem 11 Current token='c' perl='if' value='if ' Tokenstr |c(f(s,")>d)c| translated: assert ( .find ( _d , '(_d:=next(_dia, None)):' ) > 0 ) if 
Lexem 12 Current token='(' perl='(' value='(' Tokenstr |c(f(s,")>d)c(| translated: assert ( .find ( _d , '(_d:=next(_dia, None)):' ) > 0 ) if  (
Lexem 13 Current token='s' perl='$while' value='while_' Tokenstr |c(f(s,")>d)c(s| translated: assert ( .find ( _d , '(_d:=next(_dia, None)):' ) > 0 ) if  ( while_
Lexem 14 Current token='>' perl='==' value='==' Tokenstr |c(f(s,")>d)c(s>| translated: assert ( .find ( _d , '(_d:=next(_dia, None)):' ) > 0 ) if  ( while_ ==
Lexem 15 Current token='d' perl='1' value='1' Tokenstr |c(f(s,")>d)c(s>d| translated: assert ( .find ( _d , '(_d:=next(_dia, None)):' ) > 0 ) if  ( while_ == 1
Lexem 16 Current token=')' perl=')' value=')' Tokenstr |c(f(s,")>d)c(s>d)| translated: assert ( .find ( _d , '(_d:=next(_dia, None)):' ) > 0 ) if  ( while_ == 1 )
check_ref(main, _d) at 4
arg_type(index, 0) = S
scalar_reference_type(4) = S
check_ref(main, while_) at 13
scalar_reference_type(13) = I
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='index' value='.find' Tokenstr |c(f| translated: assert ( .find
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( .find (
Lexem 4 Current token='s' perl='$_' value='_d' Tokenstr |c(f(s| translated: assert ( .find ( _d
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |c(f(s,| translated: assert ( .find ( _d ,
Lexem 6 Current token='"' perl='(line:=next(_dia, None)):' value=''(line:=next(_dia, None)):'' Tokenstr |c(f(s,"| translated: assert ( .find ( _d , '(line:=next(_dia, None)):'
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |c(f(s,")| translated: assert ( .find ( _d , '(line:=next(_dia, None)):' )
Lexem 8 Current token='>' perl='>' value='>' Tokenstr |c(f(s,")>| translated: assert ( .find ( _d , '(line:=next(_dia, None)):' ) >
Lexem 9 Current token='d' perl='0' value='0' Tokenstr |c(f(s,")>d| translated: assert ( .find ( _d , '(line:=next(_dia, None)):' ) > 0
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |c(f(s,")>d)| translated: assert ( .find ( _d , '(line:=next(_dia, None)):' ) > 0 )
Lexem 11 Current token='c' perl='if' value='if ' Tokenstr |c(f(s,")>d)c| translated: assert ( .find ( _d , '(line:=next(_dia, None)):' ) > 0 ) if 
Lexem 12 Current token='(' perl='(' value='(' Tokenstr |c(f(s,")>d)c(| translated: assert ( .find ( _d , '(line:=next(_dia, None)):' ) > 0 ) if  (
Lexem 13 Current token='s' perl='$while' value='while_' Tokenstr |c(f(s,")>d)c(s| translated: assert ( .find ( _d , '(line:=next(_dia, None)):' ) > 0 ) if  ( while_
Lexem 14 Current token='>' perl='>' value='>' Tokenstr |c(f(s,")>d)c(s>| translated: assert ( .find ( _d , '(line:=next(_dia, None)):' ) > 0 ) if  ( while_ >
Lexem 15 Current token='d' perl='1' value='1' Tokenstr |c(f(s,")>d)c(s>d| translated: assert ( .find ( _d , '(line:=next(_dia, None)):' ) > 0 ) if  ( while_ > 1
Lexem 16 Current token=')' perl=')' value=')' Tokenstr |c(f(s,")>d)c(s>d)| translated: assert ( .find ( _d , '(line:=next(_dia, None)):' ) > 0 ) if  ( while_ > 1 )
check_ref(main, _d) at 4
arg_type(index, 0) = S
scalar_reference_type(4) = S
check_ref(main, while_) at 13
scalar_reference_type(13) = I
exit_block at line 117, prior nesting_level=4
exit_block at line 118, prior nesting_level=3
exit_block at line 119, prior nesting_level=2
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$with' value='with_' Tokenstr |c(s| translated: assert ( with_
Lexem 3 Current token='>' perl='==' value='==' Tokenstr |c(s>| translated: assert ( with_ ==
Lexem 4 Current token='d' perl='3' value='3' Tokenstr |c(s>d| translated: assert ( with_ == 3
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(s>d)| translated: assert ( with_ == 3 )
check_ref(main, with_) at 2
scalar_reference_type(2) = I
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$while' value='while_' Tokenstr |c(s| translated: assert ( while_
Lexem 3 Current token='>' perl='==' value='==' Tokenstr |c(s>| translated: assert ( while_ ==
Lexem 4 Current token='d' perl='3' value='3' Tokenstr |c(s>d| translated: assert ( while_ == 3
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(s>d)| translated: assert ( while_ == 3 )
check_ref(main, while_) at 2
scalar_reference_type(2) = I
exit_block at line 122, prior nesting_level=1
Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='d' perl='0' value='0' Tokenstr |c(d| translated: if  ( 0
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(d)| translated: if  ( 0 )
enter_block at line 125, prior nesting_level=0, ValPerl=if ( 0 ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 125.
nesting_info=is_loop  level 0 is_sub  in_loop 0 is_eval  in_sub 0 type if  cur_sub  lno 125
Lexem 0 Current token='c' perl='while' value='while' Tokenstr |c| translated: while
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: while (
Lexem 3 Current token='i' perl='<STDIN>' value='next(_dia, None)' Tokenstr |Wc(i| translated: with fileinput.input('-') as _dia: while ( next(_dia, None)
Lexem 4 Current token=')' perl=')' value=')' Tokenstr |Wc(i)| translated: with fileinput.input('-') as _dia: while ( next(_dia, None) )
enter_block at line 126, prior nesting_level=1, ValPerl=<STDIN> while ( <STDIN> ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 126.
nesting_info=lno 126 cur_sub  is_eval  type while in_sub 0 in_loop 1 is_sub  is_loop 1 level 1
exit_block at line 128, prior nesting_level=2
Lexem 0 Current token='c' perl='while' value='while' Tokenstr |c| translated: while
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: while (
Lexem 2 Current token='t' perl='my' value='' Tokenstr |c(t| translated: while ( 
Lexem 3 Current token='s' perl='$line' value='line' Tokenstr |c(ts| translated: while (  line
Lexem 4 Current token='=' perl='=' value=':=' Tokenstr |c(ts=| translated: while (  line :=
Lexem 6 Current token='i' perl='<STDIN>' value='next(_dia, None)' Tokenstr |Wc(ts=i| translated: with fileinput.input('-') as _dia: while (  line := next(_dia, None)
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |Wc(ts=i)| translated: with fileinput.input('-') as _dia: while (  line := next(_dia, None) )
enter_block at line 129, prior nesting_level=1, ValPerl=<STDIN> while ( my $line = <STDIN> ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 129.
nesting_info=is_sub  is_loop 1 level 1 cur_sub  is_eval  type while in_sub 0 in_loop 1 lno 129
check_ref(main, line) at 4
expr_type(6, 7, main)
merge_types(line, main, S)
expr_type(6, 7, main)
exit_block at line 131, prior nesting_level=2
Lexem 0 Current token='c' perl='while' value='while' Tokenstr |c| translated: while
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: while (
Lexem 2 Current token='s' perl='$line' value='line' Tokenstr |c(s| translated: while ( line
Lexem 3 Current token='=' perl='=' value=':=' Tokenstr |c(s=| translated: while ( line :=
Lexem 5 Current token='i' perl='<STDIN>' value='next(_dia, None)' Tokenstr |Wc(s=i| translated: with fileinput.input('-') as _dia: while ( line := next(_dia, None)
Lexem 6 Current token=')' perl=')' value=')' Tokenstr |Wc(s=i)| translated: with fileinput.input('-') as _dia: while ( line := next(_dia, None) )
enter_block at line 132, prior nesting_level=1, ValPerl=<STDIN> while ( $line = <STDIN> ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 132.
nesting_info=lno 132 in_sub 0 type while is_eval  cur_sub  in_loop 1 is_sub  level 1 is_loop 1
check_ref(main, line) at 3
expr_type(5, 6, main)
merge_types(line, main, S)
merge_types: otype=S
expr_type(5, 6, main)
exit_block at line 134, prior nesting_level=2
exit_block at line 135, prior nesting_level=1
Lexem 0 Current token='f' perl='print' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='"' perl='$0 - test passed!\n' value='f"{__file__} - test passed!\n"' Tokenstr |f"| translated: print f"{__file__} - test passed!\n"
expr_type(0, 1, main)
VarSubMap = $VAR1 = {
  'CHILD_ERROR' => {
    'main' => '+'
  },
  'j' => {
    'main' => '+'
  },
  'fd' => {
    'main' => '+'
  },
  'AUTODIE' => {
    'main' => '+'
  },
  'did_one' => {
    'main' => '+'
  },
  'count' => {
    'main' => '+'
  },
  '_OPEN_MODE_MAP' => {
    'main' => '+'
  },
  'options' => {
    'main' => '+'
  },
  'found_start' => {
    'main' => '+'
  },
  'LIST_SEPARATOR' => {
    'main' => '+'
  },
  '_script_start' => {
    'main' => '+'
  },
  'OS_ERROR' => {
    'main' => '+'
  },
  'TRACEBACK' => {
    'main' => '+'
  },
  '_DUP_MAP' => {
    'main' => '+'
  },
  'i' => {
    'main' => '+'
  },
  'while_' => {
    'main' => '+'
  },
  'with_' => {
    'main' => '+'
  }
};

VarType = $VAR1 = {
  'EVAL_ERROR' => {
    'main' => 'S'
  },
  '__file__' => {
    'main' => 'S'
  },
  'i' => {
    'main' => 'I'
  },
  'line' => {
    'main' => 'S'
  },
  'sys.argv' => {
    'main' => 'a of S'
  },
  'main' => {},
  'fileinput.lineno()' => {
    'main' => 'S'
  },
  'options' => {
    'main' => 'S'
  },
  'fileinput.filename()' => {
    'main' => 'u'
  },
  'fd' => {
    'main' => 'H'
  },
  '_d' => {
    'main' => 'S'
  },
  'os.environ' => {
    'main' => 'h of S'
  },
  'with_' => {
    'main' => 'I'
  },
  'next(_dia, None)' => {},
  'while_' => {
    'main' => 'I'
  },
  'LIST_SEPARATOR' => {
    'main' => 'S'
  },
  '_script_start' => {
    'main' => 'I'
  },
  'OS_ERROR' => {
    'main' => 'S'
  },
  'pat' => {
    'main' => 'S'
  },
  'sys.argv[1:]' => {
    'main' => 'S'
  },
  'did_one' => {
    'main' => 'I'
  },
  'THISFILE' => {
    'main' => 'S'
  },
  'count' => {
    'main' => 'I'
  },
  'found_start' => {
    'main' => 'I'
  },
  'j' => {
    'main' => 'I'
  },
  'os.name' => {
    'main' => 'S'
  },
  'extra' => {}
};

initialized = $VAR1 = {
  'main' => {
    'found_start' => 'u',
    'options' => 'S',
    'sys.argv' => 'a of S',
    'did_one' => 'I',
    'count' => 'I',
    'fd' => 'H',
    'os.name' => 'S',
    'j' => 'I',
    'os.environ' => 'h of S',
    'with_' => 'I',
    'while_' => 'I',
    'i' => 'I',
    'EVAL_ERROR' => 'S',
    'pat' => 'S',
    'OS_ERROR' => 'S',
    'sys.argv[1:]' => 'S',
    'line' => 'S',
    '_script_start' => 'I',
    'LIST_SEPARATOR' => 'S'
  }
};

NeedsInitializing = $VAR1 = {
  'main' => {
    '_d' => 'S',
    'fileinput.lineno()' => 'S',
    '__file__' => 'S',
    'fileinput.filename()' => 'u'
  }
};

sub_external_last_nexts = $VAR1 = {};

line_needs_try_block = $VAR1 = {};


DETECTED GLOBAL VARIABLES:

AUTO-INITIALIZED VARIABLES:

List of local subroutines:
THISFILE main
mkdir: cannot create directory /c/Users/Joe: File exists
cp: target 'Orost/Archive/pythonizer' is not a directory
cp: target 'Orost/Archive/Softpano.pm' is not a directory
cp: target 'Orost/Archive/Perlscan.pm' is not a directory
cp: target 'Orost/Archive/Pythonizer.pm' is not a directory
   1 | 0 |   |#!/usr/bin/python3 -u
   1 | 0 |   |# Generated by pythonizer 0.923 run by Joe Orost on Sun Dec 12 18:32:06 2021
   1 | 0 |   |# issue 66 - diamond operator with glob expression
   2 | 0 |   |import sys,os,re,fcntl,math,fileinput,subprocess,inspect,collections.abc,argparse,glob,warnings,inspect,functools,signal,traceback,io,tempfile,atexit,calendar
   2 | 0 |   |import time as tm_py
   2 | 0 |   |_DUP_MAP = dict(STDIN=0, STDOUT=1, STDERR=2)
   2 | 0 |   |_OPEN_MODE_MAP = {'<': 'r', '>': 'w', '+<': 'r+', '+>': 'w+', '>>': 'a', '+>>': 'a+', '|': '|-'}
   2 | 0 |   |CHILD_ERROR = 0
   2 | 0 |   |_script_start = tm_py.time()
   2 | 0 |   |LIST_SEPARATOR = ' '
   2 | 0 |   |TRACEBACK = 0
   2 | 0 |   |OS_ERROR = ''
   2 | 0 |   |AUTODIE = 0
   2 | 0 |   |class Die(Exception):
    pass
   2 | 0 |   |class EvalReturn(Exception):
    pass
   2 | 0 |   |class LoopControl(Exception):
    pass
   2 | 0 |   |_args = sys.argv[1:]
Main loop, line=use Carp::Assert;


 === Line 2 Perl source:use Carp::Assert;===

Lexem 0 Current token='c' perl='use' value='NoTrans!' Tokenstr |c| translated: NoTrans!
Lexem 1 Current token='i' perl='Carp::Assert' value='Carp.Assert' Tokenstr |ci| translated: NoTrans! Carp.Assert

Line:    2 TokenStr: =|ci|= @ValPy: NoTrans! Carp.Assert
   2 | 0 |   |#SKIPPED: use Carp::Assert;
Main loop, line=sub THISFILE () {"issue_66.pl"}


 === Line 3 Perl source:sub THISFILE () {"issue_66.pl"}===

Lexem 0 Current token='k' perl='sub' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' perl='THISFILE' value='THISFILE' Tokenstr |ki| translated: def THISFILE
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |ki(| translated: def THISFILE (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |ki()| translated: def THISFILE ( )
enter_block at line 3, prior nesting_level=0, ValPerl=sub THISFILE ( ) {
nesting_info=in_sub 1 type def is_eval  cur_sub THISFILE in_loop 0 lno 3 is_sub 1 is_loop  level 0

Line:    3 TokenStr: =|ki()|= @ValPy: def THISFILE ( )
Generated partial line defTHISFILE(_args):
   3 | 0 |   |def THISFILE(_args):                                                                    #PL: 

Tokens: ki() ValPy: 
Main loop, line={


 === Line 3 Perl source:{===


Line:    3 TokenStr: =|{|= @ValPy: {
loop_needs_try_block(0), top=in_sub 1 type def is_eval  cur_sub THISFILE in_loop 0 lno 3 is_sub 1 is_loop  level 0
Main loop, line="issue_66.pl"}


 === Line 3 Perl source:"issue_66.pl"}===

Lexem 0 Current token='"' perl='issue_66.pl' value=''issue_66.pl'' Tokenstr |"| translated: 'issue_66.pl'
exit_block at line 3, prior nesting_level=1

Line:    3 TokenStr: =|"|= @ValPy: 'issue_66.pl'
Main loop: Unknown statement (")
finish: prev_line="issue_66.pl"}, PythonCode=
finish: Resetting line to return "issue_66.pl";
Main loop, line=return "issue_66.pl";


 === Line 3 Perl source:return "issue_66.pl";===

Lexem 0 Current token='k' perl='return' value='return' Tokenstr |k| translated: return
Lexem 1 Current token='"' perl='issue_66.pl' value=''issue_66.pl'' Tokenstr |k"| translated: return 'issue_66.pl'

Line:    3 TokenStr: =|k"|= @ValPy: return 'issue_66.pl'
Generated partial line return
expression(1, 1, 0) =|k"|= return issue_66.pl

Generated partial line return'issue_66.pl'
expression returns 2
   3 | 1 |   |    return 'issue_66.pl'                                                                #PL: 

Tokens: k" ValPy: 
Main loop, line=}


 === Line 3 Perl source:}===

exit_block at line 3, prior nesting_level=0
ERROR: exit_block at line 3, prior nesting_level=0 <<<<

Line:    3 TokenStr: =|}|= @ValPy: }
loop_needs_try_block(1), top=in_sub 1 type def is_eval  cur_sub THISFILE in_loop 0 lno 3 is_sub 1 is_loop  level 0
initialize_globals_for_state_vars: 
   3 | 0 |   |
Main loop, line=$count = 0;


 === Line 4 Perl source:$count = 0;===

Lexem 0 Current token='s' perl='$count' value='count' Tokenstr |s| translated: count
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: count =
Lexem 2 Current token='d' perl='0' value='0' Tokenstr |s=d| translated: count = 0

Line:    4 TokenStr: =|s=d|= @ValPy: count = 0
assignment(0, 2) =|s=d|= $count = 0

Generated partial line count
Generated partial line count=
assign, ValClass[limit] = d, ValPy=0, ValPerl=0

Generated partial line count=0
   5 | 0 |   |count = 0                                                                               #PL: while (<*.pl>) {

Tokens: s=d ValPy: 
Main loop, line=while (<*.pl>) {


 === Line 5 Perl source:while (<*.pl>) {===

Lexem 0 Current token='c' perl='while' value='while' Tokenstr |c| translated: while
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: while (
Lexem 2 Current token='g' perl='*.pl' value='glob.glob('*.pl')' Tokenstr |c(g| translated: while ( glob.glob('*.pl')
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(g)| translated: while ( glob.glob('*.pl') )
enter_block at line 5, prior nesting_level=0, ValPerl=while ( *.pl ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 5.
nesting_info=is_loop 1 level 0 is_sub  lno 5 in_loop 1 type while is_eval  in_sub 0 cur_sub 

Line:    5 TokenStr: =|c(g)|= @ValPy: while ( glob.glob('*.pl') )
control(0) =|c(g)|= while ( *.pl )

control-parens removed, begin=0 start=1 =|cg|= while *.pl

   5 | 0 |   |_g = glob.glob('*.pl')                                                                  #PL: while (<*.pl>) {

Tokens: cg ValPy: 
Generated partial line for _d in _g
Generated partial line for _d in _g:
   5 | 0 |   |for _d in _g:                                                                           #PL: 

Tokens: cg ValPy: 
Main loop, line={


 === Line 5 Perl source:{===


Line:    5 TokenStr: =|{|= @ValPy: {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 5.
loop_needs_try_block(0), top=is_loop 1 level 0 is_sub  lno 5 in_loop 1 type while is_eval  in_sub 0 cur_sub 
Main loop, line=assert(/^issue/ or /^test/);


 === Line 6 Perl source:assert(/^issue/ or /^test/);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='q' perl='^issue' value='re.search(r'^issue',_d)' Tokenstr |c(q| translated: assert ( re.search(r'^issue',_d)
Lexem 3 Current token='0' perl='or' value='or' Tokenstr |c(q0| translated: assert ( re.search(r'^issue',_d) or
Lexem 4 Current token='q' perl='^test' value='re.search(r'^test',_d)' Tokenstr |c(q0q| translated: assert ( re.search(r'^issue',_d) or re.search(r'^test',_d)
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(q0q)| translated: assert ( re.search(r'^issue',_d) or re.search(r'^test',_d) )

Line:    6 TokenStr: =|c(q0q)|= @ValPy: assert ( re.search(r'^issue',_d) or re.search(r'^test',_d) )
control(0) =|c(q0q)|= assert ( ^issue or ^test )

control-parens removed, begin=0 start=1 =|cq0q|= assert ^issue or ^test

Generated partial line assert
expression(1, 3, 0) =|cq0q|= assert ^issue or ^test

Generated partial line assertre.search(r'^issue',_d)
Generated partial line assertre.search(r'^issue',_d)or
Generated partial line assertre.search(r'^issue',_d)orre.search(r'^test',_d)
expression returns 4
   7 | 1 |   |    assert re.search(r'^issue',_d) or re.search(r'^test',_d)                            #PL: $count++;

Tokens: cq0q ValPy: 
Main loop, line=$count++;


 === Line 7 Perl source:$count++;===

Lexem 0 Current token='s' perl='$count' value='count' Tokenstr |s| translated: count
Lexem 1 Current token='^' perl='++' value='+=1' Tokenstr |s^| translated: count +=1

Line:    7 TokenStr: =|s^|= @ValPy: count +=1
handle_incr_decr(0, 1, 1) with ++assignment(0, 1) =|s^|= $count ++

Generated partial line count+=1
   8 | 1 |   |    count+=1                                                                            #PL: last;

Tokens: s^ ValPy: 
Main loop, line=last;


 === Line 8 Perl source:last;===

Lexem 0 Current token='k' perl='last' value='break' Tokenstr |k| translated: break

Line:    8 TokenStr: =|k|= @ValPy: break
Generated partial line break
   9 | 1 |   |    break                                                                               #PL: 

Tokens: k ValPy: 
Main loop, line=}


 === Line 9 Perl source:}===

exit_block at line 9, prior nesting_level=1

Line:    9 TokenStr: =|}|= @ValPy: }
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 9.
loop_needs_try_block(1), top=is_loop 1 level 0 is_sub  lno 5 in_loop 1 type while is_eval  in_sub 0 cur_sub 
initialize_globals_for_state_vars: 
   9 | 0 |   |
Main loop, line=assert($count);


 === Line 10 Perl source:assert($count);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$count' value='count' Tokenstr |c(s| translated: assert ( count
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(s)| translated: assert ( count )

Line:   10 TokenStr: =|c(s)|= @ValPy: assert ( count )
control(0) =|c(s)|= assert ( $count )

control-parens removed, begin=0 start=1 =|cs|= assert $count

Generated partial line assert
expression(1, 1, 0) =|cs|= assert $count

Generated partial line assertcount
expression returns 2
  11 | 0 |   |
  12 | 0 |   |assert count                                                                            #PL: my $pat = '*.pl';

Tokens: cs ValPy: 
Main loop, line=my $pat = '*.pl';


 === Line 12 Perl source:my $pat = '*.pl';===

Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='s' perl='$pat' value='pat' Tokenstr |ts| translated:  pat
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ts=| translated:  pat =
Lexem 3 Current token='"' perl='*.pl' value=''*.pl'' Tokenstr |ts="| translated:  pat = '*.pl'

Line:   12 TokenStr: =|ts="|= @ValPy:  pat = '*.pl'
  12 | 0 |   |pat='*.pl'                                                                              #PL: my $pat = '*.pl';
Main loop, line=$count = 0;


 === Line 13 Perl source:$count = 0;===

Lexem 0 Current token='s' perl='$count' value='count' Tokenstr |s| translated: count
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: count =
Lexem 2 Current token='d' perl='0' value='0' Tokenstr |s=d| translated: count = 0

Line:   13 TokenStr: =|s=d|= @ValPy: count = 0
assignment(0, 2) =|s=d|= $count = 0

Generated partial line count
Generated partial line count=
assign, ValClass[limit] = d, ValPy=0, ValPerl=0

Generated partial line count=0
  14 | 0 |   |count = 0                                                                               #PL: while (<$pat >) {		# note the space makes it a glob not a readline

Tokens: s=d ValPy: 
Main loop, line=while (<$pat >) {		# note the space makes it a glob not a readline


 === Line 14 Perl source:while (<$pat >) {		# note the space makes it a glob not a readline===

Lexem 0 Current token='c' perl='while' value='while' Tokenstr |c| translated: while
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: while (
Lexem 2 Current token='g' perl='$pat ' value='glob.glob(f"{pat}")' Tokenstr |c(g| translated: while ( glob.glob(f"{pat}")
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(g)| translated: while ( glob.glob(f"{pat}") )
enter_block at line 14, prior nesting_level=0, ValPerl=while ( $pat  ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 14.
nesting_info=is_sub  is_loop 1 level 0 cur_sub  in_sub 0 type while is_eval  in_loop 1 lno 14

Line:   14 TokenStr: =|c(g)|= @ValPy: while ( glob.glob(f"{pat}") )
control(0) =|c(g)|= while ( $pat  )

control-parens removed, begin=0 start=1 =|cg|= while $pat 

  14 | 0 |   |_g = glob.glob(f"{pat}")                                                                #PL: while (<$pat >) {		# note the space makes it a glob not a readline

Tokens: cg ValPy: 
Generated partial line for _d in _g
Generated partial line for _d in _g:
  14 | 0 |   |for _d in _g:                                                                           #PL: 

Tokens: cg ValPy: 
Main loop, line={


 === Line 14 Perl source:{===


Line:   14 TokenStr: =|{|= @ValPy: {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 14.
loop_needs_try_block(0), top=is_sub  is_loop 1 level 0 cur_sub  in_sub 0 type while is_eval  in_loop 1 lno 14
  14 | 0 |   |# note the space makes it a glob not a readline
Main loop, line=assert(/^issue/ or /^test/);


 === Line 15 Perl source:assert(/^issue/ or /^test/);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='q' perl='^issue' value='re.search(r'^issue',_d)' Tokenstr |c(q| translated: assert ( re.search(r'^issue',_d)
Lexem 3 Current token='0' perl='or' value='or' Tokenstr |c(q0| translated: assert ( re.search(r'^issue',_d) or
Lexem 4 Current token='q' perl='^test' value='re.search(r'^test',_d)' Tokenstr |c(q0q| translated: assert ( re.search(r'^issue',_d) or re.search(r'^test',_d)
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(q0q)| translated: assert ( re.search(r'^issue',_d) or re.search(r'^test',_d) )

Line:   15 TokenStr: =|c(q0q)|= @ValPy: assert ( re.search(r'^issue',_d) or re.search(r'^test',_d) )
control(0) =|c(q0q)|= assert ( ^issue or ^test )

control-parens removed, begin=0 start=1 =|cq0q|= assert ^issue or ^test

Generated partial line assert
expression(1, 3, 0) =|cq0q|= assert ^issue or ^test

Generated partial line assertre.search(r'^issue',_d)
Generated partial line assertre.search(r'^issue',_d)or
Generated partial line assertre.search(r'^issue',_d)orre.search(r'^test',_d)
expression returns 4
  16 | 1 |   |    assert re.search(r'^issue',_d) or re.search(r'^test',_d)                            #PL: $count++;

Tokens: cq0q ValPy: 
Main loop, line=$count++;


 === Line 16 Perl source:$count++;===

Lexem 0 Current token='s' perl='$count' value='count' Tokenstr |s| translated: count
Lexem 1 Current token='^' perl='++' value='+=1' Tokenstr |s^| translated: count +=1

Line:   16 TokenStr: =|s^|= @ValPy: count +=1
handle_incr_decr(0, 1, 1) with ++assignment(0, 1) =|s^|= $count ++

Generated partial line count+=1
  17 | 1 |   |    count+=1                                                                            #PL: last;

Tokens: s^ ValPy: 
Main loop, line=last;


 === Line 17 Perl source:last;===

Lexem 0 Current token='k' perl='last' value='break' Tokenstr |k| translated: break

Line:   17 TokenStr: =|k|= @ValPy: break
Generated partial line break
  18 | 1 |   |    break                                                                               #PL: 

Tokens: k ValPy: 
Main loop, line=}


 === Line 18 Perl source:}===

exit_block at line 18, prior nesting_level=1

Line:   18 TokenStr: =|}|= @ValPy: }
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 18.
loop_needs_try_block(1), top=is_sub  is_loop 1 level 0 cur_sub  in_sub 0 type while is_eval  in_loop 1 lno 14
initialize_globals_for_state_vars: 
  18 | 0 |   |
Main loop, line=assert($count);


 === Line 19 Perl source:assert($count);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$count' value='count' Tokenstr |c(s| translated: assert ( count
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(s)| translated: assert ( count )

Line:   19 TokenStr: =|c(s)|= @ValPy: assert ( count )
control(0) =|c(s)|= assert ( $count )

control-parens removed, begin=0 start=1 =|cs|= assert $count

Generated partial line assert
expression(1, 1, 0) =|cs|= assert $count

Generated partial line assertcount
expression returns 2
  20 | 0 |   |
  21 | 0 |   |assert count                                                                            #PL: $count = 0;

Tokens: cs ValPy: 
Main loop, line=$count = 0;


 === Line 21 Perl source:$count = 0;===

Lexem 0 Current token='s' perl='$count' value='count' Tokenstr |s| translated: count
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: count =
Lexem 2 Current token='d' perl='0' value='0' Tokenstr |s=d| translated: count = 0

Line:   21 TokenStr: =|s=d|= @ValPy: count = 0
assignment(0, 2) =|s=d|= $count = 0

Generated partial line count
Generated partial line count=
assign, ValClass[limit] = d, ValPy=0, ValPerl=0

Generated partial line count=0
  22 | 0 |   |count = 0                                                                               #PL: while (<${pat}>) {	# another glob

Tokens: s=d ValPy: 
Main loop, line=while (<${pat}>) {	# another glob


 === Line 22 Perl source:while (<${pat}>) {	# another glob===

Lexem 0 Current token='c' perl='while' value='while' Tokenstr |c| translated: while
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: while (
Lexem 2 Current token='g' perl='${pat}' value='glob.glob(f"{pat}")' Tokenstr |c(g| translated: while ( glob.glob(f"{pat}")
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(g)| translated: while ( glob.glob(f"{pat}") )
enter_block at line 22, prior nesting_level=0, ValPerl=while ( ${pat} ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 22.
nesting_info=cur_sub  is_eval  type while in_sub 0 in_loop 1 lno 22 is_sub  is_loop 1 level 0

Line:   22 TokenStr: =|c(g)|= @ValPy: while ( glob.glob(f"{pat}") )
control(0) =|c(g)|= while ( ${pat} )

control-parens removed, begin=0 start=1 =|cg|= while ${pat}

  22 | 0 |   |_g = glob.glob(f"{pat}")                                                                #PL: while (<${pat}>) {	# another glob

Tokens: cg ValPy: 
Generated partial line for _d in _g
Generated partial line for _d in _g:
  22 | 0 |   |for _d in _g:                                                                           #PL: 

Tokens: cg ValPy: 
Main loop, line={


 === Line 22 Perl source:{===


Line:   22 TokenStr: =|{|= @ValPy: {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 22.
loop_needs_try_block(0), top=cur_sub  is_eval  type while in_sub 0 in_loop 1 lno 22 is_sub  is_loop 1 level 0
  22 | 0 |   |# another glob
Main loop, line=assert(/^issue/ or /^test/);


 === Line 23 Perl source:assert(/^issue/ or /^test/);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='q' perl='^issue' value='re.search(r'^issue',_d)' Tokenstr |c(q| translated: assert ( re.search(r'^issue',_d)
Lexem 3 Current token='0' perl='or' value='or' Tokenstr |c(q0| translated: assert ( re.search(r'^issue',_d) or
Lexem 4 Current token='q' perl='^test' value='re.search(r'^test',_d)' Tokenstr |c(q0q| translated: assert ( re.search(r'^issue',_d) or re.search(r'^test',_d)
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(q0q)| translated: assert ( re.search(r'^issue',_d) or re.search(r'^test',_d) )

Line:   23 TokenStr: =|c(q0q)|= @ValPy: assert ( re.search(r'^issue',_d) or re.search(r'^test',_d) )
control(0) =|c(q0q)|= assert ( ^issue or ^test )

control-parens removed, begin=0 start=1 =|cq0q|= assert ^issue or ^test

Generated partial line assert
expression(1, 3, 0) =|cq0q|= assert ^issue or ^test

Generated partial line assertre.search(r'^issue',_d)
Generated partial line assertre.search(r'^issue',_d)or
Generated partial line assertre.search(r'^issue',_d)orre.search(r'^test',_d)
expression returns 4
  24 | 1 |   |    assert re.search(r'^issue',_d) or re.search(r'^test',_d)                            #PL: $count++;

Tokens: cq0q ValPy: 
Main loop, line=$count++;


 === Line 24 Perl source:$count++;===

Lexem 0 Current token='s' perl='$count' value='count' Tokenstr |s| translated: count
Lexem 1 Current token='^' perl='++' value='+=1' Tokenstr |s^| translated: count +=1

Line:   24 TokenStr: =|s^|= @ValPy: count +=1
handle_incr_decr(0, 1, 1) with ++assignment(0, 1) =|s^|= $count ++

Generated partial line count+=1
  25 | 1 |   |    count+=1                                                                            #PL: last;

Tokens: s^ ValPy: 
Main loop, line=last;


 === Line 25 Perl source:last;===

Lexem 0 Current token='k' perl='last' value='break' Tokenstr |k| translated: break

Line:   25 TokenStr: =|k|= @ValPy: break
Generated partial line break
  26 | 1 |   |    break                                                                               #PL: 

Tokens: k ValPy: 
Main loop, line=}


 === Line 26 Perl source:}===

exit_block at line 26, prior nesting_level=1

Line:   26 TokenStr: =|}|= @ValPy: }
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 26.
loop_needs_try_block(1), top=cur_sub  is_eval  type while in_sub 0 in_loop 1 lno 22 is_sub  is_loop 1 level 0
initialize_globals_for_state_vars: 
  26 | 0 |   |
Main loop, line=assert($count);


 === Line 27 Perl source:assert($count);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$count' value='count' Tokenstr |c(s| translated: assert ( count
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(s)| translated: assert ( count )

Line:   27 TokenStr: =|c(s)|= @ValPy: assert ( count )
control(0) =|c(s)|= assert ( $count )

control-parens removed, begin=0 start=1 =|cs|= assert $count

Generated partial line assert
expression(1, 1, 0) =|cs|= assert $count

Generated partial line assertcount
expression returns 2
  28 | 0 |   |
  29 | 0 |   |assert count                                                                            #PL: $count = 0;

Tokens: cs ValPy: 
Main loop, line=$count = 0;


 === Line 29 Perl source:$count = 0;===

Lexem 0 Current token='s' perl='$count' value='count' Tokenstr |s| translated: count
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: count =
Lexem 2 Current token='d' perl='0' value='0' Tokenstr |s=d| translated: count = 0

Line:   29 TokenStr: =|s=d|= @ValPy: count = 0
assignment(0, 2) =|s=d|= $count = 0

Generated partial line count
Generated partial line count=
assign, ValClass[limit] = d, ValPy=0, ValPerl=0

Generated partial line count=0
  30 | 0 |   |count = 0                                                                               #PL: %options = (extra=>'.');

Tokens: s=d ValPy: 
Main loop, line=%options = (extra=>'.');


 === Line 30 Perl source:%options = (extra=>'.');===

Lexem 0 Current token='h' perl='options' value='options' Tokenstr |h| translated: options
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |h=| translated: options =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |h=(| translated: options = (
Lexem 3 Current token='i' perl='extra' value='extra' Tokenstr |h=(i| translated: options = ( extra
Lexem 4 Current token=':' perl='=>' value=': ' Tokenstr |h=(i:| translated: options = ( extra : 
Lexem 5 Current token='"' perl='.' value=''.'' Tokenstr |h=(i:"| translated: options = ( extra :  '.'
Lexem 6 Current token=')' perl=')' value=')' Tokenstr |h=(i:")| translated: options = ( extra :  '.' )

Line:   30 TokenStr: =|h=(i:")|= @ValPy: options = ( extra :  '.' )
Generated partial line options = {
Generated partial line options = {'extra'
Generated partial line options = {'extra': 
Generated partial line options = {'extra': '.'
Generated partial line options = {'extra': '.'}
  31 | 0 |   |options = {'extra': '.'}                                                                #PL: while (<$options{extra}/*.pl>) {	# another glob with a relative path

Tokens: h=(i:") ValPy: 
Main loop, line=while (<$options{extra}/*.pl>) {	# another glob with a relative path


 === Line 31 Perl source:while (<$options{extra}/*.pl>) {	# another glob with a relative path===

Lexem 0 Current token='c' perl='while' value='while' Tokenstr |c| translated: while
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: while (
Lexem 2 Current token='g' perl='$options{extra}/*.pl' value='glob.glob(f"{options.get('extra','')}/*.pl")' Tokenstr |c(g| translated: while ( glob.glob(f"{options.get('extra','')}/*.pl")
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(g)| translated: while ( glob.glob(f"{options.get('extra','')}/*.pl") )
enter_block at line 31, prior nesting_level=0, ValPerl=while ( $options{extra}/*.pl ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 31.
nesting_info=cur_sub  type while is_eval  in_sub 0 in_loop 1 lno 31 is_sub  is_loop 1 level 0

Line:   31 TokenStr: =|c(g)|= @ValPy: while ( glob.glob(f"{options.get('extra','')}/*.pl") )
control(0) =|c(g)|= while ( $options{extra}/*.pl )

control-parens removed, begin=0 start=1 =|cg|= while $options{extra}/*.pl

  31 | 0 |   |_g = glob.glob(f"{options.get('extra','')}/*.pl")                                       #PL: while (<$options{extra}/*.pl>) {	# another glob with a relative path

Tokens: cg ValPy: 
Generated partial line for _d in _g
Generated partial line for _d in _g:
  31 | 0 |   |for _d in _g:                                                                           #PL: 

Tokens: cg ValPy: 
Main loop, line={


 === Line 31 Perl source:{===


Line:   31 TokenStr: =|{|= @ValPy: {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 31.
loop_needs_try_block(0), top=cur_sub  type while is_eval  in_sub 0 in_loop 1 lno 31 is_sub  is_loop 1 level 0
  31 | 0 |   |# another glob with a relative path
Main loop, line=assert(/issue/ or /test/);


 === Line 32 Perl source:assert(/issue/ or /test/);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='q' perl='issue' value='re.search(r'issue',_d)' Tokenstr |c(q| translated: assert ( re.search(r'issue',_d)
Lexem 3 Current token='0' perl='or' value='or' Tokenstr |c(q0| translated: assert ( re.search(r'issue',_d) or
Lexem 4 Current token='q' perl='test' value='re.search(r'test',_d)' Tokenstr |c(q0q| translated: assert ( re.search(r'issue',_d) or re.search(r'test',_d)
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(q0q)| translated: assert ( re.search(r'issue',_d) or re.search(r'test',_d) )

Line:   32 TokenStr: =|c(q0q)|= @ValPy: assert ( re.search(r'issue',_d) or re.search(r'test',_d) )
control(0) =|c(q0q)|= assert ( issue or test )

control-parens removed, begin=0 start=1 =|cq0q|= assert issue or test

Generated partial line assert
expression(1, 3, 0) =|cq0q|= assert issue or test

Generated partial line assertre.search(r'issue',_d)
Generated partial line assertre.search(r'issue',_d)or
Generated partial line assertre.search(r'issue',_d)orre.search(r'test',_d)
expression returns 4
  33 | 1 |   |    assert re.search(r'issue',_d) or re.search(r'test',_d)                              #PL: $count++;

Tokens: cq0q ValPy: 
Main loop, line=$count++;


 === Line 33 Perl source:$count++;===

Lexem 0 Current token='s' perl='$count' value='count' Tokenstr |s| translated: count
Lexem 1 Current token='^' perl='++' value='+=1' Tokenstr |s^| translated: count +=1

Line:   33 TokenStr: =|s^|= @ValPy: count +=1
handle_incr_decr(0, 1, 1) with ++assignment(0, 1) =|s^|= $count ++

Generated partial line count+=1
  34 | 1 |   |    count+=1                                                                            #PL: last;

Tokens: s^ ValPy: 
Main loop, line=last;


 === Line 34 Perl source:last;===

Lexem 0 Current token='k' perl='last' value='break' Tokenstr |k| translated: break

Line:   34 TokenStr: =|k|= @ValPy: break
Generated partial line break
  35 | 1 |   |    break                                                                               #PL: 

Tokens: k ValPy: 
Main loop, line=}


 === Line 35 Perl source:}===

exit_block at line 35, prior nesting_level=1

Line:   35 TokenStr: =|}|= @ValPy: }
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 35.
loop_needs_try_block(1), top=cur_sub  type while is_eval  in_sub 0 in_loop 1 lno 31 is_sub  is_loop 1 level 0
initialize_globals_for_state_vars: 
  35 | 0 |   |
Main loop, line=assert($count);


 === Line 36 Perl source:assert($count);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$count' value='count' Tokenstr |c(s| translated: assert ( count
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(s)| translated: assert ( count )

Line:   36 TokenStr: =|c(s)|= @ValPy: assert ( count )
control(0) =|c(s)|= assert ( $count )

control-parens removed, begin=0 start=1 =|cs|= assert $count

Generated partial line assert
expression(1, 1, 0) =|cs|= assert $count

Generated partial line assertcount
expression returns 2
  37 | 0 |   |
  38 | 0 |   |assert count                                                                            #PL: $count = 0;

Tokens: cs ValPy: 
Main loop, line=$count = 0;


 === Line 38 Perl source:$count = 0;===

Lexem 0 Current token='s' perl='$count' value='count' Tokenstr |s| translated: count
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: count =
Lexem 2 Current token='d' perl='0' value='0' Tokenstr |s=d| translated: count = 0

Line:   38 TokenStr: =|s=d|= @ValPy: count = 0
assignment(0, 2) =|s=d|= $count = 0

Generated partial line count
Generated partial line count=
assign, ValClass[limit] = d, ValPy=0, ValPerl=0

Generated partial line count=0
  39 | 0 |   |count = 0                                                                               #PL: while (<*>) {	# another glob - thru all files

Tokens: s=d ValPy: 
Main loop, line=while (<*>) {	# another glob - thru all files


 === Line 39 Perl source:while (<*>) {	# another glob - thru all files===

Lexem 0 Current token='c' perl='while' value='while' Tokenstr |c| translated: while
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: while (
Lexem 2 Current token='g' perl='*' value='glob.glob('*')' Tokenstr |c(g| translated: while ( glob.glob('*')
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(g)| translated: while ( glob.glob('*') )
enter_block at line 39, prior nesting_level=0, ValPerl=while ( * ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 39.
nesting_info=is_sub  level 0 is_loop 1 cur_sub  is_eval  type while in_sub 0 in_loop 1 lno 39

Line:   39 TokenStr: =|c(g)|= @ValPy: while ( glob.glob('*') )
control(0) =|c(g)|= while ( * )

control-parens removed, begin=0 start=1 =|cg|= while *

  39 | 0 |   |_g = glob.glob('*')                                                                     #PL: while (<*>) {	# another glob - thru all files

Tokens: cg ValPy: 
Generated partial line for _d in _g
Generated partial line for _d in _g:
  39 | 0 |   |for _d in _g:                                                                           #PL: 

Tokens: cg ValPy: 
Main loop, line={


 === Line 39 Perl source:{===


Line:   39 TokenStr: =|{|= @ValPy: {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 39.
loop_needs_try_block(0), top=is_sub  level 0 is_loop 1 cur_sub  is_eval  type while in_sub 0 in_loop 1 lno 39
  39 | 0 |   |# another glob - thru all files
Main loop, line=next if not /\.pl$/;


 === Line 40 Perl source:next if not /\.pl$/;===

Lexem 0 Current token='k' perl='next' value='continue' Tokenstr |k| translated: continue
Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='!' perl='not' value='not' Tokenstr |c!| translated: if  not
Lexem 2 Current token='q' perl='\.pl$' value='re.search(r'\.pl$',_d)' Tokenstr |c!q| translated: if  not re.search(r'\.pl$',_d)

Line:   40 TokenStr: =|c!q|= @ValPy: if  not re.search(r'\.pl$',_d)
control(0) =|c(!q)|= if ( not \.pl$ )

control-parens removed, begin=0 start=1 =|c!q|= if not \.pl$

Generated partial line if 
expression(1, 2, 0) =|c!q|= if not \.pl$

Generated partial line if not
Generated partial line if notre.search(r'\.pl$',_d)
expression returns 3
Generated partial line if notre.search(r'\.pl$',_d):
  40 | 1 |   |    if not re.search(r'\.pl$',_d):                                                      #PL: next if not /\.pl$/;

Tokens: c!q ValPy: 
Main loop, line=next if not /\.pl$/;
enter_block at line 40, prior nesting_level=1, ValPerl={
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 40.
nesting_info=lno 40 in_loop 1 is_eval  type if in_sub 0 cur_sub  level 1 is_loop  is_sub 
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 40.
loop_needs_try_block(0), top=lno 40 in_loop 1 is_eval  type if in_sub 0 cur_sub  level 1 is_loop  is_sub 
Main loop, line=next if not /\.pl$/;
Generated partial line continue
  40 | 2 |   |        continue                                                                        #PL: next if not /\.pl$/;

Tokens: k ValPy: 
Main loop, line=next if not /\.pl$/;
exit_block at line 40, prior nesting_level=2
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 40.
loop_needs_try_block(1), top=lno 40 in_loop 1 is_eval  type if in_sub 0 cur_sub  level 1 is_loop  is_sub 
Main loop, line=assert(/^issue/ or /^test/);


 === Line 41 Perl source:assert(/^issue/ or /^test/);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='q' perl='^issue' value='re.search(r'^issue',_d)' Tokenstr |c(q| translated: assert ( re.search(r'^issue',_d)
Lexem 3 Current token='0' perl='or' value='or' Tokenstr |c(q0| translated: assert ( re.search(r'^issue',_d) or
Lexem 4 Current token='q' perl='^test' value='re.search(r'^test',_d)' Tokenstr |c(q0q| translated: assert ( re.search(r'^issue',_d) or re.search(r'^test',_d)
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(q0q)| translated: assert ( re.search(r'^issue',_d) or re.search(r'^test',_d) )

Line:   41 TokenStr: =|c(q0q)|= @ValPy: assert ( re.search(r'^issue',_d) or re.search(r'^test',_d) )
control(0) =|c(q0q)|= assert ( ^issue or ^test )

control-parens removed, begin=0 start=1 =|cq0q|= assert ^issue or ^test

Generated partial line assert
expression(1, 3, 0) =|cq0q|= assert ^issue or ^test

Generated partial line assertre.search(r'^issue',_d)
Generated partial line assertre.search(r'^issue',_d)or
Generated partial line assertre.search(r'^issue',_d)orre.search(r'^test',_d)
expression returns 4
  42 | 1 |   |    assert re.search(r'^issue',_d) or re.search(r'^test',_d)                            #PL: $count++;

Tokens: cq0q ValPy: 
Main loop, line=$count++;


 === Line 42 Perl source:$count++;===

Lexem 0 Current token='s' perl='$count' value='count' Tokenstr |s| translated: count
Lexem 1 Current token='^' perl='++' value='+=1' Tokenstr |s^| translated: count +=1

Line:   42 TokenStr: =|s^|= @ValPy: count +=1
handle_incr_decr(0, 1, 1) with ++assignment(0, 1) =|s^|= $count ++

Generated partial line count+=1
  43 | 1 |   |    count+=1                                                                            #PL: last;

Tokens: s^ ValPy: 
Main loop, line=last;


 === Line 43 Perl source:last;===

Lexem 0 Current token='k' perl='last' value='break' Tokenstr |k| translated: break

Line:   43 TokenStr: =|k|= @ValPy: break
Generated partial line break
  44 | 1 |   |    break                                                                               #PL: 

Tokens: k ValPy: 
Main loop, line=}


 === Line 44 Perl source:}===

exit_block at line 44, prior nesting_level=1

Line:   44 TokenStr: =|}|= @ValPy: }
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 44.
loop_needs_try_block(1), top=is_sub  level 0 is_loop 1 cur_sub  is_eval  type while in_sub 0 in_loop 1 lno 39
initialize_globals_for_state_vars: 
  44 | 0 |   |
Main loop, line=assert($count);


 === Line 45 Perl source:assert($count);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$count' value='count' Tokenstr |c(s| translated: assert ( count
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(s)| translated: assert ( count )

Line:   45 TokenStr: =|c(s)|= @ValPy: assert ( count )
control(0) =|c(s)|= assert ( $count )

control-parens removed, begin=0 start=1 =|cs|= assert $count

Generated partial line assert
expression(1, 1, 0) =|cs|= assert $count

Generated partial line assertcount
expression returns 2
  46 | 0 |   |
  47 | 0 |   |assert count                                                                            #PL: $i = 10;

Tokens: cs ValPy: 
Main loop, line=$i = 10;


 === Line 47 Perl source:$i = 10;===

Lexem 0 Current token='s' perl='$i' value='i' Tokenstr |s| translated: i
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: i =
Lexem 2 Current token='d' perl='10' value='10' Tokenstr |s=d| translated: i = 10

Line:   47 TokenStr: =|s=d|= @ValPy: i = 10
assignment(0, 2) =|s=d|= $i = 10

Generated partial line i
Generated partial line i=
assign, ValClass[limit] = d, ValPy=10, ValPerl=10

Generated partial line i=10
  48 | 0 |   |i = 10                                                                                  #PL: $j = 20;

Tokens: s=d ValPy: 
Main loop, line=$j = 20;


 === Line 48 Perl source:$j = 20;===

Lexem 0 Current token='s' perl='$j' value='j' Tokenstr |s| translated: j
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: j =
Lexem 2 Current token='d' perl='20' value='20' Tokenstr |s=d| translated: j = 20

Line:   48 TokenStr: =|s=d|= @ValPy: j = 20
assignment(0, 2) =|s=d|= $j = 20

Generated partial line j
Generated partial line j=
assign, ValClass[limit] = d, ValPy=20, ValPerl=20

Generated partial line j=20
  49 | 0 |   |j = 20                                                                                  #PL: assert($i<11&&$j>19);		# Not a diamond operator!

Tokens: s=d ValPy: 
Main loop, line=assert($i<11&&$j>19);		# Not a diamond operator!


 === Line 49 Perl source:assert($i<11&&$j>19);		# Not a diamond operator!===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$i' value='i' Tokenstr |c(s| translated: assert ( i
Lexem 3 Current token='>' perl='<' value='<' Tokenstr |c(s>| translated: assert ( i <
Lexem 4 Current token='d' perl='11' value='11' Tokenstr |c(s>d| translated: assert ( i < 11
Lexem 5 Current token='0' perl='&&' value=' and ' Tokenstr |c(s>d0| translated: assert ( i < 11  and 
Lexem 6 Current token='s' perl='$j' value='j' Tokenstr |c(s>d0s| translated: assert ( i < 11  and  j
Lexem 7 Current token='>' perl='>' value='>' Tokenstr |c(s>d0s>| translated: assert ( i < 11  and  j >
Lexem 8 Current token='d' perl='19' value='19' Tokenstr |c(s>d0s>d| translated: assert ( i < 11  and  j > 19
Lexem 9 Current token=')' perl=')' value=')' Tokenstr |c(s>d0s>d)| translated: assert ( i < 11  and  j > 19 )

Line:   49 TokenStr: =|c(s>d0s>d)|= @ValPy: assert ( i < 11  and  j > 19 )
control(0) =|c(s>d0s>d)|= assert ( $i < 11 && $j > 19 )

control-parens removed, begin=0 start=1 =|cs>d0s>d|= assert $i < 11 && $j > 19

Generated partial line assert
expression(1, 7, 0) =|cs>d0s>d|= assert $i < 11 && $j > 19

Generated partial line asserti
Generated partial line asserti<
Generated partial line asserti<11
Generated partial line asserti<11 and 
Generated partial line asserti<11 and j
Generated partial line asserti<11 and j>
Generated partial line asserti<11 and j>19
expression returns 8
  50 | 0 |   |
  51 | 0 |   |assert i < 11 and j > 19 # Not a diamond operator!
                                                                                                      #PL: assert(($i <=> $j) == -1);    

Tokens: cs>d0s>d ValPy: 
Main loop, line=assert(($i <=> $j) == -1);      # Not a diamond operator!


 === Line 51 Perl source:assert(($i <=> $j) == -1);      # Not a diamond operator!===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |c((| translated: assert ( (
Lexem 3 Current token='s' perl='$i' value='i' Tokenstr |c((s| translated: assert ( ( i
Lexem 4 Current token='>' perl='<=>' value='_spaceship' Tokenstr |c((s>| translated: assert ( ( i _spaceship
Lexem 5 Current token='s' perl='$j' value='j' Tokenstr |c((s>s| translated: assert ( ( i _spaceship j
Lexem 6 Current token=')' perl=')' value=')' Tokenstr |c((s>s)| translated: assert ( ( i _spaceship j )
Lexem 7 Current token='>' perl='==' value='==' Tokenstr |c((s>s)>| translated: assert ( ( i _spaceship j ) ==
Lexem 8 Current token='-' perl='-' value='-' Tokenstr |c((s>s)>-| translated: assert ( ( i _spaceship j ) == -
Lexem 9 Current token='d' perl='1' value='1' Tokenstr |c((s>s)>-d| translated: assert ( ( i _spaceship j ) == - 1
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |c((s>s)>-d)| translated: assert ( ( i _spaceship j ) == - 1 )

Line:   51 TokenStr: =|c((s>s)>-d)|= @ValPy: assert ( ( i _spaceship j ) == - 1 )
handle_cmp_spaceship(0, 4, 10): a[3:3], b[5:5] = 3 (=|c((f(s,s))>-d)|=)
control(0) =|c((f(s,s))>-d)|= assert ( ( <=> ( $i , $j ) ) == - 1 )

control-parens removed, begin=0 start=1 =|c(f(s,s))>-d|= assert ( <=> ( $i , $j ) ) == - 1

Generated partial line assert
expression(1, 11, 0) =|c(f(s,s))>-d|= assert ( <=> ( $i , $j ) ) == - 1

Generated partial line assert(
expression(2, 7, 0) =|c(f(s,s))>-d|= assert ( <=> ( $i , $j ) ) == - 1

function(2, 7) =|c(f(s,s))>-d|= assert ( <=> ( $i , $j ) ) == - 1

function start=4, end_pos=6, bracketed=1
Generated partial line assert(_spaceship
Generated partial line assert(_spaceship(
expression(4, 6, 0) =|c(f(s,s))>-d|= assert ( <=> ( $i , $j ) ) == - 1

Generated partial line assert(_spaceship(i
Generated partial line assert(_spaceship(i,
Generated partial line assert(_spaceship(i,j
expression returns 7
Generated partial line assert(_spaceship(i,j)
expression returns 8
Generated partial line assert(_spaceship(i,j))
Generated partial line assert(_spaceship(i,j))==
Generated partial line assert(_spaceship(i,j))==-
Generated partial line assert(_spaceship(i,j))==-1
expression returns 12
  52 | 0 |   |
  53 | 0 |   |assert (_spaceship(i, j)) == -1 # Not a diamond operator!
                                                                                                      #PL: 

Tokens: c(f(s,s))>-d ValPy: 
Main loop, line=open(FD, THISFILE);


 === Line 53 Perl source:open(FD, THISFILE);===

Lexem 0 Current token='f' perl='open' value='open' Tokenstr |f| translated: open
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |f(| translated: open (
Lexem 2 Current token='i' perl='FD' value='FD' Tokenstr |f(i| translated: open ( FD
Lexem 3 Current token=',' perl=',' value=',' Tokenstr |f(i,| translated: open ( FD ,
Lexem 4 Current token='i' perl='THISFILE' value='THISFILE' Tokenstr |f(i,i| translated: open ( FD , THISFILE
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |f(i,i)| translated: open ( FD , THISFILE )

Line:   53 TokenStr: =|f(i,i)|= @ValPy: open ( FD , THISFILE )
  53 | 0 |   |FD = _open_dynamic(THISFILE([]))                                                        #PL: open(FD, THISFILE);
Main loop, line=while(<FD>) {


 === Line 54 Perl source:while(<FD>) {===

Lexem 0 Current token='c' perl='while' value='while' Tokenstr |c| translated: while
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: while (
Lexem 3 Current token='i' perl='<FD>' value='next(_dia, None)' Tokenstr |Wc(i| translated: with fileinput.input("<FD>",openhook=lambda _,__:FD) as _dia: while ( next(_dia, None)
Lexem 4 Current token=')' perl=')' value=')' Tokenstr |Wc(i)| translated: with fileinput.input("<FD>",openhook=lambda _,__:FD) as _dia: while ( next(_dia, None) )
enter_block at line 54, prior nesting_level=0, ValPerl=<FD> while ( <FD> ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 54.
nesting_info=level 0 is_loop 1 is_sub  in_loop 1 is_eval  type while in_sub 0 cur_sub  lno 54

Line:   54 TokenStr: =|Wc(i)|= @ValPy: with fileinput.input("<FD>",openhook=lambda _,__:FD) as _dia: while ( next(_dia, None) )
Setting context_manager_nest = 0
  54 | 0 |   |with fileinput.input("<FD>",openhook=lambda _,__:FD) as _dia:                           #PL: while(<FD>) {

Tokens: Wc(i) ValPy: 
control(0) =|c(i)|= while ( <FD> )

control-parens removed, begin=0 start=1 =|ci|= while <FD>

Generated partial line while (_d:=next(_dia, None))
Generated partial line while (_d:=next(_dia, None)):
  54 | 1 |   |    while (_d:=next(_dia, None)):                                                       #PL: 

Tokens: ci ValPy: 
Main loop, line={


 === Line 54 Perl source:{===


Line:   54 TokenStr: =|{|= @ValPy: {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 54.
loop_needs_try_block(0), top=level 0 is_loop 1 is_sub  in_loop 1 is_eval  type while in_sub 0 cur_sub  lno 54
Main loop, line=assert($_ =~ /issue 66/) if($. eq 1);


 === Line 55 Perl source:assert($_ =~ /issue 66/) if($. eq 1);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$_' value='_d' Tokenstr |c(s| translated: assert ( _d
Lexem 3 Current token='~' perl='=~' value='' Tokenstr |c(s~| translated: assert ( _d 
Lexem 4 Current token='q' perl='issue 66' value='re.search(r'issue 66',' Tokenstr |c(s~q| translated: assert ( _d  re.search(r'issue 66',
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(s~q)| translated: assert ( _d  re.search(r'issue 66', )
Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' perl='$' value='fileinput.lineno()' Tokenstr |c(s| translated: if  ( fileinput.lineno()
Lexem 3 Current token='>' perl='eq' value='==' Tokenstr |c(s>| translated: if  ( fileinput.lineno() ==
Lexem 4 Current token='d' perl='1' value='1' Tokenstr |c(s>d| translated: if  ( fileinput.lineno() == 1
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(s>d)| translated: if  ( fileinput.lineno() == 1 )

Line:   55 TokenStr: =|c(s>d)|= @ValPy: if  ( fileinput.lineno() == 1 )
control(0) =|c(s>d)|= if ( $ eq 1 )

control-parens removed, begin=0 start=1 =|cs>d|= if $ eq 1

Generated partial line if 
expression(1, 3, 0) =|cs>d|= if $ eq 1

Generated partial line if fileinput.lineno()
Generated partial line if fileinput.lineno()==
Generated partial line if fileinput.lineno()==1
expression returns 4
Generated partial line if fileinput.lineno()==1:
  55 | 2 |   |        if fileinput.lineno() == 1:                                                     #PL: assert($_ =~ /issue 66/) if($. eq 1);

Tokens: cs>d ValPy: 
Main loop, line=assert($_ =~ /issue 66/) if($. eq 1);
enter_block at line 55, prior nesting_level=1, ValPerl={
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 55.
nesting_info=lno 55 in_loop 1 type if is_eval  in_sub 0 cur_sub  level 1 is_loop  is_sub 
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 55.
loop_needs_try_block(0), top=lno 55 in_loop 1 type if is_eval  in_sub 0 cur_sub  level 1 is_loop  is_sub 
Main loop, line=assert($_ =~ /issue 66/) if($. eq 1);
control(0) =|c(s~q)|= assert ( $_ =~ issue 66 )

control-parens removed, begin=0 start=1 =|cs~q|= assert $_ =~ issue 66

Generated partial line assert
expression(1, 3, 0) =|cs~q|= assert $_ =~ issue 66

Generated partial line assertre.search(r'issue 66',
expression(1, 1, 0) =|cs~q|= assert $_ =~ issue 66

Generated partial line assertre.search(r'issue 66',_d
expression returns 2
Generated partial line assertre.search(r'issue 66',_d)
expression returns 4
  55 | 3 |   |            assert re.search(r'issue 66',_d)                                            #PL: assert($_ =~ /issue 66/) if($. eq 1);

Tokens: cs~q ValPy: 
Main loop, line=assert($_ =~ /issue 66/) if($. eq 1);
exit_block at line 55, prior nesting_level=2
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 55.
loop_needs_try_block(1), top=lno 55 in_loop 1 type if is_eval  in_sub 0 cur_sub  level 1 is_loop  is_sub 
Main loop, line=last;


 === Line 56 Perl source:last;===

Lexem 0 Current token='k' perl='last' value='break' Tokenstr |k| translated: break

Line:   56 TokenStr: =|k|= @ValPy: break
Generated partial line break
  57 | 2 |   |        break                                                                           #PL: 

Tokens: k ValPy: 
Main loop, line=}


 === Line 57 Perl source:}===

exit_block at line 57, prior nesting_level=1

Line:   57 TokenStr: =|}|= @ValPy: }
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 57.
loop_needs_try_block(1), top=level 0 is_loop 1 is_sub  in_loop 1 is_eval  type while in_sub 0 cur_sub  lno 54
  57 | 2 |   |
Resetting context manager nest
Main loop, line=close FD;


 === Line 58 Perl source:close FD;===

Lexem 0 Current token='f' perl='close' value='.close()' Tokenstr |f| translated: .close()
Lexem 1 Current token='i' perl='FD' value='FD' Tokenstr |fi| translated: .close() FD

Line:   58 TokenStr: =|fi|= @ValPy: .close() FD
Generated partial line FD.close()
  59 | 0 |   |FD.close()                                                                              #PL: open($fd, '<', THISFILE);

Tokens: fi ValPy: 
Main loop, line=open($fd, '<', THISFILE);


 === Line 59 Perl source:open($fd, '<', THISFILE);===

Lexem 0 Current token='f' perl='open' value='open' Tokenstr |f| translated: open
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |f(| translated: open (
Lexem 2 Current token='s' perl='$fd' value='fd' Tokenstr |f(s| translated: open ( fd
Lexem 3 Current token=',' perl=',' value=',' Tokenstr |f(s,| translated: open ( fd ,
Lexem 4 Current token='"' perl='<' value=''<'' Tokenstr |f(s,"| translated: open ( fd , '<'
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |f(s,",| translated: open ( fd , '<' ,
Lexem 6 Current token='i' perl='THISFILE' value='THISFILE' Tokenstr |f(s,",i| translated: open ( fd , '<' , THISFILE
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |f(s,",i)| translated: open ( fd , '<' , THISFILE )

Line:   59 TokenStr: =|f(s,",i)|= @ValPy: open ( fd , '<' , THISFILE )
  59 | 0 |   |fd = _open(THISFILE([]), 'r')                                                           #PL: open($fd, '<', THISFILE);
Main loop, line=while(<$fd>) {


 === Line 60 Perl source:while(<$fd>) {===

Lexem 0 Current token='c' perl='while' value='while' Tokenstr |c| translated: while
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: while (
Lexem 3 Current token='i' perl='<$fd>' value='next(_dia, None)' Tokenstr |Wc(i| translated: with fileinput.input("<fd>",openhook=lambda _,__:fd) as _dia: while ( next(_dia, None)
Lexem 4 Current token=')' perl=')' value=')' Tokenstr |Wc(i)| translated: with fileinput.input("<fd>",openhook=lambda _,__:fd) as _dia: while ( next(_dia, None) )
enter_block at line 60, prior nesting_level=0, ValPerl=<fd> while ( <$fd> ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 60.
nesting_info=is_loop 1 level 0 is_sub  lno 60 in_loop 1 cur_sub  in_sub 0 is_eval  type while

Line:   60 TokenStr: =|Wc(i)|= @ValPy: with fileinput.input("<fd>",openhook=lambda _,__:fd) as _dia: while ( next(_dia, None) )
Setting context_manager_nest = 0
  60 | 0 |   |with fileinput.input("<fd>",openhook=lambda _,__:fd) as _dia:                           #PL: while(<$fd>) {

Tokens: Wc(i) ValPy: 
control(0) =|c(i)|= while ( <$fd> )

control-parens removed, begin=0 start=1 =|ci|= while <$fd>

Generated partial line while (_d:=next(_dia, None))
Generated partial line while (_d:=next(_dia, None)):
  60 | 1 |   |    while (_d:=next(_dia, None)):                                                       #PL: 

Tokens: ci ValPy: 
Main loop, line={


 === Line 60 Perl source:{===


Line:   60 TokenStr: =|{|= @ValPy: {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 60.
loop_needs_try_block(0), top=is_loop 1 level 0 is_sub  lno 60 in_loop 1 cur_sub  in_sub 0 is_eval  type while
Main loop, line=assert($_ =~ /issue 66/) if($. eq 1);


 === Line 61 Perl source:assert($_ =~ /issue 66/) if($. eq 1);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$_' value='_d' Tokenstr |c(s| translated: assert ( _d
Lexem 3 Current token='~' perl='=~' value='' Tokenstr |c(s~| translated: assert ( _d 
Lexem 4 Current token='q' perl='issue 66' value='re.search(r'issue 66',' Tokenstr |c(s~q| translated: assert ( _d  re.search(r'issue 66',
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(s~q)| translated: assert ( _d  re.search(r'issue 66', )
Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' perl='$' value='fileinput.lineno()' Tokenstr |c(s| translated: if  ( fileinput.lineno()
Lexem 3 Current token='>' perl='eq' value='==' Tokenstr |c(s>| translated: if  ( fileinput.lineno() ==
Lexem 4 Current token='d' perl='1' value='1' Tokenstr |c(s>d| translated: if  ( fileinput.lineno() == 1
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(s>d)| translated: if  ( fileinput.lineno() == 1 )

Line:   61 TokenStr: =|c(s>d)|= @ValPy: if  ( fileinput.lineno() == 1 )
control(0) =|c(s>d)|= if ( $ eq 1 )

control-parens removed, begin=0 start=1 =|cs>d|= if $ eq 1

Generated partial line if 
expression(1, 3, 0) =|cs>d|= if $ eq 1

Generated partial line if fileinput.lineno()
Generated partial line if fileinput.lineno()==
Generated partial line if fileinput.lineno()==1
expression returns 4
Generated partial line if fileinput.lineno()==1:
  61 | 2 |   |        if fileinput.lineno() == 1:                                                     #PL: assert($_ =~ /issue 66/) if($. eq 1);

Tokens: cs>d ValPy: 
Main loop, line=assert($_ =~ /issue 66/) if($. eq 1);
enter_block at line 61, prior nesting_level=1, ValPerl={
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 61.
nesting_info=in_loop 1 cur_sub  is_eval  in_sub 0 type if lno 61 level 1 is_loop  is_sub 
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 61.
loop_needs_try_block(0), top=in_loop 1 cur_sub  is_eval  in_sub 0 type if lno 61 level 1 is_loop  is_sub 
Main loop, line=assert($_ =~ /issue 66/) if($. eq 1);
control(0) =|c(s~q)|= assert ( $_ =~ issue 66 )

control-parens removed, begin=0 start=1 =|cs~q|= assert $_ =~ issue 66

Generated partial line assert
expression(1, 3, 0) =|cs~q|= assert $_ =~ issue 66

Generated partial line assertre.search(r'issue 66',
expression(1, 1, 0) =|cs~q|= assert $_ =~ issue 66

Generated partial line assertre.search(r'issue 66',_d
expression returns 2
Generated partial line assertre.search(r'issue 66',_d)
expression returns 4
  61 | 3 |   |            assert re.search(r'issue 66',_d)                                            #PL: assert($_ =~ /issue 66/) if($. eq 1);

Tokens: cs~q ValPy: 
Main loop, line=assert($_ =~ /issue 66/) if($. eq 1);
exit_block at line 61, prior nesting_level=2
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 61.
loop_needs_try_block(1), top=in_loop 1 cur_sub  is_eval  in_sub 0 type if lno 61 level 1 is_loop  is_sub 
Main loop, line=last;


 === Line 62 Perl source:last;===

Lexem 0 Current token='k' perl='last' value='break' Tokenstr |k| translated: break

Line:   62 TokenStr: =|k|= @ValPy: break
Generated partial line break
  63 | 2 |   |        break                                                                           #PL: 

Tokens: k ValPy: 
Main loop, line=}


 === Line 63 Perl source:}===

exit_block at line 63, prior nesting_level=1

Line:   63 TokenStr: =|}|= @ValPy: }
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 63.
loop_needs_try_block(1), top=is_loop 1 level 0 is_sub  lno 60 in_loop 1 cur_sub  in_sub 0 is_eval  type while
  63 | 2 |   |
Resetting context manager nest
Main loop, line=@ARGV = (THISFILE);


 === Line 64 Perl source:@ARGV = (THISFILE);===

Lexem 0 Current token='a' perl='@ARGV' value='sys.argv[1:]' Tokenstr |a| translated: sys.argv[1:]
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: sys.argv[1:] =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: sys.argv[1:] = (
Lexem 3 Current token='i' perl='THISFILE' value='THISFILE' Tokenstr |a=(i| translated: sys.argv[1:] = ( THISFILE
Lexem 4 Current token=')' perl=')' value=')' Tokenstr |a=(i)| translated: sys.argv[1:] = ( THISFILE )

Line:   64 TokenStr: =|a=(i)|= @ValPy: sys.argv[1:] = ( THISFILE )
Generated partial line sys.argv[1:] = [
Generated partial line sys.argv[1:] = [THISFILE
Generated partial line sys.argv[1:] = [THISFILE([])
Generated partial line sys.argv[1:] = [THISFILE([])]
  65 | 0 |   |# This is the emulation of what actually happens, from perldoc perlop
  66 | 0 |   |#$did_one = 0;
  67 | 0 |   |#unshift(@ARGV, '-') unless @ARGV;
  68 | 0 |   |#while ($ARGV_ = shift) {
  69 | 0 |   |#open(ARGV, $ARGV_);
  70 | 0 |   |#while (<ARGV>) {
  71 | 0 |   |#assert($_ =~ /issue 66/) if($. eq 1);
  72 | 0 |   |#assert($ARGV_ =~ /issue_66.pl/);
  73 | 0 |   |#$did_one = 1;
  74 | 0 |   |#last;
  75 | 0 |   |#}
  76 | 0 |   |#}
  77 | 0 |   |#assert($did_one);
  78 | 0 |   |#@ARGV = (THISFILE);
  79 | 0 |   |
  80 | 0 |   |sys.argv[1:] = [THISFILE([])]                                                           #PL: $did_one = 0;

Tokens: a=(i) ValPy: 
Main loop, line=$did_one = 0;


 === Line 80 Perl source:$did_one = 0;===

Lexem 0 Current token='s' perl='$did_one' value='did_one' Tokenstr |s| translated: did_one
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: did_one =
Lexem 2 Current token='d' perl='0' value='0' Tokenstr |s=d| translated: did_one = 0

Line:   80 TokenStr: =|s=d|= @ValPy: did_one = 0
assignment(0, 2) =|s=d|= $did_one = 0

Generated partial line did_one
Generated partial line did_one=
assign, ValClass[limit] = d, ValPy=0, ValPerl=0

Generated partial line did_one=0
  81 | 0 |   |did_one = 0                                                                             #PL: while(<>) {		# reads THISFILE, not STDIN

Tokens: s=d ValPy: 
Main loop, line=while(<>) {		# reads THISFILE, not STDIN


 === Line 81 Perl source:while(<>) {		# reads THISFILE, not STDIN===

Lexem 0 Current token='c' perl='while' value='while' Tokenstr |c| translated: while
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: while (
Lexem 3 Current token='i' perl='<>' value='next(_dia, None)' Tokenstr |Wc(i| translated: with fileinput.input() as _dia: while ( next(_dia, None)
Lexem 4 Current token=')' perl=')' value=')' Tokenstr |Wc(i)| translated: with fileinput.input() as _dia: while ( next(_dia, None) )
enter_block at line 81, prior nesting_level=0, ValPerl=<> while ( <> ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 81.
nesting_info=is_loop 1 level 0 is_sub  lno 81 in_loop 1 cur_sub  in_sub 0 type while is_eval 

Line:   81 TokenStr: =|Wc(i)|= @ValPy: with fileinput.input() as _dia: while ( next(_dia, None) )
Setting context_manager_nest = 0
  81 | 0 |   |with fileinput.input() as _dia:                                                         #PL: while(<>) {		# reads THISFILE, not STDIN

Tokens: Wc(i) ValPy: 
control(0) =|c(i)|= while ( <> )

control-parens removed, begin=0 start=1 =|ci|= while <>

Generated partial line while (_d:=next(_dia, None))
Generated partial line while (_d:=next(_dia, None)):
  81 | 1 |   |    while (_d:=next(_dia, None)):                                                       #PL: 

Tokens: ci ValPy: 
Main loop, line={


 === Line 81 Perl source:{===


Line:   81 TokenStr: =|{|= @ValPy: {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 81.
loop_needs_try_block(0), top=is_loop 1 level 0 is_sub  lno 81 in_loop 1 cur_sub  in_sub 0 type while is_eval 
  81 | 1 |   |    # reads THISFILE, not STDIN
Main loop, line=if($. eq 1) {


 === Line 82 Perl source:if($. eq 1) {===

Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' perl='$' value='fileinput.lineno()' Tokenstr |c(s| translated: if  ( fileinput.lineno()
Lexem 3 Current token='>' perl='eq' value='==' Tokenstr |c(s>| translated: if  ( fileinput.lineno() ==
Lexem 4 Current token='d' perl='1' value='1' Tokenstr |c(s>d| translated: if  ( fileinput.lineno() == 1
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(s>d)| translated: if  ( fileinput.lineno() == 1 )
enter_block at line 82, prior nesting_level=1, ValPerl=if ( $ eq 1 ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 82.
nesting_info=is_sub  level 1 is_loop  lno 82 in_sub 0 is_eval  type if  cur_sub  in_loop 1

Line:   82 TokenStr: =|c(s>d)|= @ValPy: if  ( fileinput.lineno() == 1 )
control(0) =|c(s>d)|= if ( $ eq 1 )

control-parens removed, begin=0 start=1 =|cs>d|= if $ eq 1

Generated partial line if 
expression(1, 3, 0) =|cs>d|= if $ eq 1

Generated partial line if fileinput.lineno()
Generated partial line if fileinput.lineno()==
Generated partial line if fileinput.lineno()==1
expression returns 4
Generated partial line if fileinput.lineno()==1:
  82 | 2 |   |        if fileinput.lineno() == 1:                                                     #PL: 

Tokens: cs>d ValPy: 
Main loop, line={


 === Line 82 Perl source:{===


Line:   82 TokenStr: =|{|= @ValPy: {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 82.
loop_needs_try_block(0), top=is_sub  level 1 is_loop  lno 82 in_sub 0 is_eval  type if  cur_sub  in_loop 1
Main loop, line=assert($_ =~ /issue 66/) if($. eq 1);


 === Line 83 Perl source:assert($_ =~ /issue 66/) if($. eq 1);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$_' value='_d' Tokenstr |c(s| translated: assert ( _d
Lexem 3 Current token='~' perl='=~' value='' Tokenstr |c(s~| translated: assert ( _d 
Lexem 4 Current token='q' perl='issue 66' value='re.search(r'issue 66',' Tokenstr |c(s~q| translated: assert ( _d  re.search(r'issue 66',
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(s~q)| translated: assert ( _d  re.search(r'issue 66', )
Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' perl='$' value='fileinput.lineno()' Tokenstr |c(s| translated: if  ( fileinput.lineno()
Lexem 3 Current token='>' perl='eq' value='==' Tokenstr |c(s>| translated: if  ( fileinput.lineno() ==
Lexem 4 Current token='d' perl='1' value='1' Tokenstr |c(s>d| translated: if  ( fileinput.lineno() == 1
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(s>d)| translated: if  ( fileinput.lineno() == 1 )

Line:   83 TokenStr: =|c(s>d)|= @ValPy: if  ( fileinput.lineno() == 1 )
control(0) =|c(s>d)|= if ( $ eq 1 )

control-parens removed, begin=0 start=1 =|cs>d|= if $ eq 1

Generated partial line if 
expression(1, 3, 0) =|cs>d|= if $ eq 1

Generated partial line if fileinput.lineno()
Generated partial line if fileinput.lineno()==
Generated partial line if fileinput.lineno()==1
expression returns 4
Generated partial line if fileinput.lineno()==1:
  83 | 3 |   |            if fileinput.lineno() == 1:                                                 #PL: assert($_ =~ /issue 66/) if($. eq 1);

Tokens: cs>d ValPy: 
Main loop, line=assert($_ =~ /issue 66/) if($. eq 1);
enter_block at line 83, prior nesting_level=2, ValPerl={
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 83.
nesting_info=level 2 is_loop  is_sub  in_loop 1 cur_sub  is_eval  in_sub 0 type if lno 83
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 83.
loop_needs_try_block(0), top=level 2 is_loop  is_sub  in_loop 1 cur_sub  is_eval  in_sub 0 type if lno 83
Main loop, line=assert($_ =~ /issue 66/) if($. eq 1);
control(0) =|c(s~q)|= assert ( $_ =~ issue 66 )

control-parens removed, begin=0 start=1 =|cs~q|= assert $_ =~ issue 66

Generated partial line assert
expression(1, 3, 0) =|cs~q|= assert $_ =~ issue 66

Generated partial line assertre.search(r'issue 66',
expression(1, 1, 0) =|cs~q|= assert $_ =~ issue 66

Generated partial line assertre.search(r'issue 66',_d
expression returns 2
Generated partial line assertre.search(r'issue 66',_d)
expression returns 4
  83 | 4 |   |                assert re.search(r'issue 66',_d)                                        #PL: assert($_ =~ /issue 66/) if($. eq 1);

Tokens: cs~q ValPy: 
Main loop, line=assert($_ =~ /issue 66/) if($. eq 1);
exit_block at line 83, prior nesting_level=3
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 83.
loop_needs_try_block(1), top=level 2 is_loop  is_sub  in_loop 1 cur_sub  is_eval  in_sub 0 type if lno 83
Main loop, line=assert($ARGV =~ /issue_66.pl/);


 === Line 84 Perl source:assert($ARGV =~ /issue_66.pl/);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$ARGV' value='fileinput.filename()' Tokenstr |c(s| translated: assert ( fileinput.filename()
Lexem 3 Current token='~' perl='=~' value='' Tokenstr |c(s~| translated: assert ( fileinput.filename() 
Lexem 4 Current token='q' perl='issue_66.pl' value='re.search(r'issue_66.pl',' Tokenstr |c(s~q| translated: assert ( fileinput.filename()  re.search(r'issue_66.pl',
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(s~q)| translated: assert ( fileinput.filename()  re.search(r'issue_66.pl', )

Line:   84 TokenStr: =|c(s~q)|= @ValPy: assert ( fileinput.filename()  re.search(r'issue_66.pl', )
control(0) =|c(s~q)|= assert ( $ARGV =~ issue_66.pl )

control-parens removed, begin=0 start=1 =|cs~q|= assert $ARGV =~ issue_66.pl

Generated partial line assert
expression(1, 3, 0) =|cs~q|= assert $ARGV =~ issue_66.pl

Generated partial line assertre.search(r'issue_66.pl',
expression(1, 1, 0) =|cs~q|= assert $ARGV =~ issue_66.pl

Generated partial line assertre.search(r'issue_66.pl',fileinput.filename()
expression returns 2
Generated partial line assertre.search(r'issue_66.pl',fileinput.filename())
expression returns 4
  85 | 3 |   |            assert re.search(r'issue_66.pl',fileinput.filename())                       #PL: 

Tokens: cs~q ValPy: 
Main loop, line=}


 === Line 85 Perl source:}===

exit_block at line 85, prior nesting_level=2

Line:   85 TokenStr: =|}|= @ValPy: }
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 85.
loop_needs_try_block(1), top=is_sub  level 1 is_loop  lno 82 in_sub 0 is_eval  type if  cur_sub  in_loop 1
  85 | 3 |   |
Main loop, line=$did_one = 1;


 === Line 86 Perl source:$did_one = 1;===

Lexem 0 Current token='s' perl='$did_one' value='did_one' Tokenstr |s| translated: did_one
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: did_one =
Lexem 2 Current token='d' perl='1' value='1' Tokenstr |s=d| translated: did_one = 1

Line:   86 TokenStr: =|s=d|= @ValPy: did_one = 1
assignment(0, 2) =|s=d|= $did_one = 1

Generated partial line did_one
Generated partial line did_one=
assign, ValClass[limit] = d, ValPy=1, ValPerl=1

Generated partial line did_one=1
  87 | 2 |   |        did_one = 1                                                                     #PL: last;

Tokens: s=d ValPy: 
Main loop, line=last;


 === Line 87 Perl source:last;===

Lexem 0 Current token='k' perl='last' value='break' Tokenstr |k| translated: break

Line:   87 TokenStr: =|k|= @ValPy: break
Generated partial line break
  88 | 2 |   |        break                                                                           #PL: 

Tokens: k ValPy: 
Main loop, line=}


 === Line 88 Perl source:}===

exit_block at line 88, prior nesting_level=1

Line:   88 TokenStr: =|}|= @ValPy: }
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 88.
loop_needs_try_block(1), top=is_loop 1 level 0 is_sub  lno 81 in_loop 1 cur_sub  in_sub 0 type while is_eval 
  88 | 2 |   |
Resetting context manager nest
Main loop, line=assert($did_one);


 === Line 89 Perl source:assert($did_one);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$did_one' value='did_one' Tokenstr |c(s| translated: assert ( did_one
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(s)| translated: assert ( did_one )

Line:   89 TokenStr: =|c(s)|= @ValPy: assert ( did_one )
control(0) =|c(s)|= assert ( $did_one )

control-parens removed, begin=0 start=1 =|cs|= assert $did_one

Generated partial line assert
expression(1, 1, 0) =|cs|= assert $did_one

Generated partial line assertdid_one
expression returns 2
  90 | 0 |   |assert did_one                                                                          #PL: @ARGV = (THISFILE);

Tokens: cs ValPy: 
Main loop, line=@ARGV = (THISFILE);


 === Line 90 Perl source:@ARGV = (THISFILE);===

Lexem 0 Current token='a' perl='@ARGV' value='sys.argv[1:]' Tokenstr |a| translated: sys.argv[1:]
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: sys.argv[1:] =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: sys.argv[1:] = (
Lexem 3 Current token='i' perl='THISFILE' value='THISFILE' Tokenstr |a=(i| translated: sys.argv[1:] = ( THISFILE
Lexem 4 Current token=')' perl=')' value=')' Tokenstr |a=(i)| translated: sys.argv[1:] = ( THISFILE )

Line:   90 TokenStr: =|a=(i)|= @ValPy: sys.argv[1:] = ( THISFILE )
Generated partial line sys.argv[1:] = [
Generated partial line sys.argv[1:] = [THISFILE
Generated partial line sys.argv[1:] = [THISFILE([])
Generated partial line sys.argv[1:] = [THISFILE([])]
  91 | 0 |   |sys.argv[1:] = [THISFILE([])]                                                           #PL: $did_one = 0;

Tokens: a=(i) ValPy: 
Main loop, line=$did_one = 0;


 === Line 91 Perl source:$did_one = 0;===

Lexem 0 Current token='s' perl='$did_one' value='did_one' Tokenstr |s| translated: did_one
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: did_one =
Lexem 2 Current token='d' perl='0' value='0' Tokenstr |s=d| translated: did_one = 0

Line:   91 TokenStr: =|s=d|= @ValPy: did_one = 0
assignment(0, 2) =|s=d|= $did_one = 0

Generated partial line did_one
Generated partial line did_one=
assign, ValClass[limit] = d, ValPy=0, ValPerl=0

Generated partial line did_one=0
  92 | 0 |   |did_one = 0                                                                             #PL: while(<<>>) {		# only can be a literal filename, not a pipe

Tokens: s=d ValPy: 
Main loop, line=while(<<>>) {		# only can be a literal filename, not a pipe


 === Line 92 Perl source:while(<<>>) {		# only can be a literal filename, not a pipe===

Lexem 0 Current token='c' perl='while' value='while' Tokenstr |c| translated: while
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: while (
Lexem 3 Current token='i' perl='<' value='next(_dia, None)' Tokenstr |Wc(i| translated: with fileinput.input() as _dia: while ( next(_dia, None)
Lexem 4 Current token=')' perl=')' value=')' Tokenstr |Wc(i)| translated: with fileinput.input() as _dia: while ( next(_dia, None) )
enter_block at line 92, prior nesting_level=0, ValPerl=<> while ( < ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 92.
nesting_info=is_sub  is_loop 1 level 0 in_sub 0 is_eval  type while cur_sub  in_loop 1 lno 92

Line:   92 TokenStr: =|Wc(i)|= @ValPy: with fileinput.input() as _dia: while ( next(_dia, None) )
Setting context_manager_nest = 0
  92 | 0 |   |with fileinput.input() as _dia:                                                         #PL: while(<<>>) {		# only can be a literal filename, not a pipe

Tokens: Wc(i) ValPy: 
control(0) =|c(i)|= while ( < )

control-parens removed, begin=0 start=1 =|ci|= while <

Generated partial line while (_d:=next(_dia, None))
Generated partial line while (_d:=next(_dia, None)):
  92 | 1 |   |    while (_d:=next(_dia, None)):                                                       #PL: 

Tokens: ci ValPy: 
Main loop, line={


 === Line 92 Perl source:{===


Line:   92 TokenStr: =|{|= @ValPy: {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 92.
loop_needs_try_block(0), top=is_sub  is_loop 1 level 0 in_sub 0 is_eval  type while cur_sub  in_loop 1 lno 92
  92 | 1 |   |    # only can be a literal filename, not a pipe
Main loop, line=if($. eq 1) {


 === Line 93 Perl source:if($. eq 1) {===

Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' perl='$' value='fileinput.lineno()' Tokenstr |c(s| translated: if  ( fileinput.lineno()
Lexem 3 Current token='>' perl='eq' value='==' Tokenstr |c(s>| translated: if  ( fileinput.lineno() ==
Lexem 4 Current token='d' perl='1' value='1' Tokenstr |c(s>d| translated: if  ( fileinput.lineno() == 1
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(s>d)| translated: if  ( fileinput.lineno() == 1 )
enter_block at line 93, prior nesting_level=1, ValPerl=if ( $ eq 1 ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 93.
nesting_info=is_sub  is_loop  level 1 cur_sub  type if  is_eval  in_sub 0 in_loop 1 lno 93

Line:   93 TokenStr: =|c(s>d)|= @ValPy: if  ( fileinput.lineno() == 1 )
control(0) =|c(s>d)|= if ( $ eq 1 )

control-parens removed, begin=0 start=1 =|cs>d|= if $ eq 1

Generated partial line if 
expression(1, 3, 0) =|cs>d|= if $ eq 1

Generated partial line if fileinput.lineno()
Generated partial line if fileinput.lineno()==
Generated partial line if fileinput.lineno()==1
expression returns 4
Generated partial line if fileinput.lineno()==1:
  93 | 2 |   |        if fileinput.lineno() == 1:                                                     #PL: 

Tokens: cs>d ValPy: 
Main loop, line={


 === Line 93 Perl source:{===


Line:   93 TokenStr: =|{|= @ValPy: {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 93.
loop_needs_try_block(0), top=is_sub  is_loop  level 1 cur_sub  type if  is_eval  in_sub 0 in_loop 1 lno 93
Main loop, line=assert($_ =~ /issue 66/) if($. eq 1);


 === Line 94 Perl source:assert($_ =~ /issue 66/) if($. eq 1);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$_' value='_d' Tokenstr |c(s| translated: assert ( _d
Lexem 3 Current token='~' perl='=~' value='' Tokenstr |c(s~| translated: assert ( _d 
Lexem 4 Current token='q' perl='issue 66' value='re.search(r'issue 66',' Tokenstr |c(s~q| translated: assert ( _d  re.search(r'issue 66',
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(s~q)| translated: assert ( _d  re.search(r'issue 66', )
Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' perl='$' value='fileinput.lineno()' Tokenstr |c(s| translated: if  ( fileinput.lineno()
Lexem 3 Current token='>' perl='eq' value='==' Tokenstr |c(s>| translated: if  ( fileinput.lineno() ==
Lexem 4 Current token='d' perl='1' value='1' Tokenstr |c(s>d| translated: if  ( fileinput.lineno() == 1
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(s>d)| translated: if  ( fileinput.lineno() == 1 )

Line:   94 TokenStr: =|c(s>d)|= @ValPy: if  ( fileinput.lineno() == 1 )
control(0) =|c(s>d)|= if ( $ eq 1 )

control-parens removed, begin=0 start=1 =|cs>d|= if $ eq 1

Generated partial line if 
expression(1, 3, 0) =|cs>d|= if $ eq 1

Generated partial line if fileinput.lineno()
Generated partial line if fileinput.lineno()==
Generated partial line if fileinput.lineno()==1
expression returns 4
Generated partial line if fileinput.lineno()==1:
  94 | 3 |   |            if fileinput.lineno() == 1:                                                 #PL: assert($_ =~ /issue 66/) if($. eq 1);

Tokens: cs>d ValPy: 
Main loop, line=assert($_ =~ /issue 66/) if($. eq 1);
enter_block at line 94, prior nesting_level=2, ValPerl={
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 94.
nesting_info=level 2 is_loop  is_sub  lno 94 in_loop 1 type if is_eval  in_sub 0 cur_sub 
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 94.
loop_needs_try_block(0), top=level 2 is_loop  is_sub  lno 94 in_loop 1 type if is_eval  in_sub 0 cur_sub 
Main loop, line=assert($_ =~ /issue 66/) if($. eq 1);
control(0) =|c(s~q)|= assert ( $_ =~ issue 66 )

control-parens removed, begin=0 start=1 =|cs~q|= assert $_ =~ issue 66

Generated partial line assert
expression(1, 3, 0) =|cs~q|= assert $_ =~ issue 66

Generated partial line assertre.search(r'issue 66',
expression(1, 1, 0) =|cs~q|= assert $_ =~ issue 66

Generated partial line assertre.search(r'issue 66',_d
expression returns 2
Generated partial line assertre.search(r'issue 66',_d)
expression returns 4
  94 | 4 |   |                assert re.search(r'issue 66',_d)                                        #PL: assert($_ =~ /issue 66/) if($. eq 1);

Tokens: cs~q ValPy: 
Main loop, line=assert($_ =~ /issue 66/) if($. eq 1);
exit_block at line 94, prior nesting_level=3
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 94.
loop_needs_try_block(1), top=level 2 is_loop  is_sub  lno 94 in_loop 1 type if is_eval  in_sub 0 cur_sub 
Main loop, line=assert($ARGV =~ /issue_66.pl/);


 === Line 95 Perl source:assert($ARGV =~ /issue_66.pl/);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$ARGV' value='fileinput.filename()' Tokenstr |c(s| translated: assert ( fileinput.filename()
Lexem 3 Current token='~' perl='=~' value='' Tokenstr |c(s~| translated: assert ( fileinput.filename() 
Lexem 4 Current token='q' perl='issue_66.pl' value='re.search(r'issue_66.pl',' Tokenstr |c(s~q| translated: assert ( fileinput.filename()  re.search(r'issue_66.pl',
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(s~q)| translated: assert ( fileinput.filename()  re.search(r'issue_66.pl', )

Line:   95 TokenStr: =|c(s~q)|= @ValPy: assert ( fileinput.filename()  re.search(r'issue_66.pl', )
control(0) =|c(s~q)|= assert ( $ARGV =~ issue_66.pl )

control-parens removed, begin=0 start=1 =|cs~q|= assert $ARGV =~ issue_66.pl

Generated partial line assert
expression(1, 3, 0) =|cs~q|= assert $ARGV =~ issue_66.pl

Generated partial line assertre.search(r'issue_66.pl',
expression(1, 1, 0) =|cs~q|= assert $ARGV =~ issue_66.pl

Generated partial line assertre.search(r'issue_66.pl',fileinput.filename()
expression returns 2
Generated partial line assertre.search(r'issue_66.pl',fileinput.filename())
expression returns 4
  96 | 3 |   |            assert re.search(r'issue_66.pl',fileinput.filename())                       #PL: 

Tokens: cs~q ValPy: 
Main loop, line=}


 === Line 96 Perl source:}===

exit_block at line 96, prior nesting_level=2

Line:   96 TokenStr: =|}|= @ValPy: }
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 96.
loop_needs_try_block(1), top=is_sub  is_loop  level 1 cur_sub  type if  is_eval  in_sub 0 in_loop 1 lno 93
  96 | 3 |   |
Main loop, line=$did_one = 1;


 === Line 97 Perl source:$did_one = 1;===

Lexem 0 Current token='s' perl='$did_one' value='did_one' Tokenstr |s| translated: did_one
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: did_one =
Lexem 2 Current token='d' perl='1' value='1' Tokenstr |s=d| translated: did_one = 1

Line:   97 TokenStr: =|s=d|= @ValPy: did_one = 1
assignment(0, 2) =|s=d|= $did_one = 1

Generated partial line did_one
Generated partial line did_one=
assign, ValClass[limit] = d, ValPy=1, ValPerl=1

Generated partial line did_one=1
  98 | 2 |   |        did_one = 1                                                                     #PL: last;

Tokens: s=d ValPy: 
Main loop, line=last;


 === Line 98 Perl source:last;===

Lexem 0 Current token='k' perl='last' value='break' Tokenstr |k| translated: break

Line:   98 TokenStr: =|k|= @ValPy: break
Generated partial line break
  99 | 2 |   |        break                                                                           #PL: 

Tokens: k ValPy: 
Main loop, line=}


 === Line 99 Perl source:}===

exit_block at line 99, prior nesting_level=1

Line:   99 TokenStr: =|}|= @ValPy: }
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 99.
loop_needs_try_block(1), top=is_sub  is_loop 1 level 0 in_sub 0 is_eval  type while cur_sub  in_loop 1 lno 92
  99 | 2 |   |
Resetting context manager nest
Main loop, line=assert($did_one);


 === Line 100 Perl source:assert($did_one);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$did_one' value='did_one' Tokenstr |c(s| translated: assert ( did_one
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(s)| translated: assert ( did_one )

Line:  100 TokenStr: =|c(s)|= @ValPy: assert ( did_one )
control(0) =|c(s)|= assert ( $did_one )

control-parens removed, begin=0 start=1 =|cs|= assert $did_one

Generated partial line assert
expression(1, 1, 0) =|cs|= assert $did_one

Generated partial line assertdid_one
expression returns 2
 101 | 0 |   |assert did_one                                                                          #PL: if($0 eq 'issue_66.py') {

Tokens: cs ValPy: 
Main loop, line=if($0 eq 'issue_66.py') {


 === Line 101 Perl source:if($0 eq 'issue_66.py') {===

Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' perl='0' value='__file__' Tokenstr |c(s| translated: if  ( __file__
Lexem 3 Current token='>' perl='eq' value='==' Tokenstr |c(s>| translated: if  ( __file__ ==
Lexem 4 Current token='"' perl='issue_66.py' value=''issue_66.py'' Tokenstr |c(s>"| translated: if  ( __file__ == 'issue_66.py'
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(s>")| translated: if  ( __file__ == 'issue_66.py' )
enter_block at line 101, prior nesting_level=0, ValPerl=if ( 0 eq issue_66.py ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 101.
nesting_info=is_eval  in_sub 0 type if  cur_sub  in_loop 0 lno 101 is_sub  level 0 is_loop 

Line:  101 TokenStr: =|c(s>")|= @ValPy: if  ( __file__ == 'issue_66.py' )
control(0) =|c(s>")|= if ( 0 eq issue_66.py )

control-parens removed, begin=0 start=1 =|cs>"|= if 0 eq issue_66.py

Generated partial line if 
expression(1, 3, 0) =|cs>"|= if 0 eq issue_66.py

Generated partial line if __file__
Generated partial line if __file__==
Generated partial line if __file__=='issue_66.py'
expression returns 4
Generated partial line if __file__=='issue_66.py':
 101 | 0 |   |if __file__ == 'issue_66.py':                                                           #PL: 

Tokens: cs>" ValPy: 
Main loop, line={


 === Line 101 Perl source:{===


Line:  101 TokenStr: =|{|= @ValPy: {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 101.
loop_needs_try_block(0), top=is_eval  in_sub 0 type if  cur_sub  in_loop 0 lno 101 is_sub  level 0 is_loop 
 102 | 0 |   |# We are running in python - check the code generation for the lines below this
Main loop, line=open(SOURCE, '<', 'issue_66.py');


 === Line 103 Perl source:open(SOURCE, '<', 'issue_66.py');===

Lexem 0 Current token='f' perl='open' value='open' Tokenstr |f| translated: open
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |f(| translated: open (
Lexem 2 Current token='i' perl='SOURCE' value='SOURCE' Tokenstr |f(i| translated: open ( SOURCE
Lexem 3 Current token=',' perl=',' value=',' Tokenstr |f(i,| translated: open ( SOURCE ,
Lexem 4 Current token='"' perl='<' value=''<'' Tokenstr |f(i,"| translated: open ( SOURCE , '<'
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |f(i,",| translated: open ( SOURCE , '<' ,
Lexem 6 Current token='"' perl='issue_66.py' value=''issue_66.py'' Tokenstr |f(i,","| translated: open ( SOURCE , '<' , 'issue_66.py'
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |f(i,",")| translated: open ( SOURCE , '<' , 'issue_66.py' )

Line:  103 TokenStr: =|f(i,",")|= @ValPy: open ( SOURCE , '<' , 'issue_66.py' )
 103 | 1 |   |    SOURCE = _open('issue_66.py', 'r')                                                  #PL: open(SOURCE, '<', 'issue_66.py');
Main loop, line=$found_start = 0;


 === Line 104 Perl source:$found_start = 0;===

Lexem 0 Current token='s' perl='$found_start' value='found_start' Tokenstr |s| translated: found_start
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: found_start =
Lexem 2 Current token='d' perl='0' value='0' Tokenstr |s=d| translated: found_start = 0

Line:  104 TokenStr: =|s=d|= @ValPy: found_start = 0
assignment(0, 2) =|s=d|= $found_start = 0

Generated partial line found_start
Generated partial line found_start=
assign, ValClass[limit] = d, ValPy=0, ValPerl=0

Generated partial line found_start=0
 105 | 1 |   |    found_start = 0                                                                     #PL: $with = 0;

Tokens: s=d ValPy: 
Main loop, line=$with = 0;


 === Line 105 Perl source:$with = 0;===

Lexem 0 Current token='s' perl='$with' value='with_' Tokenstr |s| translated: with_
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: with_ =
Lexem 2 Current token='d' perl='0' value='0' Tokenstr |s=d| translated: with_ = 0

Line:  105 TokenStr: =|s=d|= @ValPy: with_ = 0
assignment(0, 2) =|s=d|= $with = 0

Generated partial line with_
Generated partial line with_=
assign, ValClass[limit] = d, ValPy=0, ValPerl=0

Generated partial line with_=0
 106 | 1 |   |    with_ = 0                                                                           #PL: $while = 0;

Tokens: s=d ValPy: 
Main loop, line=$while = 0;


 === Line 106 Perl source:$while = 0;===

Lexem 0 Current token='s' perl='$while' value='while_' Tokenstr |s| translated: while_
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: while_ =
Lexem 2 Current token='d' perl='0' value='0' Tokenstr |s=d| translated: while_ = 0

Line:  106 TokenStr: =|s=d|= @ValPy: while_ = 0
assignment(0, 2) =|s=d|= $while = 0

Generated partial line while_
Generated partial line while_=
assign, ValClass[limit] = d, ValPy=0, ValPerl=0

Generated partial line while_=0
 107 | 1 |   |    while_ = 0                                                                          #PL: while(<SOURCE>) {

Tokens: s=d ValPy: 
Main loop, line=while(<SOURCE>) {


 === Line 107 Perl source:while(<SOURCE>) {===

Lexem 0 Current token='c' perl='while' value='while' Tokenstr |c| translated: while
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: while (
Lexem 3 Current token='i' perl='<SOURCE>' value='next(_dia, None)' Tokenstr |Wc(i| translated: with fileinput.input("<SOURCE>",openhook=lambda _,__:SOURCE) as _dia: while ( next(_dia, None)
Lexem 4 Current token=')' perl=')' value=')' Tokenstr |Wc(i)| translated: with fileinput.input("<SOURCE>",openhook=lambda _,__:SOURCE) as _dia: while ( next(_dia, None) )
enter_block at line 107, prior nesting_level=1, ValPerl=<SOURCE> while ( <SOURCE> ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 107.
nesting_info=level 1 is_loop 1 is_sub  lno 107 in_loop 1 cur_sub  is_eval  in_sub 0 type while

Line:  107 TokenStr: =|Wc(i)|= @ValPy: with fileinput.input("<SOURCE>",openhook=lambda _,__:SOURCE) as _dia: while ( next(_dia, None) )
Setting context_manager_nest = 1
 107 | 1 |   |    with fileinput.input("<SOURCE>",openhook=lambda _,__:SOURCE) as _dia:               #PL: while(<SOURCE>) {

Tokens: Wc(i) ValPy: 
control(0) =|c(i)|= while ( <SOURCE> )

control-parens removed, begin=0 start=1 =|ci|= while <SOURCE>

Generated partial line while (_d:=next(_dia, None))
Generated partial line while (_d:=next(_dia, None)):
 107 | 2 |   |        while (_d:=next(_dia, None)):                                                   #PL: 

Tokens: ci ValPy: 
Main loop, line={


 === Line 107 Perl source:{===


Line:  107 TokenStr: =|{|= @ValPy: {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 107.
loop_needs_try_block(0), top=level 1 is_loop 1 is_sub  lno 107 in_loop 1 cur_sub  is_eval  in_sub 0 type while
Main loop, line=$found_start = 1 if(substr($_,0,6) eq '######');


 === Line 108 Perl source:$found_start = 1 if(substr($_,0,6) eq '######');===

Lexem 0 Current token='s' perl='$found_start' value='found_start' Tokenstr |s| translated: found_start
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: found_start =
Lexem 2 Current token='d' perl='1' value='1' Tokenstr |s=d| translated: found_start = 1
Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='f' perl='substr' value='' Tokenstr |c(f| translated: if  ( 
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: if  (  (
Lexem 4 Current token='s' perl='$_' value='_d' Tokenstr |c(f(s| translated: if  (  ( _d
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |c(f(s,| translated: if  (  ( _d ,
Lexem 6 Current token='d' perl='0' value='0' Tokenstr |c(f(s,d| translated: if  (  ( _d , 0
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |c(f(s,d,| translated: if  (  ( _d , 0 ,
Lexem 8 Current token='d' perl='6' value='6' Tokenstr |c(f(s,d,d| translated: if  (  ( _d , 0 , 6
Lexem 9 Current token=')' perl=')' value=')' Tokenstr |c(f(s,d,d)| translated: if  (  ( _d , 0 , 6 )
Lexem 10 Current token='>' perl='eq' value='==' Tokenstr |c(f(s,d,d)>| translated: if  (  ( _d , 0 , 6 ) ==
Lexem 11 Current token='"' perl='######' value=''######'' Tokenstr |c(f(s,d,d)>"| translated: if  (  ( _d , 0 , 6 ) == '######'
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |c(f(s,d,d)>")| translated: if  (  ( _d , 0 , 6 ) == '######' )

Line:  108 TokenStr: =|c(f(s,d,d)>")|= @ValPy: if  (  ( _d , 0 , 6 ) == '######' )
control(0) =|c(f(s,d,d)>")|= if ( substr ( $_ , 0 , 6 ) eq ###### )

control-parens removed, begin=0 start=1 =|cf(s,d,d)>"|= if substr ( $_ , 0 , 6 ) eq ######

Generated partial line if 
expression(1, 10, 0) =|cf(s,d,d)>"|= if substr ( $_ , 0 , 6 ) eq ######

function(1, 10) =|cf(s,d,d)>"|= if substr ( $_ , 0 , 6 ) eq ######

function start=3, end_pos=7, bracketed=1
Generated partial line if _d[0:6]
Generated partial line if _d[0:6]==
Generated partial line if _d[0:6]=='######'
expression returns 11
Generated partial line if _d[0:6]=='######':
 108 | 3 |   |            if _d[0:6] == '######':                                                     #PL: $found_start = 1 if(substr($_,0,6) eq '######');

Tokens: cf(s,d,d)>" ValPy: 
Main loop, line=$found_start = 1 if(substr($_,0,6) eq '######');
enter_block at line 108, prior nesting_level=2, ValPerl={
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 108.
nesting_info=level 2 is_loop  is_sub  in_loop 1 type if in_sub 0 is_eval  cur_sub  lno 108
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 108.
loop_needs_try_block(0), top=level 2 is_loop  is_sub  in_loop 1 type if in_sub 0 is_eval  cur_sub  lno 108
Main loop, line=$found_start = 1 if(substr($_,0,6) eq '######');
assignment(0, 2) =|s=d|= $found_start = 1

Generated partial line found_start
Generated partial line found_start=
assign, ValClass[limit] = d, ValPy=1, ValPerl=1

Generated partial line found_start=1
 108 | 4 |   |                found_start = 1                                                         #PL: $found_start = 1 if(substr($_,0,6) eq '######');

Tokens: s=d ValPy: 
Main loop, line=$found_start = 1 if(substr($_,0,6) eq '######');
exit_block at line 108, prior nesting_level=3
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 108.
loop_needs_try_block(1), top=level 2 is_loop  is_sub  in_loop 1 type if in_sub 0 is_eval  cur_sub  lno 108
Main loop, line=if($found_start) {


 === Line 109 Perl source:if($found_start) {===

Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' perl='$found_start' value='found_start' Tokenstr |c(s| translated: if  ( found_start
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(s)| translated: if  ( found_start )
enter_block at line 109, prior nesting_level=2, ValPerl=if ( $found_start ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 109.
nesting_info=is_sub  level 2 is_loop  lno 109 cur_sub  in_sub 0 is_eval  type if  in_loop 1

Line:  109 TokenStr: =|c(s)|= @ValPy: if  ( found_start )
control(0) =|c(s)|= if ( $found_start )

control-parens removed, begin=0 start=1 =|cs|= if $found_start

Generated partial line if 
expression(1, 1, 0) =|cs|= if $found_start

Generated partial line if found_start
expression returns 2
Generated partial line if found_start:
 109 | 3 |   |            if found_start:                                                             #PL: 

Tokens: cs ValPy: 
Main loop, line={


 === Line 109 Perl source:{===


Line:  109 TokenStr: =|{|= @ValPy: {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 109.
loop_needs_try_block(0), top=is_sub  level 2 is_loop  lno 109 cur_sub  in_sub 0 is_eval  type if  in_loop 1
Main loop, line=if(/^    with/) {


 === Line 110 Perl source:if(/^    with/) {===

Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='q' perl='^    with' value='re.search(r'^    with',_d)' Tokenstr |c(q| translated: if  ( re.search(r'^    with',_d)
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(q)| translated: if  ( re.search(r'^    with',_d) )
enter_block at line 110, prior nesting_level=3, ValPerl=if ( ^    with ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 110.
nesting_info=in_loop 1 cur_sub  in_sub 0 type if  is_eval  lno 110 is_loop  level 3 is_sub 

Line:  110 TokenStr: =|c(q)|= @ValPy: if  ( re.search(r'^    with',_d) )
control(0) =|c(q)|= if ( ^    with )

control-parens removed, begin=0 start=1 =|cq|= if ^    with

Generated partial line if 
expression(1, 1, 0) =|cq|= if ^    with

Generated partial line if re.search(r'^    with',_d)
expression returns 2
Generated partial line if re.search(r'^    with',_d):
 110 | 4 |   |                if re.search(r'^    with',_d):                                          #PL: 

Tokens: cq ValPy: 
Main loop, line={


 === Line 110 Perl source:{===


Line:  110 TokenStr: =|{|= @ValPy: {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 110.
loop_needs_try_block(0), top=in_loop 1 cur_sub  in_sub 0 type if  is_eval  lno 110 is_loop  level 3 is_sub 
Main loop, line=$with++;


 === Line 111 Perl source:$with++;===

Lexem 0 Current token='s' perl='$with' value='with_' Tokenstr |s| translated: with_
Lexem 1 Current token='^' perl='++' value='+=1' Tokenstr |s^| translated: with_ +=1

Line:  111 TokenStr: =|s^|= @ValPy: with_ +=1
handle_incr_decr(0, 1, 1) with ++assignment(0, 1) =|s^|= $with ++

Generated partial line with_+=1
 112 | 5 |   |                    with_+=1                                                            #PL: assert(index($_, "fileinput.input('-') as _dia:") > 0);

Tokens: s^ ValPy: 
Main loop, line=assert(index($_, "fileinput.input('-') as _dia:") > 0);


 === Line 112 Perl source:assert(index($_, "fileinput.input('-') as _dia:") > 0);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='index' value='.find' Tokenstr |c(f| translated: assert ( .find
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( .find (
Lexem 4 Current token='s' perl='$_' value='_d' Tokenstr |c(f(s| translated: assert ( .find ( _d
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |c(f(s,| translated: assert ( .find ( _d ,
Lexem 6 Current token='"' perl='fileinput.input('-') as _dia:' value='"fileinput.input('-') as _dia:"' Tokenstr |c(f(s,"| translated: assert ( .find ( _d , "fileinput.input('-') as _dia:"
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |c(f(s,")| translated: assert ( .find ( _d , "fileinput.input('-') as _dia:" )
Lexem 8 Current token='>' perl='>' value='>' Tokenstr |c(f(s,")>| translated: assert ( .find ( _d , "fileinput.input('-') as _dia:" ) >
Lexem 9 Current token='d' perl='0' value='0' Tokenstr |c(f(s,")>d| translated: assert ( .find ( _d , "fileinput.input('-') as _dia:" ) > 0
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |c(f(s,")>d)| translated: assert ( .find ( _d , "fileinput.input('-') as _dia:" ) > 0 )

Line:  112 TokenStr: =|c(f(s,")>d)|= @ValPy: assert ( .find ( _d , "fileinput.input('-') as _dia:" ) > 0 )
control(0) =|c(f(s,")>d)|= assert ( index ( $_ , fileinput.input('-') as _dia: ) > 0 )

control-parens removed, begin=0 start=1 =|cf(s,")>d|= assert index ( $_ , fileinput.input('-') as _dia: ) > 0

Generated partial line assert
expression(1, 8, 0) =|cf(s,")>d|= assert index ( $_ , fileinput.input('-') as _dia: ) > 0

function(1, 8) =|cf(s,")>d|= assert index ( $_ , fileinput.input('-') as _dia: ) > 0

function start=3, end_pos=5, bracketed=1
Generated partial line assert_d.find(
expression(5, 5, 0) =|cf(s,")>d|= assert index ( $_ , fileinput.input('-') as _dia: ) > 0

Generated partial line assert_d.find("fileinput.input('-') as _dia:"
expression returns 6
Generated partial line assert_d.find("fileinput.input('-') as _dia:")
Generated partial line assert_d.find("fileinput.input('-') as _dia:")>
Generated partial line assert_d.find("fileinput.input('-') as _dia:")>0
expression returns 9
 113 | 5 |   |                    assert _d.find("fileinput.input('-') as _dia:") > 0                 #PL: } elsif(/^        while/) {

Tokens: cf(s,")>d ValPy: 
Main loop, line=} elsif(/^        while/) {


 === Line 113 Perl source:} elsif(/^        while/) {===

exit_block at line 113, prior nesting_level=4

Line:  113 TokenStr: =|}|= @ValPy: }
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 113.
loop_needs_try_block(1), top=in_loop 1 cur_sub  in_sub 0 type if  is_eval  lno 110 is_loop  level 3 is_sub 
Main loop, line=elsif(/^        while/) {


 === Line 113 Perl source:elsif(/^        while/) {===

Lexem 0 Current token='C' perl='elsif' value='elif ' Tokenstr |C| translated: elif 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |C(| translated: elif  (
Lexem 2 Current token='q' perl='^        while' value='re.search(r'^        while',_d)' Tokenstr |C(q| translated: elif  ( re.search(r'^        while',_d)
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |C(q)| translated: elif  ( re.search(r'^        while',_d) )
enter_block at line 113, prior nesting_level=3, ValPerl=elsif ( ^        while ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 113.
nesting_info=level 3 is_loop  is_sub  lno 113 in_loop 1 type elif  is_eval  in_sub 0 cur_sub 

Line:  113 TokenStr: =|C(q)|= @ValPy: elif  ( re.search(r'^        while',_d) )
Generated partial line elif 
expression(2, 2, 0) =|C(q)|= elsif ( ^        while )

Generated partial line elif re.search(r'^        while',_d)
expression returns 3
Generated partial line elif re.search(r'^        while',_d):
 113 | 4 |   |                elif re.search(r'^        while',_d):                                   #PL: elsif(/^        while/) {

Tokens: C(q) ValPy: 
Main loop, line={


 === Line 113 Perl source:{===


Line:  113 TokenStr: =|{|= @ValPy: {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 113.
loop_needs_try_block(0), top=level 3 is_loop  is_sub  lno 113 in_loop 1 type elif  is_eval  in_sub 0 cur_sub 
Main loop, line=$while++;


 === Line 114 Perl source:$while++;===

Lexem 0 Current token='s' perl='$while' value='while_' Tokenstr |s| translated: while_
Lexem 1 Current token='^' perl='++' value='+=1' Tokenstr |s^| translated: while_ +=1

Line:  114 TokenStr: =|s^|= @ValPy: while_ +=1
handle_incr_decr(0, 1, 1) with ++assignment(0, 1) =|s^|= $while ++

Generated partial line while_+=1
 115 | 5 |   |                    while_+=1                                                           #PL: assert(index($_, "(_d:=next(_dia, None)):") > 0) if($while==1);

Tokens: s^ ValPy: 
Main loop, line=assert(index($_, "(_d:=next(_dia, None)):") > 0) if($while==1);


 === Line 115 Perl source:assert(index($_, "(_d:=next(_dia, None)):") > 0) if($while==1);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='index' value='.find' Tokenstr |c(f| translated: assert ( .find
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( .find (
Lexem 4 Current token='s' perl='$_' value='_d' Tokenstr |c(f(s| translated: assert ( .find ( _d
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |c(f(s,| translated: assert ( .find ( _d ,
Lexem 6 Current token='"' perl='(_d:=next(_dia, None)):' value=''(_d:=next(_dia, None)):'' Tokenstr |c(f(s,"| translated: assert ( .find ( _d , '(_d:=next(_dia, None)):'
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |c(f(s,")| translated: assert ( .find ( _d , '(_d:=next(_dia, None)):' )
Lexem 8 Current token='>' perl='>' value='>' Tokenstr |c(f(s,")>| translated: assert ( .find ( _d , '(_d:=next(_dia, None)):' ) >
Lexem 9 Current token='d' perl='0' value='0' Tokenstr |c(f(s,")>d| translated: assert ( .find ( _d , '(_d:=next(_dia, None)):' ) > 0
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |c(f(s,")>d)| translated: assert ( .find ( _d , '(_d:=next(_dia, None)):' ) > 0 )
Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' perl='$while' value='while_' Tokenstr |c(s| translated: if  ( while_
Lexem 3 Current token='>' perl='==' value='==' Tokenstr |c(s>| translated: if  ( while_ ==
Lexem 4 Current token='d' perl='1' value='1' Tokenstr |c(s>d| translated: if  ( while_ == 1
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(s>d)| translated: if  ( while_ == 1 )

Line:  115 TokenStr: =|c(s>d)|= @ValPy: if  ( while_ == 1 )
control(0) =|c(s>d)|= if ( $while == 1 )

control-parens removed, begin=0 start=1 =|cs>d|= if $while == 1

Generated partial line if 
expression(1, 3, 0) =|cs>d|= if $while == 1

Generated partial line if while_
Generated partial line if while_==
Generated partial line if while_==1
expression returns 4
Generated partial line if while_==1:
 115 | 5 |   |                    if while_ == 1:                                                     #PL: assert(index($_, "(_d:=next(_dia, None)):") > 0) if($while==1);

Tokens: cs>d ValPy: 
Main loop, line=assert(index($_, "(_d:=next(_dia, None)):") > 0) if($while==1);
enter_block at line 115, prior nesting_level=4, ValPerl={
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 115.
nesting_info=in_loop 1 cur_sub  is_eval  type if in_sub 0 lno 115 is_loop  level 4 is_sub 
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 115.
loop_needs_try_block(0), top=in_loop 1 cur_sub  is_eval  type if in_sub 0 lno 115 is_loop  level 4 is_sub 
Main loop, line=assert(index($_, "(_d:=next(_dia, None)):") > 0) if($while==1);
control(0) =|c(f(s,")>d)|= assert ( index ( $_ , (_d:=next(_dia, None)): ) > 0 )

control-parens removed, begin=0 start=1 =|cf(s,")>d|= assert index ( $_ , (_d:=next(_dia, None)): ) > 0

Generated partial line assert
expression(1, 8, 0) =|cf(s,")>d|= assert index ( $_ , (_d:=next(_dia, None)): ) > 0

function(1, 8) =|cf(s,")>d|= assert index ( $_ , (_d:=next(_dia, None)): ) > 0

function start=3, end_pos=5, bracketed=1
Generated partial line assert_d.find(
expression(5, 5, 0) =|cf(s,")>d|= assert index ( $_ , (_d:=next(_dia, None)): ) > 0

Generated partial line assert_d.find('(_d:=next(_dia, None)):'
expression returns 6
Generated partial line assert_d.find('(_d:=next(_dia, None)):')
Generated partial line assert_d.find('(_d:=next(_dia, None)):')>
Generated partial line assert_d.find('(_d:=next(_dia, None)):')>0
expression returns 9
 115 | 6 |   |                        assert _d.find('(_d:=next(_dia, None)):') > 0                   #PL: assert(index($_, "(_d:=next(_dia, None)):") > 0) if($while==1);

Tokens: cf(s,")>d ValPy: 
Main loop, line=assert(index($_, "(_d:=next(_dia, None)):") > 0) if($while==1);
exit_block at line 115, prior nesting_level=5
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 115.
loop_needs_try_block(1), top=in_loop 1 cur_sub  is_eval  type if in_sub 0 lno 115 is_loop  level 4 is_sub 
Main loop, line=assert(index($_, "(line:=next(_dia, None)):") > 0) if($while>1);


 === Line 116 Perl source:assert(index($_, "(line:=next(_dia, None)):") > 0) if($while>1);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='index' value='.find' Tokenstr |c(f| translated: assert ( .find
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( .find (
Lexem 4 Current token='s' perl='$_' value='_d' Tokenstr |c(f(s| translated: assert ( .find ( _d
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |c(f(s,| translated: assert ( .find ( _d ,
Lexem 6 Current token='"' perl='(line:=next(_dia, None)):' value=''(line:=next(_dia, None)):'' Tokenstr |c(f(s,"| translated: assert ( .find ( _d , '(line:=next(_dia, None)):'
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |c(f(s,")| translated: assert ( .find ( _d , '(line:=next(_dia, None)):' )
Lexem 8 Current token='>' perl='>' value='>' Tokenstr |c(f(s,")>| translated: assert ( .find ( _d , '(line:=next(_dia, None)):' ) >
Lexem 9 Current token='d' perl='0' value='0' Tokenstr |c(f(s,")>d| translated: assert ( .find ( _d , '(line:=next(_dia, None)):' ) > 0
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |c(f(s,")>d)| translated: assert ( .find ( _d , '(line:=next(_dia, None)):' ) > 0 )
Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' perl='$while' value='while_' Tokenstr |c(s| translated: if  ( while_
Lexem 3 Current token='>' perl='>' value='>' Tokenstr |c(s>| translated: if  ( while_ >
Lexem 4 Current token='d' perl='1' value='1' Tokenstr |c(s>d| translated: if  ( while_ > 1
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(s>d)| translated: if  ( while_ > 1 )

Line:  116 TokenStr: =|c(s>d)|= @ValPy: if  ( while_ > 1 )
control(0) =|c(s>d)|= if ( $while > 1 )

control-parens removed, begin=0 start=1 =|cs>d|= if $while > 1

Generated partial line if 
expression(1, 3, 0) =|cs>d|= if $while > 1

Generated partial line if while_
Generated partial line if while_>
Generated partial line if while_>1
expression returns 4
Generated partial line if while_>1:
 116 | 5 |   |                    if while_ > 1:                                                      #PL: assert(index($_, "(line:=next(_dia, None)):") > 0) if($while>1);

Tokens: cs>d ValPy: 
Main loop, line=assert(index($_, "(line:=next(_dia, None)):") > 0) if($while>1);
enter_block at line 116, prior nesting_level=4, ValPerl={
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 116.
nesting_info=lno 116 in_loop 1 is_eval  type if in_sub 0 cur_sub  is_loop  level 4 is_sub 
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 116.
loop_needs_try_block(0), top=lno 116 in_loop 1 is_eval  type if in_sub 0 cur_sub  is_loop  level 4 is_sub 
Main loop, line=assert(index($_, "(line:=next(_dia, None)):") > 0) if($while>1);
control(0) =|c(f(s,")>d)|= assert ( index ( $_ , (line:=next(_dia, None)): ) > 0 )

control-parens removed, begin=0 start=1 =|cf(s,")>d|= assert index ( $_ , (line:=next(_dia, None)): ) > 0

Generated partial line assert
expression(1, 8, 0) =|cf(s,")>d|= assert index ( $_ , (line:=next(_dia, None)): ) > 0

function(1, 8) =|cf(s,")>d|= assert index ( $_ , (line:=next(_dia, None)): ) > 0

function start=3, end_pos=5, bracketed=1
Generated partial line assert_d.find(
expression(5, 5, 0) =|cf(s,")>d|= assert index ( $_ , (line:=next(_dia, None)): ) > 0

Generated partial line assert_d.find('(line:=next(_dia, None)):'
expression returns 6
Generated partial line assert_d.find('(line:=next(_dia, None)):')
Generated partial line assert_d.find('(line:=next(_dia, None)):')>
Generated partial line assert_d.find('(line:=next(_dia, None)):')>0
expression returns 9
 116 | 6 |   |                        assert _d.find('(line:=next(_dia, None)):') > 0                 #PL: assert(index($_, "(line:=next(_dia, None)):") > 0) if($while>1);

Tokens: cf(s,")>d ValPy: 
Main loop, line=assert(index($_, "(line:=next(_dia, None)):") > 0) if($while>1);
exit_block at line 116, prior nesting_level=5
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 116.
loop_needs_try_block(1), top=lno 116 in_loop 1 is_eval  type if in_sub 0 cur_sub  is_loop  level 4 is_sub 
Main loop, line=}


 === Line 117 Perl source:}===

exit_block at line 117, prior nesting_level=4

Line:  117 TokenStr: =|}|= @ValPy: }
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 117.
loop_needs_try_block(1), top=level 3 is_loop  is_sub  lno 113 in_loop 1 type elif  is_eval  in_sub 0 cur_sub 
 117 | 5 |   |
Main loop, line=}


 === Line 118 Perl source:}===

exit_block at line 118, prior nesting_level=3

Line:  118 TokenStr: =|}|= @ValPy: }
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 118.
loop_needs_try_block(1), top=is_sub  level 2 is_loop  lno 109 cur_sub  in_sub 0 is_eval  type if  in_loop 1
 118 | 4 |   |
Main loop, line=}


 === Line 119 Perl source:}===

exit_block at line 119, prior nesting_level=2

Line:  119 TokenStr: =|}|= @ValPy: }
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 119.
loop_needs_try_block(1), top=level 1 is_loop 1 is_sub  lno 107 in_loop 1 cur_sub  is_eval  in_sub 0 type while
 119 | 3 |   |
Resetting context manager nest
Main loop, line=assert($with == 3);


 === Line 120 Perl source:assert($with == 3);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$with' value='with_' Tokenstr |c(s| translated: assert ( with_
Lexem 3 Current token='>' perl='==' value='==' Tokenstr |c(s>| translated: assert ( with_ ==
Lexem 4 Current token='d' perl='3' value='3' Tokenstr |c(s>d| translated: assert ( with_ == 3
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(s>d)| translated: assert ( with_ == 3 )

Line:  120 TokenStr: =|c(s>d)|= @ValPy: assert ( with_ == 3 )
control(0) =|c(s>d)|= assert ( $with == 3 )

control-parens removed, begin=0 start=1 =|cs>d|= assert $with == 3

Generated partial line assert
expression(1, 3, 0) =|cs>d|= assert $with == 3

Generated partial line assertwith_
Generated partial line assertwith_==
Generated partial line assertwith_==3
expression returns 4
 121 | 1 |   |    assert with_ == 3                                                                   #PL: assert($while == 3);

Tokens: cs>d ValPy: 
Main loop, line=assert($while == 3);


 === Line 121 Perl source:assert($while == 3);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' perl='$while' value='while_' Tokenstr |c(s| translated: assert ( while_
Lexem 3 Current token='>' perl='==' value='==' Tokenstr |c(s>| translated: assert ( while_ ==
Lexem 4 Current token='d' perl='3' value='3' Tokenstr |c(s>d| translated: assert ( while_ == 3
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(s>d)| translated: assert ( while_ == 3 )

Line:  121 TokenStr: =|c(s>d)|= @ValPy: assert ( while_ == 3 )
control(0) =|c(s>d)|= assert ( $while == 3 )

control-parens removed, begin=0 start=1 =|cs>d|= assert $while == 3

Generated partial line assert
expression(1, 3, 0) =|cs>d|= assert $while == 3

Generated partial line assertwhile_
Generated partial line assertwhile_==
Generated partial line assertwhile_==3
expression returns 4
 122 | 1 |   |    assert while_ == 3                                                                  #PL: 

Tokens: cs>d ValPy: 
Main loop, line=}


 === Line 122 Perl source:}===

exit_block at line 122, prior nesting_level=1

Line:  122 TokenStr: =|}|= @ValPy: }
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 122.
loop_needs_try_block(1), top=is_eval  in_sub 0 type if  cur_sub  in_loop 0 lno 101 is_sub  level 0 is_loop 
initialize_globals_for_state_vars: 
 122 | 0 |   |
 123 | 0 |   |
 124 | 0 |   |###### START OF CODE CHECK ######
Main loop, line=if(0) {


 === Line 125 Perl source:if(0) {===

Lexem 0 Current token='c' perl='if' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='d' perl='0' value='0' Tokenstr |c(d| translated: if  ( 0
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |c(d)| translated: if  ( 0 )
enter_block at line 125, prior nesting_level=0, ValPerl=if ( 0 ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 125.
nesting_info=lno 125 cur_sub  type if  is_eval  in_sub 0 in_loop 0 is_sub  is_loop  level 0

Line:  125 TokenStr: =|c(d)|= @ValPy: if  ( 0 )
control(0) =|c(d)|= if ( 0 )

control-parens removed, begin=0 start=1 =|cd|= if 0

Generated partial line if 
expression(1, 1, 0) =|cd|= if 0

Generated partial line if 0
expression returns 2
Generated partial line if 0:
 125 | 0 |   |if 0:                                                                                   #PL: 

Tokens: cd ValPy: 
Main loop, line={


 === Line 125 Perl source:{===


Line:  125 TokenStr: =|{|= @ValPy: {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 125.
loop_needs_try_block(0), top=lno 125 cur_sub  type if  is_eval  in_sub 0 in_loop 0 is_sub  is_loop  level 0
Main loop, line=while(<STDIN>) {	# Manually check the generated code


 === Line 126 Perl source:while(<STDIN>) {	# Manually check the generated code===

Lexem 0 Current token='c' perl='while' value='while' Tokenstr |c| translated: while
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: while (
Lexem 3 Current token='i' perl='<STDIN>' value='next(_dia, None)' Tokenstr |Wc(i| translated: with fileinput.input('-') as _dia: while ( next(_dia, None)
Lexem 4 Current token=')' perl=')' value=')' Tokenstr |Wc(i)| translated: with fileinput.input('-') as _dia: while ( next(_dia, None) )
enter_block at line 126, prior nesting_level=1, ValPerl=<STDIN> while ( <STDIN> ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 126.
nesting_info=is_sub  level 1 is_loop 1 lno 126 cur_sub  is_eval  in_sub 0 type while in_loop 1

Line:  126 TokenStr: =|Wc(i)|= @ValPy: with fileinput.input('-') as _dia: while ( next(_dia, None) )
Setting context_manager_nest = 1
 126 | 1 |   |    with fileinput.input('-') as _dia:                                                  #PL: while(<STDIN>) {	# Manually check the generated code

Tokens: Wc(i) ValPy: 
control(0) =|c(i)|= while ( <STDIN> )

control-parens removed, begin=0 start=1 =|ci|= while <STDIN>

Generated partial line while (_d:=next(_dia, None))
Generated partial line while (_d:=next(_dia, None)):
 126 | 2 |   |        while (_d:=next(_dia, None)):                                                   #PL: 

Tokens: ci ValPy: 
Main loop, line={


 === Line 126 Perl source:{===


Line:  126 TokenStr: =|{|= @ValPy: {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 126.
loop_needs_try_block(0), top=is_sub  level 1 is_loop 1 lno 126 cur_sub  is_eval  in_sub 0 type while in_loop 1
 126 | 2 |   |        # Manually check the generated code
Main loop, line=;


 === Line 127 Perl source:;===


Line:  127 TokenStr: =||= @ValPy: 
 127 | 3 |   |            pass                                                                        #PL: ;

Tokens:  ValPy: 
Main loop, line=}


 === Line 128 Perl source:}===

exit_block at line 128, prior nesting_level=2

Line:  128 TokenStr: =|}|= @ValPy: }
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 128.
loop_needs_try_block(1), top=is_sub  level 1 is_loop 1 lno 126 cur_sub  is_eval  in_sub 0 type while in_loop 1
 128 | 3 |   |
Resetting context manager nest
Main loop, line=while(my $line = <STDIN>) {


 === Line 129 Perl source:while(my $line = <STDIN>) {===

Lexem 0 Current token='c' perl='while' value='while' Tokenstr |c| translated: while
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: while (
Lexem 2 Current token='s' perl='$line' value='line' Tokenstr |c(s| translated: while ( line
Lexem 3 Current token='=' perl='=' value=':=' Tokenstr |c(s=| translated: while ( line :=
Lexem 5 Current token='i' perl='<STDIN>' value='next(_dia, None)' Tokenstr |Wc(s=i| translated: with fileinput.input('-') as _dia: while ( line := next(_dia, None)
Lexem 6 Current token=')' perl=')' value=')' Tokenstr |Wc(s=i)| translated: with fileinput.input('-') as _dia: while ( line := next(_dia, None) )
enter_block at line 129, prior nesting_level=1, ValPerl=<STDIN> while ( $line = <STDIN> ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 129.
nesting_info=in_loop 1 cur_sub  is_eval  type while in_sub 0 lno 129 is_loop 1 level 1 is_sub 

Line:  129 TokenStr: =|Wc(s=i)|= @ValPy: with fileinput.input('-') as _dia: while ( line := next(_dia, None) )
Setting context_manager_nest = 1
 129 | 1 |   |    with fileinput.input('-') as _dia:                                                  #PL: while(my $line = <STDIN>) {

Tokens: Wc(s=i) ValPy: 
control(0) =|c(s=i)|= while ( $line = <STDIN> )

Generated partial line while
expression(1, 5, 1) =|c(s=i)|= while ( $line = <STDIN> )

Generated partial line while(
expression(2, 4, 0) =|c(s=i)|= while ( $line = <STDIN> )

Generated partial line while(line
Generated partial line while(line:=
Generated partial line while(line:=next(_dia, None)
expression returns 5
Generated partial line while(line:=next(_dia, None))
expression returns 6
Generated partial line while(line:=next(_dia, None)):
 129 | 2 |   |        while (line:=next(_dia, None)):                                                 #PL: 

Tokens: c(s=i) ValPy: 
Main loop, line={


 === Line 129 Perl source:{===


Line:  129 TokenStr: =|{|= @ValPy: {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 129.
loop_needs_try_block(0), top=in_loop 1 cur_sub  is_eval  type while in_sub 0 lno 129 is_loop 1 level 1 is_sub 
Main loop, line=;


 === Line 130 Perl source:;===


Line:  130 TokenStr: =||= @ValPy: 
 130 | 3 |   |            pass                                                                        #PL: ;

Tokens:  ValPy: 
Main loop, line=}


 === Line 131 Perl source:}===

exit_block at line 131, prior nesting_level=2

Line:  131 TokenStr: =|}|= @ValPy: }
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 131.
loop_needs_try_block(1), top=in_loop 1 cur_sub  is_eval  type while in_sub 0 lno 129 is_loop 1 level 1 is_sub 
 131 | 3 |   |
Resetting context manager nest
Main loop, line=while($line = <STDIN>) {


 === Line 132 Perl source:while($line = <STDIN>) {===

Lexem 0 Current token='c' perl='while' value='while' Tokenstr |c| translated: while
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: while (
Lexem 2 Current token='s' perl='$line' value='line' Tokenstr |c(s| translated: while ( line
Lexem 3 Current token='=' perl='=' value=':=' Tokenstr |c(s=| translated: while ( line :=
Lexem 5 Current token='i' perl='<STDIN>' value='next(_dia, None)' Tokenstr |Wc(s=i| translated: with fileinput.input('-') as _dia: while ( line := next(_dia, None)
Lexem 6 Current token=')' perl=')' value=')' Tokenstr |Wc(s=i)| translated: with fileinput.input('-') as _dia: while ( line := next(_dia, None) )
enter_block at line 132, prior nesting_level=1, ValPerl=<STDIN> while ( $line = <STDIN> ) {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 371, <> line 132.
nesting_info=is_loop 1 level 1 is_sub  lno 132 in_loop 1 cur_sub  in_sub 0 type while is_eval 

Line:  132 TokenStr: =|Wc(s=i)|= @ValPy: with fileinput.input('-') as _dia: while ( line := next(_dia, None) )
Setting context_manager_nest = 1
 132 | 1 |   |    with fileinput.input('-') as _dia:                                                  #PL: while($line = <STDIN>) {

Tokens: Wc(s=i) ValPy: 
control(0) =|c(s=i)|= while ( $line = <STDIN> )

Generated partial line while
expression(1, 5, 1) =|c(s=i)|= while ( $line = <STDIN> )

Generated partial line while(
expression(2, 4, 0) =|c(s=i)|= while ( $line = <STDIN> )

Generated partial line while(line
Generated partial line while(line:=
Generated partial line while(line:=next(_dia, None)
expression returns 5
Generated partial line while(line:=next(_dia, None))
expression returns 6
Generated partial line while(line:=next(_dia, None)):
 132 | 2 |   |        while (line:=next(_dia, None)):                                                 #PL: 

Tokens: c(s=i) ValPy: 
Main loop, line={


 === Line 132 Perl source:{===


Line:  132 TokenStr: =|{|= @ValPy: {
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 132.
loop_needs_try_block(0), top=is_loop 1 level 1 is_sub  lno 132 in_loop 1 cur_sub  in_sub 0 type while is_eval 
Main loop, line=;


 === Line 133 Perl source:;===


Line:  133 TokenStr: =||= @ValPy: 
 133 | 3 |   |            pass                                                                        #PL: ;

Tokens:  ValPy: 
Main loop, line=}


 === Line 134 Perl source:}===

exit_block at line 134, prior nesting_level=2

Line:  134 TokenStr: =|}|= @ValPy: }
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 134.
loop_needs_try_block(1), top=is_loop 1 level 1 is_sub  lno 132 in_loop 1 cur_sub  in_sub 0 type while is_eval 
 134 | 3 |   |
Resetting context manager nest
Main loop, line=}


 === Line 135 Perl source:}===

exit_block at line 135, prior nesting_level=1

Line:  135 TokenStr: =|}|= @ValPy: }
Use of uninitialized value in join or string at /d/pythonizer/pythonizer/Perlscan.pm line 465, <> line 135.
loop_needs_try_block(1), top=lno 125 cur_sub  type if  is_eval  in_sub 0 in_loop 0 is_sub  is_loop  level 0
initialize_globals_for_state_vars: 
 135 | 0 |   |
 136 | 0 |   |
Main loop, line=print "$0 - test passed!\n";


 === Line 137 Perl source:print "$0 - test passed!\n";===

Lexem 0 Current token='f' perl='print' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='"' perl='$0 - test passed!\n' value='f"{__file__} - test passed!\n"' Tokenstr |f"| translated: print f"{__file__} - test passed!\n"

Line:  137 TokenStr: =|f"|= @ValPy: print f"{__file__} - test passed!\n"
Generated partial line print(
print3(0) start=0, handle=, k=1, end_pos=1

expression(1, 1, 0) =|f"|= print $0 - test passed!\n

Generated partial line print(f"{__file__} - test passed!\n"
expression returns 2
Generated partial line print(f"{__file__} - test passed!")
 137 | 0 |   |print(f"{__file__} - test passed!")                                                     #PL: print "$0 - test passed!\n";

Tokens: f" ValPy: 
initialize_globals_for_state_vars: 
ERROR STATISTICS:  W: 1


 [Softpano-W317]:  Debug flag is set to 5


