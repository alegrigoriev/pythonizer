 [Softpano-W317]:  Debug flag is set to 5


PYTHONIZER: Fuzzy translator of Python to Perl. Version 0.915 (mtime 211202_1245) Started at 21/12/02 12:50

Logs are at /tmp/Pythonizer/pythonizer.211202_1250.log. Type -h for help.
=============================================================================================================
Results of transcription are written to the file  issue_cmt.py
=========================================================================================================================

Lexem 0 Current token='k' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' value='test' Tokenstr |ki| translated: def test
Lexem 0 Current token='k' value='return' Tokenstr |k| translated: return
Lexem 1 Current token='c' value='if ' Tokenstr |kc| translated: return if 
Lexem 2 Current token='!' value='not' Tokenstr |kc!| translated: return if  not
Lexem 3 Current token='f' value='filter' Tokenstr |kc!f| translated: return if  not filter
Lexem 4 Current token='q' value='re.search(r'DC_$year$month$day$hour.*-ifStats_Juniper_5MIN',_d)' Tokenstr |kc!fq| translated: return if  not filter re.search(r'DC_$year$month$day$hour.*-ifStats_Juniper_5MIN',_d)
Lexem 5 Current token=',' value=',' Tokenstr |kc!fq,| translated: return if  not filter re.search(r'DC_$year$month$day$hour.*-ifStats_Juniper_5MIN',_d) ,
Lexem 6 Current token='a' value='dirfiles' Tokenstr |kc!fq,a| translated: return if  not filter re.search(r'DC_$year$month$day$hour.*-ifStats_Juniper_5MIN',_d) , dirfiles
Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='f' value='_getM' Tokenstr |c(f| translated: if  ( _getM
Lexem 3 Current token='s' value='otherfile' Tokenstr |c(fs| translated: if  ( _getM otherfile
Lexem 4 Current token='>' value='<' Tokenstr |c(fs>| translated: if  ( _getM otherfile <
Lexem 5 Current token='f' value='_getM' Tokenstr |c(fs>f| translated: if  ( _getM otherfile < _getM
Lexem 6 Current token='s' value='currentfile' Tokenstr |c(fs>fs| translated: if  ( _getM otherfile < _getM currentfile
Lexem 7 Current token=')' value=')' Tokenstr |c(fs>fs)| translated: if  ( _getM otherfile < _getM currentfile )
decode_scalar SIG source=$SIG{ALRM} = sub { die "timeout"; };
decode_scalar SIG source=$SIG(ALRM, sub { die "timeout"; });
Lexem 0 Current token='f' value='signal.signal' Tokenstr |f| translated: signal.signal
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: signal.signal (
Lexem 2 Current token='i' value='signal.SIGALRM' Tokenstr |f(i| translated: signal.signal ( signal.SIGALRM
Lexem 3 Current token=',' value=',' Tokenstr |f(i,| translated: signal.signal ( signal.SIGALRM ,
Lexem 4 Current token='k' value='def' Tokenstr |f(i,k| translated: signal.signal ( signal.SIGALRM , def
Lexem 5 Current token='(' value='[' Tokenstr |f(i,k(| translated: signal.signal ( signal.SIGALRM , def [
Lexem 6 Current token='f' value='raise Die' Tokenstr |f(i,k(f| translated: signal.signal ( signal.SIGALRM , def [ raise Die
Lexem 7 Current token='"' value=''timeout'' Tokenstr |f(i,k(f"| translated: signal.signal ( signal.SIGALRM , def [ raise Die 'timeout'
Lexem 8 Current token=';' value=';' Tokenstr |f(i,k(f";| translated: signal.signal ( signal.SIGALRM , def [ raise Die 'timeout' ;
Lexem 9 Current token=')' value=']' Tokenstr |f(i,k(f";)| translated: signal.signal ( signal.SIGALRM , def [ raise Die 'timeout' ; ]
Lexem 10 Current token=')' value=')' Tokenstr |f(i,k(f";))| translated: signal.signal ( signal.SIGALRM , def [ raise Die 'timeout' ; ] )
Lexem 0 Current token='s' value='s' Tokenstr |s| translated: s
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: s =
Lexem 2 Current token='f' value='' Tokenstr |s=f| translated: s = 
Lexem 3 Current token='(' value='(' Tokenstr |s=f(| translated: s =  (
Lexem 4 Current token='"' value='f"{_d}\n"' Tokenstr |s=f("| translated: s =  ( f"{_d}\n"
Lexem 5 Current token=')' value=')' Tokenstr |s=f(")| translated: s =  ( f"{_d}\n" )
Lexem 0 Current token='s' value='s' Tokenstr |s| translated: s
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: s =
Lexem 2 Current token='f' value='' Tokenstr |s=f| translated: s = 
Lexem 3 Current token='"' value='f"{_d}\n"' Tokenstr |s=f"| translated: s =  f"{_d}\n"
Lexem 0 Current token='s' value='s' Tokenstr |s| translated: s
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: s =
Lexem 2 Current token='f' value='' Tokenstr |s=f| translated: s = 
Lexem 3 Current token='"' value=''%s\n'' Tokenstr |s=f"| translated: s =  '%s\n'
Lexem 4 Current token=',' value=',' Tokenstr |s=f",| translated: s =  '%s\n' ,
Lexem 5 Current token='s' value='_d' Tokenstr |s=f",s| translated: s =  '%s\n' , _d
Lexem 0 Current token='s' value='s' Tokenstr |s| translated: s
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: s =
Lexem 2 Current token='f' value='' Tokenstr |s=f| translated: s = 
Lexem 3 Current token='(' value='(' Tokenstr |s=f(| translated: s =  (
Lexem 4 Current token='"' value=''%s\n'' Tokenstr |s=f("| translated: s =  ( '%s\n'
Lexem 5 Current token=',' value=',' Tokenstr |s=f(",| translated: s =  ( '%s\n' ,
Lexem 6 Current token='s' value='_d' Tokenstr |s=f(",s| translated: s =  ( '%s\n' , _d
Lexem 7 Current token=')' value=')' Tokenstr |s=f(",s)| translated: s =  ( '%s\n' , _d )
Lexem 0 Current token='i' value='printf' Tokenstr |i| translated: printf
Lexem 1 Current token='(' value='(' Tokenstr |i(| translated: printf (
Lexem 2 Current token='i' value='OUT' Tokenstr |i(i| translated: printf ( OUT
Lexem 3 Current token='"' value='f"{_d}\n"' Tokenstr |i(i"| translated: printf ( OUT f"{_d}\n"
Lexem 4 Current token=')' value=')' Tokenstr |i(i")| translated: printf ( OUT f"{_d}\n" )
Lexem 0 Current token='i' value='printf' Tokenstr |i| translated: printf
Lexem 1 Current token='(' value='(' Tokenstr |i(| translated: printf (
Lexem 2 Current token='i' value='LOG' Tokenstr |i(i| translated: printf ( LOG
Lexem 3 Current token='"' value='f"DC_info ({hour}:{min}:{sec}): {_args[0]}"' Tokenstr |i(i"| translated: printf ( LOG f"DC_info ({hour}:{min}:{sec}): {_args[0]}"
Lexem 4 Current token=')' value=')' Tokenstr |i(i")| translated: printf ( LOG f"DC_info ({hour}:{min}:{sec}): {_args[0]}" )
Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' value='action' Tokenstr |c(s| translated: if  ( action
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: if  ( action ==
Lexem 4 Current token='"' value=''save'' Tokenstr |c(s>"| translated: if  ( action == 'save'
Lexem 5 Current token='0' value=' and ' Tokenstr |c(s>"0| translated: if  ( action == 'save'  and 
Lexem 6 Current token='!' value='not' Tokenstr |c(s>"0!| translated: if  ( action == 'save'  and  not
Lexem 7 Current token='f' value='os.path.exists' Tokenstr |c(s>"0!f| translated: if  ( action == 'save'  and  not os.path.exists
Lexem 8 Current token='s' value='name' Tokenstr |c(s>"0!fs| translated: if  ( action == 'save'  and  not os.path.exists name
Lexem 9 Current token=')' value=')' Tokenstr |c(s>"0!fs)| translated: if  ( action == 'save'  and  not os.path.exists name )
Lexem 0 Current token='f' value='os.system' Tokenstr |f| translated: os.system
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: os.system (
Lexem 2 Current token='"' value='f"scp -p {other}:{name} {name}"' Tokenstr |f("| translated: os.system ( f"scp -p {other}:{name} {name}"
Lexem 3 Current token=')' value=')' Tokenstr |f(")| translated: os.system ( f"scp -p {other}:{name} {name}" )
Lexem 0 Current token='C' value='elif ' Tokenstr |C| translated: elif 
Lexem 1 Current token='(' value='(' Tokenstr |C(| translated: elif  (
Lexem 2 Current token='s' value='action' Tokenstr |C(s| translated: elif  ( action
Lexem 3 Current token='>' value='==' Tokenstr |C(s>| translated: elif  ( action ==
Lexem 4 Current token='"' value=''delete'' Tokenstr |C(s>"| translated: elif  ( action == 'delete'
Lexem 5 Current token='0' value=' and ' Tokenstr |C(s>"0| translated: elif  ( action == 'delete'  and 
Lexem 6 Current token='f' value='os.path.exists' Tokenstr |C(s>"0f| translated: elif  ( action == 'delete'  and  os.path.exists
Lexem 7 Current token='s' value='name' Tokenstr |C(s>"0fs| translated: elif  ( action == 'delete'  and  os.path.exists name
Lexem 8 Current token='0' value=' and ' Tokenstr |C(s>"0fs0| translated: elif  ( action == 'delete'  and  os.path.exists name  and 
Lexem 9 Current token='s' value='name' Tokenstr |C(s>"0fs0s| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name
Lexem 10 Current token='~' value='!~' Tokenstr |C(s>"0fs0s~| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~
Lexem 11 Current token='q' value='re.search(r'/\.\./',' Tokenstr |C(s>"0fs0s~q| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',
Lexem 12 Current token='0' value=' and ' Tokenstr |C(s>"0fs0s~q0| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',  and 
Lexem 13 Current token='(' value='(' Tokenstr |C(s>"0fs0s~q0(| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',  and  (
Lexem 14 Current token='s' value='name' Tokenstr |C(s>"0fs0s~q0(s| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',  and  ( name
Lexem 15 Current token='~' value='' Tokenstr |C(s>"0fs0s~q0(s~| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',  and  ( name 
Lexem 16 Current token='q' value='re.search(r'cmtweb.users.*saved',' Tokenstr |C(s>"0fs0s~q0(s~q| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',  and  ( name  re.search(r'cmtweb.users.*saved',
Lexem 17 Current token='0' value=' or ' Tokenstr |C(s>"0fs0s~q0(s~q0| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',  and  ( name  re.search(r'cmtweb.users.*saved',  or 
Lexem 18 Current token='s' value='name' Tokenstr |C(s>"0fs0s~q0(s~q0s| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',  and  ( name  re.search(r'cmtweb.users.*saved',  or  name
Lexem 19 Current token='~' value='' Tokenstr |C(s>"0fs0s~q0(s~q0s~| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',  and  ( name  re.search(r'cmtweb.users.*saved',  or  name 
Lexem 20 Current token='q' value='re.search(r'cmtweb.fareports',' Tokenstr |C(s>"0fs0s~q0(s~q0s~q| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',  and  ( name  re.search(r'cmtweb.users.*saved',  or  name  re.search(r'cmtweb.fareports',
Lexem 21 Current token='0' value=' or ' Tokenstr |C(s>"0fs0s~q0(s~q0s~q0| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',  and  ( name  re.search(r'cmtweb.users.*saved',  or  name  re.search(r'cmtweb.fareports',  or 
Lexem 22 Current token='s' value='name' Tokenstr |C(s>"0fs0s~q0(s~q0s~q0s| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',  and  ( name  re.search(r'cmtweb.users.*saved',  or  name  re.search(r'cmtweb.fareports',  or  name
Lexem 23 Current token='~' value='' Tokenstr |C(s>"0fs0s~q0(s~q0s~q0s~| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',  and  ( name  re.search(r'cmtweb.users.*saved',  or  name  re.search(r'cmtweb.fareports',  or  name 
Lexem 24 Current token='q' value='re.search(r'cmtweb.hotspotreports',' Tokenstr |C(s>"0fs0s~q0(s~q0s~q0s~q| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',  and  ( name  re.search(r'cmtweb.users.*saved',  or  name  re.search(r'cmtweb.fareports',  or  name  re.search(r'cmtweb.hotspotreports',
Lexem 25 Current token=')' value=')' Tokenstr |C(s>"0fs0s~q0(s~q0s~q0s~q)| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',  and  ( name  re.search(r'cmtweb.users.*saved',  or  name  re.search(r'cmtweb.fareports',  or  name  re.search(r'cmtweb.hotspotreports', )
Lexem 26 Current token=')' value=')' Tokenstr |C(s>"0fs0s~q0(s~q0s~q0s~q))| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',  and  ( name  re.search(r'cmtweb.users.*saved',  or  name  re.search(r'cmtweb.fareports',  or  name  re.search(r'cmtweb.hotspotreports', ) )
Lexem 0 Current token='f' value='os.system' Tokenstr |f| translated: os.system
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: os.system (
Lexem 2 Current token='"' value='f"rm {name}"' Tokenstr |f("| translated: os.system ( f"rm {name}"
Lexem 3 Current token=')' value=')' Tokenstr |f(")| translated: os.system ( f"rm {name}" )
Lexem 0 Current token='f' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='@' value='@' Tokenstr |f@| translated: .extend( @
Lexem 2 Current token='(' value='[' Tokenstr |f@(| translated: .extend( @ [
Lexem 3 Current token='s' value='static' Tokenstr |f@(s| translated: .extend( @ [ static
Lexem 4 Current token='(' value='[' Tokenstr |f@(s(| translated: .extend( @ [ static [
Lexem 5 Current token='s' value='r' Tokenstr |f@(s(s| translated: .extend( @ [ static [ r
Lexem 6 Current token=')' value=']' Tokenstr |f@(s(s)| translated: .extend( @ [ static [ r ]
Lexem 7 Current token='(' value='[' Tokenstr |f@(s(s)(| translated: .extend( @ [ static [ r ] [
Lexem 8 Current token='s' value='ip' Tokenstr |f@(s(s)(s| translated: .extend( @ [ static [ r ] [ ip
Lexem 9 Current token=')' value=']' Tokenstr |f@(s(s)(s)| translated: .extend( @ [ static [ r ] [ ip ]
Lexem 10 Current token=')' value=']' Tokenstr |f@(s(s)(s))| translated: .extend( @ [ static [ r ] [ ip ] ]
Lexem 11 Current token=',' value=',' Tokenstr |f@(s(s)(s)),| translated: .extend( @ [ static [ r ] [ ip ] ] ,
Lexem 12 Current token='s' value='i' Tokenstr |f@(s(s)(s)),s| translated: .extend( @ [ static [ r ] [ ip ] ] , i
Lexem 0 Current token='f' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='@' value='@' Tokenstr |f@| translated: .extend( @
Lexem 2 Current token='(' value='[' Tokenstr |f@(| translated: .extend( @ [
Lexem 3 Current token='s' value='vrf2rt' Tokenstr |f@(s| translated: .extend( @ [ vrf2rt
Lexem 4 Current token='(' value='[' Tokenstr |f@(s(| translated: .extend( @ [ vrf2rt [
Lexem 5 Current token='s' value='r' Tokenstr |f@(s(s| translated: .extend( @ [ vrf2rt [ r
Lexem 6 Current token=')' value=']' Tokenstr |f@(s(s)| translated: .extend( @ [ vrf2rt [ r ]
Lexem 7 Current token='(' value='[' Tokenstr |f@(s(s)(| translated: .extend( @ [ vrf2rt [ r ] [
Lexem 8 Current token='s' value='vrf' Tokenstr |f@(s(s)(s| translated: .extend( @ [ vrf2rt [ r ] [ vrf
Lexem 9 Current token=')' value=']' Tokenstr |f@(s(s)(s)| translated: .extend( @ [ vrf2rt [ r ] [ vrf ]
Lexem 10 Current token=')' value=']' Tokenstr |f@(s(s)(s))| translated: .extend( @ [ vrf2rt [ r ] [ vrf ] ]
Lexem 11 Current token=',' value=',' Tokenstr |f@(s(s)(s)),| translated: .extend( @ [ vrf2rt [ r ] [ vrf ] ] ,
Lexem 12 Current token='s' value='rt' Tokenstr |f@(s(s)(s)),s| translated: .extend( @ [ vrf2rt [ r ] [ vrf ] ] , rt
Lexem 0 Current token='i' value='DCinfo' Tokenstr |i| translated: DCinfo
Lexem 1 Current token='(' value='(' Tokenstr |i(| translated: DCinfo (
Lexem 2 Current token='"' value='f"Running: {__file__} {LIST_SEPARATOR.join(sys.argv[1:])}\n"' Tokenstr |i("| translated: DCinfo ( f"Running: {__file__} {LIST_SEPARATOR.join(sys.argv[1:])}\n"
Lexem 3 Current token=')' value=')' Tokenstr |i(")| translated: DCinfo ( f"Running: {__file__} {LIST_SEPARATOR.join(sys.argv[1:])}\n" )
Lexem 0 Current token='k' value='continue ' Tokenstr |k| translated: continue 
Lexem 1 Current token='c' value='if ' Tokenstr |kc| translated: continue  if 
Lexem 2 Current token='!' value='not' Tokenstr |kc!| translated: continue  if  not
Lexem 3 Current token='f' value='in' Tokenstr |kc!f| translated: continue  if  not in
Lexem 4 Current token='s' value='bundles' Tokenstr |kc!fs| translated: continue  if  not in bundles
Lexem 5 Current token='(' value='[' Tokenstr |kc!fs(| translated: continue  if  not in bundles [
Lexem 6 Current token='s' value='cttmembers' Tokenstr |kc!fs(s| translated: continue  if  not in bundles [ cttmembers
Lexem 7 Current token='(' value='[' Tokenstr |kc!fs(s(| translated: continue  if  not in bundles [ cttmembers [
Lexem 8 Current token='s' value='key' Tokenstr |kc!fs(s(s| translated: continue  if  not in bundles [ cttmembers [ key
Lexem 9 Current token=')' value=']' Tokenstr |kc!fs(s(s)| translated: continue  if  not in bundles [ cttmembers [ key ]
Lexem 10 Current token=')' value=']' Tokenstr |kc!fs(s(s))| translated: continue  if  not in bundles [ cttmembers [ key ] ]
Lexem 0 Current token='k' value='continue ' Tokenstr |k| translated: continue 
Lexem 1 Current token='c' value='if ' Tokenstr |kc| translated: continue  if 
Lexem 2 Current token='f' value='in' Tokenstr |kcf| translated: continue  if  in
Lexem 3 Current token='s' value='bidsinterface' Tokenstr |kcfs| translated: continue  if  in bidsinterface
Lexem 4 Current token='(' value='[' Tokenstr |kcfs(| translated: continue  if  in bidsinterface [
Lexem 5 Current token='s' value='node' Tokenstr |kcfs(s| translated: continue  if  in bidsinterface [ node
Lexem 6 Current token=')' value=']' Tokenstr |kcfs(s)| translated: continue  if  in bidsinterface [ node ]
Lexem 7 Current token='(' value='[' Tokenstr |kcfs(s)(| translated: continue  if  in bidsinterface [ node ] [
Lexem 8 Current token='s' value='name' Tokenstr |kcfs(s)(s| translated: continue  if  in bidsinterface [ node ] [ name
Lexem 9 Current token=')' value=']' Tokenstr |kcfs(s)(s)| translated: continue  if  in bidsinterface [ node ] [ name ]
Lexem 0 Current token='k' value='continue ' Tokenstr |k| translated: continue 
Lexem 1 Current token='c' value='if not ' Tokenstr |kc| translated: continue  if not 
Lexem 2 Current token='f' value='in' Tokenstr |kcf| translated: continue  if not  in
Lexem 3 Current token='s' value='estimated_dmd' Tokenstr |kcfs| translated: continue  if not  in estimated_dmd
Lexem 4 Current token='(' value='[' Tokenstr |kcfs(| translated: continue  if not  in estimated_dmd [
Lexem 5 Current token='s' value='d' Tokenstr |kcfs(s| translated: continue  if not  in estimated_dmd [ d
Lexem 6 Current token=')' value=']' Tokenstr |kcfs(s)| translated: continue  if not  in estimated_dmd [ d ]
bash_style_or_and_fix(3) is_or=
After bash_style_or_and_fix(3): =|c(kcfs(s))|=
Lexem 0 Current token='f' value='in' Tokenstr |f| translated: in
Lexem 1 Current token='s' value='gravity' Tokenstr |fs| translated: in gravity
Lexem 2 Current token='(' value='[' Tokenstr |fs(| translated: in gravity [
Lexem 3 Current token='s' value='p' Tokenstr |fs(s| translated: in gravity [ p
Lexem 4 Current token=')' value=']' Tokenstr |fs(s)| translated: in gravity [ p ]
bash_style_or_and_fix(3) is_or=1
After bash_style_or_and_fix(3): =|c(!(fs(s)))|=
Lexem 0 Current token='f' value='in' Tokenstr |f| translated: in
Lexem 1 Current token='s' value='estimated_fdmd' Tokenstr |fs| translated: in estimated_fdmd
Lexem 2 Current token='(' value='[' Tokenstr |fs(| translated: in estimated_fdmd [
Lexem 3 Current token='s' value='d' Tokenstr |fs(s| translated: in estimated_fdmd [ d
Lexem 4 Current token=')' value=']' Tokenstr |fs(s)| translated: in estimated_fdmd [ d ]
bash_style_or_and_fix(3) is_or=
After bash_style_or_and_fix(3): =|c(fs(s))|=
Lexem 0 Current token='f' value='in' Tokenstr |f| translated: in
Lexem 1 Current token='s' value='nfdmd' Tokenstr |fs| translated: in nfdmd
Lexem 2 Current token='(' value='[' Tokenstr |fs(| translated: in nfdmd [
Lexem 3 Current token='s' value='p' Tokenstr |fs(s| translated: in nfdmd [ p
Lexem 4 Current token=')' value=']' Tokenstr |fs(s)| translated: in nfdmd [ p ]
Lexem 0 Current token='(' value='(' Tokenstr |(| translated: (
Lexem 1 Current token='s' value='commented_timestamp' Tokenstr |(s| translated: ( commented_timestamp
Lexem 2 Current token='=' value='=' Tokenstr |(s=| translated: ( commented_timestamp =
Lexem 3 Current token='s' value='PROPERTIES_ln' Tokenstr |(s=s| translated: ( commented_timestamp = PROPERTIES_ln
Lexem 4 Current token=')' value=')' Tokenstr |(s=s)| translated: ( commented_timestamp = PROPERTIES_ln )
Lexem 5 Current token='c' value='if ' Tokenstr |(s=s)c| translated: ( commented_timestamp = PROPERTIES_ln ) if 
Lexem 6 Current token='(' value='(' Tokenstr |(s=s)c(| translated: ( commented_timestamp = PROPERTIES_ln ) if  (
Lexem 7 Current token='s' value='fileinput.lineno()' Tokenstr |(s=s)c(s| translated: ( commented_timestamp = PROPERTIES_ln ) if  ( fileinput.lineno()
Lexem 8 Current token='>' value='==' Tokenstr |(s=s)c(s>| translated: ( commented_timestamp = PROPERTIES_ln ) if  ( fileinput.lineno() ==
Lexem 9 Current token='d' value='1' Tokenstr |(s=s)c(s>d| translated: ( commented_timestamp = PROPERTIES_ln ) if  ( fileinput.lineno() == 1
Lexem 10 Current token=')' value=')' Tokenstr |(s=s)c(s>d)| translated: ( commented_timestamp = PROPERTIES_ln ) if  ( fileinput.lineno() == 1 )
Lexem 0 Current token='(' value='(' Tokenstr |(| translated: (
Lexem 1 Current token='s' value='retVal' Tokenstr |(s| translated: ( retVal
Lexem 2 Current token='=' value='=' Tokenstr |(s=| translated: ( retVal =
Lexem 3 Current token='d' value='1' Tokenstr |(s=d| translated: ( retVal = 1
Lexem 4 Current token=')' value=')' Tokenstr |(s=d)| translated: ( retVal = 1 )
Lexem 5 Current token='c' value='if ' Tokenstr |(s=d)c| translated: ( retVal = 1 ) if 
Lexem 6 Current token='(' value='(' Tokenstr |(s=d)c(| translated: ( retVal = 1 ) if  (
Lexem 7 Current token='s' value='status' Tokenstr |(s=d)c(s| translated: ( retVal = 1 ) if  ( status
Lexem 8 Current token='>' value='==' Tokenstr |(s=d)c(s>| translated: ( retVal = 1 ) if  ( status ==
Lexem 9 Current token='d' value='0' Tokenstr |(s=d)c(s>d| translated: ( retVal = 1 ) if  ( status == 0
Lexem 10 Current token=')' value=')' Tokenstr |(s=d)c(s>d)| translated: ( retVal = 1 ) if  ( status == 0 )
Lexem 0 Current token='s' value='fh' Tokenstr |s| translated: fh
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: fh =
Lexem 2 Current token='i' value='IO.File' Tokenstr |s=i| translated: fh = IO.File
Lexem 3 Current token='.' value='.' Tokenstr |s=i.| translated: fh = IO.File .
Lexem 4 Current token='i' value='new_tmpfile' Tokenstr |s=i.i| translated: fh = IO.File . new_tmpfile
Lexem 5 Current token='0' value='or' Tokenstr |s=i.i0| translated: fh = IO.File . new_tmpfile or
Lexem 6 Current token='i' value='DCerror' Tokenstr |s=i.i0i| translated: fh = IO.File . new_tmpfile or DCerror
Lexem 7 Current token='(' value='(' Tokenstr |s=i.i0i(| translated: fh = IO.File . new_tmpfile or DCerror (
Lexem 8 Current token='"' value='f"Unable to make new temporary file: {OS_ERROR}"' Tokenstr |s=i.i0i("| translated: fh = IO.File . new_tmpfile or DCerror ( f"Unable to make new temporary file: {OS_ERROR}"
Lexem 9 Current token=')' value=')' Tokenstr |s=i.i0i(")| translated: fh = IO.File . new_tmpfile or DCerror ( f"Unable to make new temporary file: {OS_ERROR}" )
Lexem 0 Current token='s' value='fh' Tokenstr |s| translated: fh
Lexem 1 Current token='.' value='.' Tokenstr |s.| translated: fh .
Lexem 2 Current token='i' value='autoflush' Tokenstr |s.i| translated: fh . autoflush
Lexem 3 Current token='(' value='(' Tokenstr |s.i(| translated: fh . autoflush (
Lexem 4 Current token='d' value='1' Tokenstr |s.i(d| translated: fh . autoflush ( 1
Lexem 5 Current token=')' value=')' Tokenstr |s.i(d)| translated: fh . autoflush ( 1 )
Lexem 0 Current token='k' value='return' Tokenstr |k| translated: return
Lexem 1 Current token='s' value='_d' Tokenstr |ks| translated: return _d
Lexem 2 Current token='c' value='if ' Tokenstr |ksc| translated: return _d if 
Lexem 3 Current token='q' value='re.search(r'^\d{8}/$type$',_d)' Tokenstr |kscq| translated: return _d if  re.search(r'^\d{8}/$type$',_d)
Lexem 0 Current token='a' value='files' Tokenstr |a| translated: files
Lexem 1 Current token='=' value='=' Tokenstr |a=| translated: files =
Lexem 2 Current token='x' value='f"""{options.get('bin','')}/sftplist {remote} {remotedir} "{fname}" 2>/dev/null"""' Tokenstr |a=x| translated: files = f"""{options.get('bin','')}/sftplist {remote} {remotedir} "{fname}" 2>/dev/null"""
Lexem 0 Current token='k' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' value='process_file' Tokenstr |ki| translated: def process_file
Lexem 0 Current token='k' value='continue ' Tokenstr |k| translated: continue 
Lexem 1 Current token='c' value='if ' Tokenstr |kc| translated: continue  if 
Lexem 2 Current token='!' value='not' Tokenstr |kc!| translated: continue  if  not
Lexem 3 Current token='s' value='in_' Tokenstr |kc!s| translated: continue  if  not in_
Lexem 4 Current token='~' value='' Tokenstr |kc!s~| translated: continue  if  not in_ 
Lexem 5 Current token='q' value='(_m:=re.search(r'(flows)\.(\d+)\.gz',' Tokenstr |kc!s~q| translated: continue  if  not in_  (_m:=re.search(r'(flows)\.(\d+)\.gz',
Lexem 0 Current token='k' value='break ' Tokenstr |k| translated: break 
Lexem 1 Current token='c' value='if ' Tokenstr |kc| translated: break  if 
Lexem 2 Current token='(' value='(' Tokenstr |kc(| translated: break  if  (
Lexem 3 Current token='s' value='in_' Tokenstr |kc(s| translated: break  if  ( in_
Lexem 4 Current token='>' value='==' Tokenstr |kc(s>| translated: break  if  ( in_ ==
Lexem 5 Current token='"' value='''' Tokenstr |kc(s>"| translated: break  if  ( in_ == ''
Lexem 6 Current token=')' value=')' Tokenstr |kc(s>")| translated: break  if  ( in_ == '' )
Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' value='in_' Tokenstr |c(s| translated: if  ( in_
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: if  ( in_ ==
Lexem 4 Current token='"' value=''if_stmt'' Tokenstr |c(s>"| translated: if  ( in_ == 'if_stmt'
Lexem 5 Current token=')' value=')' Tokenstr |c(s>")| translated: if  ( in_ == 'if_stmt' )
Lexem 0 Current token='k' value='continue ' Tokenstr |k| translated: continue 
Lexem 1 Current token='c' value='if ' Tokenstr |kc| translated: continue  if 
Lexem 2 Current token='s' value='in_' Tokenstr |kcs| translated: continue  if  in_
Lexem 3 Current token='~' value='' Tokenstr |kcs~| translated: continue  if  in_ 
Lexem 4 Current token='q' value='re.search(r'next if',' Tokenstr |kcs~q| translated: continue  if  in_  re.search(r'next if',
Lexem 0 Current token='s' value='i' Tokenstr |s| translated: i
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: i =
Lexem 2 Current token='d' value='4' Tokenstr |s=d| translated: i = 4
Lexem 0 Current token='k' value='break ' Tokenstr |k| translated: break 
Lexem 1 Current token='c' value='if ' Tokenstr |kc| translated: break  if 
Lexem 2 Current token='s' value='in_' Tokenstr |kcs| translated: break  if  in_
Lexem 3 Current token='~' value='' Tokenstr |kcs~| translated: break  if  in_ 
Lexem 4 Current token='q' value='re.search(r'last if',' Tokenstr |kcs~q| translated: break  if  in_  re.search(r'last if',
Lexem 0 Current token='k' value='continue ' Tokenstr |k| translated: continue 
Lexem 0 Current token='k' value='break ' Tokenstr |k| translated: break 
Lexem 0 Current token='k' value='return' Tokenstr |k| translated: return
Lexem 0 Current token='s' value='i' Tokenstr |s| translated: i
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: i =
Lexem 2 Current token='d' value='1' Tokenstr |s=d| translated: i = 1
Lexem 0 Current token='k' value='continue ' Tokenstr |k| translated: continue 
Lexem 1 Current token='c' value='if ' Tokenstr |kc| translated: continue  if 
Lexem 2 Current token='(' value='(' Tokenstr |kc(| translated: continue  if  (
Lexem 3 Current token='s' value='i' Tokenstr |kc(s| translated: continue  if  ( i
Lexem 4 Current token='>' value='==' Tokenstr |kc(s>| translated: continue  if  ( i ==
Lexem 5 Current token='d' value='1' Tokenstr |kc(s>d| translated: continue  if  ( i == 1
Lexem 6 Current token=')' value=')' Tokenstr |kc(s>d)| translated: continue  if  ( i == 1 )
Lexem 0 Current token='s' value='i' Tokenstr |s| translated: i
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: i =
Lexem 2 Current token='d' value='2' Tokenstr |s=d| translated: i = 2
Lexem 0 Current token='k' value='break ' Tokenstr |k| translated: break 
Lexem 1 Current token='c' value='if ' Tokenstr |kc| translated: break  if 
Lexem 2 Current token='(' value='(' Tokenstr |kc(| translated: break  if  (
Lexem 3 Current token='s' value='i' Tokenstr |kc(s| translated: break  if  ( i
Lexem 4 Current token='>' value='==' Tokenstr |kc(s>| translated: break  if  ( i ==
Lexem 5 Current token='d' value='2' Tokenstr |kc(s>d| translated: break  if  ( i == 2
Lexem 6 Current token=')' value=')' Tokenstr |kc(s>d)| translated: break  if  ( i == 2 )
Lexem 0 Current token='s' value='i' Tokenstr |s| translated: i
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: i =
Lexem 2 Current token='d' value='3' Tokenstr |s=d| translated: i = 3
Lexem 0 Current token='k' value='continue ' Tokenstr |k| translated: continue 
Lexem 0 Current token='k' value='break ' Tokenstr |k| translated: break 
Lexem 0 Current token='k' value='return' Tokenstr |k| translated: return
Lexem 0 Current token='i' value='LINE' Tokenstr |i| translated: LINE
Lexem 1 Current token=':' value=':' Tokenstr |i:| translated: LINE :
Lexem 2 Current token='c' value='while' Tokenstr |i:c| translated: LINE : while
Lexem 3 Current token='(' value='(' Tokenstr |i:c(| translated: LINE : while (
Lexem 4 Current token='i' value='next(fileinput.input(), None)' Tokenstr |i:c(i| translated: LINE : while ( next(fileinput.input(), None)
Lexem 5 Current token=')' value=')' Tokenstr |i:c(i)| translated: LINE : while ( next(fileinput.input(), None) )
Lexem 0 Current token='k' value='continue ' Tokenstr |k| translated: continue 
Lexem 1 Current token='i' value='LINE' Tokenstr |ki| translated: continue  LINE
Lexem 2 Current token='c' value='if ' Tokenstr |kic| translated: continue  LINE if 
Lexem 3 Current token='q' value='re.search(r'^#',_d)' Tokenstr |kicq| translated: continue  LINE if  re.search(r'^#',_d)
Lexem 0 Current token='s' value='i' Tokenstr |s| translated: i
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: i =
Lexem 2 Current token='d' value='0' Tokenstr |s=d| translated: i = 0
Lexem 0 Current token='i' value='' Tokenstr |i| translated: 
Lexem 0 Current token='s' value='i' Tokenstr |s| translated: i
Lexem 1 Current token='^' value='+=1' Tokenstr |s^| translated: i +=1
Lexem 0 Current token='c' value='while not ' Tokenstr |c| translated: while not 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: while not  (
Lexem 2 Current token='s' value='i' Tokenstr |c(s| translated: while not  ( i
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: while not  ( i ==
Lexem 4 Current token='d' value='10' Tokenstr |c(s>d| translated: while not  ( i == 10
Lexem 5 Current token=')' value=')' Tokenstr |c(s>d)| translated: while not  ( i == 10 )
Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='s' value='ua' Tokenstr |ts| translated:  ua
Lexem 2 Current token='=' value='=' Tokenstr |ts=| translated:  ua =
Lexem 3 Current token='i' value='LWP.UserAgent' Tokenstr |ts=i| translated:  ua = LWP.UserAgent
Lexem 4 Current token='.' value='.' Tokenstr |ts=i.| translated:  ua = LWP.UserAgent .
Lexem 5 Current token='i' value='new' Tokenstr |ts=i.i| translated:  ua = LWP.UserAgent . new
Lexem 0 Current token='s' value='num' Tokenstr |s| translated: num
Lexem 1 Current token='(' value='[' Tokenstr |s(| translated: num [
Lexem 2 Current token='s' value='key' Tokenstr |s(s| translated: num [ key
Lexem 3 Current token=')' value=']' Tokenstr |s(s)| translated: num [ key ]
Lexem 4 Current token='(' value='[' Tokenstr |s(s)(| translated: num [ key ] [
Lexem 5 Current token='s' value='hour' Tokenstr |s(s)(s| translated: num [ key ] [ hour
Lexem 6 Current token=')' value=']' Tokenstr |s(s)(s)| translated: num [ key ] [ hour ]
Lexem 7 Current token='=' value='=' Tokenstr |s(s)(s)=| translated: num [ key ] [ hour ] =
Lexem 8 Current token='d' value='12' Tokenstr |s(s)(s)=d| translated: num [ key ] [ hour ] = 12
Lexem 0 Current token='s' value='num' Tokenstr |s| translated: num
Lexem 1 Current token='(' value='[' Tokenstr |s(| translated: num [
Lexem 2 Current token='s' value='key' Tokenstr |s(s| translated: num [ key
Lexem 3 Current token=')' value=']' Tokenstr |s(s)| translated: num [ key ]
Lexem 4 Current token='(' value='[' Tokenstr |s(s)(| translated: num [ key ] [
Lexem 5 Current token='s' value='hour' Tokenstr |s(s)(s| translated: num [ key ] [ hour
Lexem 6 Current token=')' value=']' Tokenstr |s(s)(s)| translated: num [ key ] [ hour ]
Lexem 7 Current token='^' value='+=1' Tokenstr |s(s)(s)^| translated: num [ key ] [ hour ] +=1
Lexem 0 Current token='^' value='-=1' Tokenstr |^| translated: -=1
Lexem 1 Current token='s' value='num' Tokenstr |^s| translated: -=1 num
Lexem 2 Current token='(' value='[' Tokenstr |^s(| translated: -=1 num [
Lexem 3 Current token='s' value='key' Tokenstr |^s(s| translated: -=1 num [ key
Lexem 4 Current token=')' value=']' Tokenstr |^s(s)| translated: -=1 num [ key ]
Lexem 5 Current token='(' value='[' Tokenstr |^s(s)(| translated: -=1 num [ key ] [
Lexem 6 Current token='s' value='hour' Tokenstr |^s(s)(s| translated: -=1 num [ key ] [ hour
Lexem 7 Current token=')' value=']' Tokenstr |^s(s)(s)| translated: -=1 num [ key ] [ hour ]
Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' value='num' Tokenstr |c(s| translated: if  ( num
Lexem 3 Current token='(' value='[' Tokenstr |c(s(| translated: if  ( num [
Lexem 4 Current token='s' value='key' Tokenstr |c(s(s| translated: if  ( num [ key
Lexem 5 Current token=')' value=']' Tokenstr |c(s(s)| translated: if  ( num [ key ]
Lexem 6 Current token='(' value='[' Tokenstr |c(s(s)(| translated: if  ( num [ key ] [
Lexem 7 Current token='s' value='hour' Tokenstr |c(s(s)(s| translated: if  ( num [ key ] [ hour
Lexem 8 Current token=')' value=']' Tokenstr |c(s(s)(s)| translated: if  ( num [ key ] [ hour ]
Lexem 9 Current token='^' value='+=1' Tokenstr |c(s(s)(s)^| translated: if  ( num [ key ] [ hour ] +=1
Lexem 10 Current token='>' value='==' Tokenstr |c(s(s)(s)^>| translated: if  ( num [ key ] [ hour ] +=1 ==
Lexem 11 Current token='d' value='12' Tokenstr |c(s(s)(s)^>d| translated: if  ( num [ key ] [ hour ] +=1 == 12
Lexem 12 Current token=')' value=')' Tokenstr |c(s(s)(s)^>d)| translated: if  ( num [ key ] [ hour ] +=1 == 12 )
Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='^' value='-=1' Tokenstr |c(^| translated: if  ( -=1
Lexem 3 Current token='s' value='num' Tokenstr |c(^s| translated: if  ( -=1 num
Lexem 4 Current token='(' value='[' Tokenstr |c(^s(| translated: if  ( -=1 num [
Lexem 5 Current token='s' value='key' Tokenstr |c(^s(s| translated: if  ( -=1 num [ key
Lexem 6 Current token=')' value=']' Tokenstr |c(^s(s)| translated: if  ( -=1 num [ key ]
Lexem 7 Current token='(' value='[' Tokenstr |c(^s(s)(| translated: if  ( -=1 num [ key ] [
Lexem 8 Current token='s' value='hour' Tokenstr |c(^s(s)(s| translated: if  ( -=1 num [ key ] [ hour
Lexem 9 Current token=')' value=']' Tokenstr |c(^s(s)(s)| translated: if  ( -=1 num [ key ] [ hour ]
Lexem 10 Current token='>' value='==' Tokenstr |c(^s(s)(s)>| translated: if  ( -=1 num [ key ] [ hour ] ==
Lexem 11 Current token='d' value='12' Tokenstr |c(^s(s)(s)>d| translated: if  ( -=1 num [ key ] [ hour ] == 12
Lexem 12 Current token=')' value=')' Tokenstr |c(^s(s)(s)>d)| translated: if  ( -=1 num [ key ] [ hour ] == 12 )
Lexem 0 Current token='c' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='s' value='n' Tokenstr |c(s| translated: for  ( n
Lexem 3 Current token='=' value=':=' Tokenstr |c(s=| translated: for  ( n :=
Lexem 4 Current token='d' value='1' Tokenstr |c(s=d| translated: for  ( n := 1
Lexem 5 Current token=';' value=';' Tokenstr |c(s=d;| translated: for  ( n := 1 ;
Lexem 6 Current token='s' value='n' Tokenstr |c(s=d;s| translated: for  ( n := 1 ; n
Lexem 7 Current token='>' value='<=' Tokenstr |c(s=d;s>| translated: for  ( n := 1 ; n <=
Lexem 8 Current token='d' value='30' Tokenstr |c(s=d;s>d| translated: for  ( n := 1 ; n <= 30
Lexem 9 Current token=';' value=';' Tokenstr |c(s=d;s>d;| translated: for  ( n := 1 ; n <= 30 ;
Lexem 10 Current token='s' value='n' Tokenstr |c(s=d;s>d;s| translated: for  ( n := 1 ; n <= 30 ; n
Lexem 11 Current token='^' value='+=1' Tokenstr |c(s=d;s>d;s^| translated: for  ( n := 1 ; n <= 30 ; n +=1
Lexem 12 Current token=')' value=')' Tokenstr |c(s=d;s>d;s^)| translated: for  ( n := 1 ; n <= 30 ; n +=1 )
Lexem 0 Current token='c' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='s' value='n' Tokenstr |c(s| translated: for  ( n
Lexem 3 Current token='=' value=':=' Tokenstr |c(s=| translated: for  ( n :=
Lexem 4 Current token='d' value='1' Tokenstr |c(s=d| translated: for  ( n := 1
Lexem 5 Current token=';' value=';' Tokenstr |c(s=d;| translated: for  ( n := 1 ;
Lexem 6 Current token='s' value='n' Tokenstr |c(s=d;s| translated: for  ( n := 1 ; n
Lexem 7 Current token='>' value='<=' Tokenstr |c(s=d;s>| translated: for  ( n := 1 ; n <=
Lexem 8 Current token='d' value='30' Tokenstr |c(s=d;s>d| translated: for  ( n := 1 ; n <= 30
Lexem 9 Current token=';' value=';' Tokenstr |c(s=d;s>d;| translated: for  ( n := 1 ; n <= 30 ;
Lexem 10 Current token='s' value='n' Tokenstr |c(s=d;s>d;s| translated: for  ( n := 1 ; n <= 30 ; n
Lexem 11 Current token='^' value='+=1' Tokenstr |c(s=d;s>d;s^| translated: for  ( n := 1 ; n <= 30 ; n +=1
Lexem 12 Current token=')' value=')' Tokenstr |c(s=d;s>d;s^)| translated: for  ( n := 1 ; n <= 30 ; n +=1 )
Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' value='sequence' Tokenstr |ta| translated:  sequence
Lexem 2 Current token='=' value='=' Tokenstr |ta=| translated:  sequence =
Lexem 3 Current token='f' value='sorted' Tokenstr |ta=f| translated:  sequence = sorted
Lexem 4 Current token='i' value='bynum' Tokenstr |ta=fi| translated:  sequence = sorted bynum
Lexem 5 Current token='f' value='.keys()' Tokenstr |ta=fif| translated:  sequence = sorted bynum .keys()
Lexem 6 Current token='%' value='%' Tokenstr |ta=fif%| translated:  sequence = sorted bynum .keys() %
Lexem 7 Current token='(' value='[' Tokenstr |ta=fif%(| translated:  sequence = sorted bynum .keys() % [
Lexem 8 Current token='s' value='routespans' Tokenstr |ta=fif%(s| translated:  sequence = sorted bynum .keys() % [ routespans
Lexem 9 Current token='(' value='[' Tokenstr |ta=fif%(s(| translated:  sequence = sorted bynum .keys() % [ routespans [
Lexem 10 Current token='s' value='rin' Tokenstr |ta=fif%(s(s| translated:  sequence = sorted bynum .keys() % [ routespans [ rin
Lexem 11 Current token=')' value=']' Tokenstr |ta=fif%(s(s)| translated:  sequence = sorted bynum .keys() % [ routespans [ rin ]
Lexem 12 Current token=')' value=']' Tokenstr |ta=fif%(s(s))| translated:  sequence = sorted bynum .keys() % [ routespans [ rin ] ]
Lexem 0 Current token='s' value='interfaces' Tokenstr |s| translated: interfaces
Lexem 1 Current token='(' value='[' Tokenstr |s(| translated: interfaces [
Lexem 2 Current token='s' value='key' Tokenstr |s(s| translated: interfaces [ key
Lexem 3 Current token=')' value=']' Tokenstr |s(s)| translated: interfaces [ key ]
Lexem 4 Current token='(' value='[' Tokenstr |s(s)(| translated: interfaces [ key ] [
Lexem 5 Current token='i' value='vrf' Tokenstr |s(s)(i| translated: interfaces [ key ] [ vrf
Lexem 6 Current token=')' value=']' Tokenstr |s(s)(")| translated: interfaces [ key ] [ 'vrf' ]
Lexem 7 Current token='=' value='=' Tokenstr |s(s)(")=| translated: interfaces [ key ] [ 'vrf' ] =
Lexem 8 Current token='s' value='line' Tokenstr |s(s)(")=s| translated: interfaces [ key ] [ 'vrf' ] = line
Lexem 9 Current token='(' value='[' Tokenstr |s(s)(")=s(| translated: interfaces [ key ] [ 'vrf' ] = line [
Lexem 10 Current token='(' value='(' Tokenstr |s(s)(")=s((| translated: interfaces [ key ] [ 'vrf' ] = line [ (
Lexem 11 Current token='s' value='dir' Tokenstr |s(s)(")=s((s| translated: interfaces [ key ] [ 'vrf' ] = line [ ( dir
Lexem 12 Current token='~' value='' Tokenstr |s(s)(")=s((s~| translated: interfaces [ key ] [ 'vrf' ] = line [ ( dir 
Lexem 13 Current token='q' value='re.search(r'agnip$',' Tokenstr |s(s)(")=s((s~q| translated: interfaces [ key ] [ 'vrf' ] = line [ ( dir  re.search(r'agnip$',
Lexem 14 Current token=')' value=')' Tokenstr |s(s)(")=s((s~q)| translated: interfaces [ key ] [ 'vrf' ] = line [ ( dir  re.search(r'agnip$', )
Lexem 15 Current token='?' value='?' Tokenstr |s(s)(")=s((s~q)?| translated: interfaces [ key ] [ 'vrf' ] = line [ ( dir  re.search(r'agnip$', ) ?
Lexem 16 Current token='d' value='21' Tokenstr |s(s)(")=s((s~q)?d| translated: interfaces [ key ] [ 'vrf' ] = line [ ( dir  re.search(r'agnip$', ) ? 21
Lexem 17 Current token=':' value=':' Tokenstr |s(s)(")=s((s~q)?d:| translated: interfaces [ key ] [ 'vrf' ] = line [ ( dir  re.search(r'agnip$', ) ? 21 :
Lexem 18 Current token='d' value='24' Tokenstr |s(s)(")=s((s~q)?d:d| translated: interfaces [ key ] [ 'vrf' ] = line [ ( dir  re.search(r'agnip$', ) ? 21 : 24
Lexem 19 Current token=')' value=']' Tokenstr |s(s)(")=s((s~q)?d:d)| translated: interfaces [ key ] [ 'vrf' ] = line [ ( dir  re.search(r'agnip$', ) ? 21 : 24 ]
Lexem 0 Current token='k' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' value='deletefiles' Tokenstr |ki| translated: def deletefiles
Lexem 0 Current token='c' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='s' value='file' Tokenstr |cs| translated: for  file
Lexem 2 Current token='(' value='(' Tokenstr |cs(| translated: for  file (
Lexem 3 Current token='f' value='glob.glob' Tokenstr |cs(f| translated: for  file ( glob.glob
Lexem 4 Current token='(' value='(' Tokenstr |cs(f(| translated: for  file ( glob.glob (
Lexem 5 Current token='"' value='f"{ldir}/*/d2*.*.Z"' Tokenstr |cs(f("| translated: for  file ( glob.glob ( f"{ldir}/*/d2*.*.Z"
Lexem 6 Current token=')' value=')' Tokenstr |cs(f(")| translated: for  file ( glob.glob ( f"{ldir}/*/d2*.*.Z" )
Lexem 7 Current token=')' value=')' Tokenstr |cs(f("))| translated: for  file ( glob.glob ( f"{ldir}/*/d2*.*.Z" ) )
Lexem 0 Current token='k' value='continue ' Tokenstr |k| translated: continue 
Lexem 1 Current token='c' value='if ' Tokenstr |kc| translated: continue  if 
Lexem 2 Current token='!' value='not' Tokenstr |kc!| translated: continue  if  not
Lexem 3 Current token='s' value='file' Tokenstr |kc!s| translated: continue  if  not file
Lexem 4 Current token='~' value='' Tokenstr |kc!s~| translated: continue  if  not file 
Lexem 5 Current token='q' value='(_m:=re.search(r'^$ldir/(\d{4})(\d{2})(\d{2})/d2*\.\d{2}\.Z$',' Tokenstr |kc!s~q| translated: continue  if  not file  (_m:=re.search(r'^$ldir/(\d{4})(\d{2})(\d{2})/d2*\.\d{2}\.Z$',
Lexem 0 Current token='x' value='f"rm {file}"' Tokenstr |x| translated: f"rm {file}"
Lexem 1 Current token='c' value='if ' Tokenstr |xc| translated: f"rm {file}" if 
Lexem 2 Current token='s' value='t' Tokenstr |xcs| translated: f"rm {file}" if  t
Lexem 3 Current token='-' value='-' Tokenstr |xcs-| translated: f"rm {file}" if  t -
Lexem 4 Current token='i' value='timegm' Tokenstr |xcs-i| translated: f"rm {file}" if  t - timegm
Lexem 5 Current token='(' value='(' Tokenstr |xcs-i(| translated: f"rm {file}" if  t - timegm (
Lexem 6 Current token='d' value='0' Tokenstr |xcs-i(d| translated: f"rm {file}" if  t - timegm ( 0
Lexem 7 Current token=',' value=',' Tokenstr |xcs-i(d,| translated: f"rm {file}" if  t - timegm ( 0 ,
Lexem 8 Current token='d' value='0' Tokenstr |xcs-i(d,d| translated: f"rm {file}" if  t - timegm ( 0 , 0
Lexem 9 Current token=',' value=',' Tokenstr |xcs-i(d,d,| translated: f"rm {file}" if  t - timegm ( 0 , 0 ,
Lexem 10 Current token='d' value='0' Tokenstr |xcs-i(d,d,d| translated: f"rm {file}" if  t - timegm ( 0 , 0 , 0
Lexem 11 Current token=',' value=',' Tokenstr |xcs-i(d,d,d,| translated: f"rm {file}" if  t - timegm ( 0 , 0 , 0 ,
Lexem 12 Current token='s' value='_m.group(3)' Tokenstr |xcs-i(d,d,d,s| translated: f"rm {file}" if  t - timegm ( 0 , 0 , 0 , _m.group(3)
Lexem 13 Current token=',' value=',' Tokenstr |xcs-i(d,d,d,s,| translated: f"rm {file}" if  t - timegm ( 0 , 0 , 0 , _m.group(3) ,
Lexem 14 Current token='s' value='_m.group(2)' Tokenstr |xcs-i(d,d,d,s,s| translated: f"rm {file}" if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2)
Lexem 15 Current token='-' value='-' Tokenstr |xcs-i(d,d,d,s,s-| translated: f"rm {file}" if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) -
Lexem 16 Current token='d' value='1' Tokenstr |xcs-i(d,d,d,s,s-d| translated: f"rm {file}" if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1
Lexem 17 Current token=',' value=',' Tokenstr |xcs-i(d,d,d,s,s-d,| translated: f"rm {file}" if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 ,
Lexem 18 Current token='s' value='_m.group(1)' Tokenstr |xcs-i(d,d,d,s,s-d,s| translated: f"rm {file}" if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 , _m.group(1)
Lexem 19 Current token='-' value='-' Tokenstr |xcs-i(d,d,d,s,s-d,s-| translated: f"rm {file}" if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 , _m.group(1) -
Lexem 20 Current token='d' value='1900' Tokenstr |xcs-i(d,d,d,s,s-d,s-d| translated: f"rm {file}" if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 , _m.group(1) - 1900
Lexem 21 Current token=')' value=')' Tokenstr |xcs-i(d,d,d,s,s-d,s-d)| translated: f"rm {file}" if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 , _m.group(1) - 1900 )
Lexem 22 Current token='>' value='>' Tokenstr |xcs-i(d,d,d,s,s-d,s-d)>| translated: f"rm {file}" if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 , _m.group(1) - 1900 ) >
Lexem 23 Current token='s' value='options' Tokenstr |xcs-i(d,d,d,s,s-d,s-d)>s| translated: f"rm {file}" if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 , _m.group(1) - 1900 ) > options
Lexem 24 Current token='(' value='[' Tokenstr |xcs-i(d,d,d,s,s-d,s-d)>s(| translated: f"rm {file}" if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 , _m.group(1) - 1900 ) > options [
Lexem 25 Current token='i' value='maxage' Tokenstr |xcs-i(d,d,d,s,s-d,s-d)>s(i| translated: f"rm {file}" if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 , _m.group(1) - 1900 ) > options [ maxage
Lexem 26 Current token=')' value=']' Tokenstr |xcs-i(d,d,d,s,s-d,s-d)>s(")| translated: f"rm {file}" if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 , _m.group(1) - 1900 ) > options [ 'maxage' ]
Lexem 27 Current token='*' value='*' Tokenstr |xcs-i(d,d,d,s,s-d,s-d)>s(")*| translated: f"rm {file}" if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 , _m.group(1) - 1900 ) > options [ 'maxage' ] *
Lexem 28 Current token='d' value='24' Tokenstr |xcs-i(d,d,d,s,s-d,s-d)>s(")*d| translated: f"rm {file}" if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 , _m.group(1) - 1900 ) > options [ 'maxage' ] * 24
Lexem 29 Current token='*' value='*' Tokenstr |xcs-i(d,d,d,s,s-d,s-d)>s(")*d*| translated: f"rm {file}" if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 , _m.group(1) - 1900 ) > options [ 'maxage' ] * 24 *
Lexem 30 Current token='d' value='60' Tokenstr |xcs-i(d,d,d,s,s-d,s-d)>s(")*d*d| translated: f"rm {file}" if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 , _m.group(1) - 1900 ) > options [ 'maxage' ] * 24 * 60
Lexem 31 Current token='*' value='*' Tokenstr |xcs-i(d,d,d,s,s-d,s-d)>s(")*d*d*| translated: f"rm {file}" if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 , _m.group(1) - 1900 ) > options [ 'maxage' ] * 24 * 60 *
Lexem 32 Current token='d' value='60' Tokenstr |xcs-i(d,d,d,s,s-d,s-d)>s(")*d*d*d| translated: f"rm {file}" if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 , _m.group(1) - 1900 ) > options [ 'maxage' ] * 24 * 60 * 60
Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='h' value='hop' Tokenstr |th| translated:  hop
Lexem 2 Current token='=' value='=' Tokenstr |th=| translated:  hop =
Lexem 3 Current token='(' value='(' Tokenstr |th=(| translated:  hop = (
Lexem 4 Current token='"' value=''AClli'' Tokenstr |th=("| translated:  hop = ( 'AClli'
Lexem 5 Current token=':' value=': ' Tokenstr |th=(":| translated:  hop = ( 'AClli' : 
Lexem 6 Current token='s' value='AClli' Tokenstr |th=(":s| translated:  hop = ( 'AClli' :  AClli
Lexem 7 Current token=',' value=',' Tokenstr |th=(":s,| translated:  hop = ( 'AClli' :  AClli ,
Lexem 8 Current token='"' value=''ZClli'' Tokenstr |th=(":s,"| translated:  hop = ( 'AClli' :  AClli , 'ZClli'
Lexem 9 Current token=':' value=': ' Tokenstr |th=(":s,":| translated:  hop = ( 'AClli' :  AClli , 'ZClli' : 
Lexem 10 Current token='s' value='ZClli' Tokenstr |th=(":s,":s| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli
Lexem 11 Current token=',' value=',' Tokenstr |th=(":s,":s,| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli ,
Lexem 12 Current token='"' value=''ID'' Tokenstr |th=(":s,":s,"| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID'
Lexem 13 Current token=':' value=': ' Tokenstr |th=(":s,":s,":| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' : 
Lexem 14 Current token='s' value='circuitRow' Tokenstr |th=(":s,":s,":s| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow
Lexem 15 Current token='(' value='[' Tokenstr |th=(":s,":s,":s(| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [
Lexem 16 Current token='s' value='colNames' Tokenstr |th=(":s,":s,":s(s| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames
Lexem 17 Current token='(' value='[' Tokenstr |th=(":s,":s,":s(s(| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [
Lexem 18 Current token='"' value=''ID'' Tokenstr |th=(":s,":s,":s(s("| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID'
Lexem 19 Current token=')' value=']' Tokenstr |th=(":s,":s,":s(s(")| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ]
Lexem 20 Current token=')' value=']' Tokenstr |th=(":s,":s,":s(s("))| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ]
Lexem 21 Current token=',' value=',' Tokenstr |th=(":s,":s,":s(s(")),| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] ,
Lexem 22 Current token='"' value=''mileage'' Tokenstr |th=(":s,":s,":s(s(")),"| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage'
Lexem 23 Current token=':' value=': ' Tokenstr |th=(":s,":s,":s(s(")),":| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' : 
Lexem 24 Current token='s' value='circuitRow' Tokenstr |th=(":s,":s,":s(s(")),":s| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow
Lexem 25 Current token='(' value='[' Tokenstr |th=(":s,":s,":s(s(")),":s(| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [
Lexem 26 Current token='s' value='colNames' Tokenstr |th=(":s,":s,":s(s(")),":s(s| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames
Lexem 27 Current token='(' value='[' Tokenstr |th=(":s,":s,":s(s(")),":s(s(| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames [
Lexem 28 Current token='"' value=''mileage'' Tokenstr |th=(":s,":s,":s(s(")),":s(s("| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames [ 'mileage'
Lexem 29 Current token=')' value=']' Tokenstr |th=(":s,":s,":s(s(")),":s(s(")| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames [ 'mileage' ]
Lexem 30 Current token=')' value=']' Tokenstr |th=(":s,":s,":s(s(")),":s(s("))| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames [ 'mileage' ] ]
Lexem 31 Current token=',' value=',' Tokenstr |th=(":s,":s,":s(s(")),":s(s(")),| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames [ 'mileage' ] ] ,
Lexem 32 Current token='"' value=''type'' Tokenstr |th=(":s,":s,":s(s(")),":s(s(")),"| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames [ 'mileage' ] ] , 'type'
Lexem 33 Current token=':' value=': ' Tokenstr |th=(":s,":s,":s(s(")),":s(s(")),":| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames [ 'mileage' ] ] , 'type' : 
Lexem 34 Current token='s' value='circuitRow' Tokenstr |th=(":s,":s,":s(s(")),":s(s(")),":s| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames [ 'mileage' ] ] , 'type' :  circuitRow
Lexem 35 Current token='(' value='[' Tokenstr |th=(":s,":s,":s(s(")),":s(s(")),":s(| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames [ 'mileage' ] ] , 'type' :  circuitRow [
Lexem 36 Current token='s' value='colNames' Tokenstr |th=(":s,":s,":s(s(")),":s(s(")),":s(s| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames [ 'mileage' ] ] , 'type' :  circuitRow [ colNames
Lexem 37 Current token='(' value='[' Tokenstr |th=(":s,":s,":s(s(")),":s(s(")),":s(s(| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames [ 'mileage' ] ] , 'type' :  circuitRow [ colNames [
Lexem 38 Current token='"' value=''type'' Tokenstr |th=(":s,":s,":s(s(")),":s(s(")),":s(s("| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames [ 'mileage' ] ] , 'type' :  circuitRow [ colNames [ 'type'
Lexem 39 Current token=')' value=']' Tokenstr |th=(":s,":s,":s(s(")),":s(s(")),":s(s(")| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames [ 'mileage' ] ] , 'type' :  circuitRow [ colNames [ 'type' ]
Lexem 40 Current token=')' value=']' Tokenstr |th=(":s,":s,":s(s(")),":s(s(")),":s(s("))| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames [ 'mileage' ] ] , 'type' :  circuitRow [ colNames [ 'type' ] ]
Lexem 41 Current token=')' value=')' Tokenstr |th=(":s,":s,":s(s(")),":s(s(")),":s(s(")))| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames [ 'mileage' ] ] , 'type' :  circuitRow [ colNames [ 'type' ] ] )
Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='f' value='in' Tokenstr |c(f| translated: if  ( in
Lexem 3 Current token='s' value='atm' Tokenstr |c(fs| translated: if  ( in atm
Lexem 4 Current token='(' value='[' Tokenstr |c(fs(| translated: if  ( in atm [
Lexem 5 Current token='s' value='r' Tokenstr |c(fs(s| translated: if  ( in atm [ r
Lexem 6 Current token=')' value=']' Tokenstr |c(fs(s)| translated: if  ( in atm [ r ]
Lexem 7 Current token='(' value='[' Tokenstr |c(fs(s)(| translated: if  ( in atm [ r ] [
Lexem 8 Current token='s' value='vpi' Tokenstr |c(fs(s)(s| translated: if  ( in atm [ r ] [ vpi
Lexem 9 Current token=')' value=']' Tokenstr |c(fs(s)(s)| translated: if  ( in atm [ r ] [ vpi ]
Lexem 10 Current token='(' value='[' Tokenstr |c(fs(s)(s)(| translated: if  ( in atm [ r ] [ vpi ] [
Lexem 11 Current token='s' value='vci' Tokenstr |c(fs(s)(s)(s| translated: if  ( in atm [ r ] [ vpi ] [ vci
Lexem 12 Current token=')' value=']' Tokenstr |c(fs(s)(s)(s)| translated: if  ( in atm [ r ] [ vpi ] [ vci ]
Lexem 13 Current token=')' value=')' Tokenstr |c(fs(s)(s)(s))| translated: if  ( in atm [ r ] [ vpi ] [ vci ] )
Lexem 0 Current token='s' value='i' Tokenstr |s| translated: i
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: i =
Lexem 2 Current token='s' value='atm' Tokenstr |s=s| translated: i = atm
Lexem 3 Current token='(' value='[' Tokenstr |s=s(| translated: i = atm [
Lexem 4 Current token='s' value='r' Tokenstr |s=s(s| translated: i = atm [ r
Lexem 5 Current token=')' value=']' Tokenstr |s=s(s)| translated: i = atm [ r ]
Lexem 6 Current token='(' value='[' Tokenstr |s=s(s)(| translated: i = atm [ r ] [
Lexem 7 Current token='s' value='vpi' Tokenstr |s=s(s)(s| translated: i = atm [ r ] [ vpi
Lexem 8 Current token=')' value=']' Tokenstr |s=s(s)(s)| translated: i = atm [ r ] [ vpi ]
Lexem 9 Current token='(' value='[' Tokenstr |s=s(s)(s)(| translated: i = atm [ r ] [ vpi ] [
Lexem 10 Current token='s' value='vci' Tokenstr |s=s(s)(s)(s| translated: i = atm [ r ] [ vpi ] [ vci
Lexem 11 Current token=')' value=']' Tokenstr |s=s(s)(s)(s)| translated: i = atm [ r ] [ vpi ] [ vci ]
Lexem 0 Current token='k' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' value='make_location_header' Tokenstr |ki| translated: def make_location_header
Lexem 0 Current token='s' value='locdat' Tokenstr |s| translated: locdat
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: locdat =
Lexem 2 Current token='"' value=''CTTPS:Location\n'' Tokenstr |s="| translated: locdat = 'CTTPS:Location\n'
Lexem 0 Current token='s' value='locdat' Tokenstr |s| translated: locdat
Lexem 1 Current token='=' value='+=' Tokenstr |s=| translated: locdat +=
Lexem 2 Current token='"' value=''#PlanVersion    RunID   Clli    Longitude       Latitude\n'' Tokenstr |s="| translated: locdat += '#PlanVersion    RunID   Clli    Longitude       Latitude\n'
Lexem 0 Current token='f' value='os.umask' Tokenstr |f| translated: os.umask
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: os.umask (
Lexem 2 Current token='d' value='0o22' Tokenstr |f(d| translated: os.umask ( 0o22
Lexem 3 Current token=')' value=')' Tokenstr |f(d)| translated: os.umask ( 0o22 )
Lexem 0 Current token='s' value='options' Tokenstr |s| translated: options
Lexem 1 Current token='(' value='[' Tokenstr |s(| translated: options [
Lexem 2 Current token='i' value='other' Tokenstr |s(i| translated: options [ other
Lexem 3 Current token=')' value=']' Tokenstr |s(")| translated: options [ 'other' ]
Lexem 4 Current token='=' value='=' Tokenstr |s(")=| translated: options [ 'other' ] =
Lexem 5 Current token='"' value='f"m66828@zlp23061.vci.att.com"' Tokenstr |s(")="| translated: options [ 'other' ] = f"m66828@zlp23061.vci.att.com"
Lexem 0 Current token='k' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' value='makebytes' Tokenstr |ki| translated: def makebytes
Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='*' value='*' Tokenstr |t*| translated:  *
Lexem 2 Current token='i' value='LOG' Tokenstr |t*i| translated:  * LOG
Lexem 0 Current token='f' value='open' Tokenstr |f| translated: open
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: open (
Lexem 2 Current token='i' value='LOG' Tokenstr |f(i| translated: open ( LOG
Lexem 3 Current token=',' value=',' Tokenstr |f(i,| translated: open ( LOG ,
Lexem 4 Current token='"' value=''<'' Tokenstr |f(i,"| translated: open ( LOG , '<'
Lexem 5 Current token=',' value=',' Tokenstr |f(i,",| translated: open ( LOG , '<' ,
Lexem 6 Current token='"' value=''myfile.f'' Tokenstr |f(i,","| translated: open ( LOG , '<' , 'myfile.f'
Lexem 7 Current token=')' value=')' Tokenstr |f(i,",")| translated: open ( LOG , '<' , 'myfile.f' )
bash_style_or_and_fix(2) is_or=1
After bash_style_or_and_fix(2): =|c(!(f(i,",")))|=
Lexem 0 Current token='f' value='raise Die' Tokenstr |f| translated: raise Die
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: raise Die (
Lexem 2 Current token='"' value='"Can't open myfile.f"' Tokenstr |f("| translated: raise Die ( "Can't open myfile.f"
Lexem 3 Current token=')' value=')' Tokenstr |f(")| translated: raise Die ( "Can't open myfile.f" )
Lexem 0 Current token='k' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' value='getTmpFileName' Tokenstr |ki| translated: def getTmpFileName
Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='s' value='fileName' Tokenstr |ts| translated:  fileName
Lexem 0 Current token='i' value='' Tokenstr |i| translated: 
Lexem 1 Current token='(' value='[' Tokenstr |i(| translated:  [
Lexem 2 Current token='s' value='fileName' Tokenstr |i(s| translated:  [ fileName
Lexem 3 Current token='=' value='=' Tokenstr |i(s=| translated:  [ fileName =
Lexem 4 Current token='i' value='POSIX.tmpnam' Tokenstr |i(s=i| translated:  [ fileName = POSIX.tmpnam
Lexem 5 Current token='(' value='(' Tokenstr |i(s=i(| translated:  [ fileName = POSIX.tmpnam (
Lexem 6 Current token=')' value=')' Tokenstr |i(s=i()| translated:  [ fileName = POSIX.tmpnam ( )
Lexem 0 Current token='c' value='while not ' Tokenstr |c| translated: while not 
Lexem 1 Current token='s' value='fh' Tokenstr |cs| translated: while not  fh
Lexem 2 Current token='=' value=':=' Tokenstr |cs=| translated: while not  fh :=
Lexem 3 Current token='i' value='IO.File' Tokenstr |cs=i| translated: while not  fh := IO.File
Lexem 4 Current token='.' value='.' Tokenstr |cs=i.| translated: while not  fh := IO.File .
Lexem 5 Current token='i' value='new' Tokenstr |cs=i.i| translated: while not  fh := IO.File . new
Lexem 6 Current token='(' value='(' Tokenstr |cs=i.i(| translated: while not  fh := IO.File . new (
Lexem 7 Current token='s' value='fileName' Tokenstr |cs=i.i(s| translated: while not  fh := IO.File . new ( fileName
Lexem 8 Current token=',' value=',' Tokenstr |cs=i.i(s,| translated: while not  fh := IO.File . new ( fileName ,
Lexem 9 Current token='i' value='os.O_RDWR' Tokenstr |cs=i.i(s,i| translated: while not  fh := IO.File . new ( fileName , os.O_RDWR
Lexem 10 Current token='|' value='|' Tokenstr |cs=i.i(s,i|| translated: while not  fh := IO.File . new ( fileName , os.O_RDWR |
Lexem 11 Current token='i' value='os.O_CREAT' Tokenstr |cs=i.i(s,i|i| translated: while not  fh := IO.File . new ( fileName , os.O_RDWR | os.O_CREAT
Lexem 12 Current token='|' value='|' Tokenstr |cs=i.i(s,i|i|| translated: while not  fh := IO.File . new ( fileName , os.O_RDWR | os.O_CREAT |
Lexem 13 Current token='i' value='os.O_EXCL' Tokenstr |cs=i.i(s,i|i|i| translated: while not  fh := IO.File . new ( fileName , os.O_RDWR | os.O_CREAT | os.O_EXCL
Lexem 14 Current token=')' value=')' Tokenstr |cs=i.i(s,i|i|i)| translated: while not  fh := IO.File . new ( fileName , os.O_RDWR | os.O_CREAT | os.O_EXCL )
Lexem 0 Current token='k' value='return' Tokenstr |k| translated: return
Lexem 1 Current token='s' value='fileName' Tokenstr |ks| translated: return fileName
Lexem 0 Current token='k' value='continue ' Tokenstr |k| translated: continue 
Lexem 1 Current token='c' value='if ' Tokenstr |kc| translated: continue  if 
Lexem 2 Current token='!' value='not' Tokenstr |kc!| translated: continue  if  not
Lexem 3 Current token='f' value='open' Tokenstr |kc!f| translated: continue  if  not open
Lexem 4 Current token='(' value='(' Tokenstr |kc!f(| translated: continue  if  not open (
Lexem 5 Current token='i' value='CACHE_LOCK' Tokenstr |kc!f(i| translated: continue  if  not open ( CACHE_LOCK
Lexem 6 Current token=',' value=',' Tokenstr |kc!f(i,| translated: continue  if  not open ( CACHE_LOCK ,
Lexem 7 Current token='"' value='f"<{cachelock}"' Tokenstr |kc!f(i,"| translated: continue  if  not open ( CACHE_LOCK , f"<{cachelock}"
Lexem 8 Current token=')' value=')' Tokenstr |kc!f(i,")| translated: continue  if  not open ( CACHE_LOCK , f"<{cachelock}" )
Lexem 0 Current token='k' value='continue ' Tokenstr |k| translated: continue 
Lexem 1 Current token='c' value='if ' Tokenstr |kc| translated: continue  if 
Lexem 2 Current token='!' value='not' Tokenstr |kc!| translated: continue  if  not
Lexem 3 Current token='f' value='_flock' Tokenstr |kc!f| translated: continue  if  not _flock
Lexem 4 Current token='(' value='(' Tokenstr |kc!f(| translated: continue  if  not _flock (
Lexem 5 Current token='i' value='CACHE_LOCK' Tokenstr |kc!f(i| translated: continue  if  not _flock ( CACHE_LOCK
Lexem 6 Current token=',' value=',' Tokenstr |kc!f(i,| translated: continue  if  not _flock ( CACHE_LOCK ,
Lexem 7 Current token='i' value='fcntl.LOCK_SH' Tokenstr |kc!f(i,i| translated: continue  if  not _flock ( CACHE_LOCK , fcntl.LOCK_SH
Lexem 8 Current token='|' value='|' Tokenstr |kc!f(i,i|| translated: continue  if  not _flock ( CACHE_LOCK , fcntl.LOCK_SH |
Lexem 9 Current token='i' value='fcntl.LOCK_NB' Tokenstr |kc!f(i,i|i| translated: continue  if  not _flock ( CACHE_LOCK , fcntl.LOCK_SH | fcntl.LOCK_NB
Lexem 10 Current token=')' value=')' Tokenstr |kc!f(i,i|i)| translated: continue  if  not _flock ( CACHE_LOCK , fcntl.LOCK_SH | fcntl.LOCK_NB )
Lexem 0 Current token='f' value='open' Tokenstr |f| translated: open
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: open (
Lexem 2 Current token='i' value='TM_LOCK' Tokenstr |f(i| translated: open ( TM_LOCK
Lexem 3 Current token=',' value=',' Tokenstr |f(i,| translated: open ( TM_LOCK ,
Lexem 4 Current token='"' value='f">{lockfile}"' Tokenstr |f(i,"| translated: open ( TM_LOCK , f">{lockfile}"
Lexem 5 Current token=')' value=')' Tokenstr |f(i,")| translated: open ( TM_LOCK , f">{lockfile}" )
bash_style_or_and_fix(2) is_or=1
After bash_style_or_and_fix(2): =|c(!(f(i,")))|=
Lexem 0 Current token='f' value='raise Die' Tokenstr |f| translated: raise Die
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: raise Die (
Lexem 2 Current token='"' value='f"cannot open {lockfile}"' Tokenstr |f("| translated: raise Die ( f"cannot open {lockfile}"
Lexem 3 Current token=')' value=')' Tokenstr |f(")| translated: raise Die ( f"cannot open {lockfile}" )
Lexem 0 Current token='k' value='continue ' Tokenstr |k| translated: continue 
Lexem 1 Current token='c' value='if ' Tokenstr |kc| translated: continue  if 
Lexem 2 Current token='!' value='not' Tokenstr |kc!| translated: continue  if  not
Lexem 3 Current token='f' value='_flock' Tokenstr |kc!f| translated: continue  if  not _flock
Lexem 4 Current token='(' value='(' Tokenstr |kc!f(| translated: continue  if  not _flock (
Lexem 5 Current token='i' value='TM_LOCK' Tokenstr |kc!f(i| translated: continue  if  not _flock ( TM_LOCK
Lexem 6 Current token=',' value=',' Tokenstr |kc!f(i,| translated: continue  if  not _flock ( TM_LOCK ,
Lexem 7 Current token='i' value='fcntl.LOCK_EX' Tokenstr |kc!f(i,i| translated: continue  if  not _flock ( TM_LOCK , fcntl.LOCK_EX
Lexem 8 Current token='|' value='|' Tokenstr |kc!f(i,i|| translated: continue  if  not _flock ( TM_LOCK , fcntl.LOCK_EX |
Lexem 9 Current token='i' value='fcntl.LOCK_NB' Tokenstr |kc!f(i,i|i| translated: continue  if  not _flock ( TM_LOCK , fcntl.LOCK_EX | fcntl.LOCK_NB
Lexem 10 Current token=')' value=')' Tokenstr |kc!f(i,i|i)| translated: continue  if  not _flock ( TM_LOCK , fcntl.LOCK_EX | fcntl.LOCK_NB )
Lexem 0 Current token='k' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' value='ddd' Tokenstr |ki| translated: def ddd
Lexem 0 Current token='f' value='raise Die' Tokenstr |f| translated: raise Die
Lexem 1 Current token='"' value=''not_timeout'' Tokenstr |f"| translated: raise Die 'not_timeout'
decode_scalar SIG source=$SIG{ __DIE__ } = sub { Carp::confess( @_ ) };	# SNOOPYJC
decode_scalar SIG source=$SIG=1;
Lexem 0 Current token='s' value='TRACEBACK' Tokenstr |s| translated: TRACEBACK
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: TRACEBACK =
Lexem 2 Current token='d' value='1' Tokenstr |s=d| translated: TRACEBACK = 1
decode_scalar SIG source=$SIG{ INT } = sub { Carp::confess( @_ ) };		# SNOOPYJC
decode_scalar SIG source=$SIG(INT, sub { traceback::print_stack($f) });		# SNOOPYJC
Lexem 0 Current token='f' value='signal.signal' Tokenstr |f| translated: signal.signal
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: signal.signal (
Lexem 2 Current token='i' value='signal.SIGINT' Tokenstr |f(i| translated: signal.signal ( signal.SIGINT
Lexem 3 Current token=',' value=',' Tokenstr |f(i,| translated: signal.signal ( signal.SIGINT ,
Lexem 4 Current token='k' value='def' Tokenstr |f(i,k| translated: signal.signal ( signal.SIGINT , def
Lexem 5 Current token='(' value='[' Tokenstr |f(i,k(| translated: signal.signal ( signal.SIGINT , def [
Lexem 6 Current token='i' value='traceback.print_stack' Tokenstr |f(i,k(i| translated: signal.signal ( signal.SIGINT , def [ traceback.print_stack
Lexem 7 Current token='(' value='(' Tokenstr |f(i,k(i(| translated: signal.signal ( signal.SIGINT , def [ traceback.print_stack (
Lexem 8 Current token='s' value='f' Tokenstr |f(i,k(i(s| translated: signal.signal ( signal.SIGINT , def [ traceback.print_stack ( f
Lexem 9 Current token=')' value=')' Tokenstr |f(i,k(i(s)| translated: signal.signal ( signal.SIGINT , def [ traceback.print_stack ( f )
Lexem 10 Current token=')' value=']' Tokenstr |f(i,k(i(s))| translated: signal.signal ( signal.SIGINT , def [ traceback.print_stack ( f ) ]
Lexem 11 Current token=')' value=')' Tokenstr |f(i,k(i(s)))| translated: signal.signal ( signal.SIGINT , def [ traceback.print_stack ( f ) ] )
Lexem 0 Current token='s' value='' Tokenstr |s| translated: 
Lexem 1 Current token='|' value='|' Tokenstr |s|| translated:  |
Lexem 2 Current token='=' value='=' Tokenstr |s|=| translated:  | =
Lexem 3 Current token='d' value='1' Tokenstr |s|=d| translated:  | = 1
decode_scalar SIG source=$SIG{ __DIE__ } = 'DEFAULT';
decode_scalar SIG source=$SIG=0;
Lexem 0 Current token='s' value='TRACEBACK' Tokenstr |s| translated: TRACEBACK
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: TRACEBACK =
Lexem 2 Current token='d' value='0' Tokenstr |s=d| translated: TRACEBACK = 0
Lexem 0 Current token='s' value='s' Tokenstr |s| translated: s
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: s =
decode_scalar SIG source=$SIG{ALRM};
decode_scalar SIG source=$SIG(ALRM);
Lexem 2 Current token='f' value='signal.getsignal' Tokenstr |s=f| translated: s = signal.getsignal
Lexem 3 Current token='(' value='(' Tokenstr |s=f(| translated: s = signal.getsignal (
Lexem 4 Current token='i' value='signal.SIGALRM' Tokenstr |s=f(i| translated: s = signal.getsignal ( signal.SIGALRM
Lexem 5 Current token=')' value=')' Tokenstr |s=f(i)| translated: s = signal.getsignal ( signal.SIGALRM )
Lexem 0 Current token='s' value='my_flag' Tokenstr |s| translated: my_flag
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: my_flag =
Lexem 2 Current token='d' value='0' Tokenstr |s=d| translated: my_flag = 0
decode_scalar SIG source=$SIG{ALRM} = sub { $my_flag = 1; };
decode_scalar SIG source=$SIG(ALRM, sub { $my_flag = 1; });
Lexem 0 Current token='f' value='signal.signal' Tokenstr |f| translated: signal.signal
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: signal.signal (
Lexem 2 Current token='i' value='signal.SIGALRM' Tokenstr |f(i| translated: signal.signal ( signal.SIGALRM
Lexem 3 Current token=',' value=',' Tokenstr |f(i,| translated: signal.signal ( signal.SIGALRM ,
Lexem 4 Current token='k' value='def' Tokenstr |f(i,k| translated: signal.signal ( signal.SIGALRM , def
Lexem 5 Current token='(' value='[' Tokenstr |f(i,k(| translated: signal.signal ( signal.SIGALRM , def [
Lexem 6 Current token='s' value='my_flag' Tokenstr |f(i,k(s| translated: signal.signal ( signal.SIGALRM , def [ my_flag
Lexem 7 Current token='=' value='=' Tokenstr |f(i,k(s=| translated: signal.signal ( signal.SIGALRM , def [ my_flag =
Lexem 8 Current token='d' value='1' Tokenstr |f(i,k(s=d| translated: signal.signal ( signal.SIGALRM , def [ my_flag = 1
Lexem 9 Current token=';' value=';' Tokenstr |f(i,k(s=d;| translated: signal.signal ( signal.SIGALRM , def [ my_flag = 1 ;
Lexem 10 Current token=')' value=']' Tokenstr |f(i,k(s=d;)| translated: signal.signal ( signal.SIGALRM , def [ my_flag = 1 ; ]
Lexem 11 Current token=')' value=')' Tokenstr |f(i,k(s=d;))| translated: signal.signal ( signal.SIGALRM , def [ my_flag = 1 ; ] )
decode_scalar SIG source=$SIG{ALRM} = sub { $my_flag++; };
decode_scalar SIG source=$SIG(ALRM, sub { $my_flag++; });
Lexem 0 Current token='f' value='signal.signal' Tokenstr |f| translated: signal.signal
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: signal.signal (
Lexem 2 Current token='i' value='signal.SIGALRM' Tokenstr |f(i| translated: signal.signal ( signal.SIGALRM
Lexem 3 Current token=',' value=',' Tokenstr |f(i,| translated: signal.signal ( signal.SIGALRM ,
Lexem 4 Current token='k' value='def' Tokenstr |f(i,k| translated: signal.signal ( signal.SIGALRM , def
Lexem 5 Current token='(' value='[' Tokenstr |f(i,k(| translated: signal.signal ( signal.SIGALRM , def [
Lexem 6 Current token='s' value='my_flag' Tokenstr |f(i,k(s| translated: signal.signal ( signal.SIGALRM , def [ my_flag
Lexem 7 Current token='^' value='+=1' Tokenstr |f(i,k(s^| translated: signal.signal ( signal.SIGALRM , def [ my_flag +=1
Lexem 8 Current token=';' value=';' Tokenstr |f(i,k(s^;| translated: signal.signal ( signal.SIGALRM , def [ my_flag +=1 ;
Lexem 9 Current token=')' value=']' Tokenstr |f(i,k(s^;)| translated: signal.signal ( signal.SIGALRM , def [ my_flag +=1 ; ]
Lexem 10 Current token=')' value=')' Tokenstr |f(i,k(s^;))| translated: signal.signal ( signal.SIGALRM , def [ my_flag +=1 ; ] )
decode_scalar SIG source=$SIG{ALRM} = $s;
decode_scalar SIG source=$SIG(ALRM, $s);
Lexem 0 Current token='f' value='signal.signal' Tokenstr |f| translated: signal.signal
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: signal.signal (
Lexem 2 Current token='i' value='signal.SIGALRM' Tokenstr |f(i| translated: signal.signal ( signal.SIGALRM
Lexem 3 Current token=',' value=',' Tokenstr |f(i,| translated: signal.signal ( signal.SIGALRM ,
Lexem 4 Current token='s' value='s' Tokenstr |f(i,s| translated: signal.signal ( signal.SIGALRM , s
Lexem 5 Current token=')' value=')' Tokenstr |f(i,s)| translated: signal.signal ( signal.SIGALRM , s )
decode_scalar SIG source=$SIG{ALRM} = 'WHO KNOWS';
decode_scalar SIG source=$SIG(ALRM, 'WHO KNOWS');
Lexem 0 Current token='f' value='signal.signal' Tokenstr |f| translated: signal.signal
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: signal.signal (
Lexem 2 Current token='i' value='signal.SIGALRM' Tokenstr |f(i| translated: signal.signal ( signal.SIGALRM
Lexem 3 Current token=',' value=',' Tokenstr |f(i,| translated: signal.signal ( signal.SIGALRM ,
Lexem 4 Current token='"' value=''WHO KNOWS'' Tokenstr |f(i,"| translated: signal.signal ( signal.SIGALRM , 'WHO KNOWS'
Lexem 5 Current token=')' value=')' Tokenstr |f(i,")| translated: signal.signal ( signal.SIGALRM , 'WHO KNOWS' )
decode_scalar SIG source=$SIG{ALRM} = 'IGNORE';
decode_scalar SIG source=$SIG(ALRM, _IGN);
Lexem 0 Current token='f' value='signal.signal' Tokenstr |f| translated: signal.signal
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: signal.signal (
Lexem 2 Current token='i' value='signal.SIGALRM' Tokenstr |f(i| translated: signal.signal ( signal.SIGALRM
Lexem 3 Current token=',' value=',' Tokenstr |f(i,| translated: signal.signal ( signal.SIGALRM ,
Lexem 4 Current token='i' value='signal.SIG_IGN' Tokenstr |f(i,i| translated: signal.signal ( signal.SIGALRM , signal.SIG_IGN
Lexem 5 Current token=')' value=')' Tokenstr |f(i,i)| translated: signal.signal ( signal.SIGALRM , signal.SIG_IGN )
decode_scalar SIG source=$SIG{ALRM} = 'DEFAULT';
decode_scalar SIG source=$SIG(ALRM, _DFL);
Lexem 0 Current token='f' value='signal.signal' Tokenstr |f| translated: signal.signal
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: signal.signal (
Lexem 2 Current token='i' value='signal.SIGALRM' Tokenstr |f(i| translated: signal.signal ( signal.SIGALRM
Lexem 3 Current token=',' value=',' Tokenstr |f(i,| translated: signal.signal ( signal.SIGALRM ,
Lexem 4 Current token='i' value='signal.SIG_DFL' Tokenstr |f(i,i| translated: signal.signal ( signal.SIGALRM , signal.SIG_DFL
Lexem 5 Current token=')' value=')' Tokenstr |f(i,i)| translated: signal.signal ( signal.SIGALRM , signal.SIG_DFL )
decode_scalar SIG source=$SIG{ALRM} = sub { die "timeout"; };
decode_scalar SIG source=$SIG(ALRM, sub { die "timeout"; });
Lexem 0 Current token='f' value='signal.signal' Tokenstr |f| translated: signal.signal
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: signal.signal (
Lexem 2 Current token='i' value='signal.SIGALRM' Tokenstr |f(i| translated: signal.signal ( signal.SIGALRM
Lexem 3 Current token=',' value=',' Tokenstr |f(i,| translated: signal.signal ( signal.SIGALRM ,
Lexem 4 Current token='k' value='def' Tokenstr |f(i,k| translated: signal.signal ( signal.SIGALRM , def
Lexem 5 Current token='(' value='[' Tokenstr |f(i,k(| translated: signal.signal ( signal.SIGALRM , def [
Lexem 6 Current token='f' value='raise Die' Tokenstr |f(i,k(f| translated: signal.signal ( signal.SIGALRM , def [ raise Die
Lexem 7 Current token='"' value=''timeout'' Tokenstr |f(i,k(f"| translated: signal.signal ( signal.SIGALRM , def [ raise Die 'timeout'
Lexem 8 Current token=';' value=';' Tokenstr |f(i,k(f";| translated: signal.signal ( signal.SIGALRM , def [ raise Die 'timeout' ;
Lexem 9 Current token=')' value=']' Tokenstr |f(i,k(f";)| translated: signal.signal ( signal.SIGALRM , def [ raise Die 'timeout' ; ]
Lexem 10 Current token=')' value=')' Tokenstr |f(i,k(f";))| translated: signal.signal ( signal.SIGALRM , def [ raise Die 'timeout' ; ] )
Lexem 0 Current token='s' value='retval' Tokenstr |s| translated: retval
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: retval =
Lexem 2 Current token='d' value='0' Tokenstr |s=d| translated: retval = 0
Lexem 0 Current token='C' value='try' Tokenstr |C| translated: try
Lexem 0 Current token='f' value='signal.alarm' Tokenstr |f| translated: signal.alarm
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: signal.alarm (
Lexem 2 Current token='s' value='TIME' Tokenstr |f(s| translated: signal.alarm ( TIME
Lexem 3 Current token=')' value=')' Tokenstr |f(s)| translated: signal.alarm ( TIME )
Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' value='interfacev' Tokenstr |c(s| translated: if  ( interfacev
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: if  ( interfacev ==
Lexem 4 Current token='"' value=''v1.0a'' Tokenstr |c(s>"| translated: if  ( interfacev == 'v1.0a'
Lexem 5 Current token=')' value=')' Tokenstr |c(s>")| translated: if  ( interfacev == 'v1.0a' )
Lexem 0 Current token='s' value='rc' Tokenstr |s| translated: rc
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: rc =
Lexem 2 Current token='f' value='os.system' Tokenstr |s=f| translated: rc = os.system
Lexem 3 Current token='(' value='(' Tokenstr |s=f(| translated: rc = os.system (
Lexem 4 Current token='"' value='f"ssh -l {user} {system} date >/dev/null 2>/dev/null"' Tokenstr |s=f("| translated: rc = os.system ( f"ssh -l {user} {system} date >/dev/null 2>/dev/null"
Lexem 5 Current token=')' value=')' Tokenstr |s=f(")| translated: rc = os.system ( f"ssh -l {user} {system} date >/dev/null 2>/dev/null" )
Lexem 0 Current token='C' value='else: ' Tokenstr |C| translated: else: 
Lexem 0 Current token='s' value='rc' Tokenstr |s| translated: rc
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: rc =
Lexem 2 Current token='f' value='os.system' Tokenstr |s=f| translated: rc = os.system
Lexem 3 Current token='(' value='(' Tokenstr |s=f(| translated: rc = os.system (
Lexem 4 Current token='"' value='f"echo vdate | ssh -l {user} {system} >/dev/null 2>/dev/null"' Tokenstr |s=f("| translated: rc = os.system ( f"echo vdate | ssh -l {user} {system} >/dev/null 2>/dev/null"
Lexem 5 Current token=')' value=')' Tokenstr |s=f(")| translated: rc = os.system ( f"echo vdate | ssh -l {user} {system} >/dev/null 2>/dev/null" )
Lexem 0 Current token='s' value='retval' Tokenstr |s| translated: retval
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: retval =
Lexem 2 Current token='d' value='1' Tokenstr |s=d| translated: retval = 1
Lexem 3 Current token='c' value='if ' Tokenstr |s=dc| translated: retval = 1 if 
Lexem 4 Current token='(' value='(' Tokenstr |s=dc(| translated: retval = 1 if  (
Lexem 5 Current token='s' value='rc' Tokenstr |s=dc(s| translated: retval = 1 if  ( rc
Lexem 6 Current token='>' value='>' Tokenstr |s=dc(s>| translated: retval = 1 if  ( rc >
Lexem 7 Current token='d' value='0' Tokenstr |s=dc(s>d| translated: retval = 1 if  ( rc > 0
Lexem 8 Current token=')' value=')' Tokenstr |s=dc(s>d)| translated: retval = 1 if  ( rc > 0 )
Lexem 0 Current token='f' value='signal.alarm' Tokenstr |f| translated: signal.alarm
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: signal.alarm (
Lexem 2 Current token='d' value='0' Tokenstr |f(d| translated: signal.alarm ( 0
Lexem 3 Current token=')' value=')' Tokenstr |f(d)| translated: signal.alarm ( 0 )
Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' value='EVAL_ERROR' Tokenstr |c(s| translated: if  ( EVAL_ERROR
Lexem 3 Current token=')' value=')' Tokenstr |c(s)| translated: if  ( EVAL_ERROR )
Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' value='EVAL_ERROR' Tokenstr |c(s| translated: if  ( EVAL_ERROR
Lexem 3 Current token='~' value='' Tokenstr |c(s~| translated: if  ( EVAL_ERROR 
Lexem 4 Current token='q' value='re.search(r'timeout',' Tokenstr |c(s~q| translated: if  ( EVAL_ERROR  re.search(r'timeout',
Lexem 5 Current token=')' value=')' Tokenstr |c(s~q)| translated: if  ( EVAL_ERROR  re.search(r'timeout', )
Lexem 0 Current token='s' value='retval' Tokenstr |s| translated: retval
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: retval =
Lexem 2 Current token='d' value='1' Tokenstr |s=d| translated: retval = 1
Lexem 0 Current token='C' value='else: ' Tokenstr |C| translated: else: 
Lexem 0 Current token='f' value='signal.alarm' Tokenstr |f| translated: signal.alarm
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: signal.alarm (
Lexem 2 Current token='d' value='0' Tokenstr |f(d| translated: signal.alarm ( 0
Lexem 3 Current token=')' value=')' Tokenstr |f(d)| translated: signal.alarm ( 0 )
Lexem 0 Current token='f' value='raise Die' Tokenstr |f| translated: raise Die
Lexem 0 Current token='f' value='sys.exit' Tokenstr |f| translated: sys.exit
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: sys.exit (
Lexem 2 Current token='s' value='retval' Tokenstr |f(s| translated: sys.exit ( retval
Lexem 3 Current token=')' value=')' Tokenstr |f(s)| translated: sys.exit ( retval )
Lexem 0 Current token='k' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' value='test_os_error_in_sub' Tokenstr |ki| translated: def test_os_error_in_sub
Lexem 0 Current token='f' value='open' Tokenstr |f| translated: open
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: open (
Lexem 2 Current token='i' value='FH' Tokenstr |f(i| translated: open ( FH
Lexem 3 Current token=',' value=',' Tokenstr |f(i,| translated: open ( FH ,
Lexem 4 Current token='"' value=''<'' Tokenstr |f(i,"| translated: open ( FH , '<'
Lexem 5 Current token=',' value=',' Tokenstr |f(i,",| translated: open ( FH , '<' ,
Lexem 6 Current token='"' value=''file'' Tokenstr |f(i,","| translated: open ( FH , '<' , 'file'
Lexem 7 Current token=')' value=')' Tokenstr |f(i,",")| translated: open ( FH , '<' , 'file' )
Lexem 0 Current token='f' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='"' value='f"{OS_ERROR}\n"' Tokenstr |f"| translated: print f"{OS_ERROR}\n"
VarSubMap = $VAR1 = {
  'ZClli' => {
    'main' => '+'
  },
  'estimated_fdmd' => {
    'main' => '+'
  },
  'currentfile' => {
    'main' => '+'
  },
  'f' => {
    'main' => '+'
  },
  'line' => {
    'main' => '+'
  },
  'status' => {
    'main' => '+'
  },
  'routespans' => {
    'main' => '+'
  },
  'in_' => {
    'process_file' => '+'
  },
  'OS_ERROR' => {
    'main' => '+'
  },
  'nfdmd' => {
    'main' => '+'
  },
  'LIST_SEPARATOR' => {
    'main' => '+'
  },
  'fh' => {
    'main' => '+'
  },
  'd' => {
    'main' => '+'
  },
  'rt' => {
    'main' => '+'
  },
  'bidsinterface' => {
    'main' => '+'
  },
  'interfacev' => {
    'main' => '+'
  },
  'file' => {
    'deletefiles' => '+'
  },
  'vrf2rt' => {
    'main' => '+'
  },
  'locdat' => {
    'make_location_header' => '+'
  },
  'hour' => {
    'main' => '+'
  },
  'num' => {
    'main' => '+'
  },
  'estimated_dmd' => {
    'main' => '+'
  },
  'vci' => {
    'main' => '+'
  },
  'action' => {
    'main' => '+'
  },
  'cttmembers' => {
    'main' => '+'
  },
  'otherfile' => {
    'main' => '+'
  },
  'colNames' => {
    'main' => '+'
  },
  'static' => {
    'main' => '+'
  },
  'interfaces' => {
    'main' => '+'
  },
  'rc' => {
    'main' => '+'
  },
  'vrf' => {
    'main' => '+'
  },
  'TRACEBACK' => {
    'main' => '+'
  },
  'p' => {
    'main' => '+'
  },
  'bundles' => {
    'main' => '+'
  },
  '_script_start' => {
    'main' => '+'
  },
  'ip' => {
    'main' => '+'
  },
  'AClli' => {
    'main' => '+'
  },
  'i' => {
    'process_file' => '+',
    'main' => '+'
  },
  '' => {
    'main' => '+'
  },
  'files' => {
    'main' => '+'
  },
  'retVal' => {
    'main' => '+'
  },
  'TIME' => {
    'main' => '+'
  },
  'dir' => {
    'main' => '+'
  },
  'r' => {
    'main' => '+'
  },
  'vpi' => {
    'main' => '+'
  },
  'dirfiles' => {
    'test' => '+'
  },
  'gravity' => {
    'main' => '+'
  },
  'retval' => {
    'main' => '+'
  },
  'PROPERTIES_ln' => {
    'main' => '+'
  },
  'my_flag' => {
    'main' => '+'
  },
  'key' => {
    'main' => '+'
  },
  'n' => {
    'main' => '+'
  },
  't' => {
    'deletefiles' => '+'
  },
  'commented_timestamp' => {
    'main' => '+'
  },
  'options' => {
    'main' => '+',
    'deletefiles' => '+'
  },
  'rin' => {
    'main' => '+'
  },
  'name' => {
    'main' => '+'
  },
  's' => {
    'main' => '+'
  },
  'atm' => {
    'main' => '+'
  },
  'circuitRow' => {
    'main' => '+'
  },
  'node' => {
    'main' => '+'
  },
  'AUTODIE' => {
    'main' => '+'
  }
};


DETECTED GLOBAL VARIABLES:
	deletefiles: global options
	main: global options

List of local subroutines:
main DCerror test test_os_error_in_sub getTmpFileName make_location_header DCinfo deletefiles ddd makebytes process_file
mkdir: cannot create directory ‘/c/Users/Joe’: File exists
cp: target 'Orost/Archive/pythonizer' is not a directory
cp: target 'Orost/Archive/Softpano.pm' is not a directory
cp: target 'Orost/Archive/Perlscan.pm' is not a directory
cp: target 'Orost/Archive/Pythonizer.pm' is not a directory
   1 | 0 |   |#!/usr/bin/python3 -u
   1 | 0 |   |# Generated by pythonizer 0.915 run by Joe Orost on Thu Dec  2 12:50:55 2021
   1 | 0 |   |# lines from cmt that generate syntax errors
   2 | 0 |   |
   3 | 0 |   |import sys,os,re,fcntl,math,fileinput,subprocess,inspect,collections.abc,argparse,glob,warnings,inspect,functools,signal,traceback
   3 | 0 |   |import time as tm_py
   3 | 0 |   |TRACEBACK = 1
   3 | 0 |   |_script_start = tm_py.time()
   3 | 0 |   |AUTODIE = 1
   3 | 0 |   |LIST_SEPARATOR = ' '
   3 | 0 |   |OS_ERROR = ''
   3 | 0 |   |class Die(Exception):
    def __init(self, arg):
        traceback.print_stack()
   3 | 0 |   |class EvalReturn(Exception):
    pass
   3 | 0 |   |_args = sys.argv[1:]
Main loop, line=sub test {


 === Line 3 Perl source:sub test {===

Lexem 0 Current token='k' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' value='test' Tokenstr |ki| translated: def test

Line:    3 TokenStr: =|ki|= @ValPy: def test
Generated partial line deftest(_args):
   3 | 0 |   |def test(_args):                                                                        #PL: sub test {

Tokens: ki ValPy: 
Main loop, line={


 === Line 3 Perl source:{===


Line:    3 TokenStr: =|{|= @ValPy: {
Main loop, line=return if not grep /DC_$year$month$day$hour.*-ifStats_Juniper_5MIN/,@dirfiles;


 === Line 4 Perl source:return if not grep /DC_$year$month$day$hour.*-ifStats_Juniper_5MIN/,@dirfiles;===

Lexem 0 Current token='k' value='return' Tokenstr |k| translated: return
Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='!' value='not' Tokenstr |c!| translated: if  not
Lexem 2 Current token='f' value='filter' Tokenstr |c!f| translated: if  not filter
Lexem 3 Current token='q' value='re.search(r'DC_$year$month$day$hour.*-ifStats_Juniper_5MIN',_d)' Tokenstr |c!fq| translated: if  not filter re.search(r'DC_$year$month$day$hour.*-ifStats_Juniper_5MIN',_d)
Lexem 4 Current token=',' value=',' Tokenstr |c!fq,| translated: if  not filter re.search(r'DC_$year$month$day$hour.*-ifStats_Juniper_5MIN',_d) ,
Lexem 5 Current token='a' value='dirfiles' Tokenstr |c!fq,a| translated: if  not filter re.search(r'DC_$year$month$day$hour.*-ifStats_Juniper_5MIN',_d) , dirfiles

Line:    4 TokenStr: =|c!fq,a|= @ValPy: if  not filter re.search(r'DC_$year$month$day$hour.*-ifStats_Juniper_5MIN',_d) , dirfiles
control(0) =|c(!fq,a)|= if ( not grep DC_$year$month$day$hour.*-ifStats_Juniper_5MIN , ; )

control-parens removed, begin=0 start=1 =|c!fq,a|= if not grep DC_$year$month$day$hour.*-ifStats_Juniper_5MIN , ;

Generated partial line if 
expression(1, 5, 0) =|c!fq,a|= if not grep DC_$year$month$day$hour.*-ifStats_Juniper_5MIN , ;

Generated partial line if not
function(2, 5) =|c!fq,a|= if not grep DC_$year$month$day$hour.*-ifStats_Juniper_5MIN , ;

function start=3, end_pos=5, bracketed=0
Generated partial line if notfilter
Generated partial line if notfilter(
expression(3, 5, 0) =|c!fq,a|= if not grep DC_$year$month$day$hour.*-ifStats_Juniper_5MIN , ;

Generated partial line if notfilter(re.search(r'DC_$year$month$day$hour.*-ifStats_Juniper_5MIN',_d)
Generated partial line if notfilter(re.search(r'DC_$year$month$day$hour.*-ifStats_Juniper_5MIN',_d),
Generated partial line if notfilter(re.search(r'DC_$year$month$day$hour.*-ifStats_Juniper_5MIN',_d),dirfiles
expression returns 6
Generated partial line if notfilter(re.search(r'DC_$year$month$day$hour.*-ifStats_Juniper_5MIN',_d),dirfiles)
expression returns 6
Generated partial line if notfilter(re.search(r'DC_$year$month$day$hour.*-ifStats_Juniper_5MIN',_d),dirfiles):
   4 | 1 |   |    if not filter(re.search(r'DC_$year$month$day$hour.*-ifStats_Juniper_5MIN',_d), dirfiles): #PL: return if not grep /DC_$year$month$day$hour.*-ifStats_Juniper_5MIN/,@dirfiles;

Tokens: c!fq,a ValPy: 
Main loop, line=return if not grep /DC_$year$month$day$hour.*-ifStats_Juniper_5MIN/,@dirfiles;
Main loop, line=return if not grep /DC_$year$month$day$hour.*-ifStats_Juniper_5MIN/,@dirfiles;
Generated partial line return
   4 | 2 |   |        return                                                                          #PL: return if not grep /DC_$year$month$day$hour.*-ifStats_Juniper_5MIN/,@dirfiles;

Tokens: k ValPy: 
Main loop, line=return if not grep /DC_$year$month$day$hour.*-ifStats_Juniper_5MIN/,@dirfiles;
finish: prev_line=return if not grep /DC_$year$month$day$hour.*-ifStats_Juniper_5MIN/,@dirfiles;, PythonCode=
finish: Resetting line to }
Main loop, line=}


 === Line 5 Perl source:}===


Line:    5 TokenStr: =|}|= @ValPy: }
Main loop, line=if (-M $otherfile < -M $currentfile) {


 === Line 6 Perl source:if (-M $otherfile < -M $currentfile) {===

Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='f' value='_getM' Tokenstr |c(f| translated: if  ( _getM
Lexem 3 Current token='s' value='otherfile' Tokenstr |c(fs| translated: if  ( _getM otherfile
Lexem 4 Current token='>' value='<' Tokenstr |c(fs>| translated: if  ( _getM otherfile <
Lexem 5 Current token='f' value='_getM' Tokenstr |c(fs>f| translated: if  ( _getM otherfile < _getM
Lexem 6 Current token='s' value='currentfile' Tokenstr |c(fs>fs| translated: if  ( _getM otherfile < _getM currentfile
Lexem 7 Current token=')' value=')' Tokenstr |c(fs>fs)| translated: if  ( _getM otherfile < _getM currentfile )

Line:    6 TokenStr: =|c(fs>fs)|= @ValPy: if  ( _getM otherfile < _getM currentfile )
control(0) =|c(fs>fs)|= if ( -M $otherfile < -M $currentfile )

control-parens removed, begin=0 start=1 =|cfs>fs|= if -M $otherfile < -M $currentfile

Generated partial line if 
expression(1, 5, 0) =|cfs>fs|= if -M $otherfile < -M $currentfile

function(1, 5) =|cfs>fs|= if -M $otherfile < -M $currentfile

function start=2, end_pos=2, bracketed=0
Generated partial line if _getM(otherfile)
Generated partial line if _getM(otherfile)<
function(4, 5) =|cfs>fs|= if -M $otherfile < -M $currentfile

function start=5, end_pos=5, bracketed=0
Generated partial line if _getM(otherfile)<_getM(currentfile)
expression returns 6
Generated partial line if _getM(otherfile)<_getM(currentfile):
   6 | 0 |   |if _getM(otherfile)<_getM(currentfile):                                                 #PL: if (-M $otherfile < -M $currentfile) {

Tokens: cfs>fs ValPy: 
Main loop, line={


 === Line 6 Perl source:{===


Line:    6 TokenStr: =|{|= @ValPy: {
Main loop, line=;


 === Line 7 Perl source:;===


Line:    7 TokenStr: =||= @ValPy: 
   7 | 1 |   |    pass                                                                                #PL: ;

Tokens:  ValPy: 
Main loop, line=}


 === Line 8 Perl source:}===


Line:    8 TokenStr: =|}|= @ValPy: }
   9 | 0 |   |
Main loop, line=$SIG{ALRM} = sub { die "timeout"; };


 === Line 10 Perl source:$SIG{ALRM} = sub { die "timeout"; };===

decode_scalar SIG source=$SIG{ALRM} = sub { die "timeout"; };
decode_scalar SIG source=$SIG(ALRM, sub { die "timeout"; });
Lexem 0 Current token='f' value='signal.signal' Tokenstr |f| translated: signal.signal
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: signal.signal (
Lexem 2 Current token='i' value='signal.SIGALRM' Tokenstr |f(i| translated: signal.signal ( signal.SIGALRM
Lexem 3 Current token=',' value=',' Tokenstr |f(i,| translated: signal.signal ( signal.SIGALRM ,
Lexem 4 Current token='k' value='def' Tokenstr |f(i,k| translated: signal.signal ( signal.SIGALRM , def
Lexem 5 Current token='(' value='[' Tokenstr |f(i,k(| translated: signal.signal ( signal.SIGALRM , def [
Lexem 6 Current token='f' value='raise Die' Tokenstr |f(i,k(f| translated: signal.signal ( signal.SIGALRM , def [ raise Die
Lexem 7 Current token='"' value=''timeout'' Tokenstr |f(i,k(f"| translated: signal.signal ( signal.SIGALRM , def [ raise Die 'timeout'
Lexem 8 Current token=';' value=';' Tokenstr |f(i,k(f";| translated: signal.signal ( signal.SIGALRM , def [ raise Die 'timeout' ;
Lexem 9 Current token=')' value=']' Tokenstr |f(i,k(f";)| translated: signal.signal ( signal.SIGALRM , def [ raise Die 'timeout' ; ]
Lexem 10 Current token=')' value=')' Tokenstr |f(i,k(f";))| translated: signal.signal ( signal.SIGALRM , def [ raise Die 'timeout' ; ] )

Line:   10 TokenStr: =|f(i,k(f";))|= @ValPy: signal.signal ( signal.SIGALRM , def [ raise Die 'timeout' ; ] )
function(0, 10) =|f(i,k(f";))|= $SIG ( ALRM , sub { die timeout ; } )

function start=2, end_pos=9, bracketed=1
Generated partial line signal.signal
Generated partial line signal.signal(
expression(2, 9, 0) =|f(i,k(f";))|= $SIG ( ALRM , sub { die timeout ; } )

Generated partial line signal.signal(signal.SIGALRM
Generated partial line signal.signal(signal.SIGALRM,
Generated partial line signal.signal(signal.SIGALRM,lambda s,f:
expression(6, 7, 0) =|f(i,k(f";))|= $SIG ( ALRM , sub { die timeout ; } )

function(6, 7) =|f(i,k(f";))|= $SIG ( ALRM , sub { die timeout ; } )

function start=7, end_pos=7, bracketed=0
Generated partial line signal.signal(signal.SIGALRM,lambda s,f:_die
Generated partial line signal.signal(signal.SIGALRM,lambda s,f:_die(
expression(7, 7, 0) =|f(i,k(f";))|= $SIG ( ALRM , sub { die timeout ; } )

Generated partial line signal.signal(signal.SIGALRM,lambda s,f:_die('timeout'
expression returns 8
Generated partial line signal.signal(signal.SIGALRM,lambda s,f:_die('timeout')
expression returns 8
expression returns 10
Generated partial line signal.signal(signal.SIGALRM,lambda s,f:_die('timeout'))
  10 | 0 |   |signal.signal(signal.SIGALRM, lambda s,f:_die('timeout'))                               #PL: $SIG{ALRM} = sub { die "timeout"; };

Tokens: f(i,k(f";)) ValPy: 
  11 | 0 |   |
Main loop, line=$s = sprintf("$_\n");


 === Line 12 Perl source:$s = sprintf("$_\n");===

Lexem 0 Current token='s' value='s' Tokenstr |s| translated: s
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: s =
Lexem 2 Current token='f' value='' Tokenstr |s=f| translated: s = 
Lexem 3 Current token='(' value='(' Tokenstr |s=f(| translated: s =  (
Lexem 4 Current token='"' value='f"{_d}\n"' Tokenstr |s=f("| translated: s =  ( f"{_d}\n"
Lexem 5 Current token=')' value=')' Tokenstr |s=f(")| translated: s =  ( f"{_d}\n" )

Line:   12 TokenStr: =|s=f(")|= @ValPy: s =  ( f"{_d}\n" )
assignment(0, 5) =|s=f(")|= $s = sprintf ( $_\n )

Generated partial line s
Generated partial line s=
expression(2, 5, 0) =|s=f(")|= $s = sprintf ( $_\n )

function(2, 5) =|s=f(")|= $s = sprintf ( $_\n )

function start=4, end_pos=4, bracketed=1
Generated partial line s=f"{_d}\n" % ( 
Use of uninitialized value within @ValClass in string eq at ../pythonizer line 2923, <> line 12.
expression(6, 4, 0) =|s=f(")|= $s = sprintf ( $_\n )

expression returns 5
Generated partial line s=f"{_d}\n" % ( )
expression returns 6
  12 | 0 |   |s = f"{_d}\n" % ( )                                                                     #PL: $s = sprintf("$_\n");

Tokens: s=f(") ValPy: 
Main loop, line=$s = sprintf "$_\n";


 === Line 13 Perl source:$s = sprintf "$_\n";===

Lexem 0 Current token='s' value='s' Tokenstr |s| translated: s
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: s =
Lexem 2 Current token='f' value='' Tokenstr |s=f| translated: s = 
Lexem 3 Current token='"' value='f"{_d}\n"' Tokenstr |s=f"| translated: s =  f"{_d}\n"

Line:   13 TokenStr: =|s=f"|= @ValPy: s =  f"{_d}\n"
assignment(0, 3) =|s=f"|= $s = sprintf $_\n

Generated partial line s
Generated partial line s=
expression(2, 3, 0) =|s=f"|= $s = sprintf $_\n

function(2, 3) =|s=f"|= $s = sprintf $_\n

function start=3, end_pos=3, bracketed=0
Generated partial line s=f"{_d}\n" % ( 
Use of uninitialized value within @ValClass in string eq at ../pythonizer line 2923, <> line 13.
expression(5, 3, 0) =|s=f"|= $s = sprintf $_\n

Generated partial line s=f"{_d}\n" % ( f"{_d}\n"
expression returns 4
Generated partial line s=f"{_d}\n" % ( f"{_d}\n")
expression returns 4
  13 | 0 |   |s = f"{_d}\n" % ( f"{_d}\n")                                                            #PL: $s = sprintf "$_\n";

Tokens: s=f" ValPy: 
Main loop, line=$s = sprintf "%s\n", $_;


 === Line 14 Perl source:$s = sprintf "%s\n", $_;===

Lexem 0 Current token='s' value='s' Tokenstr |s| translated: s
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: s =
Lexem 2 Current token='f' value='' Tokenstr |s=f| translated: s = 
Lexem 3 Current token='"' value=''%s\n'' Tokenstr |s=f"| translated: s =  '%s\n'
Lexem 4 Current token=',' value=',' Tokenstr |s=f",| translated: s =  '%s\n' ,
Lexem 5 Current token='s' value='_d' Tokenstr |s=f",s| translated: s =  '%s\n' , _d

Line:   14 TokenStr: =|s=f",s|= @ValPy: s =  '%s\n' , _d
assignment(0, 5) =|s=f",s|= $s = sprintf %s\n , $_

Generated partial line s
Generated partial line s=
expression(2, 5, 0) =|s=f",s|= $s = sprintf %s\n , $_

function(2, 5) =|s=f",s|= $s = sprintf %s\n , $_

function start=3, end_pos=5, bracketed=0
Generated partial line s='%s\n' % ( 
expression(5, 5, 0) =|s=f",s|= $s = sprintf %s\n , $_

Generated partial line s='%s\n' % ( _d
expression returns 6
Generated partial line s='%s\n' % ( _d)
expression returns 6
  14 | 0 |   |s = '%s\n' % ( _d)                                                                      #PL: $s = sprintf "%s\n", $_;

Tokens: s=f",s ValPy: 
Main loop, line=$s = sprintf("%s\n", $_);


 === Line 15 Perl source:$s = sprintf("%s\n", $_);===

Lexem 0 Current token='s' value='s' Tokenstr |s| translated: s
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: s =
Lexem 2 Current token='f' value='' Tokenstr |s=f| translated: s = 
Lexem 3 Current token='(' value='(' Tokenstr |s=f(| translated: s =  (
Lexem 4 Current token='"' value=''%s\n'' Tokenstr |s=f("| translated: s =  ( '%s\n'
Lexem 5 Current token=',' value=',' Tokenstr |s=f(",| translated: s =  ( '%s\n' ,
Lexem 6 Current token='s' value='_d' Tokenstr |s=f(",s| translated: s =  ( '%s\n' , _d
Lexem 7 Current token=')' value=')' Tokenstr |s=f(",s)| translated: s =  ( '%s\n' , _d )

Line:   15 TokenStr: =|s=f(",s)|= @ValPy: s =  ( '%s\n' , _d )
assignment(0, 7) =|s=f(",s)|= $s = sprintf ( %s\n , $_ )

Generated partial line s
Generated partial line s=
expression(2, 7, 0) =|s=f(",s)|= $s = sprintf ( %s\n , $_ )

function(2, 7) =|s=f(",s)|= $s = sprintf ( %s\n , $_ )

function start=4, end_pos=6, bracketed=1
Generated partial line s='%s\n' % ( 
expression(6, 6, 0) =|s=f(",s)|= $s = sprintf ( %s\n , $_ )

Generated partial line s='%s\n' % ( _d
expression returns 7
Generated partial line s='%s\n' % ( _d)
expression returns 8
  15 | 0 |   |s = '%s\n' % ( _d)                                                                      #PL: $s = sprintf("%s\n", $_);

Tokens: s=f(",s) ValPy: 
Main loop, line=printf(OUT "$_\n");


 === Line 16 Perl source:printf(OUT "$_\n");===

Lexem 0 Current token='i' value='printf' Tokenstr |i| translated: printf
Lexem 1 Current token='(' value='(' Tokenstr |i(| translated: printf (
Lexem 2 Current token='i' value='OUT' Tokenstr |i(i| translated: printf ( OUT
Lexem 3 Current token='"' value='f"{_d}\n"' Tokenstr |i(i"| translated: printf ( OUT f"{_d}\n"
Lexem 4 Current token=')' value=')' Tokenstr |i(i")| translated: printf ( OUT f"{_d}\n" )

Line:   16 TokenStr: =|i(i")|= @ValPy: printf ( OUT f"{_d}\n" )
Generated partial line printf(
print3(0) handle=, k=1, end_pos=4

expression(1, 4, 0) =|i(i")|= printf ( OUT $_\n )

Generated partial line printf((
expression(2, 3, 0) =|i(i")|= printf ( OUT $_\n )

Generated partial line printf(('OUT'
Generated partial line printf(('OUT'f"{_d}\n"
expression returns 4
Generated partial line printf(('OUT'f"{_d}\n")
expression returns 5
Generated partial line printf(('OUT'f"{_d}\n"))
  16 | 0 |   |printf(('OUT' f"{_d}\n"))                                                               #PL: printf(OUT "$_\n");

Tokens: i(i") ValPy: 
Main loop, line=printf(LOG "DC_info ($hour:$min:$sec): $_[0]");


 === Line 17 Perl source:printf(LOG "DC_info ($hour:$min:$sec): $_[0]");===

Lexem 0 Current token='i' value='printf' Tokenstr |i| translated: printf
Lexem 1 Current token='(' value='(' Tokenstr |i(| translated: printf (
Lexem 2 Current token='i' value='LOG' Tokenstr |i(i| translated: printf ( LOG
Lexem 3 Current token='"' value='f"DC_info ({hour}:{min}:{sec}): {_args[0]}"' Tokenstr |i(i"| translated: printf ( LOG f"DC_info ({hour}:{min}:{sec}): {_args[0]}"
Lexem 4 Current token=')' value=')' Tokenstr |i(i")| translated: printf ( LOG f"DC_info ({hour}:{min}:{sec}): {_args[0]}" )

Line:   17 TokenStr: =|i(i")|= @ValPy: printf ( LOG f"DC_info ({hour}:{min}:{sec}): {_args[0]}" )
Generated partial line printf(
print3(0) handle=, k=1, end_pos=4

expression(1, 4, 0) =|i(i")|= printf ( LOG DC_info ($hour:$min:$sec): $_[0] )

Generated partial line printf((
expression(2, 3, 0) =|i(i")|= printf ( LOG DC_info ($hour:$min:$sec): $_[0] )

Generated partial line printf(('LOG'
Generated partial line printf(('LOG'f"DC_info ({hour}:{min}:{sec}): {_args[0]}"
expression returns 4
Generated partial line printf(('LOG'f"DC_info ({hour}:{min}:{sec}): {_args[0]}")
expression returns 5
Generated partial line printf(('LOG'f"DC_info ({hour}:{min}:{sec}): {_args[0]}"))
  17 | 0 |   |printf(('LOG' f"DC_info ({hour}:{min}:{sec}): {_args[0]}"))                             #PL: printf(LOG "DC_info ($hour:$min:$sec): $_[0]");

Tokens: i(i") ValPy: 
  18 | 0 |   |
Main loop, line=if ($action eq "save" && ! -e $name) {


 === Line 19 Perl source:if ($action eq "save" && ! -e $name) {===

Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' value='action' Tokenstr |c(s| translated: if  ( action
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: if  ( action ==
Lexem 4 Current token='"' value=''save'' Tokenstr |c(s>"| translated: if  ( action == 'save'
Lexem 5 Current token='0' value=' and ' Tokenstr |c(s>"0| translated: if  ( action == 'save'  and 
Lexem 6 Current token='!' value='not' Tokenstr |c(s>"0!| translated: if  ( action == 'save'  and  not
Lexem 7 Current token='f' value='os.path.exists' Tokenstr |c(s>"0!f| translated: if  ( action == 'save'  and  not os.path.exists
Lexem 8 Current token='s' value='name' Tokenstr |c(s>"0!fs| translated: if  ( action == 'save'  and  not os.path.exists name
Lexem 9 Current token=')' value=')' Tokenstr |c(s>"0!fs)| translated: if  ( action == 'save'  and  not os.path.exists name )

Line:   19 TokenStr: =|c(s>"0!fs)|= @ValPy: if  ( action == 'save'  and  not os.path.exists name )
control(0) =|c(s>"0!fs)|= if ( $action eq save && ! -e $name )

control-parens removed, begin=0 start=1 =|cs>"0!fs|= if $action eq save && ! -e $name

Generated partial line if 
expression(1, 7, 0) =|cs>"0!fs|= if $action eq save && ! -e $name

Generated partial line if action
Generated partial line if action==
Generated partial line if action=='save'
Generated partial line if action=='save' and 
Generated partial line if action=='save' and not
function(6, 7) =|cs>"0!fs|= if $action eq save && ! -e $name

function start=7, end_pos=7, bracketed=0
Generated partial line if action=='save' and notos.path.exists(name)
expression returns 8
Generated partial line if action=='save' and notos.path.exists(name):
  19 | 0 |   |if action=='save' and not os.path.exists(name):                                         #PL: if ($action eq "save" && ! -e $name) {

Tokens: cs>"0!fs ValPy: 
Main loop, line={


 === Line 19 Perl source:{===


Line:   19 TokenStr: =|{|= @ValPy: {
Main loop, line=system("scp -p $other:$name $name");


 === Line 20 Perl source:system("scp -p $other:$name $name");===

Lexem 0 Current token='f' value='os.system' Tokenstr |f| translated: os.system
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: os.system (
Lexem 2 Current token='"' value='f"scp -p {other}:{name} {name}"' Tokenstr |f("| translated: os.system ( f"scp -p {other}:{name} {name}"
Lexem 3 Current token=')' value=')' Tokenstr |f(")| translated: os.system ( f"scp -p {other}:{name} {name}" )

Line:   20 TokenStr: =|f(")|= @ValPy: os.system ( f"scp -p {other}:{name} {name}" )
function(0, 3) =|f(")|= system ( scp -p $other:$name $name )

function start=2, end_pos=2, bracketed=1
Generated partial line os.system
Generated partial line os.system(
expression(2, 2, 0) =|f(")|= system ( scp -p $other:$name $name )

Generated partial line os.system(f"scp -p {other}:{name} {name}"
expression returns 3
Generated partial line os.system(f"scp -p {other}:{name} {name}")
  20 | 1 |   |    os.system(f"scp -p {other}:{name} {name}")                                          #PL: system("scp -p $other:$name $name");

Tokens: f(") ValPy: 
Main loop, line=} elsif ($action eq "delete" && -e $name &&


 === Line 21 Perl source:} elsif ($action eq "delete" && -e $name &&===


Line:   21 TokenStr: =|}|= @ValPy: }
Main loop, line=elsif ($action eq "delete" && -e $name &&


 === Line 21 Perl source:elsif ($action eq "delete" && -e $name &&===

Lexem 0 Current token='C' value='elif ' Tokenstr |C| translated: elif 
Lexem 1 Current token='(' value='(' Tokenstr |C(| translated: elif  (
Lexem 2 Current token='s' value='action' Tokenstr |C(s| translated: elif  ( action
Lexem 3 Current token='>' value='==' Tokenstr |C(s>| translated: elif  ( action ==
Lexem 4 Current token='"' value=''delete'' Tokenstr |C(s>"| translated: elif  ( action == 'delete'
Lexem 5 Current token='0' value=' and ' Tokenstr |C(s>"0| translated: elif  ( action == 'delete'  and 
Lexem 6 Current token='f' value='os.path.exists' Tokenstr |C(s>"0f| translated: elif  ( action == 'delete'  and  os.path.exists
Lexem 7 Current token='s' value='name' Tokenstr |C(s>"0fs| translated: elif  ( action == 'delete'  and  os.path.exists name
Lexem 8 Current token='0' value=' and ' Tokenstr |C(s>"0fs0| translated: elif  ( action == 'delete'  and  os.path.exists name  and 
Lexem 9 Current token='s' value='name' Tokenstr |C(s>"0fs0s| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name
Lexem 10 Current token='~' value='!~' Tokenstr |C(s>"0fs0s~| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~
Lexem 11 Current token='q' value='re.search(r'/\.\./',' Tokenstr |C(s>"0fs0s~q| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',
Lexem 12 Current token='0' value=' and ' Tokenstr |C(s>"0fs0s~q0| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',  and 
Lexem 13 Current token='(' value='(' Tokenstr |C(s>"0fs0s~q0(| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',  and  (
Lexem 14 Current token='s' value='name' Tokenstr |C(s>"0fs0s~q0(s| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',  and  ( name
Lexem 15 Current token='~' value='' Tokenstr |C(s>"0fs0s~q0(s~| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',  and  ( name 
Lexem 16 Current token='q' value='re.search(r'cmtweb.users.*saved',' Tokenstr |C(s>"0fs0s~q0(s~q| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',  and  ( name  re.search(r'cmtweb.users.*saved',
Lexem 17 Current token='0' value=' or ' Tokenstr |C(s>"0fs0s~q0(s~q0| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',  and  ( name  re.search(r'cmtweb.users.*saved',  or 
Lexem 18 Current token='s' value='name' Tokenstr |C(s>"0fs0s~q0(s~q0s| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',  and  ( name  re.search(r'cmtweb.users.*saved',  or  name
Lexem 19 Current token='~' value='' Tokenstr |C(s>"0fs0s~q0(s~q0s~| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',  and  ( name  re.search(r'cmtweb.users.*saved',  or  name 
Lexem 20 Current token='q' value='re.search(r'cmtweb.fareports',' Tokenstr |C(s>"0fs0s~q0(s~q0s~q| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',  and  ( name  re.search(r'cmtweb.users.*saved',  or  name  re.search(r'cmtweb.fareports',
Lexem 21 Current token='0' value=' or ' Tokenstr |C(s>"0fs0s~q0(s~q0s~q0| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',  and  ( name  re.search(r'cmtweb.users.*saved',  or  name  re.search(r'cmtweb.fareports',  or 
Lexem 22 Current token='s' value='name' Tokenstr |C(s>"0fs0s~q0(s~q0s~q0s| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',  and  ( name  re.search(r'cmtweb.users.*saved',  or  name  re.search(r'cmtweb.fareports',  or  name
Lexem 23 Current token='~' value='' Tokenstr |C(s>"0fs0s~q0(s~q0s~q0s~| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',  and  ( name  re.search(r'cmtweb.users.*saved',  or  name  re.search(r'cmtweb.fareports',  or  name 
Lexem 24 Current token='q' value='re.search(r'cmtweb.hotspotreports',' Tokenstr |C(s>"0fs0s~q0(s~q0s~q0s~q| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',  and  ( name  re.search(r'cmtweb.users.*saved',  or  name  re.search(r'cmtweb.fareports',  or  name  re.search(r'cmtweb.hotspotreports',
Lexem 25 Current token=')' value=')' Tokenstr |C(s>"0fs0s~q0(s~q0s~q0s~q)| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',  and  ( name  re.search(r'cmtweb.users.*saved',  or  name  re.search(r'cmtweb.fareports',  or  name  re.search(r'cmtweb.hotspotreports', )
Lexem 26 Current token=')' value=')' Tokenstr |C(s>"0fs0s~q0(s~q0s~q0s~q))| translated: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',  and  ( name  re.search(r'cmtweb.users.*saved',  or  name  re.search(r'cmtweb.fareports',  or  name  re.search(r'cmtweb.hotspotreports', ) )

Line:   25 TokenStr: =|C(s>"0fs0s~q0(s~q0s~q0s~q))|= @ValPy: elif  ( action == 'delete'  and  os.path.exists name  and  name !~ re.search(r'/\.\./',  and  ( name  re.search(r'cmtweb.users.*saved',  or  name  re.search(r'cmtweb.fareports',  or  name  re.search(r'cmtweb.hotspotreports', ) )
Generated partial line elif 
expression(2, 25, 0) =|C(s>"0fs0s~q0(s~q0s~q0s~q))|= elsif ( $action eq delete && -e $name && $name !~ /\.\./ && ( $name =~ cmtweb.users.*saved || $name =~ cmtweb.fareports || $name =~ cmtweb.hotspotreports ) )

Generated partial line elif action
Generated partial line elif action==
Generated partial line elif action=='delete'
Generated partial line elif action=='delete' and 
function(6, 8) =|C(s>"0fs0s~q0(s~q0s~q0s~q))|= elsif ( $action eq delete && -e $name && $name !~ /\.\./ && ( $name =~ cmtweb.users.*saved || $name =~ cmtweb.fareports || $name =~ cmtweb.hotspotreports ) )

function start=7, end_pos=7, bracketed=0
Generated partial line elif action=='delete' and os.path.exists(name)
Generated partial line elif action=='delete' and os.path.exists(name) and 
Generated partial line elif action=='delete' and os.path.exists(name) and re.search(r'/\.\./',
expression(9, 9, 0) =|C(s>"0fs0s~q0(s~q0s~q0s~q))|= elsif ( $action eq delete && -e $name && $name !~ /\.\./ && ( $name =~ cmtweb.users.*saved || $name =~ cmtweb.fareports || $name =~ cmtweb.hotspotreports ) )

Generated partial line elif action=='delete' and os.path.exists(name) and re.search(r'/\.\./',name
expression returns 10
Generated partial line elif action=='delete' and os.path.exists(name) and re.search(r'/\.\./',name)
Generated partial line elif action=='delete' and os.path.exists(name) and re.search(r'/\.\./',name) and 
Generated partial line elif action=='delete' and os.path.exists(name) and re.search(r'/\.\./',name) and (
expression(14, 24, 0) =|C(s>"0fs0s~q0(s~q0s~q0s~q))|= elsif ( $action eq delete && -e $name && $name !~ /\.\./ && ( $name =~ cmtweb.users.*saved || $name =~ cmtweb.fareports || $name =~ cmtweb.hotspotreports ) )

Generated partial line elif action=='delete' and os.path.exists(name) and re.search(r'/\.\./',name) and (re.search(r'cmtweb.users.*saved',
expression(14, 14, 0) =|C(s>"0fs0s~q0(s~q0s~q0s~q))|= elsif ( $action eq delete && -e $name && $name !~ /\.\./ && ( $name =~ cmtweb.users.*saved || $name =~ cmtweb.fareports || $name =~ cmtweb.hotspotreports ) )

Generated partial line elif action=='delete' and os.path.exists(name) and re.search(r'/\.\./',name) and (re.search(r'cmtweb.users.*saved',name
expression returns 15
Generated partial line elif action=='delete' and os.path.exists(name) and re.search(r'/\.\./',name) and (re.search(r'cmtweb.users.*saved',name)
Generated partial line elif action=='delete' and os.path.exists(name) and re.search(r'/\.\./',name) and (re.search(r'cmtweb.users.*saved',name) or 
Generated partial line elif action=='delete' and os.path.exists(name) and re.search(r'/\.\./',name) and (re.search(r'cmtweb.users.*saved',name) or re.search(r'cmtweb.fareports',
expression(18, 18, 0) =|C(s>"0fs0s~q0(s~q0s~q0s~q))|= elsif ( $action eq delete && -e $name && $name !~ /\.\./ && ( $name =~ cmtweb.users.*saved || $name =~ cmtweb.fareports || $name =~ cmtweb.hotspotreports ) )

Generated partial line elif action=='delete' and os.path.exists(name) and re.search(r'/\.\./',name) and (re.search(r'cmtweb.users.*saved',name) or re.search(r'cmtweb.fareports',name
expression returns 19
Generated partial line elif action=='delete' and os.path.exists(name) and re.search(r'/\.\./',name) and (re.search(r'cmtweb.users.*saved',name) or re.search(r'cmtweb.fareports',name)
Generated partial line elif action=='delete' and os.path.exists(name) and re.search(r'/\.\./',name) and (re.search(r'cmtweb.users.*saved',name) or re.search(r'cmtweb.fareports',name) or 
Generated partial line elif action=='delete' and os.path.exists(name) and re.search(r'/\.\./',name) and (re.search(r'cmtweb.users.*saved',name) or re.search(r'cmtweb.fareports',name) or re.search(r'cmtweb.hotspotreports',
expression(22, 22, 0) =|C(s>"0fs0s~q0(s~q0s~q0s~q))|= elsif ( $action eq delete && -e $name && $name !~ /\.\./ && ( $name =~ cmtweb.users.*saved || $name =~ cmtweb.fareports || $name =~ cmtweb.hotspotreports ) )

Generated partial line elif action=='delete' and os.path.exists(name) and re.search(r'/\.\./',name) and (re.search(r'cmtweb.users.*saved',name) or re.search(r'cmtweb.fareports',name) or re.search(r'cmtweb.hotspotreports',name
expression returns 23
Generated partial line elif action=='delete' and os.path.exists(name) and re.search(r'/\.\./',name) and (re.search(r'cmtweb.users.*saved',name) or re.search(r'cmtweb.fareports',name) or re.search(r'cmtweb.hotspotreports',name)
expression returns 25
Generated partial line elif action=='delete' and os.path.exists(name) and re.search(r'/\.\./',name) and (re.search(r'cmtweb.users.*saved',name) or re.search(r'cmtweb.fareports',name) or re.search(r'cmtweb.hotspotreports',name))
expression returns 26
Generated partial line elif action=='delete' and os.path.exists(name) and re.search(r'/\.\./',name) and (re.search(r'cmtweb.users.*saved',name) or re.search(r'cmtweb.fareports',name) or re.search(r'cmtweb.hotspotreports',name)):
  25 | 0 |   |elif action=='delete' and os.path.exists(name) and re.search(r'/\.\./',name) and (re.search(r'cmtweb.users.*saved',name) or re.search(r'cmtweb.fareports',name) or re.search(r'cmtweb.hotspotreports',name)):
                                                                                                      #PL: elsif ($action eq "delete" && -e $name &&
                                                                                                      #PL: $name !~ /\/\.\.\// &&
                                                                                                      #PL: ($name =~ /cmtweb.users.*saved/ ||
                                                                                                      #PL: $name =~ /cmtweb.fareports/ ||
                                                                                                      #PL: $name =~ /cmtweb.hotspotreports/)) {

Tokens: C(s>"0fs0s~q0(s~q0s~q0s~q)) ValPy: 
Main loop, line={


 === Line 25 Perl source:{===


Line:   25 TokenStr: =|{|= @ValPy: {
Main loop, line=system("rm $name");


 === Line 26 Perl source:system("rm $name");===

Lexem 0 Current token='f' value='os.system' Tokenstr |f| translated: os.system
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: os.system (
Lexem 2 Current token='"' value='f"rm {name}"' Tokenstr |f("| translated: os.system ( f"rm {name}"
Lexem 3 Current token=')' value=')' Tokenstr |f(")| translated: os.system ( f"rm {name}" )

Line:   26 TokenStr: =|f(")|= @ValPy: os.system ( f"rm {name}" )
function(0, 3) =|f(")|= system ( rm $name )

function start=2, end_pos=2, bracketed=1
Generated partial line os.system
Generated partial line os.system(
expression(2, 2, 0) =|f(")|= system ( rm $name )

Generated partial line os.system(f"rm {name}"
expression returns 3
Generated partial line os.system(f"rm {name}")
  26 | 1 |   |    os.system(f"rm {name}")                                                             #PL: system("rm $name");

Tokens: f(") ValPy: 
Main loop, line=}


 === Line 27 Perl source:}===


Line:   27 TokenStr: =|}|= @ValPy: }
  28 | 0 |   |
Main loop, line=push @{$static{$r}{$ip}},$i;


 === Line 29 Perl source:push @{$static{$r}{$ip}},$i;===

Lexem 0 Current token='f' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='@' value='@' Tokenstr |f@| translated: .extend( @
Lexem 2 Current token='(' value='[' Tokenstr |f@(| translated: .extend( @ [
Lexem 3 Current token='s' value='static' Tokenstr |f@(s| translated: .extend( @ [ static
Lexem 4 Current token='(' value='[' Tokenstr |f@(s(| translated: .extend( @ [ static [
Lexem 5 Current token='s' value='r' Tokenstr |f@(s(s| translated: .extend( @ [ static [ r
Lexem 6 Current token=')' value=']' Tokenstr |f@(s(s)| translated: .extend( @ [ static [ r ]
Lexem 7 Current token='(' value='[' Tokenstr |f@(s(s)(| translated: .extend( @ [ static [ r ] [
Lexem 8 Current token='s' value='ip' Tokenstr |f@(s(s)(s| translated: .extend( @ [ static [ r ] [ ip
Lexem 9 Current token=')' value=']' Tokenstr |f@(s(s)(s)| translated: .extend( @ [ static [ r ] [ ip ]
Lexem 10 Current token=')' value=']' Tokenstr |f@(s(s)(s))| translated: .extend( @ [ static [ r ] [ ip ] ]
Lexem 11 Current token=',' value=',' Tokenstr |f@(s(s)(s)),| translated: .extend( @ [ static [ r ] [ ip ] ] ,
Lexem 12 Current token='s' value='i' Tokenstr |f@(s(s)(s)),s| translated: .extend( @ [ static [ r ] [ ip ] ] , i

Line:   29 TokenStr: =|f@(s(s)(s)),s|= @ValPy: .extend( @ [ static [ r ] [ ip ] ] , i
function(0, 9) =|fs(s)(s),s|= push $static { $r } { $ip } , $i

function start=1, end_pos=9, bracketed=0
push s

Generated partial line static.append(
expression(3, 9, 0) =|fs(s)(s),s|= push $static { $r } { $ip } , $i

Generated partial line static.append(r
Generated partial line static.append(r]
Generated partial line static.append(r].get(
expression(6, 6, 0) =|fs(s)(s),s|= push $static { $r } { $ip } , $i

Generated partial line static.append(r].get(ip
expression returns 7
Generated partial line static.append(r].get(ip)
Generated partial line static.append(r].get(ip),
Generated partial line static.append(r].get(ip),i
expression returns 10
Generated partial line static.append(r].get(ip),i)
  29 | 0 |   |static.append(r].get(ip), i)                                                            #PL: push @{$static{$r}{$ip}},$i;

Tokens: fs(s)(s),s ValPy: 
Main loop, line=push @{$vrf2rt{$r}{$vrf}},$rt;


 === Line 30 Perl source:push @{$vrf2rt{$r}{$vrf}},$rt;===

Lexem 0 Current token='f' value='.extend(' Tokenstr |f| translated: .extend(
Lexem 1 Current token='@' value='@' Tokenstr |f@| translated: .extend( @
Lexem 2 Current token='(' value='[' Tokenstr |f@(| translated: .extend( @ [
Lexem 3 Current token='s' value='vrf2rt' Tokenstr |f@(s| translated: .extend( @ [ vrf2rt
Lexem 4 Current token='(' value='[' Tokenstr |f@(s(| translated: .extend( @ [ vrf2rt [
Lexem 5 Current token='s' value='r' Tokenstr |f@(s(s| translated: .extend( @ [ vrf2rt [ r
Lexem 6 Current token=')' value=']' Tokenstr |f@(s(s)| translated: .extend( @ [ vrf2rt [ r ]
Lexem 7 Current token='(' value='[' Tokenstr |f@(s(s)(| translated: .extend( @ [ vrf2rt [ r ] [
Lexem 8 Current token='s' value='vrf' Tokenstr |f@(s(s)(s| translated: .extend( @ [ vrf2rt [ r ] [ vrf
Lexem 9 Current token=')' value=']' Tokenstr |f@(s(s)(s)| translated: .extend( @ [ vrf2rt [ r ] [ vrf ]
Lexem 10 Current token=')' value=']' Tokenstr |f@(s(s)(s))| translated: .extend( @ [ vrf2rt [ r ] [ vrf ] ]
Lexem 11 Current token=',' value=',' Tokenstr |f@(s(s)(s)),| translated: .extend( @ [ vrf2rt [ r ] [ vrf ] ] ,
Lexem 12 Current token='s' value='rt' Tokenstr |f@(s(s)(s)),s| translated: .extend( @ [ vrf2rt [ r ] [ vrf ] ] , rt

Line:   30 TokenStr: =|f@(s(s)(s)),s|= @ValPy: .extend( @ [ vrf2rt [ r ] [ vrf ] ] , rt
function(0, 9) =|fs(s)(s),s|= push $vrf2rt { $r } { $vrf } , $rt

function start=1, end_pos=9, bracketed=0
push s

Generated partial line vrf2rt.append(
expression(3, 9, 0) =|fs(s)(s),s|= push $vrf2rt { $r } { $vrf } , $rt

Generated partial line vrf2rt.append(r
Generated partial line vrf2rt.append(r]
Generated partial line vrf2rt.append(r].get(
expression(6, 6, 0) =|fs(s)(s),s|= push $vrf2rt { $r } { $vrf } , $rt

Generated partial line vrf2rt.append(r].get(vrf
expression returns 7
Generated partial line vrf2rt.append(r].get(vrf)
Generated partial line vrf2rt.append(r].get(vrf),
Generated partial line vrf2rt.append(r].get(vrf),rt
expression returns 10
Generated partial line vrf2rt.append(r].get(vrf),rt)
  30 | 0 |   |vrf2rt.append(r].get(vrf), rt)                                                          #PL: push @{$vrf2rt{$r}{$vrf}},$rt;

Tokens: fs(s)(s),s ValPy: 
  31 | 0 |   |
Main loop, line=&DCinfo("Running: $0 @ARGV\n");


 === Line 32 Perl source:&DCinfo("Running: $0 @ARGV\n");===

Lexem 0 Current token='i' value='DCinfo' Tokenstr |i| translated: DCinfo
Lexem 1 Current token='(' value='(' Tokenstr |i(| translated: DCinfo (
Lexem 2 Current token='"' value='f"Running: {__file__} {LIST_SEPARATOR.join(sys.argv[1:])}\n"' Tokenstr |i("| translated: DCinfo ( f"Running: {__file__} {LIST_SEPARATOR.join(sys.argv[1:])}\n"
Lexem 3 Current token=')' value=')' Tokenstr |i(")| translated: DCinfo ( f"Running: {__file__} {LIST_SEPARATOR.join(sys.argv[1:])}\n" )

Line:   32 TokenStr: =|i(")|= @ValPy: DCinfo ( f"Running: {__file__} {LIST_SEPARATOR.join(sys.argv[1:])}\n" )
Generated partial line DCinfo
Generated partial line DCinfo([
expression(2, 2, -1) =|i(")|= DCinfo ( Running: $0 @ARGV\n )

Generated partial line DCinfo([f"Running: {__file__} {LIST_SEPARATOR.join(sys.argv[1:])}\n"
expression returns 3
Generated partial line DCinfo([f"Running: {__file__} {LIST_SEPARATOR.join(sys.argv[1:])}\n"])
  32 | 0 |   |DCinfo([f"Running: {__file__} {LIST_SEPARATOR.join(sys.argv[1:])}\n"])                  #PL: &DCinfo("Running: $0 @ARGV\n");

Tokens: i(") ValPy: 
  33 | 0 |   |
Main loop, line=next if not exists $bundles{$cttmembers{$key}};


 === Line 34 Perl source:next if not exists $bundles{$cttmembers{$key}};===

Lexem 0 Current token='k' value='continue ' Tokenstr |k| translated: continue 
Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='!' value='not' Tokenstr |c!| translated: if  not
Lexem 2 Current token='f' value='in' Tokenstr |c!f| translated: if  not in
Lexem 3 Current token='s' value='bundles' Tokenstr |c!fs| translated: if  not in bundles
Lexem 4 Current token='(' value='[' Tokenstr |c!fs(| translated: if  not in bundles [
Lexem 5 Current token='s' value='cttmembers' Tokenstr |c!fs(s| translated: if  not in bundles [ cttmembers
Lexem 6 Current token='(' value='[' Tokenstr |c!fs(s(| translated: if  not in bundles [ cttmembers [
Lexem 7 Current token='s' value='key' Tokenstr |c!fs(s(s| translated: if  not in bundles [ cttmembers [ key
Lexem 8 Current token=')' value=']' Tokenstr |c!fs(s(s)| translated: if  not in bundles [ cttmembers [ key ]
Lexem 9 Current token=')' value=']' Tokenstr |c!fs(s(s))| translated: if  not in bundles [ cttmembers [ key ] ]

Line:   34 TokenStr: =|c!fs(s(s))|= @ValPy: if  not in bundles [ cttmembers [ key ] ]
control(0) =|c(!fs(s(s)))|= if ( not exists $bundles { $cttmembers { $key } } )

control-parens removed, begin=0 start=1 =|c!fs(s(s))|= if not exists $bundles { $cttmembers { $key } }

Generated partial line if 
expression(1, 9, 0) =|c!fs(s(s))|= if not exists $bundles { $cttmembers { $key } }

Generated partial line if not
function(2, 9) =|c!fs(s(s))|= if not exists $bundles { $cttmembers { $key } }

function start=3, end_pos=9, bracketed=0
exists k=5, length(ValPerl)=9, end_pos=9, limit=9

expression(4, 9, 1) =|c!fs(s(s))|= if not exists $bundles { $cttmembers { $key } }

Generated partial line if not.get(
expression(5, 8, 0) =|c!fs(s(s))|= if not exists $bundles { $cttmembers { $key } }

Generated partial line if not.get(cttmembers
Generated partial line if not.get(cttmembers.get(
expression(7, 7, 0) =|c!fs(s(s))|= if not exists $bundles { $cttmembers { $key } }

Generated partial line if not.get(cttmembers.get(key
expression returns 8
Generated partial line if not.get(cttmembers.get(key)
expression returns 9
Generated partial line if not.get(cttmembers.get(key))
expression returns 10
expression returns 10
Generated partial line if not.get(cttmembers.get(key)):
  34 | 0 |   |if not .get(cttmembers.get(key)):                                                       #PL: next if not exists $bundles{$cttmembers{$key}};

Tokens: c!fs(s(s)) ValPy: 
Main loop, line=next if not exists $bundles{$cttmembers{$key}};
Main loop, line=next if not exists $bundles{$cttmembers{$key}};
Generated partial line continue 
  34 | 1 |   |    continue                                                                            #PL: next if not exists $bundles{$cttmembers{$key}};

Tokens: k ValPy: 
Main loop, line=next if not exists $bundles{$cttmembers{$key}};
Main loop, line=next if exists $bidsinterface{$node}{$name};


 === Line 35 Perl source:next if exists $bidsinterface{$node}{$name};===

Lexem 0 Current token='k' value='continue ' Tokenstr |k| translated: continue 
Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='f' value='in' Tokenstr |cf| translated: if  in
Lexem 2 Current token='s' value='bidsinterface' Tokenstr |cfs| translated: if  in bidsinterface
Lexem 3 Current token='(' value='[' Tokenstr |cfs(| translated: if  in bidsinterface [
Lexem 4 Current token='s' value='node' Tokenstr |cfs(s| translated: if  in bidsinterface [ node
Lexem 5 Current token=')' value=']' Tokenstr |cfs(s)| translated: if  in bidsinterface [ node ]
Lexem 6 Current token='(' value='[' Tokenstr |cfs(s)(| translated: if  in bidsinterface [ node ] [
Lexem 7 Current token='s' value='name' Tokenstr |cfs(s)(s| translated: if  in bidsinterface [ node ] [ name
Lexem 8 Current token=')' value=']' Tokenstr |cfs(s)(s)| translated: if  in bidsinterface [ node ] [ name ]

Line:   35 TokenStr: =|cfs(s)(s)|= @ValPy: if  in bidsinterface [ node ] [ name ]
control(0) =|c(fs(s)(s))|= if ( exists $bidsinterface { $node } { $name } )

control-parens removed, begin=0 start=1 =|cfs(s)(s)|= if exists $bidsinterface { $node } { $name }

Generated partial line if 
expression(1, 8, 0) =|cfs(s)(s)|= if exists $bidsinterface { $node } { $name }

function(1, 8) =|cfs(s)(s)|= if exists $bidsinterface { $node } { $name }

function start=2, end_pos=8, bracketed=0
exists k=4, length(ValPerl)=8, end_pos=8, limit=8

expression(3, 8, 1) =|cfs(s)(s)|= if exists $bidsinterface { $node } { $name }

Generated partial line if .get(
expression(4, 4, 0) =|cfs(s)(s)|= if exists $bidsinterface { $node } { $name }

Generated partial line if .get(node
expression returns 5
Generated partial line if .get(node)
Generated partial line if .get(node).get(
expression(7, 7, 0) =|cfs(s)(s)|= if exists $bidsinterface { $node } { $name }

Generated partial line if .get(node).get(name
expression returns 8
Generated partial line if .get(node).get(name)
expression returns 9
expression returns 9
Generated partial line if .get(node).get(name):
  35 | 0 |   |if .get(node).get(name):                                                                #PL: next if exists $bidsinterface{$node}{$name};

Tokens: cfs(s)(s) ValPy: 
Main loop, line=next if exists $bidsinterface{$node}{$name};
Main loop, line=next if exists $bidsinterface{$node}{$name};
Generated partial line continue 
  35 | 1 |   |    continue                                                                            #PL: next if exists $bidsinterface{$node}{$name};

Tokens: k ValPy: 
Main loop, line=next if exists $bidsinterface{$node}{$name};
  36 | 0 |   |
Main loop, line=next unless exists $estimated_dmd{$d} && exists $gravity{$p} ||


 === Line 37 Perl source:next unless exists $estimated_dmd{$d} && exists $gravity{$p} ||===

Lexem 0 Current token='k' value='continue ' Tokenstr |k| translated: continue 
Lexem 0 Current token='c' value='if not ' Tokenstr |c| translated: if not 
Lexem 1 Current token='f' value='in' Tokenstr |cf| translated: if not  in
Lexem 2 Current token='s' value='estimated_dmd' Tokenstr |cfs| translated: if not  in estimated_dmd
Lexem 3 Current token='(' value='[' Tokenstr |cfs(| translated: if not  in estimated_dmd [
Lexem 4 Current token='s' value='d' Tokenstr |cfs(s| translated: if not  in estimated_dmd [ d
Lexem 5 Current token=')' value=']' Tokenstr |cfs(s)| translated: if not  in estimated_dmd [ d ]
Lexem 6 Current token='0' value=' and ' Tokenstr |cfs(s)0| translated: if not  in estimated_dmd [ d ]  and 
Lexem 7 Current token='f' value='in' Tokenstr |cfs(s)0f| translated: if not  in estimated_dmd [ d ]  and  in
Lexem 8 Current token='s' value='gravity' Tokenstr |cfs(s)0fs| translated: if not  in estimated_dmd [ d ]  and  in gravity
Lexem 9 Current token='(' value='[' Tokenstr |cfs(s)0fs(| translated: if not  in estimated_dmd [ d ]  and  in gravity [
Lexem 10 Current token='s' value='p' Tokenstr |cfs(s)0fs(s| translated: if not  in estimated_dmd [ d ]  and  in gravity [ p
Lexem 11 Current token=')' value=']' Tokenstr |cfs(s)0fs(s)| translated: if not  in estimated_dmd [ d ]  and  in gravity [ p ]
Lexem 12 Current token='0' value=' or ' Tokenstr |cfs(s)0fs(s)0| translated: if not  in estimated_dmd [ d ]  and  in gravity [ p ]  or 
Lexem 13 Current token='f' value='in' Tokenstr |cfs(s)0fs(s)0f| translated: if not  in estimated_dmd [ d ]  and  in gravity [ p ]  or  in
Lexem 14 Current token='s' value='estimated_fdmd' Tokenstr |cfs(s)0fs(s)0fs| translated: if not  in estimated_dmd [ d ]  and  in gravity [ p ]  or  in estimated_fdmd
Lexem 15 Current token='(' value='[' Tokenstr |cfs(s)0fs(s)0fs(| translated: if not  in estimated_dmd [ d ]  and  in gravity [ p ]  or  in estimated_fdmd [
Lexem 16 Current token='s' value='d' Tokenstr |cfs(s)0fs(s)0fs(s| translated: if not  in estimated_dmd [ d ]  and  in gravity [ p ]  or  in estimated_fdmd [ d
Lexem 17 Current token=')' value=']' Tokenstr |cfs(s)0fs(s)0fs(s)| translated: if not  in estimated_dmd [ d ]  and  in gravity [ p ]  or  in estimated_fdmd [ d ]
Lexem 18 Current token='0' value=' and ' Tokenstr |cfs(s)0fs(s)0fs(s)0| translated: if not  in estimated_dmd [ d ]  and  in gravity [ p ]  or  in estimated_fdmd [ d ]  and 
Lexem 19 Current token='f' value='in' Tokenstr |cfs(s)0fs(s)0fs(s)0f| translated: if not  in estimated_dmd [ d ]  and  in gravity [ p ]  or  in estimated_fdmd [ d ]  and  in
Lexem 20 Current token='s' value='nfdmd' Tokenstr |cfs(s)0fs(s)0fs(s)0fs| translated: if not  in estimated_dmd [ d ]  and  in gravity [ p ]  or  in estimated_fdmd [ d ]  and  in nfdmd
Lexem 21 Current token='(' value='[' Tokenstr |cfs(s)0fs(s)0fs(s)0fs(| translated: if not  in estimated_dmd [ d ]  and  in gravity [ p ]  or  in estimated_fdmd [ d ]  and  in nfdmd [
Lexem 22 Current token='s' value='p' Tokenstr |cfs(s)0fs(s)0fs(s)0fs(s| translated: if not  in estimated_dmd [ d ]  and  in gravity [ p ]  or  in estimated_fdmd [ d ]  and  in nfdmd [ p
Lexem 23 Current token=')' value=']' Tokenstr |cfs(s)0fs(s)0fs(s)0fs(s)| translated: if not  in estimated_dmd [ d ]  and  in gravity [ p ]  or  in estimated_fdmd [ d ]  and  in nfdmd [ p ]

Line:   38 TokenStr: =|cfs(s)0fs(s)0fs(s)0fs(s)|= @ValPy: if not  in estimated_dmd [ d ]  and  in gravity [ p ]  or  in estimated_fdmd [ d ]  and  in nfdmd [ p ]
control(0) =|c(fs(s)0fs(s)0fs(s)0fs(s))|= unless ( exists $estimated_dmd { $d } && exists $gravity { $p } || exists $estimated_fdmd { $d } && exists $nfdmd { $p } )

control-parens removed, begin=0 start=1 =|cfs(s)0fs(s)0fs(s)0fs(s)|= unless exists $estimated_dmd { $d } && exists $gravity { $p } || exists $estimated_fdmd { $d } && exists $nfdmd { $p }

Generated partial line if not 
Generated partial line if not (
expression(1, 23, 0) =|cfs(s)0fs(s)0fs(s)0fs(s)|= unless exists $estimated_dmd { $d } && exists $gravity { $p } || exists $estimated_fdmd { $d } && exists $nfdmd { $p }

function(1, 6) =|cfs(s)0fs(s)0fs(s)0fs(s)|= unless exists $estimated_dmd { $d } && exists $gravity { $p } || exists $estimated_fdmd { $d } && exists $nfdmd { $p }

function start=2, end_pos=5, bracketed=0
exists k=4, length(ValPerl)=23, end_pos=5, limit=5

Generated partial line if not (d in estimated_dmd
Generated partial line if not (d in estimated_dmd and 
function(7, 12) =|cfs(s)0fs(s)0fs(s)0fs(s)|= unless exists $estimated_dmd { $d } && exists $gravity { $p } || exists $estimated_fdmd { $d } && exists $nfdmd { $p }

function start=8, end_pos=11, bracketed=0
exists k=10, length(ValPerl)=23, end_pos=11, limit=11

Generated partial line if not (d in estimated_dmd and p in gravity
Generated partial line if not (d in estimated_dmd and p in gravity or 
function(13, 18) =|cfs(s)0fs(s)0fs(s)0fs(s)|= unless exists $estimated_dmd { $d } && exists $gravity { $p } || exists $estimated_fdmd { $d } && exists $nfdmd { $p }

function start=14, end_pos=17, bracketed=0
exists k=16, length(ValPerl)=23, end_pos=17, limit=17

Generated partial line if not (d in estimated_dmd and p in gravity or d in estimated_fdmd
Generated partial line if not (d in estimated_dmd and p in gravity or d in estimated_fdmd and 
function(19, 23) =|cfs(s)0fs(s)0fs(s)0fs(s)|= unless exists $estimated_dmd { $d } && exists $gravity { $p } || exists $estimated_fdmd { $d } && exists $nfdmd { $p }

function start=20, end_pos=23, bracketed=0
exists k=22, length(ValPerl)=23, end_pos=23, limit=23

Generated partial line if not (d in estimated_dmd and p in gravity or d in estimated_fdmd and p in nfdmd
expression returns 24
Generated partial line if not (d in estimated_dmd and p in gravity or d in estimated_fdmd and p in nfdmd)
Generated partial line if not (d in estimated_dmd and p in gravity or d in estimated_fdmd and p in nfdmd):
  38 | 0 |   |if not (d in estimated_dmd and p in gravity or d in estimated_fdmd and p in nfdmd):     #PL: next unless exists $estimated_dmd{$d} && exists $gravity{$p} ||
                                                                                                      #PL: exists $estimated_fdmd{$d} && exists $nfdmd{$p};

Tokens: cfs(s)0fs(s)0fs(s)0fs(s) ValPy: 
Main loop, line=exists $estimated_fdmd{$d} && exists $nfdmd{$p};
Main loop, line=exists $estimated_fdmd{$d} && exists $nfdmd{$p};
Generated partial line continue 
  38 | 1 |   |    continue                                                                            #PL: next unless exists $estimated_dmd{$d} && exists $gravity{$p} ||
                                                                                                      #PL: exists $estimated_fdmd{$d} && exists $nfdmd{$p};

Tokens: k ValPy: 
Main loop, line=exists $estimated_fdmd{$d} && exists $nfdmd{$p};
  39 | 0 |   |
Main loop, line=($commented_timestamp = $PROPERTIES_ln ) if ( $. == 1 ) ;


 === Line 40 Perl source:($commented_timestamp = $PROPERTIES_ln ) if ( $. == 1 ) ;===

Lexem 0 Current token='(' value='(' Tokenstr |(| translated: (
Lexem 1 Current token='s' value='commented_timestamp' Tokenstr |(s| translated: ( commented_timestamp
Lexem 2 Current token='=' value='=' Tokenstr |(s=| translated: ( commented_timestamp =
Lexem 3 Current token='s' value='PROPERTIES_ln' Tokenstr |(s=s| translated: ( commented_timestamp = PROPERTIES_ln
Lexem 4 Current token=')' value=')' Tokenstr |(s=s)| translated: ( commented_timestamp = PROPERTIES_ln )
Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' value='fileinput.lineno()' Tokenstr |c(s| translated: if  ( fileinput.lineno()
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: if  ( fileinput.lineno() ==
Lexem 4 Current token='d' value='1' Tokenstr |c(s>d| translated: if  ( fileinput.lineno() == 1
Lexem 5 Current token=')' value=')' Tokenstr |c(s>d)| translated: if  ( fileinput.lineno() == 1 )

Line:   40 TokenStr: =|c(s>d)|= @ValPy: if  ( fileinput.lineno() == 1 )
control(0) =|c(s>d)|= if ( $ == 1 )

control-parens removed, begin=0 start=1 =|cs>d|= if $ == 1

Generated partial line if 
expression(1, 3, 0) =|cs>d|= if $ == 1

Generated partial line if fileinput.lineno()
Generated partial line if fileinput.lineno()==
Generated partial line if fileinput.lineno()==1
expression returns 4
Generated partial line if fileinput.lineno()==1:
  40 | 0 |   |if fileinput.lineno()==1:                                                               #PL: ($commented_timestamp = $PROPERTIES_ln ) if ( $. == 1 ) ;

Tokens: cs>d ValPy: 
Main loop, line=($commented_timestamp = $PROPERTIES_ln ) if ( $. == 1 ) ;
Main loop, line=($commented_timestamp = $PROPERTIES_ln ) if ( $. == 1 ) ;
assignment(1, 3) =|(s=s)|= ( $commented_timestamp = $PROPERTIES_ln )

Generated partial line commented_timestamp
Generated partial line commented_timestamp=
assign, ValClass[limit] = s, ValPy=PROPERTIES_ln, ValPerl=$PROPERTIES_ln

Generated partial line commented_timestamp=PROPERTIES_ln
  40 | 1 |   |    commented_timestamp = PROPERTIES_ln                                                 #PL: ($commented_timestamp = $PROPERTIES_ln ) if ( $. == 1 ) ;

Tokens: (s=s) ValPy: 
Main loop, line=($commented_timestamp = $PROPERTIES_ln ) if ( $. == 1 ) ;
Main loop, line=($retVal = 1) if ($status == 0); # if successful


 === Line 41 Perl source:($retVal = 1) if ($status == 0); # if successful===

Lexem 0 Current token='(' value='(' Tokenstr |(| translated: (
Lexem 1 Current token='s' value='retVal' Tokenstr |(s| translated: ( retVal
Lexem 2 Current token='=' value='=' Tokenstr |(s=| translated: ( retVal =
Lexem 3 Current token='d' value='1' Tokenstr |(s=d| translated: ( retVal = 1
Lexem 4 Current token=')' value=')' Tokenstr |(s=d)| translated: ( retVal = 1 )
Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' value='status' Tokenstr |c(s| translated: if  ( status
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: if  ( status ==
Lexem 4 Current token='d' value='0' Tokenstr |c(s>d| translated: if  ( status == 0
Lexem 5 Current token=')' value=')' Tokenstr |c(s>d)| translated: if  ( status == 0 )

Line:   41 TokenStr: =|c(s>d)|= @ValPy: if  ( status == 0 )
control(0) =|c(s>d)|= if ( $status == 0 )

control-parens removed, begin=0 start=1 =|cs>d|= if $status == 0

Generated partial line if 
expression(1, 3, 0) =|cs>d|= if $status == 0

Generated partial line if status
Generated partial line if status==
Generated partial line if status==0
expression returns 4
Generated partial line if status==0:
  41 | 0 |   |if status==0: # if successful
                                                                                                      #PL: ($retVal = 1) if ($status == 0);

Tokens: cs>d ValPy: 
Main loop, line=($retVal = 1) if ($status == 0); # if successful
Main loop, line=($retVal = 1) if ($status == 0); # if successful
assignment(1, 3) =|(s=d)|= ( $retVal = 1 )

Generated partial line retVal
Generated partial line retVal=
assign, ValClass[limit] = d, ValPy=1, ValPerl=1

Generated partial line retVal=1
  41 | 1 |   |    retVal = 1                                                                          #PL: ($retVal = 1) if ($status == 0); # if successful

Tokens: (s=d) ValPy: 
Main loop, line=($retVal = 1) if ($status == 0); # if successful
  42 | 0 |   |
Main loop, line=$fh = IO::File->new_tmpfile or &DCerror("Unable to make new temporary file: $!") ;


 === Line 43 Perl source:$fh = IO::File->new_tmpfile or &DCerror("Unable to make new temporary file: $!") ;===

Lexem 0 Current token='s' value='fh' Tokenstr |s| translated: fh
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: fh =
Lexem 2 Current token='i' value='IO.File' Tokenstr |s=i| translated: fh = IO.File
Lexem 3 Current token='.' value='.' Tokenstr |s=i.| translated: fh = IO.File .
Lexem 4 Current token='i' value='new_tmpfile' Tokenstr |s=i.i| translated: fh = IO.File . new_tmpfile
Lexem 5 Current token='0' value='or' Tokenstr |s=i.i0| translated: fh = IO.File . new_tmpfile or
Lexem 6 Current token='i' value='DCerror' Tokenstr |s=i.i0i| translated: fh = IO.File . new_tmpfile or DCerror
Lexem 7 Current token='(' value='(' Tokenstr |s=i.i0i(| translated: fh = IO.File . new_tmpfile or DCerror (
Lexem 8 Current token='"' value='f"Unable to make new temporary file: {OS_ERROR}"' Tokenstr |s=i.i0i("| translated: fh = IO.File . new_tmpfile or DCerror ( f"Unable to make new temporary file: {OS_ERROR}"
Lexem 9 Current token=')' value=')' Tokenstr |s=i.i0i(")| translated: fh = IO.File . new_tmpfile or DCerror ( f"Unable to make new temporary file: {OS_ERROR}" )

Line:   43 TokenStr: =|s=i.i0i(")|= @ValPy: fh = IO.File . new_tmpfile or DCerror ( f"Unable to make new temporary file: {OS_ERROR}" )
assignment(0, 9) =|s=i.i0i(")|= $fh = IO::File -> new_tmpfile or DCerror ( Unable to make new temporary file: $! )

Generated partial line fh
Generated partial line fh=
expression(2, 9, 0) =|s=i.i0i(")|= $fh = IO::File -> new_tmpfile or DCerror ( Unable to make new temporary file: $! )

Generated partial line fh=IO.File
Generated partial line fh=IO.File.
Generated partial line fh=IO.File.new_tmpfile
Generated partial line fh=IO.File.new_tmpfileor
Generated partial line fh=IO.File.new_tmpfileorDCerror
Generated partial line fh=IO.File.new_tmpfileorDCerror([
expression(8, 8, 0) =|s=i.i0i(")|= $fh = IO::File -> new_tmpfile or DCerror ( Unable to make new temporary file: $! )

Generated partial line fh=IO.File.new_tmpfileorDCerror([f"Unable to make new temporary file: {OS_ERROR}"
expression returns 9
Generated partial line fh=IO.File.new_tmpfileorDCerror([f"Unable to make new temporary file: {OS_ERROR}"])
expression returns 10
  43 | 0 |   |fh = IO.File.new_tmpfile or DCerror([f"Unable to make new temporary file: {OS_ERROR}"]) #PL: $fh = IO::File->new_tmpfile or &DCerror("Unable to make new temporary file: $!") ;

Tokens: s=i.i0i(") ValPy: 
Main loop, line=$fh->autoflush(1);


 === Line 44 Perl source:$fh->autoflush(1);===

Lexem 0 Current token='s' value='fh' Tokenstr |s| translated: fh
Lexem 1 Current token='.' value='.' Tokenstr |s.| translated: fh .
Lexem 2 Current token='i' value='autoflush' Tokenstr |s.i| translated: fh . autoflush
Lexem 3 Current token='(' value='(' Tokenstr |s.i(| translated: fh . autoflush (
Lexem 4 Current token='d' value='1' Tokenstr |s.i(d| translated: fh . autoflush ( 1
Lexem 5 Current token=')' value=')' Tokenstr |s.i(d)| translated: fh . autoflush ( 1 )

Line:   44 TokenStr: =|s.i(d)|= @ValPy: fh . autoflush ( 1 )
assignment(0, 5) =|s.i(d)|= $fh -> autoflush ( 1 )

expression(0, 5, 0) =|s.i(d)|= $fh -> autoflush ( 1 )

Generated partial line fh
Generated partial line fh.
Generated partial line fh.autoflush
LINE 44 [main-W3027]:  Function autoflush is neither internal not built-in function. Please check the correspondence of arguments
expression(3, 5, 1) =|s.i(d)|= $fh -> autoflush ( 1 )

Generated partial line fh.autoflush(
expression(4, 4, 0) =|s.i(d)|= $fh -> autoflush ( 1 )

Generated partial line fh.autoflush(1
expression returns 5
Generated partial line fh.autoflush(1)
expression returns 6
expression returns 6
  44 | 0 |   |fh.autoflush(1)                                                                         #PL: $fh->autoflush(1);

Tokens: s.i(d) ValPy: 
  45 | 0 |   |
Main loop, line=return $_ if /^\d{8}\/$type$/;


 === Line 46 Perl source:return $_ if /^\d{8}\/$type$/;===

Lexem 0 Current token='k' value='return' Tokenstr |k| translated: return
Lexem 1 Current token='s' value='_d' Tokenstr |ks| translated: return _d
Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='q' value='re.search(r'^\d{8}/$type$',_d)' Tokenstr |cq| translated: if  re.search(r'^\d{8}/$type$',_d)

Line:   46 TokenStr: =|cq|= @ValPy: if  re.search(r'^\d{8}/$type$',_d)
control(0) =|c(q)|= if ( ^\d{8}/$type$ )

control-parens removed, begin=0 start=1 =|cq|= if ^\d{8}/$type$

Generated partial line if 
expression(1, 1, 0) =|cq|= if ^\d{8}/$type$

Generated partial line if re.search(r'^\d{8}/$type$',_d)
expression returns 2
Generated partial line if re.search(r'^\d{8}/$type$',_d):
  46 | 0 |   |if re.search(r'^\d{8}/$type$',_d):                                                      #PL: return $_ if /^\d{8}\/$type$/;

Tokens: cq ValPy: 
Main loop, line=return $_ if /^\d{8}\/$type$/;
Main loop, line=return $_ if /^\d{8}\/$type$/;
Generated partial line return
expression(1, 1, 0) =|ks|= return $_

Generated partial line return_d
expression returns 2
  46 | 1 |   |    return _d                                                                           #PL: return $_ if /^\d{8}\/$type$/;

Tokens: ks ValPy: 
Main loop, line=return $_ if /^\d{8}\/$type$/;
  47 | 0 |   |
Main loop, line=@files=`$options{bin}/sftplist $remote $remotedir "$fname" 2>/dev/null`;


 === Line 48 Perl source:@files=`$options{bin}/sftplist $remote $remotedir "$fname" 2>/dev/null`;===

Lexem 0 Current token='a' value='files' Tokenstr |a| translated: files
Lexem 1 Current token='=' value='=' Tokenstr |a=| translated: files =
Lexem 2 Current token='x' value='f"""{options.get('bin','')}/sftplist {remote} {remotedir} "{fname}" 2>/dev/null"""' Tokenstr |a=x| translated: files = f"""{options.get('bin','')}/sftplist {remote} {remotedir} "{fname}" 2>/dev/null"""

Line:   48 TokenStr: =|a=x|= @ValPy: files = f"""{options.get('bin','')}/sftplist {remote} {remotedir} "{fname}" 2>/dev/null"""
assignment(0, 2) =|a=x|= =`$options{bin}/sftplist $remote $remotedir "$fname" 2>/dev/null`; = $options{bin}/sftplist $remote $remotedir "$fname" 2>/dev/null

Generated partial line files
Generated partial line files=
assign, ValClass[limit] = x, ValPy=f"""{options.get('bin','')}/sftplist {remote} {remotedir} "{fname}" 2>/dev/null""", ValPerl=$options{bin}/sftplist $remote $remotedir "$fname" 2>/dev/null

Generated partial line files=subprocess.run(f"""{options.get('bin','')}/sftplist {remote} {remotedir} "{fname}" 2>/dev/null""",capture_output=True,text=True,shell=True)
  48 | 0 |   |files = subprocess.run(f"""{options.get('bin','')}/sftplist {remote} {remotedir} "{fname}" 2>/dev/null""",capture_output=True,text=True,shell=True) #PL: @files=`$options{bin}/sftplist $remote $remotedir "$fname" 2>/dev/null`;

Tokens: a=x ValPy: 
  48 | 0 |   |_spr=files.returncode                                                                   #PL: @files=`$options{bin}/sftplist $remote $remotedir "$fname" 2>/dev/null`;

Tokens: a=x ValPy: 
Generated partial line files
Generated partial line files=
Generated partial line files=files.stdout
  48 | 0 |   |files = files.stdout                                                                    #PL: @files=`$options{bin}/sftplist $remote $remotedir "$fname" 2>/dev/null`;

Tokens: a=x ValPy: 
  49 | 0 |   |
Main loop, line=sub process_file


 === Line 50 Perl source:sub process_file===

Lexem 0 Current token='k' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' value='process_file' Tokenstr |ki| translated: def process_file

Line:   51 TokenStr: =|ki|= @ValPy: def process_file
Generated partial line defprocess_file(_args):
  51 | 0 |   |def process_file(_args):                                                                #PL: sub process_file
                                                                                                      #PL: {     # Next/last breaks you out of any block, not just loops

Tokens: ki ValPy: 
Main loop, line={


 === Line 51 Perl source:{===


Line:   51 TokenStr: =|{|= @ValPy: {
  51 | 1 |   |    # Next/last breaks you out of any block, not just loops
  52 | 1 |   |    # if it's at the sub level, just change it to a "return"
  53 | 1 |   |    # else change all empty blocks to a "try:... finally: pass" 
  54 | 1 |   |    # and make this raise a catched exception
Main loop, line=next if not $in =~ /(flows)\.(\d+)\.gz/;


 === Line 55 Perl source:next if not $in =~ /(flows)\.(\d+)\.gz/;===

Lexem 0 Current token='k' value='continue ' Tokenstr |k| translated: continue 
Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='!' value='not' Tokenstr |c!| translated: if  not
Lexem 2 Current token='s' value='in_' Tokenstr |c!s| translated: if  not in_
Lexem 3 Current token='~' value='' Tokenstr |c!s~| translated: if  not in_ 
Lexem 4 Current token='q' value='(_m:=re.search(r'(flows)\.(\d+)\.gz',' Tokenstr |c!s~q| translated: if  not in_  (_m:=re.search(r'(flows)\.(\d+)\.gz',

Line:   55 TokenStr: =|c!s~q|= @ValPy: if  not in_  (_m:=re.search(r'(flows)\.(\d+)\.gz',
control(0) =|c(!s~q)|= if ( not $in =~ (flows)\.(\d+)\.gz )

control-parens removed, begin=0 start=1 =|c!s~q|= if not $in =~ (flows)\.(\d+)\.gz

Generated partial line if 
expression(1, 4, 0) =|c!s~q|= if not $in =~ (flows)\.(\d+)\.gz

Generated partial line if not
Generated partial line if not(_m:=re.search(r'(flows)\.(\d+)\.gz',
expression(1, 2, 0) =|c!s~q|= if not $in =~ (flows)\.(\d+)\.gz

Generated partial line if not(_m:=re.search(r'(flows)\.(\d+)\.gz',not
Generated partial line if not(_m:=re.search(r'(flows)\.(\d+)\.gz',notin_
expression returns 3
Generated partial line if not(_m:=re.search(r'(flows)\.(\d+)\.gz',notin_))
expression returns 5
Generated partial line if not(_m:=re.search(r'(flows)\.(\d+)\.gz',notin_)):
  55 | 1 |   |    if not (_m:=re.search(r'(flows)\.(\d+)\.gz', not in_)):                             #PL: next if not $in =~ /(flows)\.(\d+)\.gz/;

Tokens: c!s~q ValPy: 
Main loop, line=next if not $in =~ /(flows)\.(\d+)\.gz/;
Main loop, line=next if not $in =~ /(flows)\.(\d+)\.gz/;
Generated partial line continue 
  55 | 2 |   |        continue                                                                        #PL: next if not $in =~ /(flows)\.(\d+)\.gz/;

Tokens: k ValPy: 
Main loop, line=next if not $in =~ /(flows)\.(\d+)\.gz/;
Main loop, line=last if($in eq '');


 === Line 56 Perl source:last if($in eq '');===

Lexem 0 Current token='k' value='break ' Tokenstr |k| translated: break 
Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' value='in_' Tokenstr |c(s| translated: if  ( in_
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: if  ( in_ ==
Lexem 4 Current token='"' value='''' Tokenstr |c(s>"| translated: if  ( in_ == ''
Lexem 5 Current token=')' value=')' Tokenstr |c(s>")| translated: if  ( in_ == '' )

Line:   56 TokenStr: =|c(s>")|= @ValPy: if  ( in_ == '' )
control(0) =|c(s>")|= if ( $in eq  )

control-parens removed, begin=0 start=1 =|cs>"|= if $in eq 

Generated partial line if 
expression(1, 3, 0) =|cs>"|= if $in eq 

Generated partial line if in_
Generated partial line if in_==
Generated partial line if in_==''
expression returns 4
Generated partial line if in_=='':
  56 | 1 |   |    if in_=='':                                                                         #PL: last if($in eq '');

Tokens: cs>" ValPy: 
Main loop, line=last if($in eq '');
Main loop, line=last if($in eq '');
Generated partial line break 
  56 | 2 |   |        break                                                                           #PL: last if($in eq '');

Tokens: k ValPy: 
Main loop, line=last if($in eq '');
Main loop, line=if($in eq 'if_stmt') {


 === Line 57 Perl source:if($in eq 'if_stmt') {===

Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' value='in_' Tokenstr |c(s| translated: if  ( in_
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: if  ( in_ ==
Lexem 4 Current token='"' value=''if_stmt'' Tokenstr |c(s>"| translated: if  ( in_ == 'if_stmt'
Lexem 5 Current token=')' value=')' Tokenstr |c(s>")| translated: if  ( in_ == 'if_stmt' )

Line:   57 TokenStr: =|c(s>")|= @ValPy: if  ( in_ == 'if_stmt' )
control(0) =|c(s>")|= if ( $in eq if_stmt )

control-parens removed, begin=0 start=1 =|cs>"|= if $in eq if_stmt

Generated partial line if 
expression(1, 3, 0) =|cs>"|= if $in eq if_stmt

Generated partial line if in_
Generated partial line if in_==
Generated partial line if in_=='if_stmt'
expression returns 4
Generated partial line if in_=='if_stmt':
  57 | 1 |   |    if in_=='if_stmt':                                                                  #PL: if($in eq 'if_stmt') {

Tokens: cs>" ValPy: 
Main loop, line={


 === Line 57 Perl source:{===


Line:   57 TokenStr: =|{|= @ValPy: {
Main loop, line=next if $in =~ /next if/;


 === Line 58 Perl source:next if $in =~ /next if/;===

Lexem 0 Current token='k' value='continue ' Tokenstr |k| translated: continue 
Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='s' value='in_' Tokenstr |cs| translated: if  in_
Lexem 2 Current token='~' value='' Tokenstr |cs~| translated: if  in_ 
Lexem 3 Current token='q' value='re.search(r'next if',' Tokenstr |cs~q| translated: if  in_  re.search(r'next if',

Line:   58 TokenStr: =|cs~q|= @ValPy: if  in_  re.search(r'next if',
control(0) =|c(s~q)|= if ( $in =~ next if )

control-parens removed, begin=0 start=1 =|cs~q|= if $in =~ next if

Generated partial line if 
expression(1, 3, 0) =|cs~q|= if $in =~ next if

Generated partial line if re.search(r'next if',
expression(1, 1, 0) =|cs~q|= if $in =~ next if

Generated partial line if re.search(r'next if',in_
expression returns 2
Generated partial line if re.search(r'next if',in_)
expression returns 4
Generated partial line if re.search(r'next if',in_):
  58 | 2 |   |        if re.search(r'next if', in_):                                                  #PL: next if $in =~ /next if/;

Tokens: cs~q ValPy: 
Main loop, line=next if $in =~ /next if/;
Main loop, line=next if $in =~ /next if/;
Generated partial line continue 
  58 | 3 |   |            continue                                                                    #PL: next if $in =~ /next if/;

Tokens: k ValPy: 
Main loop, line=next if $in =~ /next if/;
Main loop, line=$i = 4;


 === Line 59 Perl source:$i = 4;===

Lexem 0 Current token='s' value='i' Tokenstr |s| translated: i
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: i =
Lexem 2 Current token='d' value='4' Tokenstr |s=d| translated: i = 4

Line:   59 TokenStr: =|s=d|= @ValPy: i = 4
assignment(0, 2) =|s=d|= $i = 4

Generated partial line i
Generated partial line i=
assign, ValClass[limit] = d, ValPy=4, ValPerl=4

Generated partial line i=4
  59 | 2 |   |        i = 4                                                                           #PL: $i = 4;

Tokens: s=d ValPy: 
Main loop, line=last if $in =~ /last if/;


 === Line 60 Perl source:last if $in =~ /last if/;===

Lexem 0 Current token='k' value='break ' Tokenstr |k| translated: break 
Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='s' value='in_' Tokenstr |cs| translated: if  in_
Lexem 2 Current token='~' value='' Tokenstr |cs~| translated: if  in_ 
Lexem 3 Current token='q' value='re.search(r'last if',' Tokenstr |cs~q| translated: if  in_  re.search(r'last if',

Line:   60 TokenStr: =|cs~q|= @ValPy: if  in_  re.search(r'last if',
control(0) =|c(s~q)|= if ( $in =~ last if )

control-parens removed, begin=0 start=1 =|cs~q|= if $in =~ last if

Generated partial line if 
expression(1, 3, 0) =|cs~q|= if $in =~ last if

Generated partial line if re.search(r'last if',
expression(1, 1, 0) =|cs~q|= if $in =~ last if

Generated partial line if re.search(r'last if',in_
expression returns 2
Generated partial line if re.search(r'last if',in_)
expression returns 4
Generated partial line if re.search(r'last if',in_):
  60 | 2 |   |        if re.search(r'last if', in_):                                                  #PL: last if $in =~ /last if/;

Tokens: cs~q ValPy: 
Main loop, line=last if $in =~ /last if/;
Main loop, line=last if $in =~ /last if/;
Generated partial line break 
  60 | 3 |   |            break                                                                       #PL: last if $in =~ /last if/;

Tokens: k ValPy: 
Main loop, line=last if $in =~ /last if/;
Main loop, line=}


 === Line 61 Perl source:}===


Line:   61 TokenStr: =|}|= @ValPy: }
Main loop, line=next;


 === Line 62 Perl source:next;===

Lexem 0 Current token='k' value='continue ' Tokenstr |k| translated: continue 

Line:   62 TokenStr: =|k|= @ValPy: continue 
Generated partial line continue 
  62 | 1 |   |    continue                                                                            #PL: next;

Tokens: k ValPy: 
Main loop, line=last;


 === Line 63 Perl source:last;===

Lexem 0 Current token='k' value='break ' Tokenstr |k| translated: break 

Line:   63 TokenStr: =|k|= @ValPy: break 
Generated partial line break 
  63 | 1 |   |    break                                                                               #PL: last;

Tokens: k ValPy: 
Main loop, line=return;


 === Line 64 Perl source:return;===

Lexem 0 Current token='k' value='return' Tokenstr |k| translated: return

Line:   64 TokenStr: =|k|= @ValPy: return
Generated partial line return
  64 | 1 |   |    return                                                                              #PL: return;

Tokens: k ValPy: 
Main loop, line=}


 === Line 65 Perl source:}===


Line:   65 TokenStr: =|}|= @ValPy: }
  66 | 0 |   |
Main loop, line={


 === Line 67 Perl source:{===


Line:   67 TokenStr: =|{|= @ValPy: {
  67 | 0 |   |if True:                                                                                #PL: 

Tokens: { ValPy: 
  68 | 0 |   |# here is a block that we will "next" and "last" out of
Main loop, line=next if($i == 1);


 === Line 70 Perl source:next if($i == 1);===

Lexem 0 Current token='k' value='continue ' Tokenstr |k| translated: continue 
Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' value='i' Tokenstr |c(s| translated: if  ( i
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: if  ( i ==
Lexem 4 Current token='d' value='1' Tokenstr |c(s>d| translated: if  ( i == 1
Lexem 5 Current token=')' value=')' Tokenstr |c(s>d)| translated: if  ( i == 1 )

Line:   70 TokenStr: =|c(s>d)|= @ValPy: if  ( i == 1 )
control(0) =|c(s>d)|= if ( $i == 1 )

control-parens removed, begin=0 start=1 =|cs>d|= if $i == 1

Generated partial line if 
expression(1, 3, 0) =|cs>d|= if $i == 1

Generated partial line if i
Generated partial line if i==
Generated partial line if i==1
expression returns 4
Generated partial line if i==1:
  70 | 1 |   |    if i==1:                                                                            #PL: next if($i == 1);

Tokens: cs>d ValPy: 
Main loop, line=next if($i == 1);
Main loop, line=next if($i == 1);
Generated partial line continue 
  70 | 2 |   |        continue                                                                        #PL: next if($i == 1);

Tokens: k ValPy: 
Main loop, line=next if($i == 1);
Main loop, line=$i = 2;


 === Line 71 Perl source:$i = 2;===

Lexem 0 Current token='s' value='i' Tokenstr |s| translated: i
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: i =
Lexem 2 Current token='d' value='2' Tokenstr |s=d| translated: i = 2

Line:   71 TokenStr: =|s=d|= @ValPy: i = 2
assignment(0, 2) =|s=d|= $i = 2

Generated partial line i
Generated partial line i=
assign, ValClass[limit] = d, ValPy=2, ValPerl=2

Generated partial line i=2
  71 | 1 |   |    i = 2                                                                               #PL: $i = 2;

Tokens: s=d ValPy: 
Main loop, line=last if($i == 2);


 === Line 72 Perl source:last if($i == 2);===

Lexem 0 Current token='k' value='break ' Tokenstr |k| translated: break 
Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' value='i' Tokenstr |c(s| translated: if  ( i
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: if  ( i ==
Lexem 4 Current token='d' value='2' Tokenstr |c(s>d| translated: if  ( i == 2
Lexem 5 Current token=')' value=')' Tokenstr |c(s>d)| translated: if  ( i == 2 )

Line:   72 TokenStr: =|c(s>d)|= @ValPy: if  ( i == 2 )
control(0) =|c(s>d)|= if ( $i == 2 )

control-parens removed, begin=0 start=1 =|cs>d|= if $i == 2

Generated partial line if 
expression(1, 3, 0) =|cs>d|= if $i == 2

Generated partial line if i
Generated partial line if i==
Generated partial line if i==2
expression returns 4
Generated partial line if i==2:
  72 | 1 |   |    if i==2:                                                                            #PL: last if($i == 2);

Tokens: cs>d ValPy: 
Main loop, line=last if($i == 2);
Main loop, line=last if($i == 2);
Generated partial line break 
  72 | 2 |   |        break                                                                           #PL: last if($i == 2);

Tokens: k ValPy: 
Main loop, line=last if($i == 2);
Main loop, line=$i = 3;


 === Line 73 Perl source:$i = 3;===

Lexem 0 Current token='s' value='i' Tokenstr |s| translated: i
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: i =
Lexem 2 Current token='d' value='3' Tokenstr |s=d| translated: i = 3

Line:   73 TokenStr: =|s=d|= @ValPy: i = 3
assignment(0, 2) =|s=d|= $i = 3

Generated partial line i
Generated partial line i=
assign, ValClass[limit] = d, ValPy=3, ValPerl=3

Generated partial line i=3
  73 | 1 |   |    i = 3                                                                               #PL: $i = 3;

Tokens: s=d ValPy: 
Main loop, line=next;


 === Line 74 Perl source:next;===

Lexem 0 Current token='k' value='continue ' Tokenstr |k| translated: continue 

Line:   74 TokenStr: =|k|= @ValPy: continue 
Generated partial line continue 
  74 | 1 |   |    continue                                                                            #PL: next;

Tokens: k ValPy: 
Main loop, line=last;


 === Line 75 Perl source:last;===

Lexem 0 Current token='k' value='break ' Tokenstr |k| translated: break 

Line:   75 TokenStr: =|k|= @ValPy: break 
Generated partial line break 
  75 | 1 |   |    break                                                                               #PL: last;

Tokens: k ValPy: 
Main loop, line=return;


 === Line 76 Perl source:return;===

Lexem 0 Current token='k' value='return' Tokenstr |k| translated: return

Line:   76 TokenStr: =|k|= @ValPy: return
Generated partial line return
  76 | 1 |   |    return                                                                              #PL: return;

Tokens: k ValPy: 
Main loop, line=}


 === Line 77 Perl source:}===


Line:   77 TokenStr: =|}|= @ValPy: }
  78 | 0 |   |
Main loop, line=LINE: while(<>) {


 === Line 79 Perl source:LINE: while(<>) {===

Lexem 0 Current token='i' value='LINE' Tokenstr |i| translated: LINE
Lexem 1 Current token=':' value=':' Tokenstr |i:| translated: LINE :
Lexem 0 Current token='c' value='while' Tokenstr |c| translated: while
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: while (
Lexem 3 Current token='i' value='next(_dia, None)' Tokenstr |Wc(i| translated: with fileinput.input() as _dia: while ( next(_dia, None)
Lexem 4 Current token=')' value=')' Tokenstr |Wc(i)| translated: with fileinput.input() as _dia: while ( next(_dia, None) )

Line:   79 TokenStr: =|Wc(i)|= @ValPy: with fileinput.input() as _dia: while ( next(_dia, None) )
Setting context_manager_nest = 0
  79 | 0 |   |with fileinput.input() as _dia:                                                         #PL: LINE: while(<>) {

Tokens: Wc(i) ValPy: 
control(0) =|c(i)|= while ( <> )

control-parens removed, begin=0 start=1 =|ci|= while <>

Generated partial line while (_d:=next(_dia, None))
Generated partial line while (_d:=next(_dia, None)):
  79 | 1 |   |    while (_d:=next(_dia, None)):                                                       #PL: LINE: while(<>) {

Tokens: ci ValPy: 
Main loop, line=LINE: while(<>) {
Main loop, line=LINE: while(<>) {
expression(0, 1, 0) =|i:|= LINE :

Generated partial line 'LINE'
Generated partial line 'LINE':
expression returns 2
  79 | 2 |   |        'LINE':                                                                         #PL: LINE: while(<>) {

Tokens: i: ValPy: 
Main loop, line=LINE: while(<>) {
Resetting context manager nest
Main loop, line=next LINE if /^#/;  # discard comments


 === Line 80 Perl source:next LINE if /^#/;  # discard comments===

Lexem 0 Current token='k' value='continue ' Tokenstr |k| translated: continue 
Lexem 1 Current token='i' value='LINE' Tokenstr |ki| translated: continue  LINE
Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='q' value='re.search(r'^#',_d)' Tokenstr |cq| translated: if  re.search(r'^#',_d)

Line:   80 TokenStr: =|cq|= @ValPy: if  re.search(r'^#',_d)
control(0) =|c(q)|= if ( ^# )

control-parens removed, begin=0 start=1 =|cq|= if ^#

Generated partial line if 
expression(1, 1, 0) =|cq|= if ^#

Generated partial line if re.search(r'^#',_d)
expression returns 2
Generated partial line if re.search(r'^#',_d):
  80 | 0 |   |if re.search(r'^#',_d): # discard comments
                                                                                                      #PL: next LINE if /^#/;

Tokens: cq ValPy: 
Main loop, line=next LINE if /^#/;  # discard comments
Main loop, line=next LINE if /^#/;  # discard comments
Generated partial line continue 
expression(1, 1, 0) =|ki|= next LINE

Generated partial line continue 'LINE'
expression returns 2
  80 | 1 |   |    continue 'LINE'                                                                     #PL: next LINE if /^#/;  # discard comments

Tokens: ki ValPy: 
Main loop, line=next LINE if /^#/;  # discard comments
Main loop, line=}


 === Line 81 Perl source:}===


Line:   81 TokenStr: =|}|= @ValPy: }
LINE 81 [Pythonizer-S535]:  Attempt to set the next nesting level below zero ignored
  82 | 0 |   |
  83 | 0 |   |'''
  83 | 0 |   |goto SKIP_THIS_STUFF;
  84 | 0 |   |OUTER: 

  85 | 0 |   |for($i = 0; $i < 10; $i++) {

  86 | 0 |   |    INNER: 

  87 | 0 |   |    for($j = 0; $j < 10; $j++) {

  88 | 0 |   |        last OUTER if($i == $j);

  89 | 0 |   |    }

  90 | 0 |   |}

  91 | 0 |   |

  92 | 0 |   |SKIP_THIS_STUFF: ;

  93 | 0 |   |'''
Main loop, line=


 === Line 93 Perl source:===


Line:   93 TokenStr: =||= @ValPy: 
  93 | 0 |   |pass                                                                                    #PL: 

Tokens:  ValPy: 
Main loop, line=$i = 0;


 === Line 94 Perl source:$i = 0;===

Lexem 0 Current token='s' value='i' Tokenstr |s| translated: i
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: i =
Lexem 2 Current token='d' value='0' Tokenstr |s=d| translated: i = 0

Line:   94 TokenStr: =|s=d|= @ValPy: i = 0
assignment(0, 2) =|s=d|= $i = 0

Generated partial line i
Generated partial line i=
assign, ValClass[limit] = d, ValPy=0, ValPerl=0

Generated partial line i=0
  94 | 0 |   |i = 0                                                                                   #PL: $i = 0;

Tokens: s=d ValPy: 
Main loop, line=do {


 === Line 95 Perl source:do {===

Lexem 0 Current token='i' value='' Tokenstr |i| translated: 

Line:   95 TokenStr: =|i|= @ValPy: 
expression(0, 0, 0) =|i|= do

Generated partial line 
expression returns 1
  95 | 0 |   |

Tokens: i ValPy: 
Main loop, line={


 === Line 95 Perl source:{===


Line:   95 TokenStr: =|{|= @ValPy: {
  95 | 0 |   |if True:                                                                                #PL: 

Tokens: { ValPy: 
Main loop, line=} until ($i == 10);


 === Line 97 Perl source:} until ($i == 10);===


Line:   97 TokenStr: =|}|= @ValPy: }
Main loop, line=until ($i == 10);


 === Line 97 Perl source:until ($i == 10);===

Lexem 0 Current token='c' value='while not ' Tokenstr |c| translated: while not 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: while not  (
Lexem 2 Current token='s' value='i' Tokenstr |c(s| translated: while not  ( i
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: while not  ( i ==
Lexem 4 Current token='d' value='10' Tokenstr |c(s>d| translated: while not  ( i == 10
Lexem 5 Current token=')' value=')' Tokenstr |c(s>d)| translated: while not  ( i == 10 )

Line:   97 TokenStr: =|c(s>d)|= @ValPy: while not  ( i == 10 )
control(0) =|c(s>d)|= until ( $i == 10 )

control-parens removed, begin=0 start=1 =|cs>d|= until $i == 10

Generated partial line while not 
expression(1, 3, 0) =|cs>d|= until $i == 10

Generated partial line while not i
Generated partial line while not i==
Generated partial line while not i==10
expression returns 4
Generated partial line while not i==10:
  97 | 0 |   |while not i==10:                                                                        #PL: until ($i == 10);

Tokens: cs>d ValPy: 
  98 | 0 |   |
Main loop, line=my $ua = LWP::UserAgent->new;


 === Line 99 Perl source:my $ua = LWP::UserAgent->new;===

Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='s' value='ua' Tokenstr |ts| translated:  ua
Lexem 2 Current token='=' value='=' Tokenstr |ts=| translated:  ua =
Lexem 3 Current token='i' value='LWP.UserAgent' Tokenstr |ts=i| translated:  ua = LWP.UserAgent
Lexem 4 Current token='.' value='.' Tokenstr |ts=i.| translated:  ua = LWP.UserAgent .
Lexem 5 Current token='i' value='new' Tokenstr |ts=i.i| translated:  ua = LWP.UserAgent . new

Line:   99 TokenStr: =|ts=i.i|= @ValPy:  ua = LWP.UserAgent . new
assignment(1, 5) =|ts=i.i|= my $ua = LWP::UserAgent -> new

Generated partial line ua
Generated partial line ua=
expression(3, 5, 0) =|ts=i.i|= my $ua = LWP::UserAgent -> new

Generated partial line ua=LWP.UserAgent
Generated partial line ua=LWP.UserAgent.
Generated partial line ua=LWP.UserAgent.new
expression returns 6
  99 | 0 |   |ua = LWP.UserAgent.new                                                                  #PL: my $ua = LWP::UserAgent->new;

Tokens: ts=i.i ValPy: 
 100 | 0 |   |
Main loop, line=$num{$key}{$hour} = 12;


 === Line 101 Perl source:$num{$key}{$hour} = 12;===

Lexem 0 Current token='s' value='num' Tokenstr |s| translated: num
Lexem 1 Current token='(' value='[' Tokenstr |s(| translated: num [
Lexem 2 Current token='s' value='key' Tokenstr |s(s| translated: num [ key
Lexem 3 Current token=')' value=']' Tokenstr |s(s)| translated: num [ key ]
Lexem 4 Current token='(' value='[' Tokenstr |s(s)(| translated: num [ key ] [
Lexem 5 Current token='s' value='hour' Tokenstr |s(s)(s| translated: num [ key ] [ hour
Lexem 6 Current token=')' value=']' Tokenstr |s(s)(s)| translated: num [ key ] [ hour ]
Lexem 7 Current token='=' value='=' Tokenstr |s(s)(s)=| translated: num [ key ] [ hour ] =
Lexem 8 Current token='d' value='12' Tokenstr |s(s)(s)=d| translated: num [ key ] [ hour ] = 12

Line:  101 TokenStr: =|s(s)(s)=d|= @ValPy: num [ key ] [ hour ] = 12
assignment(0, 8) =|s(s)(s)=d|= $num { $key } { $hour } = 12

expression(0, 6, 0) =|s(s)(s)=d|= $num { $key } { $hour } = 12

Generated partial line num
Generated partial line num[
expression(2, 2, 0) =|s(s)(s)=d|= $num { $key } { $hour } = 12

Generated partial line num[key
expression returns 3
Generated partial line num[key]
Generated partial line num[key][
expression(5, 5, 0) =|s(s)(s)=d|= $num { $key } { $hour } = 12

Generated partial line num[key][hour
expression returns 6
Generated partial line num[key][hour]
expression returns 7
Generated partial line num[key][hour]=
assign, ValClass[limit] = d, ValPy=12, ValPerl=12

Generated partial line num[key][hour]=12
 101 | 0 |   |num[key][hour] = 12                                                                     #PL: $num{$key}{$hour} = 12;

Tokens: s(s)(s)=d ValPy: 
Main loop, line=$num{$key}{$hour}++;


 === Line 102 Perl source:$num{$key}{$hour}++;===

Lexem 0 Current token='s' value='num' Tokenstr |s| translated: num
Lexem 1 Current token='(' value='[' Tokenstr |s(| translated: num [
Lexem 2 Current token='s' value='key' Tokenstr |s(s| translated: num [ key
Lexem 3 Current token=')' value=']' Tokenstr |s(s)| translated: num [ key ]
Lexem 4 Current token='(' value='[' Tokenstr |s(s)(| translated: num [ key ] [
Lexem 5 Current token='s' value='hour' Tokenstr |s(s)(s| translated: num [ key ] [ hour
Lexem 6 Current token=')' value=']' Tokenstr |s(s)(s)| translated: num [ key ] [ hour ]
Lexem 7 Current token='^' value='+=1' Tokenstr |s(s)(s)^| translated: num [ key ] [ hour ] +=1

Line:  102 TokenStr: =|s(s)(s)^|= @ValPy: num [ key ] [ hour ] +=1
handle_incr_decr(0, 7, 7) with ++, pre_op=0, lvalue_start=0, lvalue_end=6 = 1
assignment(0, 8) =|s(s)(s)=d|= $num { $key } { $hour } += 1

expression(0, 6, 0) =|s(s)(s)=d|= $num { $key } { $hour } += 1

Generated partial line num
Generated partial line num[
expression(2, 2, 0) =|s(s)(s)=d|= $num { $key } { $hour } += 1

Generated partial line num[key
expression returns 3
Generated partial line num[key]
Generated partial line num[key][
expression(5, 5, 0) =|s(s)(s)=d|= $num { $key } { $hour } += 1

Generated partial line num[key][hour
expression returns 6
Generated partial line num[key][hour]
expression returns 7
Generated partial line num[key][hour]+=
assign, ValClass[limit] = d, ValPy=1, ValPerl=1

Generated partial line num[key][hour]+=1
 102 | 0 |   |num[key][hour] += 1                                                                     #PL: $num{$key}{$hour}++;

Tokens: s(s)(s)=d ValPy: 
Main loop, line=--$num{$key}{$hour};


 === Line 103 Perl source:--$num{$key}{$hour};===

Lexem 0 Current token='^' value='-=1' Tokenstr |^| translated: -=1
Lexem 1 Current token='s' value='num' Tokenstr |^s| translated: -=1 num
Lexem 2 Current token='(' value='[' Tokenstr |^s(| translated: -=1 num [
Lexem 3 Current token='s' value='key' Tokenstr |^s(s| translated: -=1 num [ key
Lexem 4 Current token=')' value=']' Tokenstr |^s(s)| translated: -=1 num [ key ]
Lexem 5 Current token='(' value='[' Tokenstr |^s(s)(| translated: -=1 num [ key ] [
Lexem 6 Current token='s' value='hour' Tokenstr |^s(s)(s| translated: -=1 num [ key ] [ hour
Lexem 7 Current token=')' value=']' Tokenstr |^s(s)(s)| translated: -=1 num [ key ] [ hour ]

Line:  103 TokenStr: =|^s(s)(s)|= @ValPy: -=1 num [ key ] [ hour ]
handle_incr_decr(0, 0, 7) with --assignment(0, 7) =|s(s)(s)^|= $num { $key } { $hour } --

assignment_updated(0, 8) =|s(s)(s)=d|= $num { $key } { $hour } = 1

expression(0, 6, 0) =|s(s)(s)=d|= $num { $key } { $hour } = 1

Generated partial line num
Generated partial line num[
expression(2, 2, 0) =|s(s)(s)=d|= $num { $key } { $hour } = 1

Generated partial line num[key
expression returns 3
Generated partial line num[key]
Generated partial line num[key][
expression(5, 5, 0) =|s(s)(s)=d|= $num { $key } { $hour } = 1

Generated partial line num[key][hour
expression returns 6
Generated partial line num[key][hour]
expression returns 7
Generated partial line num[key][hour]-=
assign, ValClass[limit] = d, ValPy=1, ValPerl=1

Generated partial line num[key][hour]-=1
 103 | 0 |   |num[key][hour] -= 1                                                                     #PL: --$num{$key}{$hour};

Tokens: s(s)(s)=d ValPy: 
Main loop, line=if($num{$key}{$hour}++ == 12) {


 === Line 104 Perl source:if($num{$key}{$hour}++ == 12) {===

Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' value='num' Tokenstr |c(s| translated: if  ( num
Lexem 3 Current token='(' value='[' Tokenstr |c(s(| translated: if  ( num [
Lexem 4 Current token='s' value='key' Tokenstr |c(s(s| translated: if  ( num [ key
Lexem 5 Current token=')' value=']' Tokenstr |c(s(s)| translated: if  ( num [ key ]
Lexem 6 Current token='(' value='[' Tokenstr |c(s(s)(| translated: if  ( num [ key ] [
Lexem 7 Current token='s' value='hour' Tokenstr |c(s(s)(s| translated: if  ( num [ key ] [ hour
Lexem 8 Current token=')' value=']' Tokenstr |c(s(s)(s)| translated: if  ( num [ key ] [ hour ]
Lexem 9 Current token='^' value='+=1' Tokenstr |c(s(s)(s)^| translated: if  ( num [ key ] [ hour ] +=1
Lexem 10 Current token='>' value='==' Tokenstr |c(s(s)(s)^>| translated: if  ( num [ key ] [ hour ] +=1 ==
Lexem 11 Current token='d' value='12' Tokenstr |c(s(s)(s)^>d| translated: if  ( num [ key ] [ hour ] +=1 == 12
Lexem 12 Current token=')' value=')' Tokenstr |c(s(s)(s)^>d)| translated: if  ( num [ key ] [ hour ] +=1 == 12 )

Line:  104 TokenStr: =|c(s(s)(s)^>d)|= @ValPy: if  ( num [ key ] [ hour ] +=1 == 12 )
handle_incr_decr(0, 9, 12) with ++, pre_op=0, lvalue_start=2, lvalue_end=8expression(2, 8, 0) =|c(s(s)(s)=>d)|= if ( $num { $key } { $hour } += 1 == 12 )

Generated partial line num
Generated partial line num[
expression(4, 4, 0) =|c(s(s)(s)=>d)|= if ( $num { $key } { $hour } += 1 == 12 )

Generated partial line num[key
expression returns 5
Generated partial line num[key]
Generated partial line num[key][
expression(7, 7, 0) =|c(s(s)(s)=>d)|= if ( $num { $key } { $hour } += 1 == 12 )

Generated partial line num[key][hour
expression returns 8
Generated partial line num[key][hour]
expression returns 9
Generated partial line num[key][hour] += 1
 104 | 0 |   |num[key][hour] += 1                                                                     #PL: if($num{$key}{$hour}++ == 12) {

Tokens: c(s(s)(s)=>d) ValPy: 
 =|c(s(s)(s)=>d)|=, op_pos=9,  = 3
control(0) =|c((s(s)(s)-d)>d)|= if ( ( $num { $key } { $hour } - 1 ) == 12 )

control-parens removed, begin=0 start=1 =|c(s(s)(s)-d)>d|= if ( $num { $key } { $hour } - 1 ) == 12

Generated partial line if 
expression(1, 13, 0) =|c(s(s)(s)-d)>d|= if ( $num { $key } { $hour } - 1 ) == 12

Generated partial line if (
expression(2, 10, 0) =|c(s(s)(s)-d)>d|= if ( $num { $key } { $hour } - 1 ) == 12

Generated partial line if (num
Generated partial line if (num.get(
expression(4, 4, 0) =|c(s(s)(s)-d)>d|= if ( $num { $key } { $hour } - 1 ) == 12

Generated partial line if (num.get(key
expression returns 5
Generated partial line if (num.get(key)
Generated partial line if (num.get(key).get(
expression(7, 7, 0) =|c(s(s)(s)-d)>d|= if ( $num { $key } { $hour } - 1 ) == 12

Generated partial line if (num.get(key).get(hour
expression returns 8
Generated partial line if (num.get(key).get(hour)
Generated partial line if (num.get(key).get(hour)-
Generated partial line if (num.get(key).get(hour)-1
expression returns 11
Generated partial line if (num.get(key).get(hour)-1)
Generated partial line if (num.get(key).get(hour)-1)==
Generated partial line if (num.get(key).get(hour)-1)==12
expression returns 14
Generated partial line if (num.get(key).get(hour)-1)==12:
 104 | 0 |   |if (num.get(key).get(hour)-1)==12:                                                      #PL: if($num{$key}{$hour}++ == 12) {

Tokens: c(s(s)(s)-d)>d ValPy: 
Main loop, line={


 === Line 104 Perl source:{===


Line:  104 TokenStr: =|{|= @ValPy: {
Main loop, line=;


 === Line 105 Perl source:;===


Line:  105 TokenStr: =||= @ValPy: 
 105 | 1 |   |    pass                                                                                #PL: ;

Tokens:  ValPy: 
Main loop, line=}


 === Line 106 Perl source:}===


Line:  106 TokenStr: =|}|= @ValPy: }
Main loop, line=if(--$num{$key}{$hour} == 12) {


 === Line 107 Perl source:if(--$num{$key}{$hour} == 12) {===

Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='^' value='-=1' Tokenstr |c(^| translated: if  ( -=1
Lexem 3 Current token='s' value='num' Tokenstr |c(^s| translated: if  ( -=1 num
Lexem 4 Current token='(' value='[' Tokenstr |c(^s(| translated: if  ( -=1 num [
Lexem 5 Current token='s' value='key' Tokenstr |c(^s(s| translated: if  ( -=1 num [ key
Lexem 6 Current token=')' value=']' Tokenstr |c(^s(s)| translated: if  ( -=1 num [ key ]
Lexem 7 Current token='(' value='[' Tokenstr |c(^s(s)(| translated: if  ( -=1 num [ key ] [
Lexem 8 Current token='s' value='hour' Tokenstr |c(^s(s)(s| translated: if  ( -=1 num [ key ] [ hour
Lexem 9 Current token=')' value=']' Tokenstr |c(^s(s)(s)| translated: if  ( -=1 num [ key ] [ hour ]
Lexem 10 Current token='>' value='==' Tokenstr |c(^s(s)(s)>| translated: if  ( -=1 num [ key ] [ hour ] ==
Lexem 11 Current token='d' value='12' Tokenstr |c(^s(s)(s)>d| translated: if  ( -=1 num [ key ] [ hour ] == 12
Lexem 12 Current token=')' value=')' Tokenstr |c(^s(s)(s)>d)| translated: if  ( -=1 num [ key ] [ hour ] == 12 )

Line:  107 TokenStr: =|c(^s(s)(s)>d)|= @ValPy: if  ( -=1 num [ key ] [ hour ] == 12 )
handle_incr_decr(0, 2, 12) with --, pre_op=1, lvalue_start=3, lvalue_end=9expression(3, 9, 0) =|c(^s(s)(s)=>d)|= if ( -- $num { $key } { $hour } -= 1 == 12 )

Generated partial line num
Generated partial line num[
expression(5, 5, 0) =|c(^s(s)(s)=>d)|= if ( -- $num { $key } { $hour } -= 1 == 12 )

Generated partial line num[key
expression returns 6
Generated partial line num[key]
Generated partial line num[key][
expression(8, 8, 0) =|c(^s(s)(s)=>d)|= if ( -- $num { $key } { $hour } -= 1 == 12 )

Generated partial line num[key][hour
expression returns 9
Generated partial line num[key][hour]
expression returns 10
Generated partial line num[key][hour] -= 1
 107 | 0 |   |num[key][hour] -= 1                                                                     #PL: if(--$num{$key}{$hour} == 12) {

Tokens: c(^s(s)(s)>d) ValPy: 
 =|c(^s(s)(s)>d)|=, op_pos=2,  = -1 (arr/hash)
control(0) =|c(s(s)(s)>d)|= if ( $num { $key } { $hour } == 12 )

control-parens removed, begin=0 start=1 =|cs(s)(s)>d|= if $num { $key } { $hour } == 12

Generated partial line if 
expression(1, 9, 0) =|cs(s)(s)>d|= if $num { $key } { $hour } == 12

Generated partial line if num
Generated partial line if num.get(
expression(3, 3, 0) =|cs(s)(s)>d|= if $num { $key } { $hour } == 12

Generated partial line if num.get(key
expression returns 4
Generated partial line if num.get(key)
Generated partial line if num.get(key).get(
expression(6, 6, 0) =|cs(s)(s)>d|= if $num { $key } { $hour } == 12

Generated partial line if num.get(key).get(hour
expression returns 7
Generated partial line if num.get(key).get(hour)
Generated partial line if num.get(key).get(hour)==
Generated partial line if num.get(key).get(hour)==12
expression returns 10
Generated partial line if num.get(key).get(hour)==12:
 107 | 0 |   |if num.get(key).get(hour)==12:                                                          #PL: if(--$num{$key}{$hour} == 12) {

Tokens: cs(s)(s)>d ValPy: 
Main loop, line={


 === Line 107 Perl source:{===


Line:  107 TokenStr: =|{|= @ValPy: {
Main loop, line=;


 === Line 108 Perl source:;===


Line:  108 TokenStr: =||= @ValPy: 
 108 | 1 |   |    pass                                                                                #PL: ;

Tokens:  ValPy: 
Main loop, line=}


 === Line 109 Perl source:}===


Line:  109 TokenStr: =|}|= @ValPy: }
 110 | 0 |   |
Main loop, line=foreach ($n=1; $n<=30; $n++)


 === Line 111 Perl source:foreach ($n=1; $n<=30; $n++)===

Lexem 0 Current token='c' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='s' value='n' Tokenstr |c(s| translated: for  ( n
Lexem 3 Current token='=' value=':=' Tokenstr |c(s=| translated: for  ( n :=
Lexem 4 Current token='d' value='1' Tokenstr |c(s=d| translated: for  ( n := 1
Lexem 5 Current token=';' value=';' Tokenstr |c(s=d;| translated: for  ( n := 1 ;
Lexem 6 Current token='s' value='n' Tokenstr |c(s=d;s| translated: for  ( n := 1 ; n
Lexem 7 Current token='>' value='<=' Tokenstr |c(s=d;s>| translated: for  ( n := 1 ; n <=
Lexem 8 Current token='d' value='30' Tokenstr |c(s=d;s>d| translated: for  ( n := 1 ; n <= 30
Lexem 9 Current token=';' value=';' Tokenstr |c(s=d;s>d;| translated: for  ( n := 1 ; n <= 30 ;
Lexem 10 Current token='s' value='n' Tokenstr |c(s=d;s>d;s| translated: for  ( n := 1 ; n <= 30 ; n
Lexem 11 Current token='^' value='+=1' Tokenstr |c(s=d;s>d;s^| translated: for  ( n := 1 ; n <= 30 ; n +=1
Lexem 12 Current token=')' value=')' Tokenstr |c(s=d;s>d;s^)| translated: for  ( n := 1 ; n <= 30 ; n +=1 )

Line:  112 TokenStr: =|c(s=d;s>d;s^)|= @ValPy: for  ( n := 1 ; n <= 30 ; n +=1 )
handle_incr_decr(0, 11, 12) with ++, pre_op=0, lvalue_start=10, lvalue_end=10 = 9
control(0) =|c(s=d;s>d;((s=s+d)-d))|= foreach ( $n = 1 ; $n <= 30 ; ( ( $n = $n + 1 ) - 1 ) )

control-parens removed, begin=0 start=1 =|cs=d;s>d;((s=s+d)-d)|= foreach $n = 1 ; $n <= 30 ; ( ( $n = $n + 1 ) - 1 )

Generated partial line for 
Generated partial line for n
Generated partial line for nin range(
Generated partial line for nin range(1
Generated partial line for nin range(1,
Generated partial line for nin range(1,30
Generated partial line for nin range(1,30+1
Generated partial line for nin range(1,30+1):
 112 | 0 |   |for n in range(1, 30+1):                                                                #PL: foreach ($n=1; $n<=30; $n++)

Tokens: cs=d;s>d;((s=s+d)-d) ValPy: 
Main loop, line={


 === Line 112 Perl source:{===


Line:  112 TokenStr: =|{|= @ValPy: {
Main loop, line=;


 === Line 113 Perl source:;===


Line:  113 TokenStr: =||= @ValPy: 
 113 | 1 |   |    pass                                                                                #PL: ;

Tokens:  ValPy: 
Main loop, line=}


 === Line 114 Perl source:}===


Line:  114 TokenStr: =|}|= @ValPy: }
Main loop, line=for ($n=1; $n<=30; $n++)


 === Line 115 Perl source:for ($n=1; $n<=30; $n++)===

Lexem 0 Current token='c' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='s' value='n' Tokenstr |c(s| translated: for  ( n
Lexem 3 Current token='=' value=':=' Tokenstr |c(s=| translated: for  ( n :=
Lexem 4 Current token='d' value='1' Tokenstr |c(s=d| translated: for  ( n := 1
Lexem 5 Current token=';' value=';' Tokenstr |c(s=d;| translated: for  ( n := 1 ;
Lexem 6 Current token='s' value='n' Tokenstr |c(s=d;s| translated: for  ( n := 1 ; n
Lexem 7 Current token='>' value='<=' Tokenstr |c(s=d;s>| translated: for  ( n := 1 ; n <=
Lexem 8 Current token='d' value='30' Tokenstr |c(s=d;s>d| translated: for  ( n := 1 ; n <= 30
Lexem 9 Current token=';' value=';' Tokenstr |c(s=d;s>d;| translated: for  ( n := 1 ; n <= 30 ;
Lexem 10 Current token='s' value='n' Tokenstr |c(s=d;s>d;s| translated: for  ( n := 1 ; n <= 30 ; n
Lexem 11 Current token='^' value='+=1' Tokenstr |c(s=d;s>d;s^| translated: for  ( n := 1 ; n <= 30 ; n +=1
Lexem 12 Current token=')' value=')' Tokenstr |c(s=d;s>d;s^)| translated: for  ( n := 1 ; n <= 30 ; n +=1 )

Line:  116 TokenStr: =|c(s=d;s>d;s^)|= @ValPy: for  ( n := 1 ; n <= 30 ; n +=1 )
handle_incr_decr(0, 11, 12) with ++, pre_op=0, lvalue_start=10, lvalue_end=10 = 9
control(0) =|c(s=d;s>d;((s=s+d)-d))|= for ( $n = 1 ; $n <= 30 ; ( ( $n = $n + 1 ) - 1 ) )

control-parens removed, begin=0 start=1 =|cs=d;s>d;((s=s+d)-d)|= for $n = 1 ; $n <= 30 ; ( ( $n = $n + 1 ) - 1 )

Generated partial line for 
Generated partial line for n
Generated partial line for nin range(
Generated partial line for nin range(1
Generated partial line for nin range(1,
Generated partial line for nin range(1,30
Generated partial line for nin range(1,30+1
Generated partial line for nin range(1,30+1):
 116 | 0 |   |for n in range(1, 30+1):                                                                #PL: for ($n=1; $n<=30; $n++)

Tokens: cs=d;s>d;((s=s+d)-d) ValPy: 
Main loop, line={


 === Line 116 Perl source:{===


Line:  116 TokenStr: =|{|= @ValPy: {
Main loop, line=;


 === Line 117 Perl source:;===


Line:  117 TokenStr: =||= @ValPy: 
 117 | 1 |   |    pass                                                                                #PL: ;

Tokens:  ValPy: 
Main loop, line=}


 === Line 118 Perl source:}===


Line:  118 TokenStr: =|}|= @ValPy: }
 119 | 0 |   |
Main loop, line=my @sequence = sort bynum keys %{$routespans{$rin}};


 === Line 120 Perl source:my @sequence = sort bynum keys %{$routespans{$rin}};===

Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' value='sequence' Tokenstr |ta| translated:  sequence
Lexem 2 Current token='=' value='=' Tokenstr |ta=| translated:  sequence =
Lexem 3 Current token='f' value='sorted' Tokenstr |ta=f| translated:  sequence = sorted
Lexem 4 Current token='i' value='bynum' Tokenstr |ta=fi| translated:  sequence = sorted bynum
Lexem 5 Current token='f' value='.keys()' Tokenstr |ta=fif| translated:  sequence = sorted bynum .keys()
Lexem 6 Current token='%' value='%' Tokenstr |ta=fif%| translated:  sequence = sorted bynum .keys() %
Lexem 7 Current token='(' value='[' Tokenstr |ta=fif%(| translated:  sequence = sorted bynum .keys() % [
Lexem 8 Current token='s' value='routespans' Tokenstr |ta=fif%(s| translated:  sequence = sorted bynum .keys() % [ routespans
Lexem 9 Current token='(' value='[' Tokenstr |ta=fif%(s(| translated:  sequence = sorted bynum .keys() % [ routespans [
Lexem 10 Current token='s' value='rin' Tokenstr |ta=fif%(s(s| translated:  sequence = sorted bynum .keys() % [ routespans [ rin
Lexem 11 Current token=')' value=']' Tokenstr |ta=fif%(s(s)| translated:  sequence = sorted bynum .keys() % [ routespans [ rin ]
Lexem 12 Current token=')' value=']' Tokenstr |ta=fif%(s(s))| translated:  sequence = sorted bynum .keys() % [ routespans [ rin ] ]

Line:  120 TokenStr: =|ta=fif%(s(s))|= @ValPy:  sequence = sorted bynum .keys() % [ routespans [ rin ] ]
assignment(0, 8) =|a=fifs(s)|=  = sort bynum keys %{$routespans{$rin}}; = sort bynum keys $routespans { $rin }

Generated partial line sequence
Generated partial line sequence=
expression(2, 8, 0) =|a=fifs(s)|=  = sort bynum keys %{$routespans{$rin}}; = sort bynum keys $routespans { $rin }

function(2, 8) =|a=fifs(s)|=  = sort bynum keys %{$routespans{$rin}}; = sort bynum keys $routespans { $rin }

function start=3, end_pos=8, bracketed=0
Generated partial line sequence=sorted
Generated partial line sequence=sorted(
expression(3, 8, 0) =|a=fifs(s)|=  = sort bynum keys %{$routespans{$rin}}; = sort bynum keys $routespans { $rin }

Generated partial line sequence=sorted('bynum'
function(4, 8) =|a=fifs(s)|=  = sort bynum keys %{$routespans{$rin}}; = sort bynum keys $routespans { $rin }

function start=5, end_pos=8, bracketed=0
expression(5, 8, 0) =|a=fifs(s)|=  = sort bynum keys %{$routespans{$rin}}; = sort bynum keys $routespans { $rin }

Generated partial line sequence=sorted('bynum'routespans
Generated partial line sequence=sorted('bynum'routespans.get(
expression(7, 7, 0) =|a=fifs(s)|=  = sort bynum keys %{$routespans{$rin}}; = sort bynum keys $routespans { $rin }

Generated partial line sequence=sorted('bynum'routespans.get(rin
expression returns 8
Generated partial line sequence=sorted('bynum'routespans.get(rin)
expression returns 9
Generated partial line sequence=sorted('bynum'routespans.get(rin).keys()
expression returns 9
Generated partial line sequence=sorted('bynum'routespans.get(rin).keys())
expression returns 9
 120 | 0 |   |sequence = sorted('bynum' routespans.get(rin).keys())                                   #PL: my @sequence = sort bynum keys %{$routespans{$rin}};

Tokens: a=fifs(s) ValPy: 
 121 | 0 |   |
Main loop, line=$interfaces{$key}{vrf} = $line[($dir =~ /agnip$/) ? 21:24];


 === Line 122 Perl source:$interfaces{$key}{vrf} = $line[($dir =~ /agnip$/) ? 21:24];===

Lexem 0 Current token='s' value='interfaces' Tokenstr |s| translated: interfaces
Lexem 1 Current token='(' value='[' Tokenstr |s(| translated: interfaces [
Lexem 2 Current token='s' value='key' Tokenstr |s(s| translated: interfaces [ key
Lexem 3 Current token=')' value=']' Tokenstr |s(s)| translated: interfaces [ key ]
Lexem 4 Current token='(' value='[' Tokenstr |s(s)(| translated: interfaces [ key ] [
Lexem 5 Current token='i' value='vrf' Tokenstr |s(s)(i| translated: interfaces [ key ] [ vrf
Lexem 6 Current token=')' value=']' Tokenstr |s(s)(")| translated: interfaces [ key ] [ 'vrf' ]
Lexem 7 Current token='=' value='=' Tokenstr |s(s)(")=| translated: interfaces [ key ] [ 'vrf' ] =
Lexem 8 Current token='s' value='line' Tokenstr |s(s)(")=s| translated: interfaces [ key ] [ 'vrf' ] = line
Lexem 9 Current token='(' value='[' Tokenstr |s(s)(")=s(| translated: interfaces [ key ] [ 'vrf' ] = line [
Lexem 10 Current token='(' value='(' Tokenstr |s(s)(")=s((| translated: interfaces [ key ] [ 'vrf' ] = line [ (
Lexem 11 Current token='s' value='dir' Tokenstr |s(s)(")=s((s| translated: interfaces [ key ] [ 'vrf' ] = line [ ( dir
Lexem 12 Current token='~' value='' Tokenstr |s(s)(")=s((s~| translated: interfaces [ key ] [ 'vrf' ] = line [ ( dir 
Lexem 13 Current token='q' value='re.search(r'agnip$',' Tokenstr |s(s)(")=s((s~q| translated: interfaces [ key ] [ 'vrf' ] = line [ ( dir  re.search(r'agnip$',
Lexem 14 Current token=')' value=')' Tokenstr |s(s)(")=s((s~q)| translated: interfaces [ key ] [ 'vrf' ] = line [ ( dir  re.search(r'agnip$', )
Lexem 15 Current token='?' value='?' Tokenstr |s(s)(")=s((s~q)?| translated: interfaces [ key ] [ 'vrf' ] = line [ ( dir  re.search(r'agnip$', ) ?
Lexem 16 Current token='d' value='21' Tokenstr |s(s)(")=s((s~q)?d| translated: interfaces [ key ] [ 'vrf' ] = line [ ( dir  re.search(r'agnip$', ) ? 21
Lexem 17 Current token=':' value=':' Tokenstr |s(s)(")=s((s~q)?d:| translated: interfaces [ key ] [ 'vrf' ] = line [ ( dir  re.search(r'agnip$', ) ? 21 :
Lexem 18 Current token='d' value='24' Tokenstr |s(s)(")=s((s~q)?d:d| translated: interfaces [ key ] [ 'vrf' ] = line [ ( dir  re.search(r'agnip$', ) ? 21 : 24
Lexem 19 Current token=')' value=']' Tokenstr |s(s)(")=s((s~q)?d:d)| translated: interfaces [ key ] [ 'vrf' ] = line [ ( dir  re.search(r'agnip$', ) ? 21 : 24 ]

Line:  122 TokenStr: =|s(s)(")=s((s~q)?d:d)|= @ValPy: interfaces [ key ] [ 'vrf' ] = line [ ( dir  re.search(r'agnip$', ) ? 21 : 24 ]
handle_question_mark_colon(0, 15, 19) cond=[10:14], fval=[18:], tval=[16:16]
after handle_question_mark_colon: =|s(s)(")=s(d:(s~q):d)|=
assignment(0, 19) =|s(s)(")=s(d:(s~q):d)|= $interfaces { $key } { vrf } = $line [ 21 ? ( $dir =~ agnip$ ) : 24 ]

expression(0, 6, 0) =|s(s)(")=s(d:(s~q):d)|= $interfaces { $key } { vrf } = $line [ 21 ? ( $dir =~ agnip$ ) : 24 ]

Generated partial line interfaces
Generated partial line interfaces[
expression(2, 2, 0) =|s(s)(")=s(d:(s~q):d)|= $interfaces { $key } { vrf } = $line [ 21 ? ( $dir =~ agnip$ ) : 24 ]

Generated partial line interfaces[key
expression returns 3
Generated partial line interfaces[key]
Generated partial line interfaces[key][
expression(5, 5, 0) =|s(s)(")=s(d:(s~q):d)|= $interfaces { $key } { vrf } = $line [ 21 ? ( $dir =~ agnip$ ) : 24 ]

Generated partial line interfaces[key]['vrf'
expression returns 6
Generated partial line interfaces[key]['vrf']
expression returns 7
Generated partial line interfaces[key]['vrf']=
expression(8, 19, 0) =|s(s)(")=s(d:(s~q):d)|= $interfaces { $key } { vrf } = $line [ 21 ? ( $dir =~ agnip$ ) : 24 ]

Generated partial line interfaces[key]['vrf']=re.search(r'agnip$',
expression(8, 13, 0) =|s(s)(")=s(d:(s~q):d)|= $interfaces { $key } { vrf } = $line [ 21 ? ( $dir =~ agnip$ ) : 24 ]

Generated partial line interfaces[key]['vrf']=re.search(r'agnip$',line
Generated partial line interfaces[key]['vrf']=re.search(r'agnip$',line[
expression(10, 18, 0) =|s(s)(")=s(d:(s~q):d)|= $interfaces { $key } { vrf } = $line [ 21 ? ( $dir =~ agnip$ ) : 24 ]

Generated partial line interfaces[key]['vrf']=re.search(r'agnip$',line[21
Generated partial line interfaces[key]['vrf']=re.search(r'agnip$',line[21if
Generated partial line interfaces[key]['vrf']=re.search(r'agnip$',line[21if(
expression(13, 15, 0) =|s(s)(")=s(d:(s~q):d)|= $interfaces { $key } { vrf } = $line [ 21 ? ( $dir =~ agnip$ ) : 24 ]

Generated partial line interfaces[key]['vrf']=re.search(r'agnip$',line[21if(re.search(r'agnip$',
expression(13, 13, 0) =|s(s)(")=s(d:(s~q):d)|= $interfaces { $key } { vrf } = $line [ 21 ? ( $dir =~ agnip$ ) : 24 ]

Generated partial line interfaces[key]['vrf']=re.search(r'agnip$',line[21if(re.search(r'agnip$',dir
expression returns 14
Generated partial line interfaces[key]['vrf']=re.search(r'agnip$',line[21if(re.search(r'agnip$',dir)
expression returns 16
Generated partial line interfaces[key]['vrf']=re.search(r'agnip$',line[21if(re.search(r'agnip$',dir))
Generated partial line interfaces[key]['vrf']=re.search(r'agnip$',line[21if(re.search(r'agnip$',dir))else
Generated partial line interfaces[key]['vrf']=re.search(r'agnip$',line[21if(re.search(r'agnip$',dir))else24
expression returns 19
expression returns 14
Generated partial line interfaces[key]['vrf']=re.search(r'agnip$',line[21if(re.search(r'agnip$',dir))else24)
Generated partial line interfaces[key]['vrf']=re.search(r'agnip$',line[21if(re.search(r'agnip$',dir))else24))
Generated partial line interfaces[key]['vrf']=re.search(r'agnip$',line[21if(re.search(r'agnip$',dir))else24))else
Generated partial line interfaces[key]['vrf']=re.search(r'agnip$',line[21if(re.search(r'agnip$',dir))else24))else24
Generated partial line interfaces[key]['vrf']=re.search(r'agnip$',line[21if(re.search(r'agnip$',dir))else24))else24]
expression returns 20
 122 | 0 |   |interfaces[key]['vrf'] = re.search(r'agnip$',line[21 if (re.search(r'agnip$',dir)) else 24)) else 24] #PL: $interfaces{$key}{vrf} = $line[($dir =~ /agnip$/) ? 21:24];

Tokens: s(s)(")=s(d:(s~q):d) ValPy: 
 123 | 0 |   |
Main loop, line=sub deletefiles


 === Line 124 Perl source:sub deletefiles===

Lexem 0 Current token='k' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' value='deletefiles' Tokenstr |ki| translated: def deletefiles

Line:  125 TokenStr: =|ki|= @ValPy: def deletefiles
Generated partial line defdeletefiles(_args):
 125 | 0 |   |def deletefiles(_args):                                                                 #PL: sub deletefiles

Tokens: ki ValPy: 
 125 | 1 |   |    global options                                                                      #PL: sub deletefiles
Main loop, line={


 === Line 125 Perl source:{===


Line:  125 TokenStr: =|{|= @ValPy: {
Main loop, line=foreach $file (glob("$ldir/*/d2*.*.Z"))


 === Line 126 Perl source:foreach $file (glob("$ldir/*/d2*.*.Z"))===

Lexem 0 Current token='c' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='s' value='file' Tokenstr |cs| translated: for  file
Lexem 2 Current token='(' value='(' Tokenstr |cs(| translated: for  file (
Lexem 3 Current token='f' value='glob.glob' Tokenstr |cs(f| translated: for  file ( glob.glob
Lexem 4 Current token='(' value='(' Tokenstr |cs(f(| translated: for  file ( glob.glob (
Lexem 5 Current token='"' value='f"{ldir}/*/d2*.*.Z"' Tokenstr |cs(f("| translated: for  file ( glob.glob ( f"{ldir}/*/d2*.*.Z"
Lexem 6 Current token=')' value=')' Tokenstr |cs(f(")| translated: for  file ( glob.glob ( f"{ldir}/*/d2*.*.Z" )
Lexem 7 Current token=')' value=')' Tokenstr |cs(f("))| translated: for  file ( glob.glob ( f"{ldir}/*/d2*.*.Z" ) )

Line:  127 TokenStr: =|cs(f("))|= @ValPy: for  file ( glob.glob ( f"{ldir}/*/d2*.*.Z" ) )
control(0) =|cs(f("))|= foreach $file ( glob ( $ldir/*/d2*.*.Z ) )

Generated partial line for 
Generated partial line for file in 
expression(3, 6, 0) =|cs(f(")|= foreach $file ( glob ( $ldir/*/d2*.*.Z )

function(3, 6) =|cs(f(")|= foreach $file ( glob ( $ldir/*/d2*.*.Z )

function start=5, end_pos=5, bracketed=1
Generated partial line for file in glob.glob
Generated partial line for file in glob.glob(
expression(5, 5, 0) =|cs(f(")|= foreach $file ( glob ( $ldir/*/d2*.*.Z )

Generated partial line for file in glob.glob(f"{ldir}/*/d2*.*.Z"
expression returns 6
Generated partial line for file in glob.glob(f"{ldir}/*/d2*.*.Z")
expression returns 7
Generated partial line for file in glob.glob(f"{ldir}/*/d2*.*.Z"):
 127 | 1 |   |    for file in glob.glob(f"{ldir}/*/d2*.*.Z"):                                         #PL: foreach $file (glob("$ldir/*/d2*.*.Z"))

Tokens: cs(f(") ValPy: 
Main loop, line={


 === Line 127 Perl source:{===


Line:  127 TokenStr: =|{|= @ValPy: {
Main loop, line=next if not


 === Line 128 Perl source:next if not===

Lexem 0 Current token='k' value='continue ' Tokenstr |k| translated: continue 
Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='!' value='not' Tokenstr |c!| translated: if  not
Lexem 2 Current token='s' value='file' Tokenstr |c!s| translated: if  not file
Lexem 3 Current token='~' value='' Tokenstr |c!s~| translated: if  not file 
Lexem 4 Current token='q' value='(_m:=re.search(r'^$ldir/(\d{4})(\d{2})(\d{2})/d2*\.\d{2}\.Z$',' Tokenstr |c!s~q| translated: if  not file  (_m:=re.search(r'^$ldir/(\d{4})(\d{2})(\d{2})/d2*\.\d{2}\.Z$',

Line:  129 TokenStr: =|c!s~q|= @ValPy: if  not file  (_m:=re.search(r'^$ldir/(\d{4})(\d{2})(\d{2})/d2*\.\d{2}\.Z$',
control(0) =|c(!s~q)|= if ( not $file =~ ^$ldir/(\d{4})(\d{2})(\d{2})/d2*\.\d{2}\.Z$ )

control-parens removed, begin=0 start=1 =|c!s~q|= if not $file =~ ^$ldir/(\d{4})(\d{2})(\d{2})/d2*\.\d{2}\.Z$

Generated partial line if 
expression(1, 4, 0) =|c!s~q|= if not $file =~ ^$ldir/(\d{4})(\d{2})(\d{2})/d2*\.\d{2}\.Z$

Generated partial line if not
Generated partial line if not(_m:=re.search(r'^$ldir/(\d{4})(\d{2})(\d{2})/d2*\.\d{2}\.Z$',
expression(1, 2, 0) =|c!s~q|= if not $file =~ ^$ldir/(\d{4})(\d{2})(\d{2})/d2*\.\d{2}\.Z$

Generated partial line if not(_m:=re.search(r'^$ldir/(\d{4})(\d{2})(\d{2})/d2*\.\d{2}\.Z$',not
Generated partial line if not(_m:=re.search(r'^$ldir/(\d{4})(\d{2})(\d{2})/d2*\.\d{2}\.Z$',notfile
expression returns 3
Generated partial line if not(_m:=re.search(r'^$ldir/(\d{4})(\d{2})(\d{2})/d2*\.\d{2}\.Z$',notfile))
expression returns 5
Generated partial line if not(_m:=re.search(r'^$ldir/(\d{4})(\d{2})(\d{2})/d2*\.\d{2}\.Z$',notfile)):
 129 | 2 |   |        if not (_m:=re.search(r'^$ldir/(\d{4})(\d{2})(\d{2})/d2*\.\d{2}\.Z$', not file)): #PL: next if not
$file =~ /^$ldir\/(\d{4})(\d{2})(\d{2})\/d2*\.\d{2}\.Z$/;

Tokens: c!s~q ValPy: 
Main loop, line=$file =~ /^$ldir\/(\d{4})(\d{2})(\d{2})\/d2*\.\d{2}\.Z$/;
Main loop, line=$file =~ /^$ldir\/(\d{4})(\d{2})(\d{2})\/d2*\.\d{2}\.Z$/;
Generated partial line continue 
 129 | 3 |   |            continue                                                                    #PL: next if not
                                                                                                      #PL: $file =~ /^$ldir\/(\d{4})(\d{2})(\d{2})\/d2*\.\d{2}\.Z$/;

Tokens: k ValPy: 
Main loop, line=$file =~ /^$ldir\/(\d{4})(\d{2})(\d{2})\/d2*\.\d{2}\.Z$/;
 130 | 2 |   |
Main loop, line=`rm $file`


 === Line 131 Perl source:`rm $file`===

Lexem 0 Current token='x' value='f"rm {file}"' Tokenstr |x| translated: f"rm {file}"
Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='s' value='t' Tokenstr |cs| translated: if  t
Lexem 2 Current token='-' value='-' Tokenstr |cs-| translated: if  t -
Lexem 3 Current token='i' value='timegm' Tokenstr |cs-i| translated: if  t - timegm
Lexem 4 Current token='(' value='(' Tokenstr |cs-i(| translated: if  t - timegm (
Lexem 5 Current token='d' value='0' Tokenstr |cs-i(d| translated: if  t - timegm ( 0
Lexem 6 Current token=',' value=',' Tokenstr |cs-i(d,| translated: if  t - timegm ( 0 ,
Lexem 7 Current token='d' value='0' Tokenstr |cs-i(d,d| translated: if  t - timegm ( 0 , 0
Lexem 8 Current token=',' value=',' Tokenstr |cs-i(d,d,| translated: if  t - timegm ( 0 , 0 ,
Lexem 9 Current token='d' value='0' Tokenstr |cs-i(d,d,d| translated: if  t - timegm ( 0 , 0 , 0
Lexem 10 Current token=',' value=',' Tokenstr |cs-i(d,d,d,| translated: if  t - timegm ( 0 , 0 , 0 ,
Lexem 11 Current token='s' value='_m.group(3)' Tokenstr |cs-i(d,d,d,s| translated: if  t - timegm ( 0 , 0 , 0 , _m.group(3)
Lexem 12 Current token=',' value=',' Tokenstr |cs-i(d,d,d,s,| translated: if  t - timegm ( 0 , 0 , 0 , _m.group(3) ,
Lexem 13 Current token='s' value='_m.group(2)' Tokenstr |cs-i(d,d,d,s,s| translated: if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2)
Lexem 14 Current token='-' value='-' Tokenstr |cs-i(d,d,d,s,s-| translated: if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) -
Lexem 15 Current token='d' value='1' Tokenstr |cs-i(d,d,d,s,s-d| translated: if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1
Lexem 16 Current token=',' value=',' Tokenstr |cs-i(d,d,d,s,s-d,| translated: if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 ,
Lexem 17 Current token='s' value='_m.group(1)' Tokenstr |cs-i(d,d,d,s,s-d,s| translated: if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 , _m.group(1)
Lexem 18 Current token='-' value='-' Tokenstr |cs-i(d,d,d,s,s-d,s-| translated: if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 , _m.group(1) -
Lexem 19 Current token='d' value='1900' Tokenstr |cs-i(d,d,d,s,s-d,s-d| translated: if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 , _m.group(1) - 1900
Lexem 20 Current token=')' value=')' Tokenstr |cs-i(d,d,d,s,s-d,s-d)| translated: if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 , _m.group(1) - 1900 )
Lexem 21 Current token='>' value='>' Tokenstr |cs-i(d,d,d,s,s-d,s-d)>| translated: if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 , _m.group(1) - 1900 ) >
Lexem 22 Current token='s' value='options' Tokenstr |cs-i(d,d,d,s,s-d,s-d)>s| translated: if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 , _m.group(1) - 1900 ) > options
Lexem 23 Current token='(' value='[' Tokenstr |cs-i(d,d,d,s,s-d,s-d)>s(| translated: if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 , _m.group(1) - 1900 ) > options [
Lexem 24 Current token='i' value='maxage' Tokenstr |cs-i(d,d,d,s,s-d,s-d)>s(i| translated: if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 , _m.group(1) - 1900 ) > options [ maxage
Lexem 25 Current token=')' value=']' Tokenstr |cs-i(d,d,d,s,s-d,s-d)>s(")| translated: if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 , _m.group(1) - 1900 ) > options [ 'maxage' ]
Lexem 26 Current token='*' value='*' Tokenstr |cs-i(d,d,d,s,s-d,s-d)>s(")*| translated: if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 , _m.group(1) - 1900 ) > options [ 'maxage' ] *
Lexem 27 Current token='d' value='24' Tokenstr |cs-i(d,d,d,s,s-d,s-d)>s(")*d| translated: if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 , _m.group(1) - 1900 ) > options [ 'maxage' ] * 24
Lexem 28 Current token='*' value='*' Tokenstr |cs-i(d,d,d,s,s-d,s-d)>s(")*d*| translated: if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 , _m.group(1) - 1900 ) > options [ 'maxage' ] * 24 *
Lexem 29 Current token='d' value='60' Tokenstr |cs-i(d,d,d,s,s-d,s-d)>s(")*d*d| translated: if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 , _m.group(1) - 1900 ) > options [ 'maxage' ] * 24 * 60
Lexem 30 Current token='*' value='*' Tokenstr |cs-i(d,d,d,s,s-d,s-d)>s(")*d*d*| translated: if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 , _m.group(1) - 1900 ) > options [ 'maxage' ] * 24 * 60 *
Lexem 31 Current token='d' value='60' Tokenstr |cs-i(d,d,d,s,s-d,s-d)>s(")*d*d*d| translated: if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 , _m.group(1) - 1900 ) > options [ 'maxage' ] * 24 * 60 * 60

Line:  132 TokenStr: =|cs-i(d,d,d,s,s-d,s-d)>s(")*d*d*d|= @ValPy: if  t - timegm ( 0 , 0 , 0 , _m.group(3) , _m.group(2) - 1 , _m.group(1) - 1900 ) > options [ 'maxage' ] * 24 * 60 * 60
control(0) =|c(s-i(d,d,d,s,s-d,s-d)>s(")*d*d*d)|= if ( $t - timegm ( 0 , 0 , 0 , 3 , 2 - 1 , 1 - 1900 ) > $options { maxage } * 24 * 60 * 60 )

control-parens removed, begin=0 start=1 =|cs-i(d,d,d,s,s-d,s-d)>s(")*d*d*d|= if $t - timegm ( 0 , 0 , 0 , 3 , 2 - 1 , 1 - 1900 ) > $options { maxage } * 24 * 60 * 60

Generated partial line if 
expression(1, 31, 0) =|cs-i(d,d,d,s,s-d,s-d)>s(")*d*d*d|= if $t - timegm ( 0 , 0 , 0 , 3 , 2 - 1 , 1 - 1900 ) > $options { maxage } * 24 * 60 * 60

Generated partial line if t
Generated partial line if t-
Generated partial line if t-timegm
LINE 132 [main-W3027]:  Function timegm is neither internal not built-in function. Please check the correspondence of arguments
expression(4, 20, 1) =|cs-i(d,d,d,s,s-d,s-d)>s(")*d*d*d|= if $t - timegm ( 0 , 0 , 0 , 3 , 2 - 1 , 1 - 1900 ) > $options { maxage } * 24 * 60 * 60

Generated partial line if t-timegm(
expression(5, 19, 0) =|cs-i(d,d,d,s,s-d,s-d)>s(")*d*d*d|= if $t - timegm ( 0 , 0 , 0 , 3 , 2 - 1 , 1 - 1900 ) > $options { maxage } * 24 * 60 * 60

Generated partial line if t-timegm(0
Generated partial line if t-timegm(0,
Generated partial line if t-timegm(0,0
Generated partial line if t-timegm(0,0,
Generated partial line if t-timegm(0,0,0
Generated partial line if t-timegm(0,0,0,
Generated partial line if t-timegm(0,0,0,_m.group(3)
Generated partial line if t-timegm(0,0,0,_m.group(3),
Generated partial line if t-timegm(0,0,0,_m.group(3),_m.group(2)
Generated partial line if t-timegm(0,0,0,_m.group(3),_m.group(2)-
Generated partial line if t-timegm(0,0,0,_m.group(3),_m.group(2)-1
Generated partial line if t-timegm(0,0,0,_m.group(3),_m.group(2)-1,
Generated partial line if t-timegm(0,0,0,_m.group(3),_m.group(2)-1,_m.group(1)
Generated partial line if t-timegm(0,0,0,_m.group(3),_m.group(2)-1,_m.group(1)-
Generated partial line if t-timegm(0,0,0,_m.group(3),_m.group(2)-1,_m.group(1)-1900
expression returns 20
Generated partial line if t-timegm(0,0,0,_m.group(3),_m.group(2)-1,_m.group(1)-1900)
expression returns 21
Generated partial line if t-timegm(0,0,0,_m.group(3),_m.group(2)-1,_m.group(1)-1900)>
Generated partial line if t-timegm(0,0,0,_m.group(3),_m.group(2)-1,_m.group(1)-1900)>options
Generated partial line if t-timegm(0,0,0,_m.group(3),_m.group(2)-1,_m.group(1)-1900)>options.get(
expression(24, 24, 0) =|cs-i(d,d,d,s,s-d,s-d)>s(")*d*d*d|= if $t - timegm ( 0 , 0 , 0 , 3 , 2 - 1 , 1 - 1900 ) > $options { maxage } * 24 * 60 * 60

Generated partial line if t-timegm(0,0,0,_m.group(3),_m.group(2)-1,_m.group(1)-1900)>options.get('maxage'
expression returns 25
Generated partial line if t-timegm(0,0,0,_m.group(3),_m.group(2)-1,_m.group(1)-1900)>options.get('maxage')
Generated partial line if t-timegm(0,0,0,_m.group(3),_m.group(2)-1,_m.group(1)-1900)>options.get('maxage')*
Generated partial line if t-timegm(0,0,0,_m.group(3),_m.group(2)-1,_m.group(1)-1900)>options.get('maxage')*24
Generated partial line if t-timegm(0,0,0,_m.group(3),_m.group(2)-1,_m.group(1)-1900)>options.get('maxage')*24*
Generated partial line if t-timegm(0,0,0,_m.group(3),_m.group(2)-1,_m.group(1)-1900)>options.get('maxage')*24*60
Generated partial line if t-timegm(0,0,0,_m.group(3),_m.group(2)-1,_m.group(1)-1900)>options.get('maxage')*24*60*
Generated partial line if t-timegm(0,0,0,_m.group(3),_m.group(2)-1,_m.group(1)-1900)>options.get('maxage')*24*60*60
expression returns 32
Generated partial line if t-timegm(0,0,0,_m.group(3),_m.group(2)-1,_m.group(1)-1900)>options.get('maxage')*24*60*60:
 132 | 2 |   |        if t-timegm(0, 0, 0, _m.group(3), _m.group(2)-1, _m.group(1)-1900)>options.get('maxage')*24*60*60: #PL: `rm $file`
if $t-timegm(0,0,0,$3,$2-1,$1-1900) > $options{maxage}*24*60*60;

Tokens: cs-i(d,d,d,s,s-d,s-d)>s(")*d*d*d ValPy: 
Main loop, line=if $t-timegm(0,0,0,$3,$2-1,$1-1900) > $options{maxage}*24*60*60;
Main loop, line=if $t-timegm(0,0,0,$3,$2-1,$1-1900) > $options{maxage}*24*60*60;
Generated partial line _d=subprocess.run(f"rm {file}",capture_output=True,text=True,shell=True)
 132 | 3 |   |            _d=subprocess.run(f"rm {file}",capture_output=True,text=True,shell=True)    #PL: `rm $file`
                                                                                                      #PL: if $t-timegm(0,0,0,$3,$2-1,$1-1900) > $options{maxage}*24*60*60;

Tokens: x ValPy: 
Generated partial line _spr=_d.returncode
 132 | 3 |   |            _spr=_d.returncode                                                          #PL: `rm $file`
                                                                                                      #PL: if $t-timegm(0,0,0,$3,$2-1,$1-1900) > $options{maxage}*24*60*60;

Tokens: x ValPy: 
Main loop, line=if $t-timegm(0,0,0,$3,$2-1,$1-1900) > $options{maxage}*24*60*60;
Main loop, line=}


 === Line 133 Perl source:}===


Line:  133 TokenStr: =|}|= @ValPy: }
finish: prev_line=}, PythonCode=
finish: Resetting line to }
Main loop, line=}


 === Line 134 Perl source:}===


Line:  134 TokenStr: =|}|= @ValPy: }
 135 | 0 |   |
Main loop, line=my %hop = ( 	"AClli" => $AClli,


 === Line 136 Perl source:my %hop = ( 	"AClli" => $AClli,===

Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='h' value='hop' Tokenstr |th| translated:  hop
Lexem 2 Current token='=' value='=' Tokenstr |th=| translated:  hop =
Lexem 3 Current token='(' value='(' Tokenstr |th=(| translated:  hop = (
Lexem 4 Current token='"' value=''AClli'' Tokenstr |th=("| translated:  hop = ( 'AClli'
Lexem 5 Current token=':' value=': ' Tokenstr |th=(":| translated:  hop = ( 'AClli' : 
Lexem 6 Current token='s' value='AClli' Tokenstr |th=(":s| translated:  hop = ( 'AClli' :  AClli
Lexem 7 Current token=',' value=',' Tokenstr |th=(":s,| translated:  hop = ( 'AClli' :  AClli ,
Lexem 8 Current token='"' value=''ZClli'' Tokenstr |th=(":s,"| translated:  hop = ( 'AClli' :  AClli , 'ZClli'
Lexem 9 Current token=':' value=': ' Tokenstr |th=(":s,":| translated:  hop = ( 'AClli' :  AClli , 'ZClli' : 
Lexem 10 Current token='s' value='ZClli' Tokenstr |th=(":s,":s| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli
Lexem 11 Current token=',' value=',' Tokenstr |th=(":s,":s,| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli ,
Lexem 12 Current token='"' value=''ID'' Tokenstr |th=(":s,":s,"| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID'
Lexem 13 Current token=':' value=': ' Tokenstr |th=(":s,":s,":| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' : 
Lexem 14 Current token='s' value='circuitRow' Tokenstr |th=(":s,":s,":s| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow
Lexem 15 Current token='(' value='[' Tokenstr |th=(":s,":s,":s(| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [
Lexem 16 Current token='s' value='colNames' Tokenstr |th=(":s,":s,":s(s| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames
Lexem 17 Current token='(' value='[' Tokenstr |th=(":s,":s,":s(s(| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [
Lexem 18 Current token='"' value=''ID'' Tokenstr |th=(":s,":s,":s(s("| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID'
Lexem 19 Current token=')' value=']' Tokenstr |th=(":s,":s,":s(s(")| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ]
Lexem 20 Current token=')' value=']' Tokenstr |th=(":s,":s,":s(s("))| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ]
Lexem 21 Current token=',' value=',' Tokenstr |th=(":s,":s,":s(s(")),| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] ,
Lexem 22 Current token='"' value=''mileage'' Tokenstr |th=(":s,":s,":s(s(")),"| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage'
Lexem 23 Current token=':' value=': ' Tokenstr |th=(":s,":s,":s(s(")),":| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' : 
Lexem 24 Current token='s' value='circuitRow' Tokenstr |th=(":s,":s,":s(s(")),":s| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow
Lexem 25 Current token='(' value='[' Tokenstr |th=(":s,":s,":s(s(")),":s(| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [
Lexem 26 Current token='s' value='colNames' Tokenstr |th=(":s,":s,":s(s(")),":s(s| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames
Lexem 27 Current token='(' value='[' Tokenstr |th=(":s,":s,":s(s(")),":s(s(| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames [
Lexem 28 Current token='"' value=''mileage'' Tokenstr |th=(":s,":s,":s(s(")),":s(s("| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames [ 'mileage'
Lexem 29 Current token=')' value=']' Tokenstr |th=(":s,":s,":s(s(")),":s(s(")| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames [ 'mileage' ]
Lexem 30 Current token=')' value=']' Tokenstr |th=(":s,":s,":s(s(")),":s(s("))| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames [ 'mileage' ] ]
Lexem 31 Current token=',' value=',' Tokenstr |th=(":s,":s,":s(s(")),":s(s(")),| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames [ 'mileage' ] ] ,
Lexem 32 Current token='"' value=''type'' Tokenstr |th=(":s,":s,":s(s(")),":s(s(")),"| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames [ 'mileage' ] ] , 'type'
Lexem 33 Current token=':' value=': ' Tokenstr |th=(":s,":s,":s(s(")),":s(s(")),":| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames [ 'mileage' ] ] , 'type' : 
Lexem 34 Current token='s' value='circuitRow' Tokenstr |th=(":s,":s,":s(s(")),":s(s(")),":s| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames [ 'mileage' ] ] , 'type' :  circuitRow
Lexem 35 Current token='(' value='[' Tokenstr |th=(":s,":s,":s(s(")),":s(s(")),":s(| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames [ 'mileage' ] ] , 'type' :  circuitRow [
Lexem 36 Current token='s' value='colNames' Tokenstr |th=(":s,":s,":s(s(")),":s(s(")),":s(s| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames [ 'mileage' ] ] , 'type' :  circuitRow [ colNames
Lexem 37 Current token='(' value='[' Tokenstr |th=(":s,":s,":s(s(")),":s(s(")),":s(s(| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames [ 'mileage' ] ] , 'type' :  circuitRow [ colNames [
Lexem 38 Current token='"' value=''type'' Tokenstr |th=(":s,":s,":s(s(")),":s(s(")),":s(s("| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames [ 'mileage' ] ] , 'type' :  circuitRow [ colNames [ 'type'
Lexem 39 Current token=')' value=']' Tokenstr |th=(":s,":s,":s(s(")),":s(s(")),":s(s(")| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames [ 'mileage' ] ] , 'type' :  circuitRow [ colNames [ 'type' ]
Lexem 40 Current token=')' value=']' Tokenstr |th=(":s,":s,":s(s(")),":s(s(")),":s(s("))| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames [ 'mileage' ] ] , 'type' :  circuitRow [ colNames [ 'type' ] ]
Lexem 41 Current token=')' value=')' Tokenstr |th=(":s,":s,":s(s(")),":s(s(")),":s(s(")))| translated:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames [ 'mileage' ] ] , 'type' :  circuitRow [ colNames [ 'type' ] ] )

Line:  141 TokenStr: =|th=(":s,":s,":s(s(")),":s(s(")),":s(s(")))|= @ValPy:  hop = ( 'AClli' :  AClli , 'ZClli' :  ZClli , 'ID' :  circuitRow [ colNames [ 'ID' ] ] , 'mileage' :  circuitRow [ colNames [ 'mileage' ] ] , 'type' :  circuitRow [ colNames [ 'type' ] ] )
Generated partial line hop = {
Generated partial line hop = {'AClli'
Generated partial line hop = {'AClli': 
Generated partial line hop = {'AClli': AClli
Generated partial line hop = {'AClli': AClli,
Generated partial line hop = {'AClli': AClli,'ZClli'
Generated partial line hop = {'AClli': AClli,'ZClli': 
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli,
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli,'ID'
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli,'ID': 
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli,'ID': circuitRow
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli,'ID': circuitRow[
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli,'ID': circuitRow[colNames
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli,'ID': circuitRow[colNames[
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli,'ID': circuitRow[colNames['ID'
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli,'ID': circuitRow[colNames['ID']
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli,'ID': circuitRow[colNames['ID']]
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli,'ID': circuitRow[colNames['ID']]:
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli,'ID': circuitRow[colNames['ID']]:'mileage'
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli,'ID': circuitRow[colNames['ID']]:'mileage': 
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli,'ID': circuitRow[colNames['ID']]:'mileage': circuitRow
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli,'ID': circuitRow[colNames['ID']]:'mileage': circuitRow[
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli,'ID': circuitRow[colNames['ID']]:'mileage': circuitRow[colNames
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli,'ID': circuitRow[colNames['ID']]:'mileage': circuitRow[colNames[
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli,'ID': circuitRow[colNames['ID']]:'mileage': circuitRow[colNames['mileage'
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli,'ID': circuitRow[colNames['ID']]:'mileage': circuitRow[colNames['mileage']
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli,'ID': circuitRow[colNames['ID']]:'mileage': circuitRow[colNames['mileage']]
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli,'ID': circuitRow[colNames['ID']]:'mileage': circuitRow[colNames['mileage']],
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli,'ID': circuitRow[colNames['ID']]:'mileage': circuitRow[colNames['mileage']],'type'
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli,'ID': circuitRow[colNames['ID']]:'mileage': circuitRow[colNames['mileage']],'type': 
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli,'ID': circuitRow[colNames['ID']]:'mileage': circuitRow[colNames['mileage']],'type': circuitRow
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli,'ID': circuitRow[colNames['ID']]:'mileage': circuitRow[colNames['mileage']],'type': circuitRow[
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli,'ID': circuitRow[colNames['ID']]:'mileage': circuitRow[colNames['mileage']],'type': circuitRow[colNames
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli,'ID': circuitRow[colNames['ID']]:'mileage': circuitRow[colNames['mileage']],'type': circuitRow[colNames[
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli,'ID': circuitRow[colNames['ID']]:'mileage': circuitRow[colNames['mileage']],'type': circuitRow[colNames['type'
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli,'ID': circuitRow[colNames['ID']]:'mileage': circuitRow[colNames['mileage']],'type': circuitRow[colNames['type']
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli,'ID': circuitRow[colNames['ID']]:'mileage': circuitRow[colNames['mileage']],'type': circuitRow[colNames['type']]
Generated partial line hop = {'AClli': AClli,'ZClli': ZClli,'ID': circuitRow[colNames['ID']]:'mileage': circuitRow[colNames['mileage']],'type': circuitRow[colNames['type']]}
 141 | 0 |   |hop = {'AClli': AClli, 'ZClli': ZClli, 'ID': circuitRow[colNames['ID']]:'mileage': circuitRow[colNames['mileage']], 'type': circuitRow[colNames['type']]}
                                                                                                      #PL: my %hop = ( 	"AClli" => $AClli,
                                                                                                      #PL: "ZClli" => $ZClli,
                                                                                                      #PL: "ID" => $circuitRow[$colNames{"ID"}],
                                                                                                      #PL: "mileage" => $circuitRow[$colNames{"mileage"}],
                                                                                                      #PL: "type" => $circuitRow[$colNames{"type"}]
                                                                                                      #PL: );

Tokens: h=(":s,":s,":s(s(")),":s(s(")),":s(s("))) ValPy: 
 142 | 0 |   |
Main loop, line=if (exists $atm{$r}{$vpi}{$vci})


 === Line 143 Perl source:if (exists $atm{$r}{$vpi}{$vci})===

Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='f' value='in' Tokenstr |c(f| translated: if  ( in
Lexem 3 Current token='s' value='atm' Tokenstr |c(fs| translated: if  ( in atm
Lexem 4 Current token='(' value='[' Tokenstr |c(fs(| translated: if  ( in atm [
Lexem 5 Current token='s' value='r' Tokenstr |c(fs(s| translated: if  ( in atm [ r
Lexem 6 Current token=')' value=']' Tokenstr |c(fs(s)| translated: if  ( in atm [ r ]
Lexem 7 Current token='(' value='[' Tokenstr |c(fs(s)(| translated: if  ( in atm [ r ] [
Lexem 8 Current token='s' value='vpi' Tokenstr |c(fs(s)(s| translated: if  ( in atm [ r ] [ vpi
Lexem 9 Current token=')' value=']' Tokenstr |c(fs(s)(s)| translated: if  ( in atm [ r ] [ vpi ]
Lexem 10 Current token='(' value='[' Tokenstr |c(fs(s)(s)(| translated: if  ( in atm [ r ] [ vpi ] [
Lexem 11 Current token='s' value='vci' Tokenstr |c(fs(s)(s)(s| translated: if  ( in atm [ r ] [ vpi ] [ vci
Lexem 12 Current token=')' value=']' Tokenstr |c(fs(s)(s)(s)| translated: if  ( in atm [ r ] [ vpi ] [ vci ]
Lexem 13 Current token=')' value=')' Tokenstr |c(fs(s)(s)(s))| translated: if  ( in atm [ r ] [ vpi ] [ vci ] )

Line:  144 TokenStr: =|c(fs(s)(s)(s))|= @ValPy: if  ( in atm [ r ] [ vpi ] [ vci ] )
control(0) =|c(fs(s)(s)(s))|= if ( exists $atm { $r } { $vpi } { $vci } )

control-parens removed, begin=0 start=1 =|cfs(s)(s)(s)|= if exists $atm { $r } { $vpi } { $vci }

Generated partial line if 
expression(1, 11, 0) =|cfs(s)(s)(s)|= if exists $atm { $r } { $vpi } { $vci }

function(1, 11) =|cfs(s)(s)(s)|= if exists $atm { $r } { $vpi } { $vci }

function start=2, end_pos=11, bracketed=0
exists k=4, length(ValPerl)=11, end_pos=11, limit=11

expression(3, 11, 1) =|cfs(s)(s)(s)|= if exists $atm { $r } { $vpi } { $vci }

Generated partial line if .get(
expression(4, 4, 0) =|cfs(s)(s)(s)|= if exists $atm { $r } { $vpi } { $vci }

Generated partial line if .get(r
expression returns 5
Generated partial line if .get(r)
Generated partial line if .get(r).get(
expression(7, 7, 0) =|cfs(s)(s)(s)|= if exists $atm { $r } { $vpi } { $vci }

Generated partial line if .get(r).get(vpi
expression returns 8
Generated partial line if .get(r).get(vpi)
Generated partial line if .get(r).get(vpi).get(
expression(10, 10, 0) =|cfs(s)(s)(s)|= if exists $atm { $r } { $vpi } { $vci }

Generated partial line if .get(r).get(vpi).get(vci
expression returns 11
Generated partial line if .get(r).get(vpi).get(vci)
expression returns 12
expression returns 12
Generated partial line if .get(r).get(vpi).get(vci):
 144 | 0 |   |if .get(r).get(vpi).get(vci):                                                           #PL: if (exists $atm{$r}{$vpi}{$vci})

Tokens: cfs(s)(s)(s) ValPy: 
Main loop, line={


 === Line 144 Perl source:{===


Line:  144 TokenStr: =|{|= @ValPy: {
Main loop, line=$i = $atm{$r}{$vpi}{$vci};


 === Line 145 Perl source:$i = $atm{$r}{$vpi}{$vci};===

Lexem 0 Current token='s' value='i' Tokenstr |s| translated: i
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: i =
Lexem 2 Current token='s' value='atm' Tokenstr |s=s| translated: i = atm
Lexem 3 Current token='(' value='[' Tokenstr |s=s(| translated: i = atm [
Lexem 4 Current token='s' value='r' Tokenstr |s=s(s| translated: i = atm [ r
Lexem 5 Current token=')' value=']' Tokenstr |s=s(s)| translated: i = atm [ r ]
Lexem 6 Current token='(' value='[' Tokenstr |s=s(s)(| translated: i = atm [ r ] [
Lexem 7 Current token='s' value='vpi' Tokenstr |s=s(s)(s| translated: i = atm [ r ] [ vpi
Lexem 8 Current token=')' value=']' Tokenstr |s=s(s)(s)| translated: i = atm [ r ] [ vpi ]
Lexem 9 Current token='(' value='[' Tokenstr |s=s(s)(s)(| translated: i = atm [ r ] [ vpi ] [
Lexem 10 Current token='s' value='vci' Tokenstr |s=s(s)(s)(s| translated: i = atm [ r ] [ vpi ] [ vci
Lexem 11 Current token=')' value=']' Tokenstr |s=s(s)(s)(s)| translated: i = atm [ r ] [ vpi ] [ vci ]

Line:  145 TokenStr: =|s=s(s)(s)(s)|= @ValPy: i = atm [ r ] [ vpi ] [ vci ]
assignment(0, 11) =|s=s(s)(s)(s)|= $i = $atm { $r } { $vpi } { $vci }

Generated partial line i
Generated partial line i=
expression(2, 11, 0) =|s=s(s)(s)(s)|= $i = $atm { $r } { $vpi } { $vci }

Generated partial line i=atm
Generated partial line i=atm.get(
expression(4, 4, 0) =|s=s(s)(s)(s)|= $i = $atm { $r } { $vpi } { $vci }

Generated partial line i=atm.get(r
expression returns 5
Generated partial line i=atm.get(r)
Generated partial line i=atm.get(r).get(
expression(7, 7, 0) =|s=s(s)(s)(s)|= $i = $atm { $r } { $vpi } { $vci }

Generated partial line i=atm.get(r).get(vpi
expression returns 8
Generated partial line i=atm.get(r).get(vpi)
Generated partial line i=atm.get(r).get(vpi).get(
expression(10, 10, 0) =|s=s(s)(s)(s)|= $i = $atm { $r } { $vpi } { $vci }

Generated partial line i=atm.get(r).get(vpi).get(vci
expression returns 11
Generated partial line i=atm.get(r).get(vpi).get(vci)
expression returns 12
 145 | 1 |   |    i = atm.get(r).get(vpi).get(vci)                                                    #PL: $i = $atm{$r}{$vpi}{$vci};

Tokens: s=s(s)(s)(s) ValPy: 
Main loop, line=}


 === Line 146 Perl source:}===


Line:  146 TokenStr: =|}|= @ValPy: }
 147 | 0 |   |
Main loop, line=sub make_location_header


 === Line 148 Perl source:sub make_location_header===

Lexem 0 Current token='k' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' value='make_location_header' Tokenstr |ki| translated: def make_location_header

Line:  149 TokenStr: =|ki|= @ValPy: def make_location_header
Generated partial line defmake_location_header(_args):
 149 | 0 |   |def make_location_header(_args):                                                        #PL: sub make_location_header

Tokens: ki ValPy: 
Main loop, line={


 === Line 149 Perl source:{===


Line:  149 TokenStr: =|{|= @ValPy: {
Main loop, line=$locdat = "CTTPS:Location\n";


 === Line 150 Perl source:$locdat = "CTTPS:Location\n";===

Lexem 0 Current token='s' value='locdat' Tokenstr |s| translated: locdat
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: locdat =
Lexem 2 Current token='"' value=''CTTPS:Location\n'' Tokenstr |s="| translated: locdat = 'CTTPS:Location\n'

Line:  150 TokenStr: =|s="|= @ValPy: locdat = 'CTTPS:Location\n'
assignment(0, 2) =|s="|= $locdat = CTTPS:Location\n

Generated partial line locdat
Generated partial line locdat=
assign, ValClass[limit] = ", ValPy='CTTPS:Location\n', ValPerl=CTTPS:Location\n

Generated partial line locdat='CTTPS:Location\n'
 150 | 1 |   |    locdat = 'CTTPS:Location\n'                                                         #PL: $locdat = "CTTPS:Location\n";

Tokens: s=" ValPy: 
Main loop, line=$locdat .= "#PlanVersion    RunID   Clli    Longitude       Latitude\n";


 === Line 151 Perl source:$locdat .= "#PlanVersion    RunID   Clli    Longitude       Latitude\n";===

Lexem 0 Current token='s' value='locdat' Tokenstr |s| translated: locdat
Lexem 1 Current token='=' value='+=' Tokenstr |s=| translated: locdat +=
Lexem 2 Current token='"' value=''#PlanVersion    RunID   Clli    Longitude       Latitude\n'' Tokenstr |s="| translated: locdat += '#PlanVersion    RunID   Clli    Longitude       Latitude\n'

Line:  151 TokenStr: =|s="|= @ValPy: locdat += '#PlanVersion    RunID   Clli    Longitude       Latitude\n'
assignment(0, 2) =|s="|= $locdat .= #PlanVersion    RunID   Clli    Longitude       Latitude\n

Generated partial line locdat
Generated partial line locdat+=
assign, ValClass[limit] = ", ValPy='#PlanVersion    RunID   Clli    Longitude       Latitude\n', ValPerl=#PlanVersion    RunID   Clli    Longitude       Latitude\n

Generated partial line locdat+='#PlanVersion    RunID   Clli    Longitude       Latitude\n'
 151 | 1 |   |    locdat += '#PlanVersion    RunID   Clli    Longitude       Latitude\n'              #PL: $locdat .= "#PlanVersion    RunID   Clli    Longitude       Latitude\n";

Tokens: s=" ValPy: 
finish: prev_line=$locdat .= "#PlanVersion    RunID   Clli    Longitude       Latitude\n";, PythonCode=
finish: Resetting line to return $locdat .;
Main loop, line=return $locdat .;


 === Line 152 Perl source:return $locdat .;===

Lexem 0 Current token='k' value='return' Tokenstr |k| translated: return
Lexem 1 Current token='s' value='locdat' Tokenstr |ks| translated: return locdat
Lexem 2 Current token='.' value=' + ' Tokenstr |ks.| translated: return locdat  + 

Line:  152 TokenStr: =|ks.|= @ValPy: return locdat  + 
fix_string_catentation1 i=2, j=-1

Use of uninitialized value within @ValClass in string eq at ../pythonizer line 852, <> line 152.
Use of uninitialized value within @ValClass in string eq at ../pythonizer line 852, <> line 152.
fix_string_catentation2 i=5, j=6

function(0, 8) =|f(ks).f()|= str ( return $locdat ) . str ( )

function start=2, end_pos=3, bracketed=1
Generated partial line str
Generated partial line str(
expression(2, 3, 0) =|f(ks).f()|= str ( return $locdat ) . str ( )

Generated partial line str(return
Generated partial line str(returnlocdat
expression returns 4
Generated partial line str(returnlocdat)
 152 | 1 |   |    str(return locdat)                                                                  #PL: 

Tokens: f(ks).f() ValPy: 
finish: prev_line=return $locdat .;, PythonCode=
finish: Resetting line to }
Main loop, line=}


 === Line 152 Perl source:}===


Line:  152 TokenStr: =|}|= @ValPy: }
 153 | 0 |   |
 154 | 0 |   |'''
 154 | 0 |   |=head1 NAME
 155 | 0 |   |

 156 | 0 |   |setroutes.pl - Set preferred routes for PVCs

 157 | 0 |   |

 158 | 0 |   |=cut

 159 | 0 |   |'''
Main loop, line=


 === Line 159 Perl source:===


Line:  159 TokenStr: =||= @ValPy: 
 159 | 0 |   |pass                                                                                    #PL: 

Tokens:  ValPy: 
 160 | 0 |   |
 161 | 0 |   |# Generate bad code:
 162 | 0 |   |
Main loop, line=umask(022);


 === Line 163 Perl source:umask(022);===

Lexem 0 Current token='f' value='os.umask' Tokenstr |f| translated: os.umask
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: os.umask (
Lexem 2 Current token='d' value='0o22' Tokenstr |f(d| translated: os.umask ( 0o22
Lexem 3 Current token=')' value=')' Tokenstr |f(d)| translated: os.umask ( 0o22 )

Line:  163 TokenStr: =|f(d)|= @ValPy: os.umask ( 0o22 )
function(0, 3) =|f(d)|= umask ( 022 )

function start=2, end_pos=2, bracketed=1
Generated partial line os.umask
Generated partial line os.umask(
expression(2, 2, 0) =|f(d)|= umask ( 022 )

Generated partial line os.umask(0o22
expression returns 3
Generated partial line os.umask(0o22)
 163 | 0 |   |os.umask(0o22)                                                                          #PL: umask(022);

Tokens: f(d) ValPy: 
 164 | 0 |   |
 165 | 0 |   |# We should guess this is an email address by looking at the char prior to @:
Main loop, line=$options{other} = "m66828@zlp23061.vci.att.com";


 === Line 166 Perl source:$options{other} = "m66828@zlp23061.vci.att.com";===

Lexem 0 Current token='s' value='options' Tokenstr |s| translated: options
Lexem 1 Current token='(' value='[' Tokenstr |s(| translated: options [
Lexem 2 Current token='i' value='other' Tokenstr |s(i| translated: options [ other
Lexem 3 Current token=')' value=']' Tokenstr |s(")| translated: options [ 'other' ]
Lexem 4 Current token='=' value='=' Tokenstr |s(")=| translated: options [ 'other' ] =
Lexem 5 Current token='"' value='f"m66828@zlp23061.vci.att.com"' Tokenstr |s(")="| translated: options [ 'other' ] = f"m66828@zlp23061.vci.att.com"

Line:  166 TokenStr: =|s(")="|= @ValPy: options [ 'other' ] = f"m66828@zlp23061.vci.att.com"
assignment(0, 5) =|s(")="|= $options { other } = m66828@zlp23061.vci.att.com

expression(0, 3, 0) =|s(")="|= $options { other } = m66828@zlp23061.vci.att.com

Generated partial line options
Generated partial line options[
expression(2, 2, 0) =|s(")="|= $options { other } = m66828@zlp23061.vci.att.com

Generated partial line options['other'
expression returns 3
Generated partial line options['other']
expression returns 4
Generated partial line options['other']=
assign, ValClass[limit] = ", ValPy=f"m66828@zlp23061.vci.att.com", ValPerl=m66828@zlp23061.vci.att.com

Generated partial line options['other']=f"m66828@zlp23061.vci.att.com"
 166 | 0 |   |options['other'] = f"m66828@zlp23061.vci.att.com"                                       #PL: $options{other} = "m66828@zlp23061.vci.att.com";

Tokens: s(")=" ValPy: 
 167 | 0 |   |
Main loop, line=sub makebytes


 === Line 168 Perl source:sub makebytes===

Lexem 0 Current token='k' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' value='makebytes' Tokenstr |ki| translated: def makebytes

Line:  169 TokenStr: =|ki|= @ValPy: def makebytes
Generated partial line defmakebytes(_args):
 169 | 0 |   |def makebytes(_args):                                                                   #PL: sub makebytes

Tokens: ki ValPy: 
Main loop, line={


 === Line 169 Perl source:{===


Line:  169 TokenStr: =|{|= @ValPy: {
Main loop, line=local *LOG;


 === Line 170 Perl source:local *LOG;===

Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='*' value='*' Tokenstr |t*| translated:  *
Lexem 2 Current token='i' value='LOG' Tokenstr |t*i| translated:  * LOG

Line:  170 TokenStr: =|t*i|= @ValPy:  * LOG
 171 | 1 |   |
Main loop, line=open(LOG, '<', 'myfile.f') or die("Can't open myfile.f");


 === Line 172 Perl source:open(LOG, '<', 'myfile.f') or die("Can't open myfile.f");===

Lexem 0 Current token='f' value='open' Tokenstr |f| translated: open
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: open (
Lexem 2 Current token='i' value='LOG' Tokenstr |f(i| translated: open ( LOG
Lexem 3 Current token=',' value=',' Tokenstr |f(i,| translated: open ( LOG ,
Lexem 4 Current token='"' value=''<'' Tokenstr |f(i,"| translated: open ( LOG , '<'
Lexem 5 Current token=',' value=',' Tokenstr |f(i,",| translated: open ( LOG , '<' ,
Lexem 6 Current token='"' value=''myfile.f'' Tokenstr |f(i,","| translated: open ( LOG , '<' , 'myfile.f'
Lexem 7 Current token=')' value=')' Tokenstr |f(i,",")| translated: open ( LOG , '<' , 'myfile.f' )
bash_style_or_and_fix(2) is_or=1
After bash_style_or_and_fix(2): =|c(!(f(i,",")))|=

Line:  172 TokenStr: =|c(!(f(i,",")))|= @ValPy: if ( not ( open ( LOG , '<' , 'myfile.f' ) ) )
control(0) =|c(!(f(i,",")))|= if ( not ( open ( LOG , < , myfile.f ) ) )

control-parens removed, begin=0 start=1 =|c!(f(i,","))|= if not ( open ( LOG , < , myfile.f ) )

Generated partial line if
expression(1, 11, 0) =|c!(f(i,","))|= if not ( open ( LOG , < , myfile.f ) )

Generated partial line ifnot
Generated partial line ifnot(
expression(3, 10, 0) =|c!(f(i,","))|= if not ( open ( LOG , < , myfile.f ) )

function(3, 10) =|c!(f(i,","))|= if not ( open ( LOG , < , myfile.f ) )

function start=5, end_pos=9, bracketed=1
Generated partial line ifnot((LOG:=_perl_open('myfile.f', 'r'))
expression returns 11
Generated partial line ifnot((LOG:=_perl_open('myfile.f', 'r')))
expression returns 12
Generated partial line ifnot((LOG:=_perl_open('myfile.f', 'r'))):
 172 | 1 |   |    if not ((LOG:=_perl_open('myfile.f', 'r'))):                                        #PL: open(LOG, '<', 'myfile.f') or die("Can't open myfile.f");

Tokens: c!(f(i,",")) ValPy: 
Main loop, line={


 === Line 172 Perl source:{===


Line:  172 TokenStr: =|{|= @ValPy: {
Main loop, line=die("Can't open myfile.f");


 === Line 172 Perl source:die("Can't open myfile.f");===

Lexem 0 Current token='f' value='raise Die' Tokenstr |f| translated: raise Die
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: raise Die (
Lexem 2 Current token='"' value='"Can't open myfile.f"' Tokenstr |f("| translated: raise Die ( "Can't open myfile.f"
Lexem 3 Current token=')' value=')' Tokenstr |f(")| translated: raise Die ( "Can't open myfile.f" )

Line:  172 TokenStr: =|f(")|= @ValPy: raise Die ( "Can't open myfile.f" )
function(0, 3) =|f(")|= die ( Can't open myfile.f )

function start=2, end_pos=2, bracketed=1
Generated partial line raise Die
Generated partial line raise Die(
expression(2, 2, 0) =|f(")|= die ( Can't open myfile.f )

Generated partial line raise Die("Can't open myfile.f"
expression returns 3
Generated partial line raise Die("Can't open myfile.f")
 172 | 2 |   |        raise Die("Can't open myfile.f")                                                #PL: die("Can't open myfile.f");

Tokens: f(") ValPy: 
Main loop, line=}


 === Line 172 Perl source:}===


Line:  172 TokenStr: =|}|= @ValPy: }
finish: prev_line=}, PythonCode=
finish: Resetting line to }
Main loop, line=}


 === Line 173 Perl source:}===


Line:  173 TokenStr: =|}|= @ValPy: }
 174 | 0 |   |
Main loop, line=sub getTmpFileName {


 === Line 175 Perl source:sub getTmpFileName {===

Lexem 0 Current token='k' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' value='getTmpFileName' Tokenstr |ki| translated: def getTmpFileName

Line:  175 TokenStr: =|ki|= @ValPy: def getTmpFileName
Generated partial line defgetTmpFileName(_args):
 175 | 0 |   |def getTmpFileName(_args):                                                              #PL: sub getTmpFileName {

Tokens: ki ValPy: 
Main loop, line={


 === Line 175 Perl source:{===


Line:  175 TokenStr: =|{|= @ValPy: {
Main loop, line=my $fileName;


 === Line 176 Perl source:my $fileName;===

Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='s' value='fileName' Tokenstr |ts| translated:  fileName

Line:  176 TokenStr: =|ts|= @ValPy:  fileName
 176 | 1 |   |    fileName=None                                                                       #PL: my $fileName;
Main loop, line=do { $fileName = POSIX::tmpnam() }


 === Line 177 Perl source:do { $fileName = POSIX::tmpnam() }===

Lexem 0 Current token='i' value='' Tokenstr |i| translated: 
Lexem 1 Current token='(' value='[' Tokenstr |i(| translated:  [
Lexem 2 Current token='s' value='fileName' Tokenstr |i(s| translated:  [ fileName
Lexem 3 Current token='=' value='=' Tokenstr |i(s=| translated:  [ fileName =
Lexem 4 Current token='i' value='POSIX.tmpnam' Tokenstr |i(s=i| translated:  [ fileName = POSIX.tmpnam
Lexem 5 Current token='(' value='(' Tokenstr |i(s=i(| translated:  [ fileName = POSIX.tmpnam (
Lexem 6 Current token=')' value=')' Tokenstr |i(s=i()| translated:  [ fileName = POSIX.tmpnam ( )

Line:  177 TokenStr: =|i(s=i()|= @ValPy:  [ fileName = POSIX.tmpnam ( )
Generated partial line 
Generated partial line ([
expression(2, 5, -1) =|i(s=i()|= do { $fileName = POSIX::tmpnam ( )

Generated partial line ([fileName
Generated partial line ([fileName=
Generated partial line ([fileName=POSIX.tmpnam
LINE 177 [main-W3027]:  Function POSIX.tmpnam is neither internal not built-in function. Please check the correspondence of arguments
expression(5, 6, 1) =|i(s=i()|= do { $fileName = POSIX::tmpnam ( )

Generated partial line ([fileName=POSIX.tmpnam(
expression(6, 5, 0) =|i(s=i()|= do { $fileName = POSIX::tmpnam ( )

expression returns 6
Generated partial line ([fileName=POSIX.tmpnam()
expression returns 7
expression returns 6
Generated partial line ([fileName=POSIX.tmpnam()])
 177 | 1 |   |    ([fileName = POSIX.tmpnam()])                                                       #PL: do { $fileName = POSIX::tmpnam() }

Tokens: i(s=i() ValPy: 
finish: prev_line=do { $fileName = POSIX::tmpnam() }, PythonCode=
finish: Resetting line to return do { $fileName ;
Main loop, line=return do { $fileName ;


 === Line 177 Perl source:return do { $fileName ;===

Lexem 0 Current token='k' value='return' Tokenstr |k| translated: return
Lexem 1 Current token='i' value='' Tokenstr |ki| translated: return 

Line:  177 TokenStr: =|ki|= @ValPy: return 
Generated partial line return
expression(1, 1, 0) =|ki|= return do

Generated partial line return
expression returns 2
 177 | 1 |   |    return                                                                              #PL: 

Tokens: ki ValPy: 
Main loop, line=}


 === Line 177 Perl source:}===


Line:  177 TokenStr: =|}|= @ValPy: }
Main loop, line={


 === Line 177 Perl source:{===


Line:  177 TokenStr: =|{|= @ValPy: {
 177 | 0 |   |if True:                                                                                #PL: 

Tokens: { ValPy: 
Main loop, line=until $fh = IO::File->new($fileName, O_RDWR|O_CREAT|O_EXCL);


 === Line 178 Perl source:until $fh = IO::File->new($fileName, O_RDWR|O_CREAT|O_EXCL);===

Lexem 0 Current token='c' value='while not ' Tokenstr |c| translated: while not 
Lexem 1 Current token='s' value='fh' Tokenstr |cs| translated: while not  fh
Lexem 2 Current token='=' value=':=' Tokenstr |cs=| translated: while not  fh :=
Lexem 3 Current token='i' value='IO.File' Tokenstr |cs=i| translated: while not  fh := IO.File
Lexem 4 Current token='.' value='.' Tokenstr |cs=i.| translated: while not  fh := IO.File .
Lexem 5 Current token='i' value='new' Tokenstr |cs=i.i| translated: while not  fh := IO.File . new
Lexem 6 Current token='(' value='(' Tokenstr |cs=i.i(| translated: while not  fh := IO.File . new (
Lexem 7 Current token='s' value='fileName' Tokenstr |cs=i.i(s| translated: while not  fh := IO.File . new ( fileName
Lexem 8 Current token=',' value=',' Tokenstr |cs=i.i(s,| translated: while not  fh := IO.File . new ( fileName ,
Lexem 9 Current token='i' value='os.O_RDWR' Tokenstr |cs=i.i(s,i| translated: while not  fh := IO.File . new ( fileName , os.O_RDWR
Lexem 10 Current token='|' value='|' Tokenstr |cs=i.i(s,i|| translated: while not  fh := IO.File . new ( fileName , os.O_RDWR |
Lexem 11 Current token='i' value='os.O_CREAT' Tokenstr |cs=i.i(s,i|i| translated: while not  fh := IO.File . new ( fileName , os.O_RDWR | os.O_CREAT
Lexem 12 Current token='|' value='|' Tokenstr |cs=i.i(s,i|i|| translated: while not  fh := IO.File . new ( fileName , os.O_RDWR | os.O_CREAT |
Lexem 13 Current token='i' value='os.O_EXCL' Tokenstr |cs=i.i(s,i|i|i| translated: while not  fh := IO.File . new ( fileName , os.O_RDWR | os.O_CREAT | os.O_EXCL
Lexem 14 Current token=')' value=')' Tokenstr |cs=i.i(s,i|i|i)| translated: while not  fh := IO.File . new ( fileName , os.O_RDWR | os.O_CREAT | os.O_EXCL )

Line:  178 TokenStr: =|cs=i.i(s,i|i|i)|= @ValPy: while not  fh := IO.File . new ( fileName , os.O_RDWR | os.O_CREAT | os.O_EXCL )
control(0) =|cs=i.i(s,i|i|i)|= until $fh = IO::File -> new ( $fileName , O_RDWR | O_CREAT | O_EXCL )

Generated partial line while not 
expression(1, 14, 0) =|cs=i.i(s,i|i|i)|= until $fh = IO::File -> new ( $fileName , O_RDWR | O_CREAT | O_EXCL )

Generated partial line while not fh
Generated partial line while not fh:=
Generated partial line while not fh:=IO.File
Generated partial line while not fh:=IO.File.
Generated partial line while not fh:=IO.File.new
LINE 178 [main-W3027]:  Function new is neither internal not built-in function. Please check the correspondence of arguments
expression(6, 14, 1) =|cs=i.i(s,i|i|i)|= until $fh = IO::File -> new ( $fileName , O_RDWR | O_CREAT | O_EXCL )

Generated partial line while not fh:=IO.File.new(
expression(7, 13, 0) =|cs=i.i(s,i|i|i)|= until $fh = IO::File -> new ( $fileName , O_RDWR | O_CREAT | O_EXCL )

Generated partial line while not fh:=IO.File.new(fileName
Generated partial line while not fh:=IO.File.new(fileName,
Generated partial line while not fh:=IO.File.new(fileName,os.O_RDWR
Generated partial line while not fh:=IO.File.new(fileName,os.O_RDWR|
Generated partial line while not fh:=IO.File.new(fileName,os.O_RDWR|os.O_CREAT
Generated partial line while not fh:=IO.File.new(fileName,os.O_RDWR|os.O_CREAT|
Generated partial line while not fh:=IO.File.new(fileName,os.O_RDWR|os.O_CREAT|os.O_EXCL
expression returns 14
Generated partial line while not fh:=IO.File.new(fileName,os.O_RDWR|os.O_CREAT|os.O_EXCL)
expression returns 15
expression returns 15
Generated partial line while not fh:=IO.File.new(fileName,os.O_RDWR|os.O_CREAT|os.O_EXCL):
 178 | 1 |   |    while not fh:=IO.File.new(fileName, os.O_RDWR|os.O_CREAT|os.O_EXCL):                #PL: until $fh = IO::File->new($fileName, O_RDWR|O_CREAT|O_EXCL);

Tokens: cs=i.i(s,i|i|i) ValPy: 
 179 | 1 |   |
 180 | 1 |   |    #    END { unlink($fileName) };
Main loop, line=return $fileName;


 === Line 181 Perl source:return $fileName;===

Lexem 0 Current token='k' value='return' Tokenstr |k| translated: return
Lexem 1 Current token='s' value='fileName' Tokenstr |ks| translated: return fileName

Line:  181 TokenStr: =|ks|= @ValPy: return fileName
Generated partial line return
expression(1, 1, 0) =|ks|= return $fileName

Generated partial line returnfileName
expression returns 2
 181 | 1 |   |    return fileName                                                                     #PL: return $fileName;

Tokens: ks ValPy: 
 182 | 1 |   |
Main loop, line=}


 === Line 183 Perl source:}===


Line:  183 TokenStr: =|}|= @ValPy: }
 184 | 0 |   |
Main loop, line=next if not open(CACHE_LOCK,"<$cachelock");


 === Line 185 Perl source:next if not open(CACHE_LOCK,"<$cachelock");===

Lexem 0 Current token='k' value='continue ' Tokenstr |k| translated: continue 
Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='!' value='not' Tokenstr |c!| translated: if  not
Lexem 2 Current token='f' value='open' Tokenstr |c!f| translated: if  not open
Lexem 3 Current token='(' value='(' Tokenstr |c!f(| translated: if  not open (
Lexem 4 Current token='i' value='CACHE_LOCK' Tokenstr |c!f(i| translated: if  not open ( CACHE_LOCK
Lexem 5 Current token=',' value=',' Tokenstr |c!f(i,| translated: if  not open ( CACHE_LOCK ,
Lexem 6 Current token='"' value='f"<{cachelock}"' Tokenstr |c!f(i,"| translated: if  not open ( CACHE_LOCK , f"<{cachelock}"
Lexem 7 Current token=')' value=')' Tokenstr |c!f(i,")| translated: if  not open ( CACHE_LOCK , f"<{cachelock}" )

Line:  185 TokenStr: =|c!f(i,")|= @ValPy: if  not open ( CACHE_LOCK , f"<{cachelock}" )
 185 | 0 |   |try:                                                                                    #PL: next if not open(CACHE_LOCK,"<$cachelock");
 185 | 1 |   |    CACHE_LOCK=open(f"{cachelock}", 'r')                                                #PL: next if not open(CACHE_LOCK,"<$cachelock");
Generated partial line except OSError as _e:
 185 | 1 |   |    OS_ERROR = str(_e)                                                                  #PL: next if not open(CACHE_LOCK,"<$cachelock");
 185 | 1 |   |    traceback.print_exc()                                                               #PL: next if not open(CACHE_LOCK,"<$cachelock");
 185 | 1 |   |    raise                                                                               #PL: next if not open(CACHE_LOCK,"<$cachelock");
 185 | 0 |   |except OSError as _e:                                                                   #PL: next if not open(CACHE_LOCK,"<$cachelock");

Tokens: c(!f(i,")) ValPy: 
Main loop, line=next if not open(CACHE_LOCK,"<$cachelock");
Main loop, line=next if not open(CACHE_LOCK,"<$cachelock");
Generated partial line continue 
 185 | 1 |   |    continue                                                                            #PL: next if not open(CACHE_LOCK,"<$cachelock");

Tokens: k ValPy: 
Main loop, line=next if not open(CACHE_LOCK,"<$cachelock");
Main loop, line=next if not flock(CACHE_LOCK, LOCK_SH|LOCK_NB);


 === Line 186 Perl source:next if not flock(CACHE_LOCK, LOCK_SH|LOCK_NB);===

Lexem 0 Current token='k' value='continue ' Tokenstr |k| translated: continue 
Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='!' value='not' Tokenstr |c!| translated: if  not
Lexem 2 Current token='f' value='_flock' Tokenstr |c!f| translated: if  not _flock
Lexem 3 Current token='(' value='(' Tokenstr |c!f(| translated: if  not _flock (
Lexem 4 Current token='i' value='CACHE_LOCK' Tokenstr |c!f(i| translated: if  not _flock ( CACHE_LOCK
Lexem 5 Current token=',' value=',' Tokenstr |c!f(i,| translated: if  not _flock ( CACHE_LOCK ,
Lexem 6 Current token='i' value='fcntl.LOCK_SH' Tokenstr |c!f(i,i| translated: if  not _flock ( CACHE_LOCK , fcntl.LOCK_SH
Lexem 7 Current token='|' value='|' Tokenstr |c!f(i,i|| translated: if  not _flock ( CACHE_LOCK , fcntl.LOCK_SH |
Lexem 8 Current token='i' value='fcntl.LOCK_NB' Tokenstr |c!f(i,i|i| translated: if  not _flock ( CACHE_LOCK , fcntl.LOCK_SH | fcntl.LOCK_NB
Lexem 9 Current token=')' value=')' Tokenstr |c!f(i,i|i)| translated: if  not _flock ( CACHE_LOCK , fcntl.LOCK_SH | fcntl.LOCK_NB )

Line:  186 TokenStr: =|c!f(i,i|i)|= @ValPy: if  not _flock ( CACHE_LOCK , fcntl.LOCK_SH | fcntl.LOCK_NB )
control(0) =|c(!f(i,i|i))|= if ( not flock ( CACHE_LOCK , LOCK_SH | LOCK_NB ) )

control-parens removed, begin=0 start=1 =|c!f(i,i|i)|= if not flock ( CACHE_LOCK , LOCK_SH | LOCK_NB )

Generated partial line if 
expression(1, 9, 0) =|c!f(i,i|i)|= if not flock ( CACHE_LOCK , LOCK_SH | LOCK_NB )

Generated partial line if not
function(2, 9) =|c!f(i,i|i)|= if not flock ( CACHE_LOCK , LOCK_SH | LOCK_NB )

function start=4, end_pos=8, bracketed=1
Generated partial line if not_flock
Generated partial line if not_flock(
expression(4, 8, 0) =|c!f(i,i|i)|= if not flock ( CACHE_LOCK , LOCK_SH | LOCK_NB )

Generated partial line if not_flock(CACHE_LOCK
Generated partial line if not_flock(CACHE_LOCK,
Generated partial line if not_flock(CACHE_LOCK,fcntl.LOCK_SH
Generated partial line if not_flock(CACHE_LOCK,fcntl.LOCK_SH|
Generated partial line if not_flock(CACHE_LOCK,fcntl.LOCK_SH|fcntl.LOCK_NB
expression returns 9
Generated partial line if not_flock(CACHE_LOCK,fcntl.LOCK_SH|fcntl.LOCK_NB)
expression returns 10
Generated partial line if not_flock(CACHE_LOCK,fcntl.LOCK_SH|fcntl.LOCK_NB):
 186 | 0 |   |if not _flock(CACHE_LOCK, fcntl.LOCK_SH|fcntl.LOCK_NB):                                 #PL: next if not flock(CACHE_LOCK, LOCK_SH|LOCK_NB);

Tokens: c!f(i,i|i) ValPy: 
Main loop, line=next if not flock(CACHE_LOCK, LOCK_SH|LOCK_NB);
Main loop, line=next if not flock(CACHE_LOCK, LOCK_SH|LOCK_NB);
Generated partial line continue 
 186 | 1 |   |    continue                                                                            #PL: next if not flock(CACHE_LOCK, LOCK_SH|LOCK_NB);

Tokens: k ValPy: 
Main loop, line=next if not flock(CACHE_LOCK, LOCK_SH|LOCK_NB);
 187 | 0 |   |
Main loop, line=open(TM_LOCK,">$lockfile") or die("cannot open $lockfile");


 === Line 188 Perl source:open(TM_LOCK,">$lockfile") or die("cannot open $lockfile");===

Lexem 0 Current token='f' value='open' Tokenstr |f| translated: open
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: open (
Lexem 2 Current token='i' value='TM_LOCK' Tokenstr |f(i| translated: open ( TM_LOCK
Lexem 3 Current token=',' value=',' Tokenstr |f(i,| translated: open ( TM_LOCK ,
Lexem 4 Current token='"' value='f">{lockfile}"' Tokenstr |f(i,"| translated: open ( TM_LOCK , f">{lockfile}"
Lexem 5 Current token=')' value=')' Tokenstr |f(i,")| translated: open ( TM_LOCK , f">{lockfile}" )
bash_style_or_and_fix(2) is_or=1
After bash_style_or_and_fix(2): =|c(!(f(i,")))|=

Line:  188 TokenStr: =|c(!(f(i,")))|= @ValPy: if ( not ( open ( TM_LOCK , f">{lockfile}" ) ) )
control(0) =|c(!(f(i,")))|= if ( not ( open ( TM_LOCK , >$lockfile ) ) )

control-parens removed, begin=0 start=1 =|c!(f(i,"))|= if not ( open ( TM_LOCK , >$lockfile ) )

Generated partial line if
expression(1, 9, 0) =|c!(f(i,"))|= if not ( open ( TM_LOCK , >$lockfile ) )

Generated partial line ifnot
Generated partial line ifnot(
expression(3, 8, 0) =|c!(f(i,"))|= if not ( open ( TM_LOCK , >$lockfile ) )

function(3, 8) =|c!(f(i,"))|= if not ( open ( TM_LOCK , >$lockfile ) )

function start=5, end_pos=7, bracketed=1
Generated partial line ifnot((TM_LOCK:=_perl_open(f"{lockfile}", 'w'))
expression returns 9
Generated partial line ifnot((TM_LOCK:=_perl_open(f"{lockfile}", 'w')))
expression returns 10
Generated partial line ifnot((TM_LOCK:=_perl_open(f"{lockfile}", 'w'))):
 188 | 0 |   |if not ((TM_LOCK:=_perl_open(f"{lockfile}", 'w'))):                                     #PL: open(TM_LOCK,">$lockfile") or die("cannot open $lockfile");

Tokens: c!(f(i,")) ValPy: 
Main loop, line={


 === Line 188 Perl source:{===


Line:  188 TokenStr: =|{|= @ValPy: {
Main loop, line=die("cannot open $lockfile");


 === Line 188 Perl source:die("cannot open $lockfile");===

Lexem 0 Current token='f' value='raise Die' Tokenstr |f| translated: raise Die
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: raise Die (
Lexem 2 Current token='"' value='f"cannot open {lockfile}"' Tokenstr |f("| translated: raise Die ( f"cannot open {lockfile}"
Lexem 3 Current token=')' value=')' Tokenstr |f(")| translated: raise Die ( f"cannot open {lockfile}" )

Line:  188 TokenStr: =|f(")|= @ValPy: raise Die ( f"cannot open {lockfile}" )
function(0, 3) =|f(")|= die ( cannot open $lockfile )

function start=2, end_pos=2, bracketed=1
Generated partial line raise Die
Generated partial line raise Die(
expression(2, 2, 0) =|f(")|= die ( cannot open $lockfile )

Generated partial line raise Die(f"cannot open {lockfile}"
expression returns 3
Generated partial line raise Die(f"cannot open {lockfile}")
 188 | 1 |   |    raise Die(f"cannot open {lockfile}")                                                #PL: die("cannot open $lockfile");

Tokens: f(") ValPy: 
Main loop, line=}


 === Line 188 Perl source:}===


Line:  188 TokenStr: =|}|= @ValPy: }
Main loop, line=next if not flock(TM_LOCK,LOCK_EX|LOCK_NB);


 === Line 189 Perl source:next if not flock(TM_LOCK,LOCK_EX|LOCK_NB);===

Lexem 0 Current token='k' value='continue ' Tokenstr |k| translated: continue 
Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='!' value='not' Tokenstr |c!| translated: if  not
Lexem 2 Current token='f' value='_flock' Tokenstr |c!f| translated: if  not _flock
Lexem 3 Current token='(' value='(' Tokenstr |c!f(| translated: if  not _flock (
Lexem 4 Current token='i' value='TM_LOCK' Tokenstr |c!f(i| translated: if  not _flock ( TM_LOCK
Lexem 5 Current token=',' value=',' Tokenstr |c!f(i,| translated: if  not _flock ( TM_LOCK ,
Lexem 6 Current token='i' value='fcntl.LOCK_EX' Tokenstr |c!f(i,i| translated: if  not _flock ( TM_LOCK , fcntl.LOCK_EX
Lexem 7 Current token='|' value='|' Tokenstr |c!f(i,i|| translated: if  not _flock ( TM_LOCK , fcntl.LOCK_EX |
Lexem 8 Current token='i' value='fcntl.LOCK_NB' Tokenstr |c!f(i,i|i| translated: if  not _flock ( TM_LOCK , fcntl.LOCK_EX | fcntl.LOCK_NB
Lexem 9 Current token=')' value=')' Tokenstr |c!f(i,i|i)| translated: if  not _flock ( TM_LOCK , fcntl.LOCK_EX | fcntl.LOCK_NB )

Line:  189 TokenStr: =|c!f(i,i|i)|= @ValPy: if  not _flock ( TM_LOCK , fcntl.LOCK_EX | fcntl.LOCK_NB )
control(0) =|c(!f(i,i|i))|= if ( not flock ( TM_LOCK , LOCK_EX | LOCK_NB ) )

control-parens removed, begin=0 start=1 =|c!f(i,i|i)|= if not flock ( TM_LOCK , LOCK_EX | LOCK_NB )

Generated partial line if 
expression(1, 9, 0) =|c!f(i,i|i)|= if not flock ( TM_LOCK , LOCK_EX | LOCK_NB )

Generated partial line if not
function(2, 9) =|c!f(i,i|i)|= if not flock ( TM_LOCK , LOCK_EX | LOCK_NB )

function start=4, end_pos=8, bracketed=1
Generated partial line if not_flock
Generated partial line if not_flock(
expression(4, 8, 0) =|c!f(i,i|i)|= if not flock ( TM_LOCK , LOCK_EX | LOCK_NB )

Generated partial line if not_flock(TM_LOCK
Generated partial line if not_flock(TM_LOCK,
Generated partial line if not_flock(TM_LOCK,fcntl.LOCK_EX
Generated partial line if not_flock(TM_LOCK,fcntl.LOCK_EX|
Generated partial line if not_flock(TM_LOCK,fcntl.LOCK_EX|fcntl.LOCK_NB
expression returns 9
Generated partial line if not_flock(TM_LOCK,fcntl.LOCK_EX|fcntl.LOCK_NB)
expression returns 10
Generated partial line if not_flock(TM_LOCK,fcntl.LOCK_EX|fcntl.LOCK_NB):
 189 | 0 |   |if not _flock(TM_LOCK, fcntl.LOCK_EX|fcntl.LOCK_NB):                                    #PL: next if not flock(TM_LOCK,LOCK_EX|LOCK_NB);

Tokens: c!f(i,i|i) ValPy: 
Main loop, line=next if not flock(TM_LOCK,LOCK_EX|LOCK_NB);
Main loop, line=next if not flock(TM_LOCK,LOCK_EX|LOCK_NB);
Generated partial line continue 
 189 | 1 |   |    continue                                                                            #PL: next if not flock(TM_LOCK,LOCK_EX|LOCK_NB);

Tokens: k ValPy: 
Main loop, line=next if not flock(TM_LOCK,LOCK_EX|LOCK_NB);
 190 | 0 |   |
Main loop, line=sub ddd { die "not_timeout"; }


 === Line 191 Perl source:sub ddd { die "not_timeout"; }===

Lexem 0 Current token='k' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' value='ddd' Tokenstr |ki| translated: def ddd

Line:  191 TokenStr: =|ki|= @ValPy: def ddd
Generated partial line defddd(_args):
 191 | 0 |   |def ddd(_args):                                                                         #PL: sub ddd { die "not_timeout"; }

Tokens: ki ValPy: 
Main loop, line={


 === Line 191 Perl source:{===


Line:  191 TokenStr: =|{|= @ValPy: {
Main loop, line=die "not_timeout"; }


 === Line 191 Perl source:die "not_timeout"; }===

Lexem 0 Current token='f' value='raise Die' Tokenstr |f| translated: raise Die
Lexem 1 Current token='"' value=''not_timeout'' Tokenstr |f"| translated: raise Die 'not_timeout'

Line:  191 TokenStr: =|f"|= @ValPy: raise Die 'not_timeout'
function(0, 1) =|f"|= die not_timeout

function start=1, end_pos=1, bracketed=0
Generated partial line raise Die
Generated partial line raise Die(
expression(1, 1, 0) =|f"|= die not_timeout

Generated partial line raise Die('not_timeout'
expression returns 2
Generated partial line raise Die('not_timeout')
 191 | 1 |   |    raise Die('not_timeout')                                                            #PL: die "not_timeout"; }

Tokens: f" ValPy: 
finish: prev_line=die "not_timeout"; }, PythonCode=
finish: Resetting line to }
Main loop, line=}


 === Line 191 Perl source:}===


Line:  191 TokenStr: =|}|= @ValPy: }
 192 | 0 |   |
Main loop, line=$SIG{ __DIE__ } = sub { Carp::confess( @_ ) };	# SNOOPYJC


 === Line 193 Perl source:$SIG{ __DIE__ } = sub { Carp::confess( @_ ) };	# SNOOPYJC===

decode_scalar SIG source=$SIG{ __DIE__ } = sub { Carp::confess( @_ ) };	# SNOOPYJC
decode_scalar SIG source=$SIG=1;
Lexem 0 Current token='s' value='TRACEBACK' Tokenstr |s| translated: TRACEBACK
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: TRACEBACK =
Lexem 2 Current token='d' value='1' Tokenstr |s=d| translated: TRACEBACK = 1

Line:  193 TokenStr: =|s=d|= @ValPy: TRACEBACK = 1
assignment(0, 2) =|s=d|= $SIG = 1

Generated partial line TRACEBACK
Generated partial line TRACEBACK=
assign, ValClass[limit] = d, ValPy=1, ValPerl=1

Generated partial line TRACEBACK=1
 193 | 0 |   |TRACEBACK = 1                                                                           #PL: $SIG{ __DIE__ } = sub { Carp::confess( @_ ) };	# SNOOPYJC

Tokens: s=d ValPy: 
Main loop, line=$SIG{ INT } = sub { Carp::confess( @_ ) };		# SNOOPYJC


 === Line 194 Perl source:$SIG{ INT } = sub { Carp::confess( @_ ) };		# SNOOPYJC===

decode_scalar SIG source=$SIG{ INT } = sub { Carp::confess( @_ ) };		# SNOOPYJC
decode_scalar SIG source=$SIG(INT, sub { traceback::print_stack($f) });		# SNOOPYJC
Lexem 0 Current token='f' value='signal.signal' Tokenstr |f| translated: signal.signal
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: signal.signal (
Lexem 2 Current token='i' value='signal.SIGINT' Tokenstr |f(i| translated: signal.signal ( signal.SIGINT
Lexem 3 Current token=',' value=',' Tokenstr |f(i,| translated: signal.signal ( signal.SIGINT ,
Lexem 4 Current token='k' value='def' Tokenstr |f(i,k| translated: signal.signal ( signal.SIGINT , def
Lexem 5 Current token='(' value='[' Tokenstr |f(i,k(| translated: signal.signal ( signal.SIGINT , def [
Lexem 6 Current token='i' value='traceback.print_stack' Tokenstr |f(i,k(i| translated: signal.signal ( signal.SIGINT , def [ traceback.print_stack
Lexem 7 Current token='(' value='(' Tokenstr |f(i,k(i(| translated: signal.signal ( signal.SIGINT , def [ traceback.print_stack (
Lexem 8 Current token='s' value='f' Tokenstr |f(i,k(i(s| translated: signal.signal ( signal.SIGINT , def [ traceback.print_stack ( f
Lexem 9 Current token=')' value=')' Tokenstr |f(i,k(i(s)| translated: signal.signal ( signal.SIGINT , def [ traceback.print_stack ( f )
Lexem 10 Current token=')' value=']' Tokenstr |f(i,k(i(s))| translated: signal.signal ( signal.SIGINT , def [ traceback.print_stack ( f ) ]
Lexem 11 Current token=')' value=')' Tokenstr |f(i,k(i(s)))| translated: signal.signal ( signal.SIGINT , def [ traceback.print_stack ( f ) ] )

Line:  194 TokenStr: =|f(i,k(i(s)))|= @ValPy: signal.signal ( signal.SIGINT , def [ traceback.print_stack ( f ) ] )
function(0, 11) =|f(i,k(i(s)))|= $SIG ( INT , sub { traceback::print_stack ( $f ) } )

function start=2, end_pos=10, bracketed=1
Generated partial line signal.signal
Generated partial line signal.signal(
expression(2, 10, 0) =|f(i,k(i(s)))|= $SIG ( INT , sub { traceback::print_stack ( $f ) } )

Generated partial line signal.signal(signal.SIGINT
Generated partial line signal.signal(signal.SIGINT,
Generated partial line signal.signal(signal.SIGINT,lambda s,f:
expression(6, 9, 0) =|f(i,k(i(s)))|= $SIG ( INT , sub { traceback::print_stack ( $f ) } )

Generated partial line signal.signal(signal.SIGINT,lambda s,f:traceback.print_stack
LINE 194 [main-W3027]:  Function traceback.print_stack is neither internal not built-in function. Please check the correspondence of arguments
expression(7, 9, 1) =|f(i,k(i(s)))|= $SIG ( INT , sub { traceback::print_stack ( $f ) } )

Generated partial line signal.signal(signal.SIGINT,lambda s,f:traceback.print_stack(
expression(8, 8, 0) =|f(i,k(i(s)))|= $SIG ( INT , sub { traceback::print_stack ( $f ) } )

Generated partial line signal.signal(signal.SIGINT,lambda s,f:traceback.print_stack(f
expression returns 9
Generated partial line signal.signal(signal.SIGINT,lambda s,f:traceback.print_stack(f)
expression returns 10
expression returns 10
expression returns 11
Generated partial line signal.signal(signal.SIGINT,lambda s,f:traceback.print_stack(f))
 194 | 0 |   |signal.signal(signal.SIGINT, lambda s,f:traceback.print_stack(f)) # SNOOPYJC
                                                                                                      #PL: $SIG{ INT } = sub { Carp::confess( @_ ) };

Tokens: f(i,k(i(s))) ValPy: 
Main loop, line=$| = 1;                                              # SNOOPYJC - unbuffer STDOUT


 === Line 195 Perl source:$| = 1;                                              # SNOOPYJC - unbuffer STDOUT===

Lexem 0 Current token='s' value='' Tokenstr |s| translated: 
Lexem 1 Current token='|' value='|' Tokenstr |s|| translated:  |
Lexem 2 Current token='=' value='=' Tokenstr |s|=| translated:  | =
Lexem 3 Current token='d' value='1' Tokenstr |s|=d| translated:  | = 1

Line:  195 TokenStr: =|s|=d|= @ValPy:  | = 1
assignment(0, 3) =|s|=d|= $ | = 1

expression(0, 1, 0) =|s|=d|= $ | = 1

Generated partial line 
Generated partial line |
expression returns 2
Generated partial line |=
assign, ValClass[limit] = d, ValPy=1, ValPerl=1

Generated partial line |=1
 195 | 0 |   || = 1 # SNOOPYJC - unbuffer STDOUT
                                                                                                      #PL: $| = 1;

Tokens: s|=d ValPy: 
Main loop, line=$SIG{ __DIE__ } = 'DEFAULT';


 === Line 196 Perl source:$SIG{ __DIE__ } = 'DEFAULT';===

decode_scalar SIG source=$SIG{ __DIE__ } = 'DEFAULT';
decode_scalar SIG source=$SIG=0;
Lexem 0 Current token='s' value='TRACEBACK' Tokenstr |s| translated: TRACEBACK
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: TRACEBACK =
Lexem 2 Current token='d' value='0' Tokenstr |s=d| translated: TRACEBACK = 0

Line:  196 TokenStr: =|s=d|= @ValPy: TRACEBACK = 0
assignment(0, 2) =|s=d|= $SIG = 0

Generated partial line TRACEBACK
Generated partial line TRACEBACK=
assign, ValClass[limit] = d, ValPy=0, ValPerl=0

Generated partial line TRACEBACK=0
 196 | 0 |   |TRACEBACK = 0                                                                           #PL: $SIG{ __DIE__ } = 'DEFAULT';

Tokens: s=d ValPy: 
 197 | 0 |   |
Main loop, line=$s = $SIG{ALRM};


 === Line 198 Perl source:$s = $SIG{ALRM};===

Lexem 0 Current token='s' value='s' Tokenstr |s| translated: s
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: s =
decode_scalar SIG source=$SIG{ALRM};
decode_scalar SIG source=$SIG(ALRM);
Lexem 2 Current token='f' value='signal.getsignal' Tokenstr |s=f| translated: s = signal.getsignal
Lexem 3 Current token='(' value='(' Tokenstr |s=f(| translated: s = signal.getsignal (
Lexem 4 Current token='i' value='signal.SIGALRM' Tokenstr |s=f(i| translated: s = signal.getsignal ( signal.SIGALRM
Lexem 5 Current token=')' value=')' Tokenstr |s=f(i)| translated: s = signal.getsignal ( signal.SIGALRM )

Line:  198 TokenStr: =|s=f(i)|= @ValPy: s = signal.getsignal ( signal.SIGALRM )
assignment(0, 5) =|s=f(i)|= $s = $SIG ( ALRM )

Generated partial line s
Generated partial line s=
expression(2, 5, 0) =|s=f(i)|= $s = $SIG ( ALRM )

function(2, 5) =|s=f(i)|= $s = $SIG ( ALRM )

function start=4, end_pos=4, bracketed=1
Generated partial line s=signal.getsignal
Generated partial line s=signal.getsignal(
expression(4, 4, 0) =|s=f(i)|= $s = $SIG ( ALRM )

Generated partial line s=signal.getsignal(signal.SIGALRM
expression returns 5
Generated partial line s=signal.getsignal(signal.SIGALRM)
expression returns 6
 198 | 0 |   |s = signal.getsignal(signal.SIGALRM)                                                    #PL: $s = $SIG{ALRM};

Tokens: s=f(i) ValPy: 
Main loop, line=$my_flag = 0;


 === Line 199 Perl source:$my_flag = 0;===

Lexem 0 Current token='s' value='my_flag' Tokenstr |s| translated: my_flag
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: my_flag =
Lexem 2 Current token='d' value='0' Tokenstr |s=d| translated: my_flag = 0

Line:  199 TokenStr: =|s=d|= @ValPy: my_flag = 0
assignment(0, 2) =|s=d|= $my_flag = 0

Generated partial line my_flag
Generated partial line my_flag=
assign, ValClass[limit] = d, ValPy=0, ValPerl=0

Generated partial line my_flag=0
 199 | 0 |   |my_flag = 0                                                                             #PL: $my_flag = 0;

Tokens: s=d ValPy: 
Main loop, line=$SIG{ALRM} = sub { $my_flag = 1; };


 === Line 200 Perl source:$SIG{ALRM} = sub { $my_flag = 1; };===

decode_scalar SIG source=$SIG{ALRM} = sub { $my_flag = 1; };
decode_scalar SIG source=$SIG(ALRM, sub { $my_flag = 1; });
Lexem 0 Current token='f' value='signal.signal' Tokenstr |f| translated: signal.signal
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: signal.signal (
Lexem 2 Current token='i' value='signal.SIGALRM' Tokenstr |f(i| translated: signal.signal ( signal.SIGALRM
Lexem 3 Current token=',' value=',' Tokenstr |f(i,| translated: signal.signal ( signal.SIGALRM ,
Lexem 4 Current token='k' value='def' Tokenstr |f(i,k| translated: signal.signal ( signal.SIGALRM , def
Lexem 5 Current token='(' value='[' Tokenstr |f(i,k(| translated: signal.signal ( signal.SIGALRM , def [
Lexem 6 Current token='s' value='my_flag' Tokenstr |f(i,k(s| translated: signal.signal ( signal.SIGALRM , def [ my_flag
Lexem 7 Current token='=' value='=' Tokenstr |f(i,k(s=| translated: signal.signal ( signal.SIGALRM , def [ my_flag =
Lexem 8 Current token='d' value='1' Tokenstr |f(i,k(s=d| translated: signal.signal ( signal.SIGALRM , def [ my_flag = 1
Lexem 9 Current token=';' value=';' Tokenstr |f(i,k(s=d;| translated: signal.signal ( signal.SIGALRM , def [ my_flag = 1 ;
Lexem 10 Current token=')' value=']' Tokenstr |f(i,k(s=d;)| translated: signal.signal ( signal.SIGALRM , def [ my_flag = 1 ; ]
Lexem 11 Current token=')' value=')' Tokenstr |f(i,k(s=d;))| translated: signal.signal ( signal.SIGALRM , def [ my_flag = 1 ; ] )

Line:  200 TokenStr: =|f(i,k(s=d;))|= @ValPy: signal.signal ( signal.SIGALRM , def [ my_flag = 1 ; ] )
function(0, 11) =|f(i,k(s=d;))|= $SIG ( ALRM , sub { $my_flag = 1 ; } )

function start=2, end_pos=10, bracketed=1
Generated partial line signal.signal
Generated partial line signal.signal(
expression(2, 10, 0) =|f(i,k(s=d;))|= $SIG ( ALRM , sub { $my_flag = 1 ; } )

Generated partial line signal.signal(signal.SIGALRM
Generated partial line signal.signal(signal.SIGALRM,
Generated partial line signal.signal(signal.SIGALRM,lambda s,f:
Generated partial line signal.signal(signal.SIGALRM,lambda s,f:(
expression(6, 8, 0) =|f(i,k(s=d;))|= $SIG ( ALRM , sub { $my_flag = 1 ; } )

Generated partial line signal.signal(signal.SIGALRM,lambda s,f:(my_flag
Generated partial line signal.signal(signal.SIGALRM,lambda s,f:(my_flag:=
Generated partial line signal.signal(signal.SIGALRM,lambda s,f:(my_flag:=1
expression returns 9
Generated partial line signal.signal(signal.SIGALRM,lambda s,f:(my_flag:=1)
expression returns 11
Generated partial line signal.signal(signal.SIGALRM,lambda s,f:(my_flag:=1))
 200 | 0 |   |signal.signal(signal.SIGALRM, lambda s,f:(my_flag:=1))                                  #PL: $SIG{ALRM} = sub { $my_flag = 1; };

Tokens: f(i,k(s=d;)) ValPy: 
Main loop, line=$SIG{ALRM} = sub { $my_flag++; };


 === Line 201 Perl source:$SIG{ALRM} = sub { $my_flag++; };===

decode_scalar SIG source=$SIG{ALRM} = sub { $my_flag++; };
decode_scalar SIG source=$SIG(ALRM, sub { $my_flag++; });
Lexem 0 Current token='f' value='signal.signal' Tokenstr |f| translated: signal.signal
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: signal.signal (
Lexem 2 Current token='i' value='signal.SIGALRM' Tokenstr |f(i| translated: signal.signal ( signal.SIGALRM
Lexem 3 Current token=',' value=',' Tokenstr |f(i,| translated: signal.signal ( signal.SIGALRM ,
Lexem 4 Current token='k' value='def' Tokenstr |f(i,k| translated: signal.signal ( signal.SIGALRM , def
Lexem 5 Current token='(' value='[' Tokenstr |f(i,k(| translated: signal.signal ( signal.SIGALRM , def [
Lexem 6 Current token='s' value='my_flag' Tokenstr |f(i,k(s| translated: signal.signal ( signal.SIGALRM , def [ my_flag
Lexem 7 Current token='^' value='+=1' Tokenstr |f(i,k(s^| translated: signal.signal ( signal.SIGALRM , def [ my_flag +=1
Lexem 8 Current token=';' value=';' Tokenstr |f(i,k(s^;| translated: signal.signal ( signal.SIGALRM , def [ my_flag +=1 ;
Lexem 9 Current token=')' value=']' Tokenstr |f(i,k(s^;)| translated: signal.signal ( signal.SIGALRM , def [ my_flag +=1 ; ]
Lexem 10 Current token=')' value=')' Tokenstr |f(i,k(s^;))| translated: signal.signal ( signal.SIGALRM , def [ my_flag +=1 ; ] )

Line:  201 TokenStr: =|f(i,k(s^;))|= @ValPy: signal.signal ( signal.SIGALRM , def [ my_flag +=1 ; ] )
handle_incr_decr(0, 7, 10) with ++, pre_op=0, lvalue_start=6, lvalue_end=6 = 9
function(0, 19) =|f(i,k(((s=s+d)-d);))|= $SIG ( ALRM , sub { ( ( $my_flag = $my_flag + 1 ) - 1 ) ; } )

function start=2, end_pos=18, bracketed=1
Generated partial line signal.signal
Generated partial line signal.signal(
expression(2, 18, 0) =|f(i,k(((s=s+d)-d);))|= $SIG ( ALRM , sub { ( ( $my_flag = $my_flag + 1 ) - 1 ) ; } )

Generated partial line signal.signal(signal.SIGALRM
Generated partial line signal.signal(signal.SIGALRM,
Generated partial line signal.signal(signal.SIGALRM,lambda s,f:
Generated partial line signal.signal(signal.SIGALRM,lambda s,f:(
expression(6, 16, 0) =|f(i,k(((s=s+d)-d);))|= $SIG ( ALRM , sub { ( ( $my_flag = $my_flag + 1 ) - 1 ) ; } )

Generated partial line signal.signal(signal.SIGALRM,lambda s,f:((
expression(7, 15, 0) =|f(i,k(((s=s+d)-d);))|= $SIG ( ALRM , sub { ( ( $my_flag = $my_flag + 1 ) - 1 ) ; } )

Generated partial line signal.signal(signal.SIGALRM,lambda s,f:(((
expression(8, 12, 0) =|f(i,k(((s=s+d)-d);))|= $SIG ( ALRM , sub { ( ( $my_flag = $my_flag + 1 ) - 1 ) ; } )

Generated partial line signal.signal(signal.SIGALRM,lambda s,f:(((my_flag
Generated partial line signal.signal(signal.SIGALRM,lambda s,f:(((my_flag:=
Generated partial line signal.signal(signal.SIGALRM,lambda s,f:(((my_flag:=my_flag
Generated partial line signal.signal(signal.SIGALRM,lambda s,f:(((my_flag:=my_flag+
Generated partial line signal.signal(signal.SIGALRM,lambda s,f:(((my_flag:=my_flag+1
expression returns 13
Generated partial line signal.signal(signal.SIGALRM,lambda s,f:(((my_flag:=my_flag+1)
Generated partial line signal.signal(signal.SIGALRM,lambda s,f:(((my_flag:=my_flag+1)-
Generated partial line signal.signal(signal.SIGALRM,lambda s,f:(((my_flag:=my_flag+1)-1
expression returns 16
Generated partial line signal.signal(signal.SIGALRM,lambda s,f:(((my_flag:=my_flag+1)-1)
expression returns 17
Generated partial line signal.signal(signal.SIGALRM,lambda s,f:(((my_flag:=my_flag+1)-1))
expression returns 19
Generated partial line signal.signal(signal.SIGALRM,lambda s,f:(((my_flag:=my_flag+1)-1)))
 201 | 0 |   |signal.signal(signal.SIGALRM, lambda s,f:(((my_flag:=my_flag+1)-1)))                    #PL: $SIG{ALRM} = sub { $my_flag++; };

Tokens: f(i,k(((s=s+d)-d);)) ValPy: 
Main loop, line=$SIG{ALRM} = $s;


 === Line 202 Perl source:$SIG{ALRM} = $s;===

decode_scalar SIG source=$SIG{ALRM} = $s;
decode_scalar SIG source=$SIG(ALRM, $s);
Lexem 0 Current token='f' value='signal.signal' Tokenstr |f| translated: signal.signal
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: signal.signal (
Lexem 2 Current token='i' value='signal.SIGALRM' Tokenstr |f(i| translated: signal.signal ( signal.SIGALRM
Lexem 3 Current token=',' value=',' Tokenstr |f(i,| translated: signal.signal ( signal.SIGALRM ,
Lexem 4 Current token='s' value='s' Tokenstr |f(i,s| translated: signal.signal ( signal.SIGALRM , s
Lexem 5 Current token=')' value=')' Tokenstr |f(i,s)| translated: signal.signal ( signal.SIGALRM , s )

Line:  202 TokenStr: =|f(i,s)|= @ValPy: signal.signal ( signal.SIGALRM , s )
function(0, 5) =|f(i,s)|= $SIG ( ALRM , $s )

function start=2, end_pos=4, bracketed=1
Generated partial line signal.signal
Generated partial line signal.signal(
expression(2, 4, 0) =|f(i,s)|= $SIG ( ALRM , $s )

Generated partial line signal.signal(signal.SIGALRM
Generated partial line signal.signal(signal.SIGALRM,
Generated partial line signal.signal(signal.SIGALRM,s
expression returns 5
Generated partial line signal.signal(signal.SIGALRM,s)
 202 | 0 |   |signal.signal(signal.SIGALRM, s)                                                        #PL: $SIG{ALRM} = $s;

Tokens: f(i,s) ValPy: 
Main loop, line=$SIG{ALRM} = 'WHO KNOWS';


 === Line 203 Perl source:$SIG{ALRM} = 'WHO KNOWS';===

decode_scalar SIG source=$SIG{ALRM} = 'WHO KNOWS';
decode_scalar SIG source=$SIG(ALRM, 'WHO KNOWS');
Lexem 0 Current token='f' value='signal.signal' Tokenstr |f| translated: signal.signal
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: signal.signal (
Lexem 2 Current token='i' value='signal.SIGALRM' Tokenstr |f(i| translated: signal.signal ( signal.SIGALRM
Lexem 3 Current token=',' value=',' Tokenstr |f(i,| translated: signal.signal ( signal.SIGALRM ,
Lexem 4 Current token='"' value=''WHO KNOWS'' Tokenstr |f(i,"| translated: signal.signal ( signal.SIGALRM , 'WHO KNOWS'
Lexem 5 Current token=')' value=')' Tokenstr |f(i,")| translated: signal.signal ( signal.SIGALRM , 'WHO KNOWS' )

Line:  203 TokenStr: =|f(i,")|= @ValPy: signal.signal ( signal.SIGALRM , 'WHO KNOWS' )
function(0, 5) =|f(i,")|= $SIG ( ALRM , WHO KNOWS )

function start=2, end_pos=4, bracketed=1
Generated partial line signal.signal
Generated partial line signal.signal(
expression(2, 4, 0) =|f(i,")|= $SIG ( ALRM , WHO KNOWS )

Generated partial line signal.signal(signal.SIGALRM
Generated partial line signal.signal(signal.SIGALRM,
Generated partial line signal.signal(signal.SIGALRM,'WHO KNOWS'
expression returns 5
Generated partial line signal.signal(signal.SIGALRM,'WHO KNOWS')
 203 | 0 |   |signal.signal(signal.SIGALRM, 'WHO KNOWS')                                              #PL: $SIG{ALRM} = 'WHO KNOWS';

Tokens: f(i,") ValPy: 
Main loop, line=$SIG{ALRM} = 'IGNORE';


 === Line 204 Perl source:$SIG{ALRM} = 'IGNORE';===

decode_scalar SIG source=$SIG{ALRM} = 'IGNORE';
decode_scalar SIG source=$SIG(ALRM, _IGN);
Lexem 0 Current token='f' value='signal.signal' Tokenstr |f| translated: signal.signal
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: signal.signal (
Lexem 2 Current token='i' value='signal.SIGALRM' Tokenstr |f(i| translated: signal.signal ( signal.SIGALRM
Lexem 3 Current token=',' value=',' Tokenstr |f(i,| translated: signal.signal ( signal.SIGALRM ,
Lexem 4 Current token='i' value='signal.SIG_IGN' Tokenstr |f(i,i| translated: signal.signal ( signal.SIGALRM , signal.SIG_IGN
Lexem 5 Current token=')' value=')' Tokenstr |f(i,i)| translated: signal.signal ( signal.SIGALRM , signal.SIG_IGN )

Line:  204 TokenStr: =|f(i,i)|= @ValPy: signal.signal ( signal.SIGALRM , signal.SIG_IGN )
function(0, 5) =|f(i,i)|= $SIG ( ALRM , _IGN )

function start=2, end_pos=4, bracketed=1
Generated partial line signal.signal
Generated partial line signal.signal(
expression(2, 4, 0) =|f(i,i)|= $SIG ( ALRM , _IGN )

Generated partial line signal.signal(signal.SIGALRM
Generated partial line signal.signal(signal.SIGALRM,
Generated partial line signal.signal(signal.SIGALRM,signal.SIG_IGN
expression returns 5
Generated partial line signal.signal(signal.SIGALRM,signal.SIG_IGN)
 204 | 0 |   |signal.signal(signal.SIGALRM, signal.SIG_IGN)                                           #PL: $SIG{ALRM} = 'IGNORE';

Tokens: f(i,i) ValPy: 
Main loop, line=$SIG{ALRM} = 'DEFAULT';


 === Line 205 Perl source:$SIG{ALRM} = 'DEFAULT';===

decode_scalar SIG source=$SIG{ALRM} = 'DEFAULT';
decode_scalar SIG source=$SIG(ALRM, _DFL);
Lexem 0 Current token='f' value='signal.signal' Tokenstr |f| translated: signal.signal
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: signal.signal (
Lexem 2 Current token='i' value='signal.SIGALRM' Tokenstr |f(i| translated: signal.signal ( signal.SIGALRM
Lexem 3 Current token=',' value=',' Tokenstr |f(i,| translated: signal.signal ( signal.SIGALRM ,
Lexem 4 Current token='i' value='signal.SIG_DFL' Tokenstr |f(i,i| translated: signal.signal ( signal.SIGALRM , signal.SIG_DFL
Lexem 5 Current token=')' value=')' Tokenstr |f(i,i)| translated: signal.signal ( signal.SIGALRM , signal.SIG_DFL )

Line:  205 TokenStr: =|f(i,i)|= @ValPy: signal.signal ( signal.SIGALRM , signal.SIG_DFL )
function(0, 5) =|f(i,i)|= $SIG ( ALRM , _DFL )

function start=2, end_pos=4, bracketed=1
Generated partial line signal.signal
Generated partial line signal.signal(
expression(2, 4, 0) =|f(i,i)|= $SIG ( ALRM , _DFL )

Generated partial line signal.signal(signal.SIGALRM
Generated partial line signal.signal(signal.SIGALRM,
Generated partial line signal.signal(signal.SIGALRM,signal.SIG_DFL
expression returns 5
Generated partial line signal.signal(signal.SIGALRM,signal.SIG_DFL)
 205 | 0 |   |signal.signal(signal.SIGALRM, signal.SIG_DFL)                                           #PL: $SIG{ALRM} = 'DEFAULT';

Tokens: f(i,i) ValPy: 
Main loop, line=$SIG{ALRM} = sub { die "timeout"; };


 === Line 206 Perl source:$SIG{ALRM} = sub { die "timeout"; };===

decode_scalar SIG source=$SIG{ALRM} = sub { die "timeout"; };
decode_scalar SIG source=$SIG(ALRM, sub { die "timeout"; });
Lexem 0 Current token='f' value='signal.signal' Tokenstr |f| translated: signal.signal
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: signal.signal (
Lexem 2 Current token='i' value='signal.SIGALRM' Tokenstr |f(i| translated: signal.signal ( signal.SIGALRM
Lexem 3 Current token=',' value=',' Tokenstr |f(i,| translated: signal.signal ( signal.SIGALRM ,
Lexem 4 Current token='k' value='def' Tokenstr |f(i,k| translated: signal.signal ( signal.SIGALRM , def
Lexem 5 Current token='(' value='[' Tokenstr |f(i,k(| translated: signal.signal ( signal.SIGALRM , def [
Lexem 6 Current token='f' value='raise Die' Tokenstr |f(i,k(f| translated: signal.signal ( signal.SIGALRM , def [ raise Die
Lexem 7 Current token='"' value=''timeout'' Tokenstr |f(i,k(f"| translated: signal.signal ( signal.SIGALRM , def [ raise Die 'timeout'
Lexem 8 Current token=';' value=';' Tokenstr |f(i,k(f";| translated: signal.signal ( signal.SIGALRM , def [ raise Die 'timeout' ;
Lexem 9 Current token=')' value=']' Tokenstr |f(i,k(f";)| translated: signal.signal ( signal.SIGALRM , def [ raise Die 'timeout' ; ]
Lexem 10 Current token=')' value=')' Tokenstr |f(i,k(f";))| translated: signal.signal ( signal.SIGALRM , def [ raise Die 'timeout' ; ] )

Line:  206 TokenStr: =|f(i,k(f";))|= @ValPy: signal.signal ( signal.SIGALRM , def [ raise Die 'timeout' ; ] )
function(0, 10) =|f(i,k(f";))|= $SIG ( ALRM , sub { die timeout ; } )

function start=2, end_pos=9, bracketed=1
Generated partial line signal.signal
Generated partial line signal.signal(
expression(2, 9, 0) =|f(i,k(f";))|= $SIG ( ALRM , sub { die timeout ; } )

Generated partial line signal.signal(signal.SIGALRM
Generated partial line signal.signal(signal.SIGALRM,
Generated partial line signal.signal(signal.SIGALRM,lambda s,f:
expression(6, 7, 0) =|f(i,k(f";))|= $SIG ( ALRM , sub { die timeout ; } )

function(6, 7) =|f(i,k(f";))|= $SIG ( ALRM , sub { die timeout ; } )

function start=7, end_pos=7, bracketed=0
Generated partial line signal.signal(signal.SIGALRM,lambda s,f:_die
Generated partial line signal.signal(signal.SIGALRM,lambda s,f:_die(
expression(7, 7, 0) =|f(i,k(f";))|= $SIG ( ALRM , sub { die timeout ; } )

Generated partial line signal.signal(signal.SIGALRM,lambda s,f:_die('timeout'
expression returns 8
Generated partial line signal.signal(signal.SIGALRM,lambda s,f:_die('timeout')
expression returns 8
expression returns 10
Generated partial line signal.signal(signal.SIGALRM,lambda s,f:_die('timeout'))
 206 | 0 |   |signal.signal(signal.SIGALRM, lambda s,f:_die('timeout'))                               #PL: $SIG{ALRM} = sub { die "timeout"; };

Tokens: f(i,k(f";)) ValPy: 
 207 | 0 |   |
Main loop, line=$retval = 0;


 === Line 208 Perl source:$retval = 0;===

Lexem 0 Current token='s' value='retval' Tokenstr |s| translated: retval
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: retval =
Lexem 2 Current token='d' value='0' Tokenstr |s=d| translated: retval = 0

Line:  208 TokenStr: =|s=d|= @ValPy: retval = 0
assignment(0, 2) =|s=d|= $retval = 0

Generated partial line retval
Generated partial line retval=
assign, ValClass[limit] = d, ValPy=0, ValPerl=0

Generated partial line retval=0
 208 | 0 |   |retval = 0                                                                              #PL: $retval = 0;

Tokens: s=d ValPy: 
 209 | 0 |   |
Main loop, line=eval


 === Line 210 Perl source:eval===

Lexem 0 Current token='C' value='try' Tokenstr |C| translated: try

Line:  211 TokenStr: =|C|= @ValPy: try
 211 | 0 |   |try:                                                                                    #PL: eval

Tokens: C ValPy: 
eval_stack=HASH(0x800651fc8), eval_nest=0
Main loop, line={


 === Line 211 Perl source:{===


Line:  211 TokenStr: =|{|= @ValPy: {
eval_stack=HASH(0x800651fc8), eval_nest=0
Main loop, line=alarm($TIME);


 === Line 212 Perl source:alarm($TIME);===

Lexem 0 Current token='f' value='signal.alarm' Tokenstr |f| translated: signal.alarm
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: signal.alarm (
Lexem 2 Current token='s' value='TIME' Tokenstr |f(s| translated: signal.alarm ( TIME
Lexem 3 Current token=')' value=')' Tokenstr |f(s)| translated: signal.alarm ( TIME )

Line:  212 TokenStr: =|f(s)|= @ValPy: signal.alarm ( TIME )
function(0, 3) =|f(s)|= alarm ( $TIME )

function start=2, end_pos=2, bracketed=1
Generated partial line signal.alarm
Generated partial line signal.alarm(
expression(2, 2, 0) =|f(s)|= alarm ( $TIME )

Generated partial line signal.alarm(TIME
expression returns 3
Generated partial line signal.alarm(TIME)
 212 | 1 |   |    signal.alarm(TIME)                                                                  #PL: alarm($TIME);

Tokens: f(s) ValPy: 
 213 | 1 |   |
 214 | 1 |   |    # to test the failure condition, uncomment the following sleep command...
 215 | 1 |   |
 216 | 1 |   |    #sleep $TIME;
 217 | 1 |   |
 218 | 1 |   |    # system ("ssh -l $user $system date >/dev/null 2>/dev/null");
 219 | 1 |   |
eval_stack=HASH(0x800651fc8), eval_nest=0
Main loop, line=if ($interfacev eq "v1.0a") {


 === Line 220 Perl source:if ($interfacev eq "v1.0a") {===

Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' value='interfacev' Tokenstr |c(s| translated: if  ( interfacev
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: if  ( interfacev ==
Lexem 4 Current token='"' value=''v1.0a'' Tokenstr |c(s>"| translated: if  ( interfacev == 'v1.0a'
Lexem 5 Current token=')' value=')' Tokenstr |c(s>")| translated: if  ( interfacev == 'v1.0a' )

Line:  220 TokenStr: =|c(s>")|= @ValPy: if  ( interfacev == 'v1.0a' )
control(0) =|c(s>")|= if ( $interfacev eq v1.0a )

control-parens removed, begin=0 start=1 =|cs>"|= if $interfacev eq v1.0a

Generated partial line if 
expression(1, 3, 0) =|cs>"|= if $interfacev eq v1.0a

Generated partial line if interfacev
Generated partial line if interfacev==
Generated partial line if interfacev=='v1.0a'
expression returns 4
Generated partial line if interfacev=='v1.0a':
 220 | 1 |   |    if interfacev=='v1.0a':                                                             #PL: if ($interfacev eq "v1.0a") {

Tokens: cs>" ValPy: 
eval_stack=HASH(0x800651fc8), eval_nest=0
Main loop, line={


 === Line 220 Perl source:{===


Line:  220 TokenStr: =|{|= @ValPy: {
eval_stack=HASH(0x800651fc8), eval_nest=0
Main loop, line=$rc = system ("ssh -l $user $system date >/dev/null 2>/dev/null");


 === Line 221 Perl source:$rc = system ("ssh -l $user $system date >/dev/null 2>/dev/null");===

Lexem 0 Current token='s' value='rc' Tokenstr |s| translated: rc
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: rc =
Lexem 2 Current token='f' value='os.system' Tokenstr |s=f| translated: rc = os.system
Lexem 3 Current token='(' value='(' Tokenstr |s=f(| translated: rc = os.system (
Lexem 4 Current token='"' value='f"ssh -l {user} {system} date >/dev/null 2>/dev/null"' Tokenstr |s=f("| translated: rc = os.system ( f"ssh -l {user} {system} date >/dev/null 2>/dev/null"
Lexem 5 Current token=')' value=')' Tokenstr |s=f(")| translated: rc = os.system ( f"ssh -l {user} {system} date >/dev/null 2>/dev/null" )

Line:  221 TokenStr: =|s=f(")|= @ValPy: rc = os.system ( f"ssh -l {user} {system} date >/dev/null 2>/dev/null" )
assignment(0, 5) =|s=f(")|= $rc = system ( ssh -l $user $system date >/dev/null 2>/dev/null )

Generated partial line rc
Generated partial line rc=
expression(2, 5, 0) =|s=f(")|= $rc = system ( ssh -l $user $system date >/dev/null 2>/dev/null )

function(2, 5) =|s=f(")|= $rc = system ( ssh -l $user $system date >/dev/null 2>/dev/null )

function start=4, end_pos=4, bracketed=1
Generated partial line rc=os.system
Generated partial line rc=os.system(
expression(4, 4, 0) =|s=f(")|= $rc = system ( ssh -l $user $system date >/dev/null 2>/dev/null )

Generated partial line rc=os.system(f"ssh -l {user} {system} date >/dev/null 2>/dev/null"
expression returns 5
Generated partial line rc=os.system(f"ssh -l {user} {system} date >/dev/null 2>/dev/null")
expression returns 6
 221 | 2 |   |        rc = os.system(f"ssh -l {user} {system} date >/dev/null 2>/dev/null")           #PL: $rc = system ("ssh -l $user $system date >/dev/null 2>/dev/null");

Tokens: s=f(") ValPy: 
eval_stack=HASH(0x800651fc8), eval_nest=0
Main loop, line=}


 === Line 222 Perl source:}===


Line:  222 TokenStr: =|}|= @ValPy: }
eval_stack=HASH(0x800651fc8), eval_nest=0
Main loop, line=else{


 === Line 223 Perl source:else{===

Lexem 0 Current token='C' value='else: ' Tokenstr |C| translated: else: 

Line:  223 TokenStr: =|C|= @ValPy: else: 
Generated partial line else:
 223 | 1 |   |    else:                                                                               #PL: else{

Tokens: C ValPy: 
eval_stack=HASH(0x800651fc8), eval_nest=0
Main loop, line={


 === Line 223 Perl source:{===


Line:  223 TokenStr: =|{|= @ValPy: {
eval_stack=HASH(0x800651fc8), eval_nest=0
Main loop, line=$rc = system ("echo vdate | ssh -l $user $system >/dev/null 2>/dev/null");


 === Line 224 Perl source:$rc = system ("echo vdate | ssh -l $user $system >/dev/null 2>/dev/null");===

Lexem 0 Current token='s' value='rc' Tokenstr |s| translated: rc
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: rc =
Lexem 2 Current token='f' value='os.system' Tokenstr |s=f| translated: rc = os.system
Lexem 3 Current token='(' value='(' Tokenstr |s=f(| translated: rc = os.system (
Lexem 4 Current token='"' value='f"echo vdate | ssh -l {user} {system} >/dev/null 2>/dev/null"' Tokenstr |s=f("| translated: rc = os.system ( f"echo vdate | ssh -l {user} {system} >/dev/null 2>/dev/null"
Lexem 5 Current token=')' value=')' Tokenstr |s=f(")| translated: rc = os.system ( f"echo vdate | ssh -l {user} {system} >/dev/null 2>/dev/null" )

Line:  224 TokenStr: =|s=f(")|= @ValPy: rc = os.system ( f"echo vdate | ssh -l {user} {system} >/dev/null 2>/dev/null" )
assignment(0, 5) =|s=f(")|= $rc = system ( echo vdate | ssh -l $user $system >/dev/null 2>/dev/null )

Generated partial line rc
Generated partial line rc=
expression(2, 5, 0) =|s=f(")|= $rc = system ( echo vdate | ssh -l $user $system >/dev/null 2>/dev/null )

function(2, 5) =|s=f(")|= $rc = system ( echo vdate | ssh -l $user $system >/dev/null 2>/dev/null )

function start=4, end_pos=4, bracketed=1
Generated partial line rc=os.system
Generated partial line rc=os.system(
expression(4, 4, 0) =|s=f(")|= $rc = system ( echo vdate | ssh -l $user $system >/dev/null 2>/dev/null )

Generated partial line rc=os.system(f"echo vdate | ssh -l {user} {system} >/dev/null 2>/dev/null"
expression returns 5
Generated partial line rc=os.system(f"echo vdate | ssh -l {user} {system} >/dev/null 2>/dev/null")
expression returns 6
 224 | 2 |   |        rc = os.system(f"echo vdate | ssh -l {user} {system} >/dev/null 2>/dev/null")   #PL: $rc = system ("echo vdate | ssh -l $user $system >/dev/null 2>/dev/null");

Tokens: s=f(") ValPy: 
eval_stack=HASH(0x800651fc8), eval_nest=0
Main loop, line=}


 === Line 225 Perl source:}===


Line:  225 TokenStr: =|}|= @ValPy: }
eval_stack=HASH(0x800651fc8), eval_nest=0
Main loop, line=$retval = 1 if ($rc > 0);


 === Line 226 Perl source:$retval = 1 if ($rc > 0);===

Lexem 0 Current token='s' value='retval' Tokenstr |s| translated: retval
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: retval =
Lexem 2 Current token='d' value='1' Tokenstr |s=d| translated: retval = 1
Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' value='rc' Tokenstr |c(s| translated: if  ( rc
Lexem 3 Current token='>' value='>' Tokenstr |c(s>| translated: if  ( rc >
Lexem 4 Current token='d' value='0' Tokenstr |c(s>d| translated: if  ( rc > 0
Lexem 5 Current token=')' value=')' Tokenstr |c(s>d)| translated: if  ( rc > 0 )

Line:  226 TokenStr: =|c(s>d)|= @ValPy: if  ( rc > 0 )
control(0) =|c(s>d)|= if ( $rc > 0 )

control-parens removed, begin=0 start=1 =|cs>d|= if $rc > 0

Generated partial line if 
expression(1, 3, 0) =|cs>d|= if $rc > 0

Generated partial line if rc
Generated partial line if rc>
Generated partial line if rc>0
expression returns 4
Generated partial line if rc>0:
 226 | 1 |   |    if rc>0:                                                                            #PL: $retval = 1 if ($rc > 0);

Tokens: cs>d ValPy: 
eval_stack=HASH(0x800651fc8), eval_nest=0
Main loop, line=$retval = 1 if ($rc > 0);
eval_stack=HASH(0x800651fc8), eval_nest=0
Main loop, line=$retval = 1 if ($rc > 0);
assignment(0, 2) =|s=d|= $retval = 1

Generated partial line retval
Generated partial line retval=
assign, ValClass[limit] = d, ValPy=1, ValPerl=1

Generated partial line retval=1
 226 | 2 |   |        retval = 1                                                                      #PL: $retval = 1 if ($rc > 0);

Tokens: s=d ValPy: 
eval_stack=HASH(0x800651fc8), eval_nest=0
Main loop, line=$retval = 1 if ($rc > 0);
 227 | 1 |   |
eval_stack=HASH(0x800651fc8), eval_nest=0
Main loop, line=alarm(0);


 === Line 228 Perl source:alarm(0);===

Lexem 0 Current token='f' value='signal.alarm' Tokenstr |f| translated: signal.alarm
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: signal.alarm (
Lexem 2 Current token='d' value='0' Tokenstr |f(d| translated: signal.alarm ( 0
Lexem 3 Current token=')' value=')' Tokenstr |f(d)| translated: signal.alarm ( 0 )

Line:  228 TokenStr: =|f(d)|= @ValPy: signal.alarm ( 0 )
function(0, 3) =|f(d)|= alarm ( 0 )

function start=2, end_pos=2, bracketed=1
Generated partial line signal.alarm
Generated partial line signal.alarm(
expression(2, 2, 0) =|f(d)|= alarm ( 0 )

Generated partial line signal.alarm(0
expression returns 3
Generated partial line signal.alarm(0)
 228 | 1 |   |    signal.alarm(0)                                                                     #PL: alarm(0);

Tokens: f(d) ValPy: 
 229 | 1 |   |
finish: prev_line=alarm(0);, PythonCode=
finish: Resetting line to };
eval_stack=HASH(0x800651fc8), eval_nest=0
Main loop, line=};


 === Line 230 Perl source:};===


Line:  230 TokenStr: =|}|= @ValPy: }
eval_stack=HASH(0x800651fc8), eval_nest=0
 230 | 1 |   |    EVAL_ERROR = None                                                                   #PL: ;

Tokens: } ValPy: 
 230 | 0 |   |except Exception as _e:                                                                 #PL: ;

Tokens: } ValPy: 
 230 | 1 |   |    EVAL_ERROR = _exc(_e)                                                               #PL: ;

Tokens: } ValPy: 
 230 | 1 |   |    traceback.print_exc()                                                               #PL: ;
Main loop, line=;


 === Line 230 Perl source:;===


Line:  230 TokenStr: =||= @ValPy: 
 230 | 0 |   |pass                                                                                    #PL: ;

Tokens:  ValPy: 
 231 | 0 |   |
Main loop, line=if ($@)


 === Line 232 Perl source:if ($@)===

Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' value='EVAL_ERROR' Tokenstr |c(s| translated: if  ( EVAL_ERROR
Lexem 3 Current token=')' value=')' Tokenstr |c(s)| translated: if  ( EVAL_ERROR )

Line:  233 TokenStr: =|c(s)|= @ValPy: if  ( EVAL_ERROR )
control(0) =|c(s)|= if ( $ )

control-parens removed, begin=0 start=1 =|cs|= if $

Generated partial line if 
expression(1, 1, 0) =|cs|= if $

Generated partial line if EVAL_ERROR
expression returns 2
Generated partial line if EVAL_ERROR:
 233 | 0 |   |if EVAL_ERROR:                                                                          #PL: if ($@)

Tokens: cs ValPy: 
Main loop, line={


 === Line 233 Perl source:{===


Line:  233 TokenStr: =|{|= @ValPy: {
Main loop, line=if ($@ =~ /timeout/)


 === Line 234 Perl source:if ($@ =~ /timeout/)===

Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' value='EVAL_ERROR' Tokenstr |c(s| translated: if  ( EVAL_ERROR
Lexem 3 Current token='~' value='' Tokenstr |c(s~| translated: if  ( EVAL_ERROR 
Lexem 4 Current token='q' value='re.search(r'timeout',' Tokenstr |c(s~q| translated: if  ( EVAL_ERROR  re.search(r'timeout',
Lexem 5 Current token=')' value=')' Tokenstr |c(s~q)| translated: if  ( EVAL_ERROR  re.search(r'timeout', )

Line:  235 TokenStr: =|c(s~q)|= @ValPy: if  ( EVAL_ERROR  re.search(r'timeout', )
control(0) =|c(s~q)|= if ( $ =~ timeout )

control-parens removed, begin=0 start=1 =|cs~q|= if $ =~ timeout

Generated partial line if 
expression(1, 3, 0) =|cs~q|= if $ =~ timeout

Generated partial line if re.search(r'timeout',
expression(1, 1, 0) =|cs~q|= if $ =~ timeout

Generated partial line if re.search(r'timeout',EVAL_ERROR
expression returns 2
Generated partial line if re.search(r'timeout',EVAL_ERROR)
expression returns 4
Generated partial line if re.search(r'timeout',EVAL_ERROR):
 235 | 1 |   |    if re.search(r'timeout',EVAL_ERROR):                                                #PL: if ($@ =~ /timeout/)

Tokens: cs~q ValPy: 
Main loop, line={


 === Line 235 Perl source:{===


Line:  235 TokenStr: =|{|= @ValPy: {
 236 | 2 |   |        # timed out
 237 | 2 |   |
Main loop, line=$retval = 1;


 === Line 238 Perl source:$retval = 1;===

Lexem 0 Current token='s' value='retval' Tokenstr |s| translated: retval
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: retval =
Lexem 2 Current token='d' value='1' Tokenstr |s=d| translated: retval = 1

Line:  238 TokenStr: =|s=d|= @ValPy: retval = 1
assignment(0, 2) =|s=d|= $retval = 1

Generated partial line retval
Generated partial line retval=
assign, ValClass[limit] = d, ValPy=1, ValPerl=1

Generated partial line retval=1
 238 | 2 |   |        retval = 1                                                                      #PL: $retval = 1;

Tokens: s=d ValPy: 
Main loop, line=}


 === Line 239 Perl source:}===


Line:  239 TokenStr: =|}|= @ValPy: }
Main loop, line=else


 === Line 240 Perl source:else===

Lexem 0 Current token='C' value='else: ' Tokenstr |C| translated: else: 

Line:  241 TokenStr: =|C|= @ValPy: else: 
Generated partial line else:
 241 | 1 |   |    else:                                                                               #PL: else

Tokens: C ValPy: 
Main loop, line={


 === Line 241 Perl source:{===


Line:  241 TokenStr: =|{|= @ValPy: {
Main loop, line=alarm (0);


 === Line 242 Perl source:alarm (0);===

Lexem 0 Current token='f' value='signal.alarm' Tokenstr |f| translated: signal.alarm
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: signal.alarm (
Lexem 2 Current token='d' value='0' Tokenstr |f(d| translated: signal.alarm ( 0
Lexem 3 Current token=')' value=')' Tokenstr |f(d)| translated: signal.alarm ( 0 )

Line:  242 TokenStr: =|f(d)|= @ValPy: signal.alarm ( 0 )
function(0, 3) =|f(d)|= alarm ( 0 )

function start=2, end_pos=2, bracketed=1
Generated partial line signal.alarm
Generated partial line signal.alarm(
expression(2, 2, 0) =|f(d)|= alarm ( 0 )

Generated partial line signal.alarm(0
expression returns 3
Generated partial line signal.alarm(0)
 242 | 2 |   |        signal.alarm(0)                                                                 #PL: alarm (0);

Tokens: f(d) ValPy: 
 243 | 2 |   |
Main loop, line=die;


 === Line 244 Perl source:die;===

Lexem 0 Current token='f' value='raise Die' Tokenstr |f| translated: raise Die

Line:  244 TokenStr: =|f|= @ValPy: raise Die
function(0, 0) =|f|= die

function start=1, end_pos=0, bracketed=-1
Generated partial line raise Die
Generated partial line raise Die()
 244 | 2 |   |        raise Die()                                                                     #PL: die;

Tokens: f ValPy: 
Main loop, line=}


 === Line 245 Perl source:}===


Line:  245 TokenStr: =|}|= @ValPy: }
 246 | 1 |   |
Main loop, line=}


 === Line 247 Perl source:}===


Line:  247 TokenStr: =|}|= @ValPy: }
 248 | 0 |   |
Main loop, line=exit($retval);


 === Line 249 Perl source:exit($retval);===

Lexem 0 Current token='f' value='sys.exit' Tokenstr |f| translated: sys.exit
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: sys.exit (
Lexem 2 Current token='s' value='retval' Tokenstr |f(s| translated: sys.exit ( retval
Lexem 3 Current token=')' value=')' Tokenstr |f(s)| translated: sys.exit ( retval )

Line:  249 TokenStr: =|f(s)|= @ValPy: sys.exit ( retval )
function(0, 3) =|f(s)|= exit ( $retval )

function start=2, end_pos=2, bracketed=1
Generated partial line sys.exit
Generated partial line sys.exit(
expression(2, 2, 0) =|f(s)|= exit ( $retval )

Generated partial line sys.exit(retval
expression returns 3
Generated partial line sys.exit(retval)
 249 | 0 |   |sys.exit(retval)                                                                        #PL: exit($retval);

Tokens: f(s) ValPy: 
 250 | 0 |   |
Main loop, line=sub test_os_error_in_sub


 === Line 251 Perl source:sub test_os_error_in_sub===

Lexem 0 Current token='k' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' value='test_os_error_in_sub' Tokenstr |ki| translated: def test_os_error_in_sub

Line:  252 TokenStr: =|ki|= @ValPy: def test_os_error_in_sub
Generated partial line deftest_os_error_in_sub(_args):
 252 | 0 |   |def test_os_error_in_sub(_args):                                                        #PL: sub test_os_error_in_sub

Tokens: ki ValPy: 
Main loop, line={


 === Line 252 Perl source:{===


Line:  252 TokenStr: =|{|= @ValPy: {
Main loop, line=open(FH, "<", "file");


 === Line 253 Perl source:open(FH, "<", "file");===

Lexem 0 Current token='f' value='open' Tokenstr |f| translated: open
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: open (
Lexem 2 Current token='i' value='FH' Tokenstr |f(i| translated: open ( FH
Lexem 3 Current token=',' value=',' Tokenstr |f(i,| translated: open ( FH ,
Lexem 4 Current token='"' value=''<'' Tokenstr |f(i,"| translated: open ( FH , '<'
Lexem 5 Current token=',' value=',' Tokenstr |f(i,",| translated: open ( FH , '<' ,
Lexem 6 Current token='"' value=''file'' Tokenstr |f(i,","| translated: open ( FH , '<' , 'file'
Lexem 7 Current token=')' value=')' Tokenstr |f(i,",")| translated: open ( FH , '<' , 'file' )

Line:  253 TokenStr: =|f(i,",")|= @ValPy: open ( FH , '<' , 'file' )
 253 | 1 |   |    try:                                                                                #PL: open(FH, "<", "file");
 253 | 2 |   |        FH=open('file', 'r')                                                            #PL: open(FH, "<", "file");
 253 | 1 |   |    except OSError as _e:                                                               #PL: open(FH, "<", "file");
 253 | 2 |   |        global OS_ERROR                                                                 #PL: open(FH, "<", "file");
 253 | 2 |   |        OS_ERROR = str(_e)                                                              #PL: open(FH, "<", "file");
 253 | 2 |   |        traceback.print_exc()                                                           #PL: open(FH, "<", "file");
 253 | 2 |   |        raise                                                                           #PL: open(FH, "<", "file");
Main loop, line=print "$!\n";


 === Line 254 Perl source:print "$!\n";===

Lexem 0 Current token='f' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='"' value='f"{OS_ERROR}\n"' Tokenstr |f"| translated: print f"{OS_ERROR}\n"

Line:  254 TokenStr: =|f"|= @ValPy: print f"{OS_ERROR}\n"
Generated partial line print(
print3(0) handle=, k=1, end_pos=1

expression(1, 1, 0) =|f"|= print $!\n

Generated partial line print(f"{OS_ERROR}\n"
expression returns 2
Generated partial line print(f"{OS_ERROR}")
 254 | 1 |   |    print(f"{OS_ERROR}")                                                                #PL: print "$!\n";

Tokens: f" ValPy: 
finish: prev_line=print "$!\n";, PythonCode=
finish: Resetting line to }
Main loop, line=}


 === Line 255 Perl source:}===


Line:  255 TokenStr: =|}|= @ValPy: }
ERROR STATISTICS:  W: 6 S: 1


LINE 81 [Pythonizer-S535]:  Attempt to set the next nesting level below zero ignored




 [Softpano-W317]:  Debug flag is set to 5

LINE 44 [main-W3027]:  Function autoflush is neither internal not built-in function. Please check the correspondence of arguments

LINE 132 [main-W3027]:  Function timegm is neither internal not built-in function. Please check the correspondence of arguments

LINE 177 [main-W3027]:  Function POSIX.tmpnam is neither internal not built-in function. Please check the correspondence of arguments

LINE 178 [main-W3027]:  Function new is neither internal not built-in function. Please check the correspondence of arguments

LINE 194 [main-W3027]:  Function traceback.print_stack is neither internal not built-in function. Please check the correspondence of arguments



*** PLEASE CHECK 1 SERIOUS MESSAGES ABOVE
