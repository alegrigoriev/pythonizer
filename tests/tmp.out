 [Softpano-W317]:  Debug flag is set to 5


PYTHONIZER: Fuzzy translator of Python to Perl. Version 0.920 (mtime 211209_1706) Started at 21/12/09 17:06

Logs are at /tmp/Pythonizer/pythonizer.211209_1706.log. Type -h for help.
=============================================================================================================
Results of transcription are written to the file  test_sort.py
=========================================================================================================================

Lexem 0 Current token='c' perl='use' value='NoTrans!' Tokenstr |c| translated: NoTrans!
Lexem 1 Current token='i' perl='Carp::Assert' value='Carp.Assert' Tokenstr |ci| translated: NoTrans! Carp.Assert
Lexem 0 Current token='c' perl='use' value='NoTrans!' Tokenstr |c| translated: NoTrans!
Lexem 1 Current token='i' perl='Data::Dumper' value='Data.Dumper' Tokenstr |ci| translated: NoTrans! Data.Dumper
Lexem 0 Current token='c' perl='use' value='NoTrans!' Tokenstr |c| translated: NoTrans!
Lexem 1 Current token='i' perl='feature' value='feature' Tokenstr |ci| translated: NoTrans! feature
Lexem 2 Current token='"' perl='fc' value=''fc'' Tokenstr |ci"| translated: NoTrans! feature 'fc'
Lexem 0 Current token='a' perl='@files' value='files' Tokenstr |a| translated: files
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: files =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: files = (
Lexem 3 Current token='"' perl='d' value=''d'' Tokenstr |a=("| translated: files = ( 'd'
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |a=(",| translated: files = ( 'd' ,
Lexem 5 Current token='"' perl='e' value=''e'' Tokenstr |a=(","| translated: files = ( 'd' , 'e'
Lexem 6 Current token=',' perl=',' value=',' Tokenstr |a=(",",| translated: files = ( 'd' , 'e' ,
Lexem 7 Current token='"' perl='c' value=''c'' Tokenstr |a=(",","| translated: files = ( 'd' , 'e' , 'c'
Lexem 8 Current token=',' perl=',' value=',' Tokenstr |a=(",",",| translated: files = ( 'd' , 'e' , 'c' ,
Lexem 9 Current token='"' perl='a' value=''a'' Tokenstr |a=(",",","| translated: files = ( 'd' , 'e' , 'c' , 'a'
Lexem 10 Current token=',' perl=',' value=',' Tokenstr |a=(",",",",| translated: files = ( 'd' , 'e' , 'c' , 'a' ,
Lexem 11 Current token='"' perl='b' value=''b'' Tokenstr |a=(",",",","| translated: files = ( 'd' , 'e' , 'c' , 'a' , 'b'
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |a=(",",",",")| translated: files = ( 'd' , 'e' , 'c' , 'a' , 'b' )
check_ref(main, files) at 0
expr_type(2, 12, main)
expr_type(3, 3, main)
expr_type(5, 5, main)
expr_type(7, 7, main)
expr_type(9, 9, main)
merge_types(files, main, a of u)
expr_type(0, 12, main)
Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@articles' value='articles' Tokenstr |ta| translated:  articles
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  articles =
Lexem 3 Current token='f' perl='sort' value='sorted' Tokenstr |ta=f| translated:  articles = sorted
Lexem 4 Current token='a' perl='@files' value='files' Tokenstr |ta=fa| translated:  articles = sorted files
check_ref(main, articles) at 1
expr_type(3, 4, main)
merge_types(articles, main, a)
check_ref(main, files) at 4
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='join' value='.join(' Tokenstr |c(f| translated: assert ( .join(
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( .join( (
Lexem 4 Current token='"' perl='' value='''' Tokenstr |c(f("| translated: assert ( .join( ( ''
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |c(f(",| translated: assert ( .join( ( '' ,
Lexem 6 Current token='a' perl='@articles' value='articles' Tokenstr |c(f(",a| translated: assert ( .join( ( '' , articles
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |c(f(",a)| translated: assert ( .join( ( '' , articles )
Lexem 8 Current token='>' perl='eq' value='==' Tokenstr |c(f(",a)>| translated: assert ( .join( ( '' , articles ) ==
Lexem 9 Current token='"' perl='abcde' value=''abcde'' Tokenstr |c(f(",a)>"| translated: assert ( .join( ( '' , articles ) == 'abcde'
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |c(f(",a)>")| translated: assert ( .join( ( '' , articles ) == 'abcde' )
check_ref(main, articles) at 6
Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@articles1' value='articles1' Tokenstr |ta| translated:  articles1
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  articles1 =
Lexem 3 Current token='f' perl='sort' value='sorted' Tokenstr |ta=f| translated:  articles1 = sorted
Lexem 4 Current token='(' perl='{' value='[' Tokenstr |ta=f(| translated:  articles1 = sorted [
Lexem 5 Current token='s' perl='$a' value='a' Tokenstr |ta=f(s| translated:  articles1 = sorted [ a
Lexem 6 Current token='>' perl='cmp' value='_cmp' Tokenstr |ta=f(s>| translated:  articles1 = sorted [ a _cmp
Lexem 7 Current token='s' perl='$b' value='b' Tokenstr |ta=f(s>s| translated:  articles1 = sorted [ a _cmp b
Lexem 8 Current token=')' perl='}' value=']' Tokenstr |ta=f(s>s)| translated:  articles1 = sorted [ a _cmp b ]
Lexem 9 Current token='a' perl='@files' value='files' Tokenstr |ta=f(s>s)a| translated:  articles1 = sorted [ a _cmp b ] files
check_ref(main, articles1) at 1
expr_type(3, 9, main)
merge_types(articles1, main, a)
check_ref(main, a) at 5
arg_type(sort, 0) = f
scalar_reference_type(5) = f
merge_types(a, main, f)
check_ref(main, b) at 7
arg_type(sort, 1) = a
scalar_reference_type(7) = a
merge_types(b, main, a)
check_ref(main, files) at 9
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='join' value='.join(' Tokenstr |c(f| translated: assert ( .join(
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( .join( (
Lexem 4 Current token='"' perl='' value='''' Tokenstr |c(f("| translated: assert ( .join( ( ''
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |c(f(",| translated: assert ( .join( ( '' ,
Lexem 6 Current token='a' perl='@articles1' value='articles1' Tokenstr |c(f(",a| translated: assert ( .join( ( '' , articles1
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |c(f(",a)| translated: assert ( .join( ( '' , articles1 )
Lexem 8 Current token='>' perl='eq' value='==' Tokenstr |c(f(",a)>| translated: assert ( .join( ( '' , articles1 ) ==
Lexem 9 Current token='"' perl='abcde' value=''abcde'' Tokenstr |c(f(",a)>"| translated: assert ( .join( ( '' , articles1 ) == 'abcde'
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |c(f(",a)>")| translated: assert ( .join( ( '' , articles1 ) == 'abcde' )
check_ref(main, articles1) at 6
Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@articles2' value='articles2' Tokenstr |ta| translated:  articles2
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  articles2 =
Lexem 3 Current token='f' perl='sort' value='sorted' Tokenstr |ta=f| translated:  articles2 = sorted
Lexem 4 Current token='(' perl='{' value='[' Tokenstr |ta=f(| translated:  articles2 = sorted [
Lexem 5 Current token='f' perl='fc' value='.casefold()' Tokenstr |ta=f(f| translated:  articles2 = sorted [ .casefold()
Lexem 6 Current token='(' perl='(' value='(' Tokenstr |ta=f(f(| translated:  articles2 = sorted [ .casefold() (
Lexem 7 Current token='s' perl='$a' value='a' Tokenstr |ta=f(f(s| translated:  articles2 = sorted [ .casefold() ( a
Lexem 8 Current token=')' perl=')' value=')' Tokenstr |ta=f(f(s)| translated:  articles2 = sorted [ .casefold() ( a )
Lexem 9 Current token='>' perl='cmp' value='_cmp' Tokenstr |ta=f(f(s)>| translated:  articles2 = sorted [ .casefold() ( a ) _cmp
Lexem 10 Current token='f' perl='fc' value='.casefold()' Tokenstr |ta=f(f(s)>f| translated:  articles2 = sorted [ .casefold() ( a ) _cmp .casefold()
Lexem 11 Current token='(' perl='(' value='(' Tokenstr |ta=f(f(s)>f(| translated:  articles2 = sorted [ .casefold() ( a ) _cmp .casefold() (
Lexem 12 Current token='s' perl='$b' value='b' Tokenstr |ta=f(f(s)>f(s| translated:  articles2 = sorted [ .casefold() ( a ) _cmp .casefold() ( b
Lexem 13 Current token=')' perl=')' value=')' Tokenstr |ta=f(f(s)>f(s)| translated:  articles2 = sorted [ .casefold() ( a ) _cmp .casefold() ( b )
Lexem 14 Current token=')' perl='}' value=']' Tokenstr |ta=f(f(s)>f(s))| translated:  articles2 = sorted [ .casefold() ( a ) _cmp .casefold() ( b ) ]
Lexem 15 Current token='a' perl='@files' value='files' Tokenstr |ta=f(f(s)>f(s))a| translated:  articles2 = sorted [ .casefold() ( a ) _cmp .casefold() ( b ) ] files
check_ref(main, articles2) at 1
expr_type(3, 15, main)
merge_types(articles2, main, a)
check_ref(main, a) at 7
arg_type(fc, 0) = S
scalar_reference_type(7) = S
check_ref(main, b) at 12
arg_type(fc, 0) = S
scalar_reference_type(12) = S
check_ref(main, files) at 15
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='join' value='.join(' Tokenstr |c(f| translated: assert ( .join(
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( .join( (
Lexem 4 Current token='"' perl='' value='''' Tokenstr |c(f("| translated: assert ( .join( ( ''
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |c(f(",| translated: assert ( .join( ( '' ,
Lexem 6 Current token='a' perl='@articles2' value='articles2' Tokenstr |c(f(",a| translated: assert ( .join( ( '' , articles2
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |c(f(",a)| translated: assert ( .join( ( '' , articles2 )
Lexem 8 Current token='>' perl='eq' value='==' Tokenstr |c(f(",a)>| translated: assert ( .join( ( '' , articles2 ) ==
Lexem 9 Current token='"' perl='abcde' value=''abcde'' Tokenstr |c(f(",a)>"| translated: assert ( .join( ( '' , articles2 ) == 'abcde'
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |c(f(",a)>")| translated: assert ( .join( ( '' , articles2 ) == 'abcde' )
check_ref(main, articles2) at 6
Lexem 0 Current token='a' perl='@files' value='files' Tokenstr |a| translated: files
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: files =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: files = (
Lexem 3 Current token='"' perl='d' value=''d'' Tokenstr |a=("| translated: files = ( 'd'
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |a=(",| translated: files = ( 'd' ,
Lexem 5 Current token='"' perl='e' value=''e'' Tokenstr |a=(","| translated: files = ( 'd' , 'e'
Lexem 6 Current token=',' perl=',' value=',' Tokenstr |a=(",",| translated: files = ( 'd' , 'e' ,
Lexem 7 Current token='"' perl='c' value=''c'' Tokenstr |a=(",","| translated: files = ( 'd' , 'e' , 'c'
Lexem 8 Current token=',' perl=',' value=',' Tokenstr |a=(",",",| translated: files = ( 'd' , 'e' , 'c' ,
Lexem 9 Current token='"' perl='a' value=''a'' Tokenstr |a=(",",","| translated: files = ( 'd' , 'e' , 'c' , 'a'
Lexem 10 Current token=',' perl=',' value=',' Tokenstr |a=(",",",",| translated: files = ( 'd' , 'e' , 'c' , 'a' ,
Lexem 11 Current token='"' perl='b' value=''b'' Tokenstr |a=(",",",","| translated: files = ( 'd' , 'e' , 'c' , 'a' , 'b'
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |a=(",",",",")| translated: files = ( 'd' , 'e' , 'c' , 'a' , 'b' )
check_ref(main, files) at 0
expr_type(2, 12, main)
expr_type(3, 3, main)
expr_type(5, 5, main)
expr_type(7, 7, main)
expr_type(9, 9, main)
merge_types(files, main, a of u)
merge_types: otype=a of u
expr_type(0, 12, main)
Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@articlesr' value='articlesr' Tokenstr |ta| translated:  articlesr
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  articlesr =
Lexem 3 Current token='f' perl='sort' value='sorted' Tokenstr |ta=f| translated:  articlesr = sorted
Lexem 4 Current token='(' perl='{' value='[' Tokenstr |ta=f(| translated:  articlesr = sorted [
Lexem 5 Current token='s' perl='$b' value='b' Tokenstr |ta=f(s| translated:  articlesr = sorted [ b
Lexem 6 Current token='>' perl='cmp' value='_cmp' Tokenstr |ta=f(s>| translated:  articlesr = sorted [ b _cmp
Lexem 7 Current token='s' perl='$a' value='a' Tokenstr |ta=f(s>s| translated:  articlesr = sorted [ b _cmp a
Lexem 8 Current token=')' perl='}' value=']' Tokenstr |ta=f(s>s)| translated:  articlesr = sorted [ b _cmp a ]
Lexem 9 Current token='a' perl='@files' value='files' Tokenstr |ta=f(s>s)a| translated:  articlesr = sorted [ b _cmp a ] files
check_ref(main, articlesr) at 1
expr_type(3, 9, main)
merge_types(articlesr, main, a)
check_ref(main, b) at 5
arg_type(sort, 0) = f
scalar_reference_type(5) = f
check_ref(main, a) at 7
arg_type(sort, 1) = a
scalar_reference_type(7) = a
check_ref(main, files) at 9
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='join' value='.join(' Tokenstr |c(f| translated: assert ( .join(
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( .join( (
Lexem 4 Current token='"' perl='' value='''' Tokenstr |c(f("| translated: assert ( .join( ( ''
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |c(f(",| translated: assert ( .join( ( '' ,
Lexem 6 Current token='a' perl='@articlesr' value='articlesr' Tokenstr |c(f(",a| translated: assert ( .join( ( '' , articlesr
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |c(f(",a)| translated: assert ( .join( ( '' , articlesr )
Lexem 8 Current token='>' perl='eq' value='==' Tokenstr |c(f(",a)>| translated: assert ( .join( ( '' , articlesr ) ==
Lexem 9 Current token='"' perl='edcba' value=''edcba'' Tokenstr |c(f(",a)>"| translated: assert ( .join( ( '' , articlesr ) == 'edcba'
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |c(f(",a)>")| translated: assert ( .join( ( '' , articlesr ) == 'edcba' )
check_ref(main, articlesr) at 6
Lexem 0 Current token='a' perl='@files' value='files' Tokenstr |a| translated: files
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: files =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: files = (
Lexem 3 Current token='d' perl='4' value='4' Tokenstr |a=(d| translated: files = ( 4
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |a=(d,| translated: files = ( 4 ,
Lexem 5 Current token='d' perl='5' value='5' Tokenstr |a=(d,d| translated: files = ( 4 , 5
Lexem 6 Current token=',' perl=',' value=',' Tokenstr |a=(d,d,| translated: files = ( 4 , 5 ,
Lexem 7 Current token='d' perl='3' value='3' Tokenstr |a=(d,d,d| translated: files = ( 4 , 5 , 3
Lexem 8 Current token=',' perl=',' value=',' Tokenstr |a=(d,d,d,| translated: files = ( 4 , 5 , 3 ,
Lexem 9 Current token='d' perl='1' value='1' Tokenstr |a=(d,d,d,d| translated: files = ( 4 , 5 , 3 , 1
Lexem 10 Current token=',' perl=',' value=',' Tokenstr |a=(d,d,d,d,| translated: files = ( 4 , 5 , 3 , 1 ,
Lexem 11 Current token='d' perl='2' value='2' Tokenstr |a=(d,d,d,d,d| translated: files = ( 4 , 5 , 3 , 1 , 2
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |a=(d,d,d,d,d)| translated: files = ( 4 , 5 , 3 , 1 , 2 )
check_ref(main, files) at 0
expr_type(2, 12, main)
expr_type(3, 3, main)
expr_type(5, 5, main)
expr_type(7, 7, main)
expr_type(9, 9, main)
merge_types(files, main, a of u)
merge_types: otype=a of u
expr_type(0, 12, main)
Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@articlesn' value='articlesn' Tokenstr |ta| translated:  articlesn
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  articlesn =
Lexem 3 Current token='f' perl='sort' value='sorted' Tokenstr |ta=f| translated:  articlesn = sorted
Lexem 4 Current token='(' perl='{' value='[' Tokenstr |ta=f(| translated:  articlesn = sorted [
Lexem 5 Current token='s' perl='$a' value='a' Tokenstr |ta=f(s| translated:  articlesn = sorted [ a
Lexem 6 Current token='>' perl='<=>' value='_spaceship' Tokenstr |ta=f(s>| translated:  articlesn = sorted [ a _spaceship
Lexem 7 Current token='s' perl='$b' value='b' Tokenstr |ta=f(s>s| translated:  articlesn = sorted [ a _spaceship b
Lexem 8 Current token=')' perl='}' value=']' Tokenstr |ta=f(s>s)| translated:  articlesn = sorted [ a _spaceship b ]
Lexem 9 Current token='a' perl='@files' value='files' Tokenstr |ta=f(s>s)a| translated:  articlesn = sorted [ a _spaceship b ] files
check_ref(main, articlesn) at 1
expr_type(3, 9, main)
merge_types(articlesn, main, a)
check_ref(main, a) at 5
arg_type(sort, 0) = f
scalar_reference_type(5) = f
check_ref(main, b) at 7
arg_type(sort, 1) = a
scalar_reference_type(7) = a
check_ref(main, files) at 9
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='join' value='.join(' Tokenstr |c(f| translated: assert ( .join(
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( .join( (
Lexem 4 Current token='"' perl='' value='''' Tokenstr |c(f("| translated: assert ( .join( ( ''
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |c(f(",| translated: assert ( .join( ( '' ,
Lexem 6 Current token='f' perl='map' value='map' Tokenstr |c(f(",f| translated: assert ( .join( ( '' , map
Lexem 7 Current token='(' perl='{' value='[' Tokenstr |c(f(",f(| translated: assert ( .join( ( '' , map [
Lexem 8 Current token='"' perl='' value='''' Tokenstr |c(f(",f("| translated: assert ( .join( ( '' , map [ ''
Lexem 9 Current token='.' perl='.' value=' + ' Tokenstr |c(f(",f(".| translated: assert ( .join( ( '' , map [ ''  + 
Lexem 10 Current token='s' perl='$_' value='_d' Tokenstr |c(f(",f(".s| translated: assert ( .join( ( '' , map [ ''  +  _d
Lexem 11 Current token=')' perl='}' value=']' Tokenstr |c(f(",f(".s)| translated: assert ( .join( ( '' , map [ ''  +  _d ]
Lexem 12 Current token='a' perl='@articlesn' value='articlesn' Tokenstr |c(f(",f(".s)a| translated: assert ( .join( ( '' , map [ ''  +  _d ] articlesn
Lexem 13 Current token=')' perl=')' value=')' Tokenstr |c(f(",f(".s)a)| translated: assert ( .join( ( '' , map [ ''  +  _d ] articlesn )
Lexem 14 Current token='>' perl='eq' value='==' Tokenstr |c(f(",f(".s)a)>| translated: assert ( .join( ( '' , map [ ''  +  _d ] articlesn ) ==
Lexem 15 Current token='"' perl='12345' value=''12345'' Tokenstr |c(f(",f(".s)a)>"| translated: assert ( .join( ( '' , map [ ''  +  _d ] articlesn ) == '12345'
Lexem 16 Current token=')' perl=')' value=')' Tokenstr |c(f(",f(".s)a)>")| translated: assert ( .join( ( '' , map [ ''  +  _d ] articlesn ) == '12345' )
check_ref(main, _d) at 10
arg_type(map, 1) = a
scalar_reference_type(10) = a
merge_types(_d, main, a)
check_ref(main, articlesn) at 12
Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@articlesnd' value='articlesnd' Tokenstr |ta| translated:  articlesnd
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  articlesnd =
Lexem 3 Current token='f' perl='sort' value='sorted' Tokenstr |ta=f| translated:  articlesnd = sorted
Lexem 4 Current token='(' perl='{' value='[' Tokenstr |ta=f(| translated:  articlesnd = sorted [
Lexem 5 Current token='s' perl='$b' value='b' Tokenstr |ta=f(s| translated:  articlesnd = sorted [ b
Lexem 6 Current token='>' perl='<=>' value='_spaceship' Tokenstr |ta=f(s>| translated:  articlesnd = sorted [ b _spaceship
Lexem 7 Current token='s' perl='$a' value='a' Tokenstr |ta=f(s>s| translated:  articlesnd = sorted [ b _spaceship a
Lexem 8 Current token=')' perl='}' value=']' Tokenstr |ta=f(s>s)| translated:  articlesnd = sorted [ b _spaceship a ]
Lexem 9 Current token='a' perl='@files' value='files' Tokenstr |ta=f(s>s)a| translated:  articlesnd = sorted [ b _spaceship a ] files
check_ref(main, articlesnd) at 1
expr_type(3, 9, main)
merge_types(articlesnd, main, a)
check_ref(main, b) at 5
arg_type(sort, 0) = f
scalar_reference_type(5) = f
check_ref(main, a) at 7
arg_type(sort, 1) = a
scalar_reference_type(7) = a
check_ref(main, files) at 9
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='join' value='.join(' Tokenstr |c(f| translated: assert ( .join(
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( .join( (
Lexem 4 Current token='"' perl='' value='''' Tokenstr |c(f("| translated: assert ( .join( ( ''
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |c(f(",| translated: assert ( .join( ( '' ,
Lexem 6 Current token='f' perl='map' value='map' Tokenstr |c(f(",f| translated: assert ( .join( ( '' , map
Lexem 7 Current token='(' perl='{' value='[' Tokenstr |c(f(",f(| translated: assert ( .join( ( '' , map [
Lexem 8 Current token='"' perl='' value='''' Tokenstr |c(f(",f("| translated: assert ( .join( ( '' , map [ ''
Lexem 9 Current token='.' perl='.' value=' + ' Tokenstr |c(f(",f(".| translated: assert ( .join( ( '' , map [ ''  + 
Lexem 10 Current token='s' perl='$_' value='_d' Tokenstr |c(f(",f(".s| translated: assert ( .join( ( '' , map [ ''  +  _d
Lexem 11 Current token=')' perl='}' value=']' Tokenstr |c(f(",f(".s)| translated: assert ( .join( ( '' , map [ ''  +  _d ]
Lexem 12 Current token='a' perl='@articlesnd' value='articlesnd' Tokenstr |c(f(",f(".s)a| translated: assert ( .join( ( '' , map [ ''  +  _d ] articlesnd
Lexem 13 Current token=')' perl=')' value=')' Tokenstr |c(f(",f(".s)a)| translated: assert ( .join( ( '' , map [ ''  +  _d ] articlesnd )
Lexem 14 Current token='>' perl='eq' value='==' Tokenstr |c(f(",f(".s)a)>| translated: assert ( .join( ( '' , map [ ''  +  _d ] articlesnd ) ==
Lexem 15 Current token='"' perl='54321' value=''54321'' Tokenstr |c(f(",f(".s)a)>"| translated: assert ( .join( ( '' , map [ ''  +  _d ] articlesnd ) == '54321'
Lexem 16 Current token=')' perl=')' value=')' Tokenstr |c(f(",f(".s)a)>")| translated: assert ( .join( ( '' , map [ ''  +  _d ] articlesnd ) == '54321' )
check_ref(main, _d) at 10
arg_type(map, 1) = a
scalar_reference_type(10) = a
check_ref(main, articlesnd) at 12
Lexem 0 Current token='h' perl='age' value='age' Tokenstr |h| translated: age
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |h=| translated: age =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |h=(| translated: age = (
Lexem 3 Current token='i' perl='a' value='a' Tokenstr |h=(i| translated: age = ( a
Lexem 4 Current token=':' perl='=>' value=': ' Tokenstr |h=(i:| translated: age = ( a : 
Lexem 5 Current token='d' perl='10' value='10' Tokenstr |h=(i:d| translated: age = ( a :  10
Lexem 6 Current token=',' perl=',' value=',' Tokenstr |h=(i:d,| translated: age = ( a :  10 ,
Lexem 7 Current token='i' perl='b' value='b' Tokenstr |h=(i:d,i| translated: age = ( a :  10 , b
Lexem 8 Current token=':' perl='=>' value=': ' Tokenstr |h=(i:d,i:| translated: age = ( a :  10 , b : 
Lexem 9 Current token='d' perl='5' value='5' Tokenstr |h=(i:d,i:d| translated: age = ( a :  10 , b :  5
Lexem 10 Current token=',' perl=',' value=',' Tokenstr |h=(i:d,i:d,| translated: age = ( a :  10 , b :  5 ,
Lexem 11 Current token='i' perl='c' value='c' Tokenstr |h=(i:d,i:d,i| translated: age = ( a :  10 , b :  5 , c
Lexem 12 Current token=':' perl='=>' value=': ' Tokenstr |h=(i:d,i:d,i:| translated: age = ( a :  10 , b :  5 , c : 
Lexem 13 Current token='d' perl='20' value='20' Tokenstr |h=(i:d,i:d,i:d| translated: age = ( a :  10 , b :  5 , c :  20
Lexem 14 Current token=',' perl=',' value=',' Tokenstr |h=(i:d,i:d,i:d,| translated: age = ( a :  10 , b :  5 , c :  20 ,
Lexem 15 Current token='i' perl='d' value='d' Tokenstr |h=(i:d,i:d,i:d,i| translated: age = ( a :  10 , b :  5 , c :  20 , d
Lexem 16 Current token=':' perl='=>' value=': ' Tokenstr |h=(i:d,i:d,i:d,i:| translated: age = ( a :  10 , b :  5 , c :  20 , d : 
Lexem 17 Current token='d' perl='1' value='1' Tokenstr |h=(i:d,i:d,i:d,i:d| translated: age = ( a :  10 , b :  5 , c :  20 , d :  1
Lexem 18 Current token=',' perl=',' value=',' Tokenstr |h=(i:d,i:d,i:d,i:d,| translated: age = ( a :  10 , b :  5 , c :  20 , d :  1 ,
Lexem 19 Current token='i' perl='e' value='e' Tokenstr |h=(i:d,i:d,i:d,i:d,i| translated: age = ( a :  10 , b :  5 , c :  20 , d :  1 , e
Lexem 20 Current token=':' perl='=>' value=': ' Tokenstr |h=(i:d,i:d,i:d,i:d,i:| translated: age = ( a :  10 , b :  5 , c :  20 , d :  1 , e : 
Lexem 21 Current token='d' perl='6' value='6' Tokenstr |h=(i:d,i:d,i:d,i:d,i:d| translated: age = ( a :  10 , b :  5 , c :  20 , d :  1 , e :  6
Lexem 22 Current token=')' perl=')' value=')' Tokenstr |h=(i:d,i:d,i:d,i:d,i:d)| translated: age = ( a :  10 , b :  5 , c :  20 , d :  1 , e :  6 )
check_ref(main, age) at 0
expr_type(2, 22, main)
expr_type(5, 5, main)
expr_type(9, 9, main)
expr_type(13, 13, main)
expr_type(17, 17, main)
merge_types(age, main, h of u)
expr_type(0, 22, main)
Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@eldest' value='eldest' Tokenstr |ta| translated:  eldest
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  eldest =
Lexem 3 Current token='f' perl='sort' value='sorted' Tokenstr |ta=f| translated:  eldest = sorted
Lexem 4 Current token='(' perl='{' value='[' Tokenstr |ta=f(| translated:  eldest = sorted [
Lexem 5 Current token='s' perl='$age' value='age' Tokenstr |ta=f(s| translated:  eldest = sorted [ age
Lexem 6 Current token='(' perl='{' value='[' Tokenstr |ta=f(s(| translated:  eldest = sorted [ age [
Lexem 7 Current token='s' perl='$b' value='b' Tokenstr |ta=f(s(s| translated:  eldest = sorted [ age [ b
Lexem 8 Current token=')' perl='}' value=']' Tokenstr |ta=f(s(s)| translated:  eldest = sorted [ age [ b ]
Lexem 9 Current token='>' perl='<=>' value='_spaceship' Tokenstr |ta=f(s(s)>| translated:  eldest = sorted [ age [ b ] _spaceship
Lexem 10 Current token='s' perl='$age' value='age' Tokenstr |ta=f(s(s)>s| translated:  eldest = sorted [ age [ b ] _spaceship age
Lexem 11 Current token='(' perl='{' value='[' Tokenstr |ta=f(s(s)>s(| translated:  eldest = sorted [ age [ b ] _spaceship age [
Lexem 12 Current token='s' perl='$a' value='a' Tokenstr |ta=f(s(s)>s(s| translated:  eldest = sorted [ age [ b ] _spaceship age [ a
Lexem 13 Current token=')' perl='}' value=']' Tokenstr |ta=f(s(s)>s(s)| translated:  eldest = sorted [ age [ b ] _spaceship age [ a ]
Lexem 14 Current token=')' perl='}' value=']' Tokenstr |ta=f(s(s)>s(s))| translated:  eldest = sorted [ age [ b ] _spaceship age [ a ] ]
Lexem 15 Current token='f' perl='keys' value='.keys()' Tokenstr |ta=f(s(s)>s(s))f| translated:  eldest = sorted [ age [ b ] _spaceship age [ a ] ] .keys()
Lexem 16 Current token='h' perl='age' value='age' Tokenstr |ta=f(s(s)>s(s))fh| translated:  eldest = sorted [ age [ b ] _spaceship age [ a ] ] .keys() age
check_ref(main, eldest) at 1
expr_type(3, 16, main)
merge_types(eldest, main, a)
check_ref(main, age) at 5
merge_types(age, main, h of u)
merge_types: otype=h of u
check_ref(main, b) at 7
scalar_reference_type(7) = S
check_ref(main, age) at 10
merge_types(age, main, h of u)
merge_types: otype=h of u
check_ref(main, a) at 12
scalar_reference_type(12) = S
check_ref(main, age) at 16
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='join' value='.join(' Tokenstr |c(f| translated: assert ( .join(
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( .join( (
Lexem 4 Current token='"' perl='' value='''' Tokenstr |c(f("| translated: assert ( .join( ( ''
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |c(f(",| translated: assert ( .join( ( '' ,
Lexem 6 Current token='a' perl='@eldest' value='eldest' Tokenstr |c(f(",a| translated: assert ( .join( ( '' , eldest
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |c(f(",a)| translated: assert ( .join( ( '' , eldest )
Lexem 8 Current token='>' perl='eq' value='==' Tokenstr |c(f(",a)>| translated: assert ( .join( ( '' , eldest ) ==
Lexem 9 Current token='"' perl='caebd' value=''caebd'' Tokenstr |c(f(",a)>"| translated: assert ( .join( ( '' , eldest ) == 'caebd'
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |c(f(",a)>")| translated: assert ( .join( ( '' , eldest ) == 'caebd' )
check_ref(main, eldest) at 6
Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@class' value='class_' Tokenstr |ta| translated:  class_
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  class_ =
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |ta=(| translated:  class_ = (
Lexem 4 Current token='"' perl='a' value=''a'' Tokenstr |ta=("| translated:  class_ = ( 'a'
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |ta=(",| translated:  class_ = ( 'a' ,
Lexem 6 Current token='"' perl='c' value=''c'' Tokenstr |ta=(","| translated:  class_ = ( 'a' , 'c'
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |ta=(",",| translated:  class_ = ( 'a' , 'c' ,
Lexem 8 Current token='"' perl='b' value=''b'' Tokenstr |ta=(",","| translated:  class_ = ( 'a' , 'c' , 'b'
Lexem 9 Current token=')' perl=')' value=')' Tokenstr |ta=(",",")| translated:  class_ = ( 'a' , 'c' , 'b' )
check_ref(main, class_) at 1
expr_type(3, 9, main)
expr_type(4, 4, main)
expr_type(6, 6, main)
merge_types(class_, main, a of u)
Lexem 0 Current token='k' perl='sub' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' perl='byage' value='byage' Tokenstr |ki| translated: def byage
get_globals: switching to 'byage' at line 42
expr_type(1, 1, byage)
Lexem 0 Current token='s' perl='$age' value='age' Tokenstr |s| translated: age
Lexem 1 Current token='(' perl='{' value='[' Tokenstr |s(| translated: age [
Lexem 2 Current token='s' perl='$a' value='a' Tokenstr |s(s| translated: age [ a
Lexem 3 Current token=')' perl='}' value=']' Tokenstr |s(s)| translated: age [ a ]
Lexem 4 Current token='>' perl='<=>' value='_spaceship' Tokenstr |s(s)>| translated: age [ a ] _spaceship
Lexem 5 Current token='s' perl='$age' value='age' Tokenstr |s(s)>s| translated: age [ a ] _spaceship age
Lexem 6 Current token='(' perl='{' value='[' Tokenstr |s(s)>s(| translated: age [ a ] _spaceship age [
Lexem 7 Current token='s' perl='$b' value='b' Tokenstr |s(s)>s(s| translated: age [ a ] _spaceship age [ b
Lexem 8 Current token=')' perl='}' value=']' Tokenstr |s(s)>s(s)| translated: age [ a ] _spaceship age [ b ]
check_ref(byage, age) at 0
merge_types(age, byage, h of u)
check_ref(byage, a) at 2
scalar_reference_type(2) = S
merge_types(a, byage, S)
check_ref(byage, age) at 5
merge_types(age, byage, h of u)
merge_types: otype=h of u
check_ref(byage, b) at 7
scalar_reference_type(7) = S
merge_types(b, byage, S)
expr_type(0, 8, byage)
get_globals: switching back to 'main' at line 44
merge_types(byage, main, I)
Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@sortedclass' value='sortedclass' Tokenstr |ta| translated:  sortedclass
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  sortedclass =
Lexem 3 Current token='f' perl='sort' value='sorted' Tokenstr |ta=f| translated:  sortedclass = sorted
Lexem 4 Current token='i' perl='byage' value='byage' Tokenstr |ta=fi| translated:  sortedclass = sorted byage
Lexem 5 Current token='a' perl='@class' value='class_' Tokenstr |ta=fia| translated:  sortedclass = sorted byage class_
check_ref(main, sortedclass) at 1
expr_type(3, 5, main)
merge_types(sortedclass, main, a)
check_ref(main, class_) at 5
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='join' value='.join(' Tokenstr |c(f| translated: assert ( .join(
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( .join( (
Lexem 4 Current token='"' perl='' value='''' Tokenstr |c(f("| translated: assert ( .join( ( ''
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |c(f(",| translated: assert ( .join( ( '' ,
Lexem 6 Current token='a' perl='@sortedclass' value='sortedclass' Tokenstr |c(f(",a| translated: assert ( .join( ( '' , sortedclass
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |c(f(",a)| translated: assert ( .join( ( '' , sortedclass )
Lexem 8 Current token='>' perl='eq' value='==' Tokenstr |c(f(",a)>| translated: assert ( .join( ( '' , sortedclass ) ==
Lexem 9 Current token='"' perl='bac' value=''bac'' Tokenstr |c(f(",a)>"| translated: assert ( .join( ( '' , sortedclass ) == 'bac'
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |c(f(",a)>")| translated: assert ( .join( ( '' , sortedclass ) == 'bac' )
check_ref(main, sortedclass) at 6
Lexem 0 Current token='k' perl='sub' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' perl='backwards' value='backwards' Tokenstr |ki| translated: def backwards
get_globals: switching to 'backwards' at line 48
expr_type(1, 1, backwards)
Lexem 0 Current token='s' perl='$b' value='b' Tokenstr |s| translated: b
Lexem 1 Current token='>' perl='cmp' value='_cmp' Tokenstr |s>| translated: b _cmp
Lexem 2 Current token='s' perl='$a' value='a' Tokenstr |s>s| translated: b _cmp a
check_ref(backwards, b) at 0
scalar_reference_type(0) = I
merge_types(b, backwards, I)
check_ref(backwards, a) at 2
scalar_reference_type(2) = u
merge_types(a, backwards, u)
expr_type(0, 2, backwards)
get_globals: switching back to 'main' at line 48
merge_types(backwards, main, I)
Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@harry' value='harry' Tokenstr |ta| translated:  harry
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  harry =
Lexem 3 Current token='q' perl='dog cat x Cain Abel' value='"dog cat x Cain Abel".split()' Tokenstr |ta=q| translated:  harry = "dog cat x Cain Abel".split()
check_ref(main, harry) at 1
expr_type(3, 3, main)
merge_types(harry, main, u)
Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@george' value='george' Tokenstr |ta| translated:  george
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  george =
Lexem 3 Current token='q' perl='gone chased yz Punished Axed' value='"gone chased yz Punished Axed".split()' Tokenstr |ta=q| translated:  george = "gone chased yz Punished Axed".split()
check_ref(main, george) at 1
expr_type(3, 3, main)
merge_types(george, main, u)
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='join' value='.join(' Tokenstr |c(f| translated: assert ( .join(
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( .join( (
Lexem 4 Current token='"' perl='' value='''' Tokenstr |c(f("| translated: assert ( .join( ( ''
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |c(f(",| translated: assert ( .join( ( '' ,
Lexem 6 Current token='f' perl='sort' value='sorted' Tokenstr |c(f(",f| translated: assert ( .join( ( '' , sorted
Lexem 7 Current token='a' perl='@harry' value='harry' Tokenstr |c(f(",fa| translated: assert ( .join( ( '' , sorted harry
Lexem 8 Current token=')' perl=')' value=')' Tokenstr |c(f(",fa)| translated: assert ( .join( ( '' , sorted harry )
Lexem 9 Current token='>' perl='eq' value='==' Tokenstr |c(f(",fa)>| translated: assert ( .join( ( '' , sorted harry ) ==
Lexem 10 Current token='"' perl='AbelCaincatdogx' value=''AbelCaincatdogx'' Tokenstr |c(f(",fa)>"| translated: assert ( .join( ( '' , sorted harry ) == 'AbelCaincatdogx'
Lexem 11 Current token=')' perl=')' value=')' Tokenstr |c(f(",fa)>")| translated: assert ( .join( ( '' , sorted harry ) == 'AbelCaincatdogx' )
check_ref(main, harry) at 7
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='join' value='.join(' Tokenstr |c(f| translated: assert ( .join(
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( .join( (
Lexem 4 Current token='"' perl='' value='''' Tokenstr |c(f("| translated: assert ( .join( ( ''
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |c(f(",| translated: assert ( .join( ( '' ,
Lexem 6 Current token='f' perl='sort' value='sorted' Tokenstr |c(f(",f| translated: assert ( .join( ( '' , sorted
Lexem 7 Current token='i' perl='backwards' value='backwards' Tokenstr |c(f(",fi| translated: assert ( .join( ( '' , sorted backwards
Lexem 8 Current token='a' perl='@harry' value='harry' Tokenstr |c(f(",fia| translated: assert ( .join( ( '' , sorted backwards harry
Lexem 9 Current token=')' perl=')' value=')' Tokenstr |c(f(",fia)| translated: assert ( .join( ( '' , sorted backwards harry )
Lexem 10 Current token='>' perl='eq' value='==' Tokenstr |c(f(",fia)>| translated: assert ( .join( ( '' , sorted backwards harry ) ==
Lexem 11 Current token='"' perl='xdogcatCainAbel' value=''xdogcatCainAbel'' Tokenstr |c(f(",fia)>"| translated: assert ( .join( ( '' , sorted backwards harry ) == 'xdogcatCainAbel'
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |c(f(",fia)>")| translated: assert ( .join( ( '' , sorted backwards harry ) == 'xdogcatCainAbel' )
check_ref(main, harry) at 8
Lexem 0 Current token='h' perl='routespans' value='routespans' Tokenstr |h| translated: routespans
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |h=| translated: routespans =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |h=(| translated: routespans = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |h=()| translated: routespans = ( )
check_ref(main, routespans) at 0
expr_type(2, 3, main)
expr_type(3, 2, main)
merge_types(routespans, main, u)
expr_type(0, 3, main)
Lexem 0 Current token='s' perl='$routespans' value='routespans' Tokenstr |s| translated: routespans
Lexem 1 Current token='(' perl='{' value='[' Tokenstr |s(| translated: routespans [
Lexem 2 Current token='i' perl='rin' value='rin' Tokenstr |s(i| translated: routespans [ rin
Lexem 3 Current token=')' perl='}' value=']' Tokenstr |s(")| translated: routespans [ 'rin' ]
Lexem 4 Current token='=' perl='=' value='=' Tokenstr |s(")=| translated: routespans [ 'rin' ] =
Lexem 5 Current token='(' perl='{' value='[' Tokenstr |s(")=(| translated: routespans [ 'rin' ] = [
Lexem 6 Current token='d' perl='1' value='1' Tokenstr |s(")=(d| translated: routespans [ 'rin' ] = [ 1
Lexem 7 Current token=':' perl='=>' value=': ' Tokenstr |s(")=(d:| translated: routespans [ 'rin' ] = [ 1 : 
Lexem 8 Current token='"' perl='av' value=''av'' Tokenstr |s(")=(d:"| translated: routespans [ 'rin' ] = [ 1 :  'av'
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |s(")=(d:",| translated: routespans [ 'rin' ] = [ 1 :  'av' ,
Lexem 10 Current token='d' perl='3' value='3' Tokenstr |s(")=(d:",d| translated: routespans [ 'rin' ] = [ 1 :  'av' , 3
Lexem 11 Current token=':' perl='=>' value=': ' Tokenstr |s(")=(d:",d:| translated: routespans [ 'rin' ] = [ 1 :  'av' , 3 : 
Lexem 12 Current token='"' perl='cv' value=''cv'' Tokenstr |s(")=(d:",d:"| translated: routespans [ 'rin' ] = [ 1 :  'av' , 3 :  'cv'
Lexem 13 Current token=',' perl=',' value=',' Tokenstr |s(")=(d:",d:",| translated: routespans [ 'rin' ] = [ 1 :  'av' , 3 :  'cv' ,
Lexem 14 Current token='d' perl='2' value='2' Tokenstr |s(")=(d:",d:",d| translated: routespans [ 'rin' ] = [ 1 :  'av' , 3 :  'cv' , 2
Lexem 15 Current token=':' perl='=>' value=': ' Tokenstr |s(")=(d:",d:",d:| translated: routespans [ 'rin' ] = [ 1 :  'av' , 3 :  'cv' , 2 : 
Lexem 16 Current token='"' perl='bv' value=''bv'' Tokenstr |s(")=(d:",d:",d:"| translated: routespans [ 'rin' ] = [ 1 :  'av' , 3 :  'cv' , 2 :  'bv'
Lexem 17 Current token=')' perl='}' value=']' Tokenstr |s(")=(d:",d:",d:")| translated: routespans [ 'rin' ] = [ 1 :  'av' , 3 :  'cv' , 2 :  'bv' ]
check_ref(main, routespans) at 0
expr_type(5, 17, main)
expr_type(8, 8, main)
expr_type(12, 12, main)
merge_types(routespans, main, h of h of u)
merge_types: otype=u
expr_type(0, 17, main)
Lexem 0 Current token='s' perl='$rin' value='rin' Tokenstr |s| translated: rin
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: rin =
Lexem 2 Current token='"' perl='rin' value=''rin'' Tokenstr |s="| translated: rin = 'rin'
check_ref(main, rin) at 0
expr_type(2, 2, main)
merge_types(rin, main, S)
expr_type(0, 2, main)
Lexem 0 Current token='k' perl='sub' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' perl='bynum' value='bynum' Tokenstr |ki| translated: def bynum
get_globals: switching to 'bynum' at line 65
expr_type(1, 1, bynum)
Lexem 0 Current token='s' perl='$a' value='a' Tokenstr |s| translated: a
Lexem 1 Current token='>' perl='<=>' value='_spaceship' Tokenstr |s>| translated: a _spaceship
Lexem 2 Current token='s' perl='$b' value='b' Tokenstr |s>s| translated: a _spaceship b
check_ref(bynum, a) at 0
scalar_reference_type(0) = I
merge_types(a, bynum, I)
check_ref(bynum, b) at 2
scalar_reference_type(2) = u
merge_types(b, bynum, u)
expr_type(0, 2, bynum)
get_globals: switching back to 'main' at line 67
merge_types(bynum, main, I)
Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@sequence' value='sequence' Tokenstr |ta| translated:  sequence
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  sequence =
Lexem 3 Current token='f' perl='sort' value='sorted' Tokenstr |ta=f| translated:  sequence = sorted
Lexem 4 Current token='i' perl='bynum' value='bynum' Tokenstr |ta=fi| translated:  sequence = sorted bynum
Lexem 5 Current token='f' perl='keys' value='.keys()' Tokenstr |ta=fif| translated:  sequence = sorted bynum .keys()
Lexem 6 Current token='%' perl='%' value='%' Tokenstr |ta=fif%| translated:  sequence = sorted bynum .keys() %
Lexem 7 Current token='(' perl='{' value='[' Tokenstr |ta=fif%(| translated:  sequence = sorted bynum .keys() % [
Lexem 8 Current token='s' perl='$routespans' value='routespans' Tokenstr |ta=fif%(s| translated:  sequence = sorted bynum .keys() % [ routespans
Lexem 9 Current token='(' perl='{' value='[' Tokenstr |ta=fif%(s(| translated:  sequence = sorted bynum .keys() % [ routespans [
Lexem 10 Current token='s' perl='$rin' value='rin' Tokenstr |ta=fif%(s(s| translated:  sequence = sorted bynum .keys() % [ routespans [ rin
Lexem 11 Current token=')' perl='}' value=']' Tokenstr |ta=fif%(s(s)| translated:  sequence = sorted bynum .keys() % [ routespans [ rin ]
Lexem 12 Current token=')' perl='}' value=']' Tokenstr |ta=fif%(s(s))| translated:  sequence = sorted bynum .keys() % [ routespans [ rin ] ]
check_ref(main, sequence) at 1
expr_type(3, 12, main)
merge_types(sequence, main, a)
check_ref(main, routespans) at 8
merge_types(routespans, main, h of u)
merge_types: otype=h of h of u
check_ref(main, rin) at 10
scalar_reference_type(10) = S
Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='scalar' value='len' Tokenstr |c(f| translated: assert ( len
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( len (
Lexem 4 Current token='a' perl='@sequence' value='sequence' Tokenstr |c(f(a| translated: assert ( len ( sequence
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(f(a)| translated: assert ( len ( sequence )
Lexem 6 Current token='>' perl='==' value='==' Tokenstr |c(f(a)>| translated: assert ( len ( sequence ) ==
Lexem 7 Current token='d' perl='3' value='3' Tokenstr |c(f(a)>d| translated: assert ( len ( sequence ) == 3
Lexem 8 Current token='0' perl='&&' value=' and ' Tokenstr |c(f(a)>d0| translated: assert ( len ( sequence ) == 3  and 
Lexem 9 Current token='s' perl='$sequence' value='sequence' Tokenstr |c(f(a)>d0s| translated: assert ( len ( sequence ) == 3  and  sequence
Lexem 10 Current token='(' perl='[' value='[' Tokenstr |c(f(a)>d0s(| translated: assert ( len ( sequence ) == 3  and  sequence [
Lexem 11 Current token='d' perl='0' value='0' Tokenstr |c(f(a)>d0s(d| translated: assert ( len ( sequence ) == 3  and  sequence [ 0
Lexem 12 Current token=')' perl=']' value=']' Tokenstr |c(f(a)>d0s(d)| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ]
Lexem 13 Current token='>' perl='==' value='==' Tokenstr |c(f(a)>d0s(d)>| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] ==
Lexem 14 Current token='d' perl='1' value='1' Tokenstr |c(f(a)>d0s(d)>d| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1
Lexem 15 Current token='0' perl='&&' value=' and ' Tokenstr |c(f(a)>d0s(d)>d0| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1  and 
Lexem 16 Current token='s' perl='$sequence' value='sequence' Tokenstr |c(f(a)>d0s(d)>d0s| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1  and  sequence
Lexem 17 Current token='(' perl='[' value='[' Tokenstr |c(f(a)>d0s(d)>d0s(| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1  and  sequence [
Lexem 18 Current token='d' perl='1' value='1' Tokenstr |c(f(a)>d0s(d)>d0s(d| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1  and  sequence [ 1
Lexem 19 Current token=')' perl=']' value=']' Tokenstr |c(f(a)>d0s(d)>d0s(d)| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1  and  sequence [ 1 ]
Lexem 20 Current token='>' perl='==' value='==' Tokenstr |c(f(a)>d0s(d)>d0s(d)>| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1  and  sequence [ 1 ] ==
Lexem 21 Current token='d' perl='2' value='2' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1  and  sequence [ 1 ] == 2
Lexem 22 Current token='0' perl='&&' value=' and ' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1  and  sequence [ 1 ] == 2  and 
Lexem 23 Current token='s' perl='$sequence' value='sequence' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0s| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1  and  sequence [ 1 ] == 2  and  sequence
Lexem 24 Current token='(' perl='[' value='[' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0s(| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1  and  sequence [ 1 ] == 2  and  sequence [
Lexem 25 Current token='d' perl='2' value='2' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0s(d| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1  and  sequence [ 1 ] == 2  and  sequence [ 2
Lexem 26 Current token=')' perl=']' value=']' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0s(d)| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1  and  sequence [ 1 ] == 2  and  sequence [ 2 ]
Lexem 27 Current token='>' perl='==' value='==' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0s(d)>| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1  and  sequence [ 1 ] == 2  and  sequence [ 2 ] ==
Lexem 28 Current token='d' perl='3' value='3' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0s(d)>d| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1  and  sequence [ 1 ] == 2  and  sequence [ 2 ] == 3
Lexem 29 Current token=')' perl=')' value=')' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0s(d)>d)| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1  and  sequence [ 1 ] == 2  and  sequence [ 2 ] == 3 )
check_ref(main, sequence) at 4
check_ref(main, sequence) at 9
merge_types(sequence, main, a of u)
merge_types: otype=a
check_ref(main, sequence) at 16
merge_types(sequence, main, a of u)
merge_types: otype=a of u
check_ref(main, sequence) at 23
merge_types(sequence, main, a of u)
merge_types: otype=a of u
Lexem 0 Current token='f' perl='print' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='"' perl='$0 - test passed!\n' value='f"{__file__} - test passed!\n"' Tokenstr |f"| translated: print f"{__file__} - test passed!\n"
expr_type(0, 1, main)
VarSubMap = $VAR1 = {
  '_script_start' => {
    'main' => '+'
  },
  'AUTODIE' => {
    'main' => '+'
  },
  'routespans' => {
    'main' => '+'
  },
  'TRACEBACK' => {
    'main' => '+'
  },
  '_OPEN_MODE_MAP' => {
    'main' => '+'
  },
  'LIST_SEPARATOR' => {
    'main' => '+'
  },
  '_DUP_MAP' => {
    'main' => '+'
  },
  'class_' => {
    'main' => '+'
  },
  'age' => {
    'main' => '+',
    'byage' => '+'
  },
  'rin' => {
    'main' => '+'
  },
  'OS_ERROR' => {
    'main' => '+'
  },
  'files' => {
    'main' => '+'
  }
};

VarType = $VAR1 = {
  'routespans' => {
    'main' => 'h of h of u'
  },
  'rin' => {
    'main' => 'S'
  },
  'OS_ERROR' => {
    'main' => 'S'
  },
  'LIST_SEPARATOR' => {
    'main' => 'S'
  },
  'a' => {
    'byage' => 'S',
    'main' => 'f',
    'bynum' => 'I',
    'backwards' => 'u'
  },
  'class_' => {
    'main' => 'a of u'
  },
  'articles2' => {
    'main' => 'a'
  },
  'os.environ' => {
    'main' => 'h of S'
  },
  'os.name' => {
    'main' => 'S'
  },
  'george' => {
    'main' => 'u'
  },
  'files' => {
    'main' => 'a of u'
  },
  'byage' => {
    'main' => 'I'
  },
  'articlesr' => {
    'main' => 'a'
  },
  'backwards' => {
    'main' => 'I'
  },
  '_d' => {
    'main' => 'a'
  },
  'eldest' => {
    'main' => 'a'
  },
  'sortedclass' => {
    'main' => 'a'
  },
  'age' => {
    'main' => 'h of u',
    'byage' => 'h of u'
  },
  'sequence' => {
    'main' => 'a of u'
  },
  'b' => {
    'main' => 'a',
    'bynum' => 'u',
    'byage' => 'S',
    'backwards' => 'I'
  },
  'articlesnd' => {
    'main' => 'a'
  },
  'main' => {},
  'articlesn' => {
    'main' => 'a'
  },
  'sys.argv' => {
    'main' => 'a of S'
  },
  'bynum' => {
    'main' => 'I'
  },
  'EVAL_ERROR' => {
    'main' => 'S'
  },
  '_script_start' => {
    'main' => 'I'
  },
  'articles1' => {
    'main' => 'a'
  },
  'harry' => {
    'main' => 'u'
  },
  'articles' => {
    'main' => 'a'
  }
};

initialized = $VAR1 = {
  'backwards' => {},
  'byage' => {},
  'main' => {
    'rin' => 'S',
    'OS_ERROR' => 'S',
    'LIST_SEPARATOR' => 'S',
    'class_' => 'a of u',
    'routespans' => 'u',
    'os.name' => 'S',
    'george' => 'u',
    'files' => 'a of u',
    'articles2' => 'a',
    'os.environ' => 'h of S',
    'sequence' => 'a',
    'age' => 'h of u',
    'articlesnd' => 'a',
    'articlesn' => 'a',
    'articlesr' => 'a',
    'sortedclass' => 'a',
    'eldest' => 'a',
    'harry' => 'u',
    'articles1' => 'a',
    'articles' => 'a',
    'sys.argv' => 'a of S',
    'EVAL_ERROR' => 'S',
    '_script_start' => 'I'
  },
  'bynum' => {}
};

NeedsInitializing = $VAR1 = {
  'main' => {
    'a' => 'S',
    '_d' => 'a',
    'b' => 'S'
  },
  'bynum' => {
    'a' => 'I',
    'b' => 'u'
  },
  'byage' => {
    'b' => 'S',
    'age' => 'h',
    'a' => 'S'
  },
  'backwards' => {
    'b' => 'I',
    'a' => 'u'
  }
};

merge_types(age, byage, h)
merge_types: otype=h of u

DETECTED GLOBAL VARIABLES:
	main: global age
	byage: global age

AUTO-INITIALIZED VARIABLES:
	main: 
age = {}

List of local subroutines:
main bynum byage backwards
mkdir: cannot create directory ‘/c/Users/Joe’: File exists
cp: target 'Orost/Archive/pythonizer' is not a directory
cp: target 'Orost/Archive/Softpano.pm' is not a directory
cp: target 'Orost/Archive/Perlscan.pm' is not a directory
cp: target 'Orost/Archive/Pythonizer.pm' is not a directory
   1 | 0 |   |#!/usr/bin/python3 -u
   1 | 0 |   |# Generated by pythonizer 0.920 run by Joe Orost on Thu Dec  9 17:06:16 2021
   1 | 0 |   |# Test the sort function using the examples on the definition page
   2 | 0 |   |
   3 | 0 |   |import sys,os,re,fcntl,math,fileinput,subprocess,inspect,collections.abc,argparse,glob,warnings,inspect,functools,signal,traceback,io,tempfile,atexit,calendar
   3 | 0 |   |import time as tm_py
   3 | 0 |   |_script_start = tm_py.time()
   3 | 0 |   |AUTODIE = 0
   3 | 0 |   |TRACEBACK = 0
   3 | 0 |   |LIST_SEPARATOR = ' '
   3 | 0 |   |_OPEN_MODE_MAP = {'<': 'r', '>': 'w', '+<': 'r+', '+>': 'w+', '>>': 'a', '+>>': 'a+', '|': '|-'}
   3 | 0 |   |_DUP_MAP = dict(STDIN=0, STDOUT=1, STDERR=2)
   3 | 0 |   |OS_ERROR = ''
   3 | 0 |   |class Die(Exception):
    pass
   3 | 0 |   |class EvalReturn(Exception):
    pass
   3 | 0 |   |age = {}
   3 | 0 |   |_args = sys.argv[1:]
Main loop, line=use Carp::Assert;


 === Line 3 Perl source:use Carp::Assert;===

Lexem 0 Current token='c' perl='use' value='NoTrans!' Tokenstr |c| translated: NoTrans!
Lexem 1 Current token='i' perl='Carp::Assert' value='Carp.Assert' Tokenstr |ci| translated: NoTrans! Carp.Assert

Line:    3 TokenStr: =|ci|= @ValPy: NoTrans! Carp.Assert
   3 | 0 |   |#SKIPPED: use Carp::Assert;
Main loop, line=use Data::Dumper;


 === Line 4 Perl source:use Data::Dumper;===

Lexem 0 Current token='c' perl='use' value='NoTrans!' Tokenstr |c| translated: NoTrans!
Lexem 1 Current token='i' perl='Data::Dumper' value='Data.Dumper' Tokenstr |ci| translated: NoTrans! Data.Dumper

Line:    4 TokenStr: =|ci|= @ValPy: NoTrans! Data.Dumper
   4 | 0 |   |#SKIPPED: use Data::Dumper;
Main loop, line=use feature 'fc';


 === Line 5 Perl source:use feature 'fc';===

Lexem 0 Current token='c' perl='use' value='NoTrans!' Tokenstr |c| translated: NoTrans!
Lexem 1 Current token='i' perl='feature' value='feature' Tokenstr |ci| translated: NoTrans! feature
Lexem 2 Current token='"' perl='fc' value=''fc'' Tokenstr |ci"| translated: NoTrans! feature 'fc'

Line:    5 TokenStr: =|ci"|= @ValPy: NoTrans! feature 'fc'
   5 | 0 |   |#SKIPPED: use feature 'fc';
   6 | 0 |   |
Main loop, line=@files = ('d', 'e', 'c', 'a', 'b');


 === Line 7 Perl source:@files = ('d', 'e', 'c', 'a', 'b');===

Lexem 0 Current token='a' perl='@files' value='files' Tokenstr |a| translated: files
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: files =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: files = (
Lexem 3 Current token='"' perl='d' value=''d'' Tokenstr |a=("| translated: files = ( 'd'
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |a=(",| translated: files = ( 'd' ,
Lexem 5 Current token='"' perl='e' value=''e'' Tokenstr |a=(","| translated: files = ( 'd' , 'e'
Lexem 6 Current token=',' perl=',' value=',' Tokenstr |a=(",",| translated: files = ( 'd' , 'e' ,
Lexem 7 Current token='"' perl='c' value=''c'' Tokenstr |a=(",","| translated: files = ( 'd' , 'e' , 'c'
Lexem 8 Current token=',' perl=',' value=',' Tokenstr |a=(",",",| translated: files = ( 'd' , 'e' , 'c' ,
Lexem 9 Current token='"' perl='a' value=''a'' Tokenstr |a=(",",","| translated: files = ( 'd' , 'e' , 'c' , 'a'
Lexem 10 Current token=',' perl=',' value=',' Tokenstr |a=(",",",",| translated: files = ( 'd' , 'e' , 'c' , 'a' ,
Lexem 11 Current token='"' perl='b' value=''b'' Tokenstr |a=(",",",","| translated: files = ( 'd' , 'e' , 'c' , 'a' , 'b'
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |a=(",",",",")| translated: files = ( 'd' , 'e' , 'c' , 'a' , 'b' )

Line:    7 TokenStr: =|a=(",",",",")|= @ValPy: files = ( 'd' , 'e' , 'c' , 'a' , 'b' )
Generated partial line files = [
Generated partial line files = ['d'
Generated partial line files = ['d',
Generated partial line files = ['d','e'
Generated partial line files = ['d','e',
Generated partial line files = ['d','e','c'
Generated partial line files = ['d','e','c',
Generated partial line files = ['d','e','c','a'
Generated partial line files = ['d','e','c','a',
Generated partial line files = ['d','e','c','a','b'
Generated partial line files = ['d','e','c','a','b']
   8 | 0 |   |# sort lexically
   9 | 0 |   |files = ['d', 'e', 'c', 'a', 'b']                                                       #PL: my @articles = sort @files;

Tokens: a=(",",",",") ValPy: 
Main loop, line=my @articles = sort @files;


 === Line 9 Perl source:my @articles = sort @files;===

Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@articles' value='articles' Tokenstr |ta| translated:  articles
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  articles =
Lexem 3 Current token='f' perl='sort' value='sorted' Tokenstr |ta=f| translated:  articles = sorted
Lexem 4 Current token='a' perl='@files' value='files' Tokenstr |ta=fa| translated:  articles = sorted files

Line:    9 TokenStr: =|ta=fa|= @ValPy:  articles = sorted files
assignment(0, 3) =|a=fa|= @articles = sort @files

Generated partial line articles
Generated partial line articles=
expression(2, 3, 0) =|a=fa|= @articles = sort @files

function(2, 3) =|a=fa|= @articles = sort @files

function start=3, end_pos=3, bracketed=0
Generated partial line articles=sorted
Generated partial line articles=sorted(
expression(3, 3, 0) =|a=fa|= @articles = sort @files

Generated partial line articles=sorted(files
expression returns 4
Generated partial line articles=sorted(files)
expression returns 4
  10 | 0 |   |articles = sorted(files)                                                                #PL: assert(join('', @articles) eq 'abcde');

Tokens: a=fa ValPy: 
Main loop, line=assert(join('', @articles) eq 'abcde');


 === Line 10 Perl source:assert(join('', @articles) eq 'abcde');===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='join' value='.join(' Tokenstr |c(f| translated: assert ( .join(
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( .join( (
Lexem 4 Current token='"' perl='' value='''' Tokenstr |c(f("| translated: assert ( .join( ( ''
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |c(f(",| translated: assert ( .join( ( '' ,
Lexem 6 Current token='a' perl='@articles' value='articles' Tokenstr |c(f(",a| translated: assert ( .join( ( '' , articles
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |c(f(",a)| translated: assert ( .join( ( '' , articles )
Lexem 8 Current token='>' perl='eq' value='==' Tokenstr |c(f(",a)>| translated: assert ( .join( ( '' , articles ) ==
Lexem 9 Current token='"' perl='abcde' value=''abcde'' Tokenstr |c(f(",a)>"| translated: assert ( .join( ( '' , articles ) == 'abcde'
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |c(f(",a)>")| translated: assert ( .join( ( '' , articles ) == 'abcde' )

Line:   10 TokenStr: =|c(f(",a)>")|= @ValPy: assert ( .join( ( '' , articles ) == 'abcde' )
control(0) =|c(f(",a)>")|= assert ( join (  , @articles ) eq abcde )

control-parens removed, begin=0 start=1 =|cf(",a)>"|= assert join (  , @articles ) eq abcde

Generated partial line assert
expression(1, 8, 0) =|cf(",a)>"|= assert join (  , @articles ) eq abcde

function(1, 8) =|cf(",a)>"|= assert join (  , @articles ) eq abcde

function start=3, end_pos=5, bracketed=1
Generated partial line assert''
Generated partial line assert''.join(
Generated partial line assert''.join(articles
Generated partial line assert''.join(articles)
Generated partial line assert''.join(articles)==
Generated partial line assert''.join(articles)=='abcde'
expression returns 9
  11 | 0 |   |
  12 | 0 |   |# same thing, but with explicit sort routine
  13 | 0 |   |assert ''.join(articles) == 'abcde'                                                     #PL: my @articles1 = sort {$a cmp $b} @files;

Tokens: cf(",a)>" ValPy: 
Main loop, line=my @articles1 = sort {$a cmp $b} @files;


 === Line 13 Perl source:my @articles1 = sort {$a cmp $b} @files;===

Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@articles1' value='articles1' Tokenstr |ta| translated:  articles1
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  articles1 =
Lexem 3 Current token='f' perl='sort' value='sorted' Tokenstr |ta=f| translated:  articles1 = sorted
Lexem 4 Current token='(' perl='{' value='[' Tokenstr |ta=f(| translated:  articles1 = sorted [
Lexem 5 Current token='s' perl='$a' value='a' Tokenstr |ta=f(s| translated:  articles1 = sorted [ a
Lexem 6 Current token='>' perl='cmp' value='_cmp' Tokenstr |ta=f(s>| translated:  articles1 = sorted [ a _cmp
Lexem 7 Current token='s' perl='$b' value='b' Tokenstr |ta=f(s>s| translated:  articles1 = sorted [ a _cmp b
Lexem 8 Current token=')' perl='}' value=']' Tokenstr |ta=f(s>s)| translated:  articles1 = sorted [ a _cmp b ]
Lexem 9 Current token='a' perl='@files' value='files' Tokenstr |ta=f(s>s)a| translated:  articles1 = sorted [ a _cmp b ] files

Line:   13 TokenStr: =|ta=f(s>s)a|= @ValPy:  articles1 = sorted [ a _cmp b ] files
handle_cmp_spaceship(0, 6, 9): a[5:5], b[7:7] = 3 (=|ta=f(f(s,s))a|=)
assignment(0, 11) =|a=f(f(s,s))a|= @articles1 = sort { cmp ( $a , $b ) } @files

Generated partial line articles1
Generated partial line articles1=
expression(2, 11, 0) =|a=f(f(s,s))a|= @articles1 = sort { cmp ( $a , $b ) } @files

function(2, 11) =|a=f(f(s,s))a|= @articles1 = sort { cmp ( $a , $b ) } @files

function start=4, end_pos=9, bracketed=1
Generated partial line articles1=sorted
Generated partial line articles1=sorted(
expression(11, 11, 0) =|a=f(f(s,s))a|= @articles1 = sort { cmp ( $a , $b ) } @files

Generated partial line articles1=sorted(files
expression returns 12
Generated partial line articles1=sorted(files, key=functools.cmp_to_key(lambda a,b:
expression(4, 9, 0) =|a=f(f(s,s))a|= @articles1 = sort { cmp ( $a , $b ) } @files

function(4, 9) =|a=f(f(s,s))a|= @articles1 = sort { cmp ( $a , $b ) } @files

function start=6, end_pos=8, bracketed=1
Generated partial line articles1=sorted(files, key=functools.cmp_to_key(lambda a,b:_cmp
Generated partial line articles1=sorted(files, key=functools.cmp_to_key(lambda a,b:_cmp(
expression(6, 8, 0) =|a=f(f(s,s))a|= @articles1 = sort { cmp ( $a , $b ) } @files

Generated partial line articles1=sorted(files, key=functools.cmp_to_key(lambda a,b:_cmp(a
Generated partial line articles1=sorted(files, key=functools.cmp_to_key(lambda a,b:_cmp(a,
Generated partial line articles1=sorted(files, key=functools.cmp_to_key(lambda a,b:_cmp(a,b
expression returns 9
Generated partial line articles1=sorted(files, key=functools.cmp_to_key(lambda a,b:_cmp(a,b)
expression returns 10
Generated partial line articles1=sorted(files, key=functools.cmp_to_key(lambda a,b:_cmp(a,b))
Generated partial line articles1=sorted(files, key=functools.cmp_to_key(lambda a,b:_cmp(a,b)))
expression returns 12
  14 | 0 |   |articles1 = sorted(files, key=functools.cmp_to_key(lambda a,b:_cmp(a, b)))              #PL: assert(join('', @articles1) eq 'abcde');

Tokens: a=f(f(s,s))a ValPy: 
Main loop, line=assert(join('', @articles1) eq 'abcde');


 === Line 14 Perl source:assert(join('', @articles1) eq 'abcde');===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='join' value='.join(' Tokenstr |c(f| translated: assert ( .join(
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( .join( (
Lexem 4 Current token='"' perl='' value='''' Tokenstr |c(f("| translated: assert ( .join( ( ''
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |c(f(",| translated: assert ( .join( ( '' ,
Lexem 6 Current token='a' perl='@articles1' value='articles1' Tokenstr |c(f(",a| translated: assert ( .join( ( '' , articles1
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |c(f(",a)| translated: assert ( .join( ( '' , articles1 )
Lexem 8 Current token='>' perl='eq' value='==' Tokenstr |c(f(",a)>| translated: assert ( .join( ( '' , articles1 ) ==
Lexem 9 Current token='"' perl='abcde' value=''abcde'' Tokenstr |c(f(",a)>"| translated: assert ( .join( ( '' , articles1 ) == 'abcde'
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |c(f(",a)>")| translated: assert ( .join( ( '' , articles1 ) == 'abcde' )

Line:   14 TokenStr: =|c(f(",a)>")|= @ValPy: assert ( .join( ( '' , articles1 ) == 'abcde' )
control(0) =|c(f(",a)>")|= assert ( join (  , @articles1 ) eq abcde )

control-parens removed, begin=0 start=1 =|cf(",a)>"|= assert join (  , @articles1 ) eq abcde

Generated partial line assert
expression(1, 8, 0) =|cf(",a)>"|= assert join (  , @articles1 ) eq abcde

function(1, 8) =|cf(",a)>"|= assert join (  , @articles1 ) eq abcde

function start=3, end_pos=5, bracketed=1
Generated partial line assert''
Generated partial line assert''.join(
Generated partial line assert''.join(articles1
Generated partial line assert''.join(articles1)
Generated partial line assert''.join(articles1)==
Generated partial line assert''.join(articles1)=='abcde'
expression returns 9
  15 | 0 |   |
  16 | 0 |   |# now case-insensitively
  17 | 0 |   |assert ''.join(articles1) == 'abcde'                                                    #PL: my @articles2 = sort {fc($a) cmp fc($b)} @files;

Tokens: cf(",a)>" ValPy: 
Main loop, line=my @articles2 = sort {fc($a) cmp fc($b)} @files;


 === Line 17 Perl source:my @articles2 = sort {fc($a) cmp fc($b)} @files;===

Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@articles2' value='articles2' Tokenstr |ta| translated:  articles2
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  articles2 =
Lexem 3 Current token='f' perl='sort' value='sorted' Tokenstr |ta=f| translated:  articles2 = sorted
Lexem 4 Current token='(' perl='{' value='[' Tokenstr |ta=f(| translated:  articles2 = sorted [
Lexem 5 Current token='f' perl='fc' value='.casefold()' Tokenstr |ta=f(f| translated:  articles2 = sorted [ .casefold()
Lexem 6 Current token='(' perl='(' value='(' Tokenstr |ta=f(f(| translated:  articles2 = sorted [ .casefold() (
Lexem 7 Current token='s' perl='$a' value='a' Tokenstr |ta=f(f(s| translated:  articles2 = sorted [ .casefold() ( a
Lexem 8 Current token=')' perl=')' value=')' Tokenstr |ta=f(f(s)| translated:  articles2 = sorted [ .casefold() ( a )
Lexem 9 Current token='>' perl='cmp' value='_cmp' Tokenstr |ta=f(f(s)>| translated:  articles2 = sorted [ .casefold() ( a ) _cmp
Lexem 10 Current token='f' perl='fc' value='.casefold()' Tokenstr |ta=f(f(s)>f| translated:  articles2 = sorted [ .casefold() ( a ) _cmp .casefold()
Lexem 11 Current token='(' perl='(' value='(' Tokenstr |ta=f(f(s)>f(| translated:  articles2 = sorted [ .casefold() ( a ) _cmp .casefold() (
Lexem 12 Current token='s' perl='$b' value='b' Tokenstr |ta=f(f(s)>f(s| translated:  articles2 = sorted [ .casefold() ( a ) _cmp .casefold() ( b
Lexem 13 Current token=')' perl=')' value=')' Tokenstr |ta=f(f(s)>f(s)| translated:  articles2 = sorted [ .casefold() ( a ) _cmp .casefold() ( b )
Lexem 14 Current token=')' perl='}' value=']' Tokenstr |ta=f(f(s)>f(s))| translated:  articles2 = sorted [ .casefold() ( a ) _cmp .casefold() ( b ) ]
Lexem 15 Current token='a' perl='@files' value='files' Tokenstr |ta=f(f(s)>f(s))a| translated:  articles2 = sorted [ .casefold() ( a ) _cmp .casefold() ( b ) ] files

Line:   17 TokenStr: =|ta=f(f(s)>f(s))a|= @ValPy:  articles2 = sorted [ .casefold() ( a ) _cmp .casefold() ( b ) ] files
handle_cmp_spaceship(0, 9, 15): a[5:8], b[10:13] = 3 (=|ta=f(f(f(s),f(s)))a|=)
assignment(0, 17) =|a=f(f(f(s),f(s)))a|= @articles2 = sort { cmp ( fc ( $a ) , fc ( $b ) ) } @files

Generated partial line articles2
Generated partial line articles2=
expression(2, 17, 0) =|a=f(f(f(s),f(s)))a|= @articles2 = sort { cmp ( fc ( $a ) , fc ( $b ) ) } @files

function(2, 17) =|a=f(f(f(s),f(s)))a|= @articles2 = sort { cmp ( fc ( $a ) , fc ( $b ) ) } @files

function start=4, end_pos=15, bracketed=1
Generated partial line articles2=sorted
Generated partial line articles2=sorted(
expression(17, 17, 0) =|a=f(f(f(s),f(s)))a|= @articles2 = sort { cmp ( fc ( $a ) , fc ( $b ) ) } @files

Generated partial line articles2=sorted(files
expression returns 18
Generated partial line articles2=sorted(files, key=functools.cmp_to_key(lambda a,b:
expression(4, 15, 0) =|a=f(f(f(s),f(s)))a|= @articles2 = sort { cmp ( fc ( $a ) , fc ( $b ) ) } @files

function(4, 15) =|a=f(f(f(s),f(s)))a|= @articles2 = sort { cmp ( fc ( $a ) , fc ( $b ) ) } @files

function start=6, end_pos=14, bracketed=1
Generated partial line articles2=sorted(files, key=functools.cmp_to_key(lambda a,b:_cmp
Generated partial line articles2=sorted(files, key=functools.cmp_to_key(lambda a,b:_cmp(
expression(6, 14, 0) =|a=f(f(f(s),f(s)))a|= @articles2 = sort { cmp ( fc ( $a ) , fc ( $b ) ) } @files

function(6, 14) =|a=f(f(f(s),f(s)))a|= @articles2 = sort { cmp ( fc ( $a ) , fc ( $b ) ) } @files

function start=8, end_pos=8, bracketed=1
expression(8, 8, 0) =|a=f(f(f(s),f(s)))a|= @articles2 = sort { cmp ( fc ( $a ) , fc ( $b ) ) } @files

Generated partial line articles2=sorted(files, key=functools.cmp_to_key(lambda a,b:_cmp(a
expression returns 9
Generated partial line articles2=sorted(files, key=functools.cmp_to_key(lambda a,b:_cmp(a.casefold()
Generated partial line articles2=sorted(files, key=functools.cmp_to_key(lambda a,b:_cmp(a.casefold(),
function(11, 14) =|a=f(f(f(s),f(s)))a|= @articles2 = sort { cmp ( fc ( $a ) , fc ( $b ) ) } @files

function start=13, end_pos=13, bracketed=1
expression(13, 13, 0) =|a=f(f(f(s),f(s)))a|= @articles2 = sort { cmp ( fc ( $a ) , fc ( $b ) ) } @files

Generated partial line articles2=sorted(files, key=functools.cmp_to_key(lambda a,b:_cmp(a.casefold(),b
expression returns 14
Generated partial line articles2=sorted(files, key=functools.cmp_to_key(lambda a,b:_cmp(a.casefold(),b.casefold()
expression returns 15
Generated partial line articles2=sorted(files, key=functools.cmp_to_key(lambda a,b:_cmp(a.casefold(),b.casefold())
expression returns 16
Generated partial line articles2=sorted(files, key=functools.cmp_to_key(lambda a,b:_cmp(a.casefold(),b.casefold()))
Generated partial line articles2=sorted(files, key=functools.cmp_to_key(lambda a,b:_cmp(a.casefold(),b.casefold())))
expression returns 18
  18 | 0 |   |articles2 = sorted(files, key=functools.cmp_to_key(lambda a,b:_cmp(a.casefold(), b.casefold()))) #PL: assert(join('', @articles2) eq 'abcde');

Tokens: a=f(f(f(s),f(s)))a ValPy: 
Main loop, line=assert(join('', @articles2) eq 'abcde');


 === Line 18 Perl source:assert(join('', @articles2) eq 'abcde');===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='join' value='.join(' Tokenstr |c(f| translated: assert ( .join(
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( .join( (
Lexem 4 Current token='"' perl='' value='''' Tokenstr |c(f("| translated: assert ( .join( ( ''
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |c(f(",| translated: assert ( .join( ( '' ,
Lexem 6 Current token='a' perl='@articles2' value='articles2' Tokenstr |c(f(",a| translated: assert ( .join( ( '' , articles2
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |c(f(",a)| translated: assert ( .join( ( '' , articles2 )
Lexem 8 Current token='>' perl='eq' value='==' Tokenstr |c(f(",a)>| translated: assert ( .join( ( '' , articles2 ) ==
Lexem 9 Current token='"' perl='abcde' value=''abcde'' Tokenstr |c(f(",a)>"| translated: assert ( .join( ( '' , articles2 ) == 'abcde'
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |c(f(",a)>")| translated: assert ( .join( ( '' , articles2 ) == 'abcde' )

Line:   18 TokenStr: =|c(f(",a)>")|= @ValPy: assert ( .join( ( '' , articles2 ) == 'abcde' )
control(0) =|c(f(",a)>")|= assert ( join (  , @articles2 ) eq abcde )

control-parens removed, begin=0 start=1 =|cf(",a)>"|= assert join (  , @articles2 ) eq abcde

Generated partial line assert
expression(1, 8, 0) =|cf(",a)>"|= assert join (  , @articles2 ) eq abcde

function(1, 8) =|cf(",a)>"|= assert join (  , @articles2 ) eq abcde

function start=3, end_pos=5, bracketed=1
Generated partial line assert''
Generated partial line assert''.join(
Generated partial line assert''.join(articles2
Generated partial line assert''.join(articles2)
Generated partial line assert''.join(articles2)==
Generated partial line assert''.join(articles2)=='abcde'
expression returns 9
  19 | 0 |   |
  20 | 0 |   |assert ''.join(articles2) == 'abcde'                                                    #PL: @files = ('d', 'e', 'c', 'a', 'b');

Tokens: cf(",a)>" ValPy: 
Main loop, line=@files = ('d', 'e', 'c', 'a', 'b');


 === Line 20 Perl source:@files = ('d', 'e', 'c', 'a', 'b');===

Lexem 0 Current token='a' perl='@files' value='files' Tokenstr |a| translated: files
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: files =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: files = (
Lexem 3 Current token='"' perl='d' value=''d'' Tokenstr |a=("| translated: files = ( 'd'
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |a=(",| translated: files = ( 'd' ,
Lexem 5 Current token='"' perl='e' value=''e'' Tokenstr |a=(","| translated: files = ( 'd' , 'e'
Lexem 6 Current token=',' perl=',' value=',' Tokenstr |a=(",",| translated: files = ( 'd' , 'e' ,
Lexem 7 Current token='"' perl='c' value=''c'' Tokenstr |a=(",","| translated: files = ( 'd' , 'e' , 'c'
Lexem 8 Current token=',' perl=',' value=',' Tokenstr |a=(",",",| translated: files = ( 'd' , 'e' , 'c' ,
Lexem 9 Current token='"' perl='a' value=''a'' Tokenstr |a=(",",","| translated: files = ( 'd' , 'e' , 'c' , 'a'
Lexem 10 Current token=',' perl=',' value=',' Tokenstr |a=(",",",",| translated: files = ( 'd' , 'e' , 'c' , 'a' ,
Lexem 11 Current token='"' perl='b' value=''b'' Tokenstr |a=(",",",","| translated: files = ( 'd' , 'e' , 'c' , 'a' , 'b'
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |a=(",",",",")| translated: files = ( 'd' , 'e' , 'c' , 'a' , 'b' )

Line:   20 TokenStr: =|a=(",",",",")|= @ValPy: files = ( 'd' , 'e' , 'c' , 'a' , 'b' )
Generated partial line files = [
Generated partial line files = ['d'
Generated partial line files = ['d',
Generated partial line files = ['d','e'
Generated partial line files = ['d','e',
Generated partial line files = ['d','e','c'
Generated partial line files = ['d','e','c',
Generated partial line files = ['d','e','c','a'
Generated partial line files = ['d','e','c','a',
Generated partial line files = ['d','e','c','a','b'
Generated partial line files = ['d','e','c','a','b']
  21 | 0 |   |# same thing in reversed order
  22 | 0 |   |files = ['d', 'e', 'c', 'a', 'b']                                                       #PL: my @articlesr = sort {$b cmp $a} @files;

Tokens: a=(",",",",") ValPy: 
Main loop, line=my @articlesr = sort {$b cmp $a} @files;


 === Line 22 Perl source:my @articlesr = sort {$b cmp $a} @files;===

Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@articlesr' value='articlesr' Tokenstr |ta| translated:  articlesr
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  articlesr =
Lexem 3 Current token='f' perl='sort' value='sorted' Tokenstr |ta=f| translated:  articlesr = sorted
Lexem 4 Current token='(' perl='{' value='[' Tokenstr |ta=f(| translated:  articlesr = sorted [
Lexem 5 Current token='s' perl='$b' value='b' Tokenstr |ta=f(s| translated:  articlesr = sorted [ b
Lexem 6 Current token='>' perl='cmp' value='_cmp' Tokenstr |ta=f(s>| translated:  articlesr = sorted [ b _cmp
Lexem 7 Current token='s' perl='$a' value='a' Tokenstr |ta=f(s>s| translated:  articlesr = sorted [ b _cmp a
Lexem 8 Current token=')' perl='}' value=']' Tokenstr |ta=f(s>s)| translated:  articlesr = sorted [ b _cmp a ]
Lexem 9 Current token='a' perl='@files' value='files' Tokenstr |ta=f(s>s)a| translated:  articlesr = sorted [ b _cmp a ] files

Line:   22 TokenStr: =|ta=f(s>s)a|= @ValPy:  articlesr = sorted [ b _cmp a ] files
handle_cmp_spaceship(0, 6, 9): a[5:5], b[7:7] = 3 (=|ta=f(f(s,s))a|=)
assignment(0, 11) =|a=f(f(s,s))a|= @articlesr = sort { cmp ( $b , $a ) } @files

Generated partial line articlesr
Generated partial line articlesr=
expression(2, 11, 0) =|a=f(f(s,s))a|= @articlesr = sort { cmp ( $b , $a ) } @files

function(2, 11) =|a=f(f(s,s))a|= @articlesr = sort { cmp ( $b , $a ) } @files

function start=4, end_pos=9, bracketed=1
Generated partial line articlesr=sorted
Generated partial line articlesr=sorted(
expression(11, 11, 0) =|a=f(f(s,s))a|= @articlesr = sort { cmp ( $b , $a ) } @files

Generated partial line articlesr=sorted(files
expression returns 12
Generated partial line articlesr=sorted(files, key=functools.cmp_to_key(lambda a,b:
expression(4, 9, 0) =|a=f(f(s,s))a|= @articlesr = sort { cmp ( $b , $a ) } @files

function(4, 9) =|a=f(f(s,s))a|= @articlesr = sort { cmp ( $b , $a ) } @files

function start=6, end_pos=8, bracketed=1
Generated partial line articlesr=sorted(files, key=functools.cmp_to_key(lambda a,b:_cmp
Generated partial line articlesr=sorted(files, key=functools.cmp_to_key(lambda a,b:_cmp(
expression(6, 8, 0) =|a=f(f(s,s))a|= @articlesr = sort { cmp ( $b , $a ) } @files

Generated partial line articlesr=sorted(files, key=functools.cmp_to_key(lambda a,b:_cmp(b
Generated partial line articlesr=sorted(files, key=functools.cmp_to_key(lambda a,b:_cmp(b,
Generated partial line articlesr=sorted(files, key=functools.cmp_to_key(lambda a,b:_cmp(b,a
expression returns 9
Generated partial line articlesr=sorted(files, key=functools.cmp_to_key(lambda a,b:_cmp(b,a)
expression returns 10
Generated partial line articlesr=sorted(files, key=functools.cmp_to_key(lambda a,b:_cmp(b,a))
Generated partial line articlesr=sorted(files, key=functools.cmp_to_key(lambda a,b:_cmp(b,a)))
expression returns 12
  23 | 0 |   |articlesr = sorted(files, key=functools.cmp_to_key(lambda a,b:_cmp(b, a)))              #PL: assert(join('', @articlesr) eq 'edcba');

Tokens: a=f(f(s,s))a ValPy: 
Main loop, line=assert(join('', @articlesr) eq 'edcba');


 === Line 23 Perl source:assert(join('', @articlesr) eq 'edcba');===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='join' value='.join(' Tokenstr |c(f| translated: assert ( .join(
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( .join( (
Lexem 4 Current token='"' perl='' value='''' Tokenstr |c(f("| translated: assert ( .join( ( ''
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |c(f(",| translated: assert ( .join( ( '' ,
Lexem 6 Current token='a' perl='@articlesr' value='articlesr' Tokenstr |c(f(",a| translated: assert ( .join( ( '' , articlesr
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |c(f(",a)| translated: assert ( .join( ( '' , articlesr )
Lexem 8 Current token='>' perl='eq' value='==' Tokenstr |c(f(",a)>| translated: assert ( .join( ( '' , articlesr ) ==
Lexem 9 Current token='"' perl='edcba' value=''edcba'' Tokenstr |c(f(",a)>"| translated: assert ( .join( ( '' , articlesr ) == 'edcba'
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |c(f(",a)>")| translated: assert ( .join( ( '' , articlesr ) == 'edcba' )

Line:   23 TokenStr: =|c(f(",a)>")|= @ValPy: assert ( .join( ( '' , articlesr ) == 'edcba' )
control(0) =|c(f(",a)>")|= assert ( join (  , @articlesr ) eq edcba )

control-parens removed, begin=0 start=1 =|cf(",a)>"|= assert join (  , @articlesr ) eq edcba

Generated partial line assert
expression(1, 8, 0) =|cf(",a)>"|= assert join (  , @articlesr ) eq edcba

function(1, 8) =|cf(",a)>"|= assert join (  , @articlesr ) eq edcba

function start=3, end_pos=5, bracketed=1
Generated partial line assert''
Generated partial line assert''.join(
Generated partial line assert''.join(articlesr
Generated partial line assert''.join(articlesr)
Generated partial line assert''.join(articlesr)==
Generated partial line assert''.join(articlesr)=='edcba'
expression returns 9
  24 | 0 |   |
  25 | 0 |   |assert ''.join(articlesr) == 'edcba'                                                    #PL: @files = (4, 5, 3, 1, 2);

Tokens: cf(",a)>" ValPy: 
Main loop, line=@files = (4, 5, 3, 1, 2);


 === Line 25 Perl source:@files = (4, 5, 3, 1, 2);===

Lexem 0 Current token='a' perl='@files' value='files' Tokenstr |a| translated: files
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |a=| translated: files =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |a=(| translated: files = (
Lexem 3 Current token='d' perl='4' value='4' Tokenstr |a=(d| translated: files = ( 4
Lexem 4 Current token=',' perl=',' value=',' Tokenstr |a=(d,| translated: files = ( 4 ,
Lexem 5 Current token='d' perl='5' value='5' Tokenstr |a=(d,d| translated: files = ( 4 , 5
Lexem 6 Current token=',' perl=',' value=',' Tokenstr |a=(d,d,| translated: files = ( 4 , 5 ,
Lexem 7 Current token='d' perl='3' value='3' Tokenstr |a=(d,d,d| translated: files = ( 4 , 5 , 3
Lexem 8 Current token=',' perl=',' value=',' Tokenstr |a=(d,d,d,| translated: files = ( 4 , 5 , 3 ,
Lexem 9 Current token='d' perl='1' value='1' Tokenstr |a=(d,d,d,d| translated: files = ( 4 , 5 , 3 , 1
Lexem 10 Current token=',' perl=',' value=',' Tokenstr |a=(d,d,d,d,| translated: files = ( 4 , 5 , 3 , 1 ,
Lexem 11 Current token='d' perl='2' value='2' Tokenstr |a=(d,d,d,d,d| translated: files = ( 4 , 5 , 3 , 1 , 2
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |a=(d,d,d,d,d)| translated: files = ( 4 , 5 , 3 , 1 , 2 )

Line:   25 TokenStr: =|a=(d,d,d,d,d)|= @ValPy: files = ( 4 , 5 , 3 , 1 , 2 )
Generated partial line files = [
Generated partial line files = [4
Generated partial line files = [4,
Generated partial line files = [4,5
Generated partial line files = [4,5,
Generated partial line files = [4,5,3
Generated partial line files = [4,5,3,
Generated partial line files = [4,5,3,1
Generated partial line files = [4,5,3,1,
Generated partial line files = [4,5,3,1,2
Generated partial line files = [4,5,3,1,2]
  26 | 0 |   |# sort numerically ascending
  27 | 0 |   |files = [4, 5, 3, 1, 2]                                                                 #PL: my @articlesn = sort {$a <=> $b} @files;

Tokens: a=(d,d,d,d,d) ValPy: 
Main loop, line=my @articlesn = sort {$a <=> $b} @files;


 === Line 27 Perl source:my @articlesn = sort {$a <=> $b} @files;===

Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@articlesn' value='articlesn' Tokenstr |ta| translated:  articlesn
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  articlesn =
Lexem 3 Current token='f' perl='sort' value='sorted' Tokenstr |ta=f| translated:  articlesn = sorted
Lexem 4 Current token='(' perl='{' value='[' Tokenstr |ta=f(| translated:  articlesn = sorted [
Lexem 5 Current token='s' perl='$a' value='a' Tokenstr |ta=f(s| translated:  articlesn = sorted [ a
Lexem 6 Current token='>' perl='<=>' value='_spaceship' Tokenstr |ta=f(s>| translated:  articlesn = sorted [ a _spaceship
Lexem 7 Current token='s' perl='$b' value='b' Tokenstr |ta=f(s>s| translated:  articlesn = sorted [ a _spaceship b
Lexem 8 Current token=')' perl='}' value=']' Tokenstr |ta=f(s>s)| translated:  articlesn = sorted [ a _spaceship b ]
Lexem 9 Current token='a' perl='@files' value='files' Tokenstr |ta=f(s>s)a| translated:  articlesn = sorted [ a _spaceship b ] files

Line:   27 TokenStr: =|ta=f(s>s)a|= @ValPy:  articlesn = sorted [ a _spaceship b ] files
handle_cmp_spaceship(0, 6, 9): a[5:5], b[7:7] = 3 (=|ta=f(f(s,s))a|=)
assignment(0, 11) =|a=f(f(s,s))a|= @articlesn = sort { <=> ( $a , $b ) } @files

Generated partial line articlesn
Generated partial line articlesn=
expression(2, 11, 0) =|a=f(f(s,s))a|= @articlesn = sort { <=> ( $a , $b ) } @files

function(2, 11) =|a=f(f(s,s))a|= @articlesn = sort { <=> ( $a , $b ) } @files

function start=4, end_pos=9, bracketed=1
Generated partial line articlesn=sorted
Generated partial line articlesn=sorted(
expression(11, 11, 0) =|a=f(f(s,s))a|= @articlesn = sort { <=> ( $a , $b ) } @files

Generated partial line articlesn=sorted(files
expression returns 12
Generated partial line articlesn=sorted(files, key=functools.cmp_to_key(lambda a,b:
expression(4, 9, 0) =|a=f(f(s,s))a|= @articlesn = sort { <=> ( $a , $b ) } @files

function(4, 9) =|a=f(f(s,s))a|= @articlesn = sort { <=> ( $a , $b ) } @files

function start=6, end_pos=8, bracketed=1
Generated partial line articlesn=sorted(files, key=functools.cmp_to_key(lambda a,b:_spaceship
Generated partial line articlesn=sorted(files, key=functools.cmp_to_key(lambda a,b:_spaceship(
expression(6, 8, 0) =|a=f(f(s,s))a|= @articlesn = sort { <=> ( $a , $b ) } @files

Generated partial line articlesn=sorted(files, key=functools.cmp_to_key(lambda a,b:_spaceship(a
Generated partial line articlesn=sorted(files, key=functools.cmp_to_key(lambda a,b:_spaceship(a,
Generated partial line articlesn=sorted(files, key=functools.cmp_to_key(lambda a,b:_spaceship(a,b
expression returns 9
Generated partial line articlesn=sorted(files, key=functools.cmp_to_key(lambda a,b:_spaceship(a,b)
expression returns 10
Generated partial line articlesn=sorted(files, key=functools.cmp_to_key(lambda a,b:_spaceship(a,b))
Generated partial line articlesn=sorted(files, key=functools.cmp_to_key(lambda a,b:_spaceship(a,b)))
expression returns 12
  28 | 0 |   |articlesn = sorted(files, key=functools.cmp_to_key(lambda a,b:_spaceship(a, b)))        #PL: assert(join('', map {''.$_} @articlesn) eq '12345');

Tokens: a=f(f(s,s))a ValPy: 
Main loop, line=assert(join('', map {''.$_} @articlesn) eq '12345');


 === Line 28 Perl source:assert(join('', map {''.$_} @articlesn) eq '12345');===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='join' value='.join(' Tokenstr |c(f| translated: assert ( .join(
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( .join( (
Lexem 4 Current token='"' perl='' value='''' Tokenstr |c(f("| translated: assert ( .join( ( ''
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |c(f(",| translated: assert ( .join( ( '' ,
Lexem 6 Current token='f' perl='map' value='map' Tokenstr |c(f(",f| translated: assert ( .join( ( '' , map
Lexem 7 Current token='(' perl='{' value='[' Tokenstr |c(f(",f(| translated: assert ( .join( ( '' , map [
Lexem 8 Current token='"' perl='' value='''' Tokenstr |c(f(",f("| translated: assert ( .join( ( '' , map [ ''
Lexem 9 Current token='.' perl='.' value=' + ' Tokenstr |c(f(",f(".| translated: assert ( .join( ( '' , map [ ''  + 
Lexem 10 Current token='s' perl='$_' value='_d' Tokenstr |c(f(",f(".s| translated: assert ( .join( ( '' , map [ ''  +  _d
Lexem 11 Current token=')' perl='}' value=']' Tokenstr |c(f(",f(".s)| translated: assert ( .join( ( '' , map [ ''  +  _d ]
Lexem 12 Current token='a' perl='@articlesn' value='articlesn' Tokenstr |c(f(",f(".s)a| translated: assert ( .join( ( '' , map [ ''  +  _d ] articlesn
Lexem 13 Current token=')' perl=')' value=')' Tokenstr |c(f(",f(".s)a)| translated: assert ( .join( ( '' , map [ ''  +  _d ] articlesn )
Lexem 14 Current token='>' perl='eq' value='==' Tokenstr |c(f(",f(".s)a)>| translated: assert ( .join( ( '' , map [ ''  +  _d ] articlesn ) ==
Lexem 15 Current token='"' perl='12345' value=''12345'' Tokenstr |c(f(",f(".s)a)>"| translated: assert ( .join( ( '' , map [ ''  +  _d ] articlesn ) == '12345'
Lexem 16 Current token=')' perl=')' value=')' Tokenstr |c(f(",f(".s)a)>")| translated: assert ( .join( ( '' , map [ ''  +  _d ] articlesn ) == '12345' )

Line:   28 TokenStr: =|c(f(",f(".s)a)>")|= @ValPy: assert ( .join( ( '' , map [ ''  +  _d ] articlesn ) == '12345' )
fix_string_catentation2 i=9, j=11

control(0) =|c(f(",f(".f(s))a)>")|= assert ( join (  , map {  . str ( $_ ) } @articlesn ) eq 12345 )

control-parens removed, begin=0 start=1 =|cf(",f(".f(s))a)>"|= assert join (  , map {  . str ( $_ ) } @articlesn ) eq 12345

Generated partial line assert
expression(1, 17, 0) =|cf(",f(".f(s))a)>"|= assert join (  , map {  . str ( $_ ) } @articlesn ) eq 12345

function(1, 17) =|cf(",f(".f(s))a)>"|= assert join (  , map {  . str ( $_ ) } @articlesn ) eq 12345

function start=3, end_pos=14, bracketed=1
Generated partial line assert''
Generated partial line assert''.join(
Generated partial line assert''.join((
expression(5, 14, 0) =|cf(",f(".f(s))a)>"|= assert join (  , map {  . str ( $_ ) } @articlesn ) eq 12345

function(5, 14) =|cf(",f(".f(s))a)>"|= assert join (  , map {  . str ( $_ ) } @articlesn ) eq 12345

function start=7, end_pos=12, bracketed=1
Generated partial line assert''.join((list(
Generated partial line assert''.join((list(map
Generated partial line assert''.join((list(map(lambda _d:
expression(7, 12, 0) =|cf(",f(".f(s))a)>"|= assert join (  , map {  . str ( $_ ) } @articlesn ) eq 12345

Generated partial line assert''.join((list(map(lambda _d:''
Generated partial line assert''.join((list(map(lambda _d:'' + 
function(9, 12) =|cf(",f(".f(s))a)>"|= assert join (  , map {  . str ( $_ ) } @articlesn ) eq 12345

function start=11, end_pos=11, bracketed=1
Generated partial line assert''.join((list(map(lambda _d:'' + str
Generated partial line assert''.join((list(map(lambda _d:'' + str(
expression(11, 11, 0) =|cf(",f(".f(s))a)>"|= assert join (  , map {  . str ( $_ ) } @articlesn ) eq 12345

Generated partial line assert''.join((list(map(lambda _d:'' + str(_d
expression returns 12
Generated partial line assert''.join((list(map(lambda _d:'' + str(_d)
expression returns 13
Generated partial line assert''.join((list(map(lambda _d:'' + str(_d),
expression(14, 14, 0) =|cf(",f(".f(s))a)>"|= assert join (  , map {  . str ( $_ ) } @articlesn ) eq 12345

Generated partial line assert''.join((list(map(lambda _d:'' + str(_d),articlesn
expression returns 15
Generated partial line assert''.join((list(map(lambda _d:'' + str(_d),articlesn)
Generated partial line assert''.join((list(map(lambda _d:'' + str(_d),articlesn))
expression returns 15
Generated partial line assert''.join((list(map(lambda _d:'' + str(_d),articlesn)))
Generated partial line assert''.join((list(map(lambda _d:'' + str(_d),articlesn))))
Generated partial line assert''.join((list(map(lambda _d:'' + str(_d),articlesn))))==
Generated partial line assert''.join((list(map(lambda _d:'' + str(_d),articlesn))))=='12345'
expression returns 18
  29 | 0 |   |
  30 | 0 |   |# sort numerically descending
  31 | 0 |   |assert ''.join((list(map(lambda _d:'' + str(_d), articlesn)))) == '12345'               #PL: my @articlesnd = sort {$b <=> $a} @files;

Tokens: cf(",f(".f(s))a)>" ValPy: 
Main loop, line=my @articlesnd = sort {$b <=> $a} @files;


 === Line 31 Perl source:my @articlesnd = sort {$b <=> $a} @files;===

Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@articlesnd' value='articlesnd' Tokenstr |ta| translated:  articlesnd
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  articlesnd =
Lexem 3 Current token='f' perl='sort' value='sorted' Tokenstr |ta=f| translated:  articlesnd = sorted
Lexem 4 Current token='(' perl='{' value='[' Tokenstr |ta=f(| translated:  articlesnd = sorted [
Lexem 5 Current token='s' perl='$b' value='b' Tokenstr |ta=f(s| translated:  articlesnd = sorted [ b
Lexem 6 Current token='>' perl='<=>' value='_spaceship' Tokenstr |ta=f(s>| translated:  articlesnd = sorted [ b _spaceship
Lexem 7 Current token='s' perl='$a' value='a' Tokenstr |ta=f(s>s| translated:  articlesnd = sorted [ b _spaceship a
Lexem 8 Current token=')' perl='}' value=']' Tokenstr |ta=f(s>s)| translated:  articlesnd = sorted [ b _spaceship a ]
Lexem 9 Current token='a' perl='@files' value='files' Tokenstr |ta=f(s>s)a| translated:  articlesnd = sorted [ b _spaceship a ] files

Line:   31 TokenStr: =|ta=f(s>s)a|= @ValPy:  articlesnd = sorted [ b _spaceship a ] files
handle_cmp_spaceship(0, 6, 9): a[5:5], b[7:7] = 3 (=|ta=f(f(s,s))a|=)
assignment(0, 11) =|a=f(f(s,s))a|= @articlesnd = sort { <=> ( $b , $a ) } @files

Generated partial line articlesnd
Generated partial line articlesnd=
expression(2, 11, 0) =|a=f(f(s,s))a|= @articlesnd = sort { <=> ( $b , $a ) } @files

function(2, 11) =|a=f(f(s,s))a|= @articlesnd = sort { <=> ( $b , $a ) } @files

function start=4, end_pos=9, bracketed=1
Generated partial line articlesnd=sorted
Generated partial line articlesnd=sorted(
expression(11, 11, 0) =|a=f(f(s,s))a|= @articlesnd = sort { <=> ( $b , $a ) } @files

Generated partial line articlesnd=sorted(files
expression returns 12
Generated partial line articlesnd=sorted(files, key=functools.cmp_to_key(lambda a,b:
expression(4, 9, 0) =|a=f(f(s,s))a|= @articlesnd = sort { <=> ( $b , $a ) } @files

function(4, 9) =|a=f(f(s,s))a|= @articlesnd = sort { <=> ( $b , $a ) } @files

function start=6, end_pos=8, bracketed=1
Generated partial line articlesnd=sorted(files, key=functools.cmp_to_key(lambda a,b:_spaceship
Generated partial line articlesnd=sorted(files, key=functools.cmp_to_key(lambda a,b:_spaceship(
expression(6, 8, 0) =|a=f(f(s,s))a|= @articlesnd = sort { <=> ( $b , $a ) } @files

Generated partial line articlesnd=sorted(files, key=functools.cmp_to_key(lambda a,b:_spaceship(b
Generated partial line articlesnd=sorted(files, key=functools.cmp_to_key(lambda a,b:_spaceship(b,
Generated partial line articlesnd=sorted(files, key=functools.cmp_to_key(lambda a,b:_spaceship(b,a
expression returns 9
Generated partial line articlesnd=sorted(files, key=functools.cmp_to_key(lambda a,b:_spaceship(b,a)
expression returns 10
Generated partial line articlesnd=sorted(files, key=functools.cmp_to_key(lambda a,b:_spaceship(b,a))
Generated partial line articlesnd=sorted(files, key=functools.cmp_to_key(lambda a,b:_spaceship(b,a)))
expression returns 12
  32 | 0 |   |articlesnd = sorted(files, key=functools.cmp_to_key(lambda a,b:_spaceship(b, a)))       #PL: assert(join('', map {''.$_} @articlesnd) eq '54321');

Tokens: a=f(f(s,s))a ValPy: 
Main loop, line=assert(join('', map {''.$_} @articlesnd) eq '54321');


 === Line 32 Perl source:assert(join('', map {''.$_} @articlesnd) eq '54321');===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='join' value='.join(' Tokenstr |c(f| translated: assert ( .join(
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( .join( (
Lexem 4 Current token='"' perl='' value='''' Tokenstr |c(f("| translated: assert ( .join( ( ''
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |c(f(",| translated: assert ( .join( ( '' ,
Lexem 6 Current token='f' perl='map' value='map' Tokenstr |c(f(",f| translated: assert ( .join( ( '' , map
Lexem 7 Current token='(' perl='{' value='[' Tokenstr |c(f(",f(| translated: assert ( .join( ( '' , map [
Lexem 8 Current token='"' perl='' value='''' Tokenstr |c(f(",f("| translated: assert ( .join( ( '' , map [ ''
Lexem 9 Current token='.' perl='.' value=' + ' Tokenstr |c(f(",f(".| translated: assert ( .join( ( '' , map [ ''  + 
Lexem 10 Current token='s' perl='$_' value='_d' Tokenstr |c(f(",f(".s| translated: assert ( .join( ( '' , map [ ''  +  _d
Lexem 11 Current token=')' perl='}' value=']' Tokenstr |c(f(",f(".s)| translated: assert ( .join( ( '' , map [ ''  +  _d ]
Lexem 12 Current token='a' perl='@articlesnd' value='articlesnd' Tokenstr |c(f(",f(".s)a| translated: assert ( .join( ( '' , map [ ''  +  _d ] articlesnd
Lexem 13 Current token=')' perl=')' value=')' Tokenstr |c(f(",f(".s)a)| translated: assert ( .join( ( '' , map [ ''  +  _d ] articlesnd )
Lexem 14 Current token='>' perl='eq' value='==' Tokenstr |c(f(",f(".s)a)>| translated: assert ( .join( ( '' , map [ ''  +  _d ] articlesnd ) ==
Lexem 15 Current token='"' perl='54321' value=''54321'' Tokenstr |c(f(",f(".s)a)>"| translated: assert ( .join( ( '' , map [ ''  +  _d ] articlesnd ) == '54321'
Lexem 16 Current token=')' perl=')' value=')' Tokenstr |c(f(",f(".s)a)>")| translated: assert ( .join( ( '' , map [ ''  +  _d ] articlesnd ) == '54321' )

Line:   32 TokenStr: =|c(f(",f(".s)a)>")|= @ValPy: assert ( .join( ( '' , map [ ''  +  _d ] articlesnd ) == '54321' )
fix_string_catentation2 i=9, j=11

control(0) =|c(f(",f(".f(s))a)>")|= assert ( join (  , map {  . str ( $_ ) } @articlesnd ) eq 54321 )

control-parens removed, begin=0 start=1 =|cf(",f(".f(s))a)>"|= assert join (  , map {  . str ( $_ ) } @articlesnd ) eq 54321

Generated partial line assert
expression(1, 17, 0) =|cf(",f(".f(s))a)>"|= assert join (  , map {  . str ( $_ ) } @articlesnd ) eq 54321

function(1, 17) =|cf(",f(".f(s))a)>"|= assert join (  , map {  . str ( $_ ) } @articlesnd ) eq 54321

function start=3, end_pos=14, bracketed=1
Generated partial line assert''
Generated partial line assert''.join(
Generated partial line assert''.join((
expression(5, 14, 0) =|cf(",f(".f(s))a)>"|= assert join (  , map {  . str ( $_ ) } @articlesnd ) eq 54321

function(5, 14) =|cf(",f(".f(s))a)>"|= assert join (  , map {  . str ( $_ ) } @articlesnd ) eq 54321

function start=7, end_pos=12, bracketed=1
Generated partial line assert''.join((list(
Generated partial line assert''.join((list(map
Generated partial line assert''.join((list(map(lambda _d:
expression(7, 12, 0) =|cf(",f(".f(s))a)>"|= assert join (  , map {  . str ( $_ ) } @articlesnd ) eq 54321

Generated partial line assert''.join((list(map(lambda _d:''
Generated partial line assert''.join((list(map(lambda _d:'' + 
function(9, 12) =|cf(",f(".f(s))a)>"|= assert join (  , map {  . str ( $_ ) } @articlesnd ) eq 54321

function start=11, end_pos=11, bracketed=1
Generated partial line assert''.join((list(map(lambda _d:'' + str
Generated partial line assert''.join((list(map(lambda _d:'' + str(
expression(11, 11, 0) =|cf(",f(".f(s))a)>"|= assert join (  , map {  . str ( $_ ) } @articlesnd ) eq 54321

Generated partial line assert''.join((list(map(lambda _d:'' + str(_d
expression returns 12
Generated partial line assert''.join((list(map(lambda _d:'' + str(_d)
expression returns 13
Generated partial line assert''.join((list(map(lambda _d:'' + str(_d),
expression(14, 14, 0) =|cf(",f(".f(s))a)>"|= assert join (  , map {  . str ( $_ ) } @articlesnd ) eq 54321

Generated partial line assert''.join((list(map(lambda _d:'' + str(_d),articlesnd
expression returns 15
Generated partial line assert''.join((list(map(lambda _d:'' + str(_d),articlesnd)
Generated partial line assert''.join((list(map(lambda _d:'' + str(_d),articlesnd))
expression returns 15
Generated partial line assert''.join((list(map(lambda _d:'' + str(_d),articlesnd)))
Generated partial line assert''.join((list(map(lambda _d:'' + str(_d),articlesnd))))
Generated partial line assert''.join((list(map(lambda _d:'' + str(_d),articlesnd))))==
Generated partial line assert''.join((list(map(lambda _d:'' + str(_d),articlesnd))))=='54321'
expression returns 18
  33 | 0 |   |
  34 | 0 |   |assert ''.join((list(map(lambda _d:'' + str(_d), articlesnd)))) == '54321'              #PL: %age = (a=>10, b=>5, c=>20, d=>1, e=>6);

Tokens: cf(",f(".f(s))a)>" ValPy: 
Main loop, line=%age = (a=>10, b=>5, c=>20, d=>1, e=>6);


 === Line 34 Perl source:%age = (a=>10, b=>5, c=>20, d=>1, e=>6);===

Lexem 0 Current token='h' perl='age' value='age' Tokenstr |h| translated: age
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |h=| translated: age =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |h=(| translated: age = (
Lexem 3 Current token='i' perl='a' value='a' Tokenstr |h=(i| translated: age = ( a
Lexem 4 Current token=':' perl='=>' value=': ' Tokenstr |h=(i:| translated: age = ( a : 
Lexem 5 Current token='d' perl='10' value='10' Tokenstr |h=(i:d| translated: age = ( a :  10
Lexem 6 Current token=',' perl=',' value=',' Tokenstr |h=(i:d,| translated: age = ( a :  10 ,
Lexem 7 Current token='i' perl='b' value='b' Tokenstr |h=(i:d,i| translated: age = ( a :  10 , b
Lexem 8 Current token=':' perl='=>' value=': ' Tokenstr |h=(i:d,i:| translated: age = ( a :  10 , b : 
Lexem 9 Current token='d' perl='5' value='5' Tokenstr |h=(i:d,i:d| translated: age = ( a :  10 , b :  5
Lexem 10 Current token=',' perl=',' value=',' Tokenstr |h=(i:d,i:d,| translated: age = ( a :  10 , b :  5 ,
Lexem 11 Current token='i' perl='c' value='c' Tokenstr |h=(i:d,i:d,i| translated: age = ( a :  10 , b :  5 , c
Lexem 12 Current token=':' perl='=>' value=': ' Tokenstr |h=(i:d,i:d,i:| translated: age = ( a :  10 , b :  5 , c : 
Lexem 13 Current token='d' perl='20' value='20' Tokenstr |h=(i:d,i:d,i:d| translated: age = ( a :  10 , b :  5 , c :  20
Lexem 14 Current token=',' perl=',' value=',' Tokenstr |h=(i:d,i:d,i:d,| translated: age = ( a :  10 , b :  5 , c :  20 ,
Lexem 15 Current token='i' perl='d' value='d' Tokenstr |h=(i:d,i:d,i:d,i| translated: age = ( a :  10 , b :  5 , c :  20 , d
Lexem 16 Current token=':' perl='=>' value=': ' Tokenstr |h=(i:d,i:d,i:d,i:| translated: age = ( a :  10 , b :  5 , c :  20 , d : 
Lexem 17 Current token='d' perl='1' value='1' Tokenstr |h=(i:d,i:d,i:d,i:d| translated: age = ( a :  10 , b :  5 , c :  20 , d :  1
Lexem 18 Current token=',' perl=',' value=',' Tokenstr |h=(i:d,i:d,i:d,i:d,| translated: age = ( a :  10 , b :  5 , c :  20 , d :  1 ,
Lexem 19 Current token='i' perl='e' value='e' Tokenstr |h=(i:d,i:d,i:d,i:d,i| translated: age = ( a :  10 , b :  5 , c :  20 , d :  1 , e
Lexem 20 Current token=':' perl='=>' value=': ' Tokenstr |h=(i:d,i:d,i:d,i:d,i:| translated: age = ( a :  10 , b :  5 , c :  20 , d :  1 , e : 
Lexem 21 Current token='d' perl='6' value='6' Tokenstr |h=(i:d,i:d,i:d,i:d,i:d| translated: age = ( a :  10 , b :  5 , c :  20 , d :  1 , e :  6
Lexem 22 Current token=')' perl=')' value=')' Tokenstr |h=(i:d,i:d,i:d,i:d,i:d)| translated: age = ( a :  10 , b :  5 , c :  20 , d :  1 , e :  6 )

Line:   34 TokenStr: =|h=(i:d,i:d,i:d,i:d,i:d)|= @ValPy: age = ( a :  10 , b :  5 , c :  20 , d :  1 , e :  6 )
Generated partial line age = {
Generated partial line age = {'a'
Generated partial line age = {'a': 
Generated partial line age = {'a': 10
Generated partial line age = {'a': 10,
Generated partial line age = {'a': 10,'b'
Generated partial line age = {'a': 10,'b': 
Generated partial line age = {'a': 10,'b': 5
Generated partial line age = {'a': 10,'b': 5,
Generated partial line age = {'a': 10,'b': 5,'c'
Generated partial line age = {'a': 10,'b': 5,'c': 
Generated partial line age = {'a': 10,'b': 5,'c': 20
Generated partial line age = {'a': 10,'b': 5,'c': 20,
Generated partial line age = {'a': 10,'b': 5,'c': 20,'d'
Generated partial line age = {'a': 10,'b': 5,'c': 20,'d': 
Generated partial line age = {'a': 10,'b': 5,'c': 20,'d': 1
Generated partial line age = {'a': 10,'b': 5,'c': 20,'d': 1,
Generated partial line age = {'a': 10,'b': 5,'c': 20,'d': 1,'e'
Generated partial line age = {'a': 10,'b': 5,'c': 20,'d': 1,'e': 
Generated partial line age = {'a': 10,'b': 5,'c': 20,'d': 1,'e': 6
Generated partial line age = {'a': 10,'b': 5,'c': 20,'d': 1,'e': 6}
  35 | 0 |   |# this sorts the %age hash by value instead of key
  36 | 0 |   |# using an in-line function
  37 | 0 |   |age = {'a': 10, 'b': 5, 'c': 20, 'd': 1, 'e': 6}                                        #PL: my @eldest = sort { $age{$b} <=> $age{$a} } keys %age;

Tokens: h=(i:d,i:d,i:d,i:d,i:d) ValPy: 
Main loop, line=my @eldest = sort { $age{$b} <=> $age{$a} } keys %age;


 === Line 37 Perl source:my @eldest = sort { $age{$b} <=> $age{$a} } keys %age;===

Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@eldest' value='eldest' Tokenstr |ta| translated:  eldest
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  eldest =
Lexem 3 Current token='f' perl='sort' value='sorted' Tokenstr |ta=f| translated:  eldest = sorted
Lexem 4 Current token='(' perl='{' value='[' Tokenstr |ta=f(| translated:  eldest = sorted [
Lexem 5 Current token='s' perl='$age' value='age' Tokenstr |ta=f(s| translated:  eldest = sorted [ age
Lexem 6 Current token='(' perl='{' value='[' Tokenstr |ta=f(s(| translated:  eldest = sorted [ age [
Lexem 7 Current token='s' perl='$b' value='b' Tokenstr |ta=f(s(s| translated:  eldest = sorted [ age [ b
Lexem 8 Current token=')' perl='}' value=']' Tokenstr |ta=f(s(s)| translated:  eldest = sorted [ age [ b ]
Lexem 9 Current token='>' perl='<=>' value='_spaceship' Tokenstr |ta=f(s(s)>| translated:  eldest = sorted [ age [ b ] _spaceship
Lexem 10 Current token='s' perl='$age' value='age' Tokenstr |ta=f(s(s)>s| translated:  eldest = sorted [ age [ b ] _spaceship age
Lexem 11 Current token='(' perl='{' value='[' Tokenstr |ta=f(s(s)>s(| translated:  eldest = sorted [ age [ b ] _spaceship age [
Lexem 12 Current token='s' perl='$a' value='a' Tokenstr |ta=f(s(s)>s(s| translated:  eldest = sorted [ age [ b ] _spaceship age [ a
Lexem 13 Current token=')' perl='}' value=']' Tokenstr |ta=f(s(s)>s(s)| translated:  eldest = sorted [ age [ b ] _spaceship age [ a ]
Lexem 14 Current token=')' perl='}' value=']' Tokenstr |ta=f(s(s)>s(s))| translated:  eldest = sorted [ age [ b ] _spaceship age [ a ] ]
Lexem 15 Current token='f' perl='keys' value='.keys()' Tokenstr |ta=f(s(s)>s(s))f| translated:  eldest = sorted [ age [ b ] _spaceship age [ a ] ] .keys()
Lexem 16 Current token='h' perl='age' value='age' Tokenstr |ta=f(s(s)>s(s))fh| translated:  eldest = sorted [ age [ b ] _spaceship age [ a ] ] .keys() age

Line:   37 TokenStr: =|ta=f(s(s)>s(s))fh|= @ValPy:  eldest = sorted [ age [ b ] _spaceship age [ a ] ] .keys() age
handle_cmp_spaceship(0, 9, 16): a[5:8], b[10:13] = 3 (=|ta=f(f(s(s),s(s)))fh|=)
assignment(0, 18) =|a=f(f(s(s),s(s)))fh|= @eldest = sort { <=> ( $age { $b } , $age { $a } ) } keys age

Generated partial line eldest
Generated partial line eldest=
expression(2, 18, 0) =|a=f(f(s(s),s(s)))fh|= @eldest = sort { <=> ( $age { $b } , $age { $a } ) } keys age

function(2, 18) =|a=f(f(s(s),s(s)))fh|= @eldest = sort { <=> ( $age { $b } , $age { $a } ) } keys age

function start=4, end_pos=15, bracketed=1
Generated partial line eldest=sorted
Generated partial line eldest=sorted(
expression(17, 18, 0) =|a=f(f(s(s),s(s)))fh|= @eldest = sort { <=> ( $age { $b } , $age { $a } ) } keys age

function(17, 18) =|a=f(f(s(s),s(s)))fh|= @eldest = sort { <=> ( $age { $b } , $age { $a } ) } keys age

function start=18, end_pos=18, bracketed=0
expression(18, 18, 0) =|a=f(f(s(s),s(s)))fh|= @eldest = sort { <=> ( $age { $b } , $age { $a } ) } keys age

Generated partial line eldest=sorted(age
expression returns 19
Generated partial line eldest=sorted(age.keys()
expression returns 19
Generated partial line eldest=sorted(age.keys(), key=functools.cmp_to_key(lambda a,b:
expression(4, 15, 0) =|a=f(f(s(s),s(s)))fh|= @eldest = sort { <=> ( $age { $b } , $age { $a } ) } keys age

function(4, 15) =|a=f(f(s(s),s(s)))fh|= @eldest = sort { <=> ( $age { $b } , $age { $a } ) } keys age

function start=6, end_pos=14, bracketed=1
Generated partial line eldest=sorted(age.keys(), key=functools.cmp_to_key(lambda a,b:_spaceship
Generated partial line eldest=sorted(age.keys(), key=functools.cmp_to_key(lambda a,b:_spaceship(
expression(6, 14, 0) =|a=f(f(s(s),s(s)))fh|= @eldest = sort { <=> ( $age { $b } , $age { $a } ) } keys age

Generated partial line eldest=sorted(age.keys(), key=functools.cmp_to_key(lambda a,b:_spaceship(age
Generated partial line eldest=sorted(age.keys(), key=functools.cmp_to_key(lambda a,b:_spaceship(age.get(
expression(8, 8, 0) =|a=f(f(s(s),s(s)))fh|= @eldest = sort { <=> ( $age { $b } , $age { $a } ) } keys age

Generated partial line eldest=sorted(age.keys(), key=functools.cmp_to_key(lambda a,b:_spaceship(age.get(b
expression returns 9
Generated partial line eldest=sorted(age.keys(), key=functools.cmp_to_key(lambda a,b:_spaceship(age.get(b)
Generated partial line eldest=sorted(age.keys(), key=functools.cmp_to_key(lambda a,b:_spaceship(age.get(b),
Generated partial line eldest=sorted(age.keys(), key=functools.cmp_to_key(lambda a,b:_spaceship(age.get(b),age
Generated partial line eldest=sorted(age.keys(), key=functools.cmp_to_key(lambda a,b:_spaceship(age.get(b),age.get(
expression(13, 13, 0) =|a=f(f(s(s),s(s)))fh|= @eldest = sort { <=> ( $age { $b } , $age { $a } ) } keys age

Generated partial line eldest=sorted(age.keys(), key=functools.cmp_to_key(lambda a,b:_spaceship(age.get(b),age.get(a
expression returns 14
Generated partial line eldest=sorted(age.keys(), key=functools.cmp_to_key(lambda a,b:_spaceship(age.get(b),age.get(a)
expression returns 15
Generated partial line eldest=sorted(age.keys(), key=functools.cmp_to_key(lambda a,b:_spaceship(age.get(b),age.get(a))
expression returns 16
Generated partial line eldest=sorted(age.keys(), key=functools.cmp_to_key(lambda a,b:_spaceship(age.get(b),age.get(a)))
Generated partial line eldest=sorted(age.keys(), key=functools.cmp_to_key(lambda a,b:_spaceship(age.get(b),age.get(a))))
expression returns 19
  38 | 0 |   |eldest = sorted(age.keys(), key=functools.cmp_to_key(lambda a,b:_spaceship(age.get(b), age.get(a)))) #PL: assert(join('', @eldest) eq 'caebd');

Tokens: a=f(f(s(s),s(s)))fh ValPy: 
Main loop, line=assert(join('', @eldest) eq 'caebd');


 === Line 38 Perl source:assert(join('', @eldest) eq 'caebd');===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='join' value='.join(' Tokenstr |c(f| translated: assert ( .join(
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( .join( (
Lexem 4 Current token='"' perl='' value='''' Tokenstr |c(f("| translated: assert ( .join( ( ''
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |c(f(",| translated: assert ( .join( ( '' ,
Lexem 6 Current token='a' perl='@eldest' value='eldest' Tokenstr |c(f(",a| translated: assert ( .join( ( '' , eldest
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |c(f(",a)| translated: assert ( .join( ( '' , eldest )
Lexem 8 Current token='>' perl='eq' value='==' Tokenstr |c(f(",a)>| translated: assert ( .join( ( '' , eldest ) ==
Lexem 9 Current token='"' perl='caebd' value=''caebd'' Tokenstr |c(f(",a)>"| translated: assert ( .join( ( '' , eldest ) == 'caebd'
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |c(f(",a)>")| translated: assert ( .join( ( '' , eldest ) == 'caebd' )

Line:   38 TokenStr: =|c(f(",a)>")|= @ValPy: assert ( .join( ( '' , eldest ) == 'caebd' )
control(0) =|c(f(",a)>")|= assert ( join (  , @eldest ) eq caebd )

control-parens removed, begin=0 start=1 =|cf(",a)>"|= assert join (  , @eldest ) eq caebd

Generated partial line assert
expression(1, 8, 0) =|cf(",a)>"|= assert join (  , @eldest ) eq caebd

function(1, 8) =|cf(",a)>"|= assert join (  , @eldest ) eq caebd

function start=3, end_pos=5, bracketed=1
Generated partial line assert''
Generated partial line assert''.join(
Generated partial line assert''.join(eldest
Generated partial line assert''.join(eldest)
Generated partial line assert''.join(eldest)==
Generated partial line assert''.join(eldest)=='caebd'
expression returns 9
  39 | 0 |   |
  40 | 0 |   |assert ''.join(eldest) == 'caebd'                                                       #PL: my @class = ('a', 'c', 'b');

Tokens: cf(",a)>" ValPy: 
Main loop, line=my @class = ('a', 'c', 'b');


 === Line 40 Perl source:my @class = ('a', 'c', 'b');===

Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@class' value='class_' Tokenstr |ta| translated:  class_
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  class_ =
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |ta=(| translated:  class_ = (
Lexem 4 Current token='"' perl='a' value=''a'' Tokenstr |ta=("| translated:  class_ = ( 'a'
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |ta=(",| translated:  class_ = ( 'a' ,
Lexem 6 Current token='"' perl='c' value=''c'' Tokenstr |ta=(","| translated:  class_ = ( 'a' , 'c'
Lexem 7 Current token=',' perl=',' value=',' Tokenstr |ta=(",",| translated:  class_ = ( 'a' , 'c' ,
Lexem 8 Current token='"' perl='b' value=''b'' Tokenstr |ta=(",","| translated:  class_ = ( 'a' , 'c' , 'b'
Lexem 9 Current token=')' perl=')' value=')' Tokenstr |ta=(",",")| translated:  class_ = ( 'a' , 'c' , 'b' )

Line:   40 TokenStr: =|ta=(",",")|= @ValPy:  class_ = ( 'a' , 'c' , 'b' )
Generated partial line class_ = [
Generated partial line class_ = ['a'
Generated partial line class_ = ['a',
Generated partial line class_ = ['a','c'
Generated partial line class_ = ['a','c',
Generated partial line class_ = ['a','c','b'
Generated partial line class_ = ['a','c','b']
  41 | 0 |   |# sort using explicit subroutine name
  42 | 0 |   |class_ = ['a', 'c', 'b']                                                                #PL: sub byage {

Tokens: a=(",",") ValPy: 
Main loop, line=sub byage {


 === Line 42 Perl source:sub byage {===

Lexem 0 Current token='k' perl='sub' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' perl='byage' value='byage' Tokenstr |ki| translated: def byage

Line:   42 TokenStr: =|ki|= @ValPy: def byage
Generated partial line defbyage(_args):
  42 | 0 |   |def byage(_args):                                                                       #PL: sub byage {

Tokens: ki ValPy: 
  42 | 1 |   |    global age                                                                          #PL: sub byage {
Main loop, line={


 === Line 42 Perl source:{===


Line:   42 TokenStr: =|{|= @ValPy: {
Main loop, line=$age{$a} <=> $age{$b};  # presuming numeric


 === Line 43 Perl source:$age{$a} <=> $age{$b};  # presuming numeric===

Lexem 0 Current token='s' perl='$age' value='age' Tokenstr |s| translated: age
Lexem 1 Current token='(' perl='{' value='[' Tokenstr |s(| translated: age [
Lexem 2 Current token='s' perl='$a' value='a' Tokenstr |s(s| translated: age [ a
Lexem 3 Current token=')' perl='}' value=']' Tokenstr |s(s)| translated: age [ a ]
Lexem 4 Current token='>' perl='<=>' value='_spaceship' Tokenstr |s(s)>| translated: age [ a ] _spaceship
Lexem 5 Current token='s' perl='$age' value='age' Tokenstr |s(s)>s| translated: age [ a ] _spaceship age
Lexem 6 Current token='(' perl='{' value='[' Tokenstr |s(s)>s(| translated: age [ a ] _spaceship age [
Lexem 7 Current token='s' perl='$b' value='b' Tokenstr |s(s)>s(s| translated: age [ a ] _spaceship age [ b
Lexem 8 Current token=')' perl='}' value=']' Tokenstr |s(s)>s(s)| translated: age [ a ] _spaceship age [ b ]

Line:   43 TokenStr: =|s(s)>s(s)|= @ValPy: age [ a ] _spaceship age [ b ]
handle_cmp_spaceship(0, 4, 8): a[0:3], b[5:8] = 3 (=|f(s(s),s(s)))|=)
function(0, 12) =|f(s(s),s(s)))|= <=> ( $age { $a } , $age { $b } ) )

function start=2, end_pos=10, bracketed=1
Generated partial line _spaceship
Generated partial line _spaceship(
expression(2, 10, 0) =|f(s(s),s(s)))|= <=> ( $age { $a } , $age { $b } ) )

Generated partial line _spaceship(age
Generated partial line _spaceship(age.get(
expression(4, 4, 0) =|f(s(s),s(s)))|= <=> ( $age { $a } , $age { $b } ) )

Generated partial line _spaceship(age.get(a
expression returns 5
Generated partial line _spaceship(age.get(a)
Generated partial line _spaceship(age.get(a),
Generated partial line _spaceship(age.get(a),age
Generated partial line _spaceship(age.get(a),age.get(
expression(9, 9, 0) =|f(s(s),s(s)))|= <=> ( $age { $a } , $age { $b } ) )

Generated partial line _spaceship(age.get(a),age.get(b
expression returns 10
Generated partial line _spaceship(age.get(a),age.get(b)
expression returns 11
Generated partial line _spaceship(age.get(a),age.get(b))
finish: prev_line=$age{$a} <=> $age{$b};  # presuming numeric, PythonCode=_spaceship ( age .get( a ) , age .get( b ) )
finish: Resetting line to }
  44 | 1 |   |    return _spaceship(age.get(a), age.get(b))     # presuming numeric
                                                                                                      #PL: 

Tokens: f(s(s),s(s))) ValPy: 
Main loop, line=}


 === Line 44 Perl source:}===


Line:   44 TokenStr: =|}|= @ValPy: }
initialize_globals_for_state_vars: 
  44 | 0 |   |
Main loop, line=my @sortedclass = sort byage @class;


 === Line 45 Perl source:my @sortedclass = sort byage @class;===

Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@sortedclass' value='sortedclass' Tokenstr |ta| translated:  sortedclass
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  sortedclass =
Lexem 3 Current token='f' perl='sort' value='sorted' Tokenstr |ta=f| translated:  sortedclass = sorted
Lexem 4 Current token='i' perl='byage' value='byage' Tokenstr |ta=fi| translated:  sortedclass = sorted byage
Lexem 5 Current token='a' perl='@class' value='class_' Tokenstr |ta=fia| translated:  sortedclass = sorted byage class_

Line:   45 TokenStr: =|ta=fia|= @ValPy:  sortedclass = sorted byage class_
assignment(0, 4) =|a=fia|= @sortedclass = sort byage @class

Generated partial line sortedclass
Generated partial line sortedclass=
expression(2, 4, 0) =|a=fia|= @sortedclass = sort byage @class

function(2, 4) =|a=fia|= @sortedclass = sort byage @class

function start=3, end_pos=4, bracketed=0
Generated partial line sortedclass=sorted
Generated partial line sortedclass=sorted(
expression(4, 4, 0) =|a=fia|= @sortedclass = sort byage @class

Generated partial line sortedclass=sorted(class_
expression returns 5
Generated partial line sortedclass=sorted(class_, key=functools.cmp_to_key(lambda a,b:
Generated partial line sortedclass=sorted(class_, key=functools.cmp_to_key(lambda a,b:_sortf(byage, a, b)
Generated partial line sortedclass=sorted(class_, key=functools.cmp_to_key(lambda a,b:_sortf(byage, a, b))
Generated partial line sortedclass=sorted(class_, key=functools.cmp_to_key(lambda a,b:_sortf(byage, a, b)))
expression returns 5
  46 | 0 |   |sortedclass = sorted(class_, key=functools.cmp_to_key(lambda a,b:_sortf(byage, a, b)))  #PL: assert(join('', @sortedclass) eq 'bac');

Tokens: a=fia ValPy: 
Main loop, line=assert(join('', @sortedclass) eq 'bac');


 === Line 46 Perl source:assert(join('', @sortedclass) eq 'bac');===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='join' value='.join(' Tokenstr |c(f| translated: assert ( .join(
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( .join( (
Lexem 4 Current token='"' perl='' value='''' Tokenstr |c(f("| translated: assert ( .join( ( ''
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |c(f(",| translated: assert ( .join( ( '' ,
Lexem 6 Current token='a' perl='@sortedclass' value='sortedclass' Tokenstr |c(f(",a| translated: assert ( .join( ( '' , sortedclass
Lexem 7 Current token=')' perl=')' value=')' Tokenstr |c(f(",a)| translated: assert ( .join( ( '' , sortedclass )
Lexem 8 Current token='>' perl='eq' value='==' Tokenstr |c(f(",a)>| translated: assert ( .join( ( '' , sortedclass ) ==
Lexem 9 Current token='"' perl='bac' value=''bac'' Tokenstr |c(f(",a)>"| translated: assert ( .join( ( '' , sortedclass ) == 'bac'
Lexem 10 Current token=')' perl=')' value=')' Tokenstr |c(f(",a)>")| translated: assert ( .join( ( '' , sortedclass ) == 'bac' )

Line:   46 TokenStr: =|c(f(",a)>")|= @ValPy: assert ( .join( ( '' , sortedclass ) == 'bac' )
control(0) =|c(f(",a)>")|= assert ( join (  , @sortedclass ) eq bac )

control-parens removed, begin=0 start=1 =|cf(",a)>"|= assert join (  , @sortedclass ) eq bac

Generated partial line assert
expression(1, 8, 0) =|cf(",a)>"|= assert join (  , @sortedclass ) eq bac

function(1, 8) =|cf(",a)>"|= assert join (  , @sortedclass ) eq bac

function start=3, end_pos=5, bracketed=1
Generated partial line assert''
Generated partial line assert''.join(
Generated partial line assert''.join(sortedclass
Generated partial line assert''.join(sortedclass)
Generated partial line assert''.join(sortedclass)==
Generated partial line assert''.join(sortedclass)=='bac'
expression returns 9
  47 | 0 |   |
  48 | 0 |   |assert ''.join(sortedclass) == 'bac'                                                    #PL: sub backwards { $b cmp $a }

Tokens: cf(",a)>" ValPy: 
Main loop, line=sub backwards { $b cmp $a }


 === Line 48 Perl source:sub backwards { $b cmp $a }===

Lexem 0 Current token='k' perl='sub' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' perl='backwards' value='backwards' Tokenstr |ki| translated: def backwards

Line:   48 TokenStr: =|ki|= @ValPy: def backwards
Generated partial line defbackwards(_args):
  48 | 0 |   |def backwards(_args):                                                                   #PL: 

Tokens: ki ValPy: 
Main loop, line={


 === Line 48 Perl source:{===


Line:   48 TokenStr: =|{|= @ValPy: {
Main loop, line=$b cmp $a }


 === Line 48 Perl source:$b cmp $a }===

Lexem 0 Current token='s' perl='$b' value='b' Tokenstr |s| translated: b
Lexem 1 Current token='>' perl='cmp' value='_cmp' Tokenstr |s>| translated: b _cmp
Lexem 2 Current token='s' perl='$a' value='a' Tokenstr |s>s| translated: b _cmp a

Line:   48 TokenStr: =|s>s|= @ValPy: b _cmp a
handle_cmp_spaceship(0, 1, 2): a[0:0], b[2:2] = 3 (=|f(s,s))|=)
function(0, 6) =|f(s,s))|= cmp ( $b , $a ) )

function start=2, end_pos=4, bracketed=1
Generated partial line _cmp
Generated partial line _cmp(
expression(2, 4, 0) =|f(s,s))|= cmp ( $b , $a ) )

Generated partial line _cmp(b
Generated partial line _cmp(b,
Generated partial line _cmp(b,a
expression returns 5
Generated partial line _cmp(b,a)
finish: prev_line=$b cmp $a }, PythonCode=_cmp ( b , a )
finish: Resetting line to }
  48 | 1 |   |    return _cmp(b, a)                                                                   #PL: 

Tokens: f(s,s)) ValPy: 
Main loop, line=}


 === Line 48 Perl source:}===


Line:   48 TokenStr: =|}|= @ValPy: }
initialize_globals_for_state_vars: 
  48 | 0 |   |
Main loop, line=my @harry  = qw(dog cat x Cain Abel);


 === Line 49 Perl source:my @harry  = qw(dog cat x Cain Abel);===

Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@harry' value='harry' Tokenstr |ta| translated:  harry
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  harry =
Lexem 3 Current token='q' perl='dog cat x Cain Abel' value='"dog cat x Cain Abel".split()' Tokenstr |ta=q| translated:  harry = "dog cat x Cain Abel".split()

Line:   49 TokenStr: =|ta=q|= @ValPy:  harry = "dog cat x Cain Abel".split()
assignment(0, 2) =|a=q|= @harry = dog cat x Cain Abel

Generated partial line harry
Generated partial line harry=
assign, ValClass[limit] = q, ValPy="dog cat x Cain Abel".split(), ValPerl=dog cat x Cain Abel

Generated partial line harry="dog cat x Cain Abel".split()
  50 | 0 |   |harry = "dog cat x Cain Abel".split()                                                   #PL: my @george = qw(gone chased yz Punished Axed);

Tokens: a=q ValPy: 
Main loop, line=my @george = qw(gone chased yz Punished Axed);


 === Line 50 Perl source:my @george = qw(gone chased yz Punished Axed);===

Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@george' value='george' Tokenstr |ta| translated:  george
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  george =
Lexem 3 Current token='q' perl='gone chased yz Punished Axed' value='"gone chased yz Punished Axed".split()' Tokenstr |ta=q| translated:  george = "gone chased yz Punished Axed".split()

Line:   50 TokenStr: =|ta=q|= @ValPy:  george = "gone chased yz Punished Axed".split()
assignment(0, 2) =|a=q|= @george = gone chased yz Punished Axed

Generated partial line george
Generated partial line george=
assign, ValClass[limit] = q, ValPy="gone chased yz Punished Axed".split(), ValPerl=gone chased yz Punished Axed

Generated partial line george="gone chased yz Punished Axed".split()
  51 | 0 |   |
  52 | 0 |   |george = "gone chased yz Punished Axed".split()                                         #PL: assert(join('', sort @harry) eq 'AbelCaincatdogx');

Tokens: a=q ValPy: 
Main loop, line=assert(join('', sort @harry) eq 'AbelCaincatdogx');


 === Line 52 Perl source:assert(join('', sort @harry) eq 'AbelCaincatdogx');===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='join' value='.join(' Tokenstr |c(f| translated: assert ( .join(
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( .join( (
Lexem 4 Current token='"' perl='' value='''' Tokenstr |c(f("| translated: assert ( .join( ( ''
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |c(f(",| translated: assert ( .join( ( '' ,
Lexem 6 Current token='f' perl='sort' value='sorted' Tokenstr |c(f(",f| translated: assert ( .join( ( '' , sorted
Lexem 7 Current token='a' perl='@harry' value='harry' Tokenstr |c(f(",fa| translated: assert ( .join( ( '' , sorted harry
Lexem 8 Current token=')' perl=')' value=')' Tokenstr |c(f(",fa)| translated: assert ( .join( ( '' , sorted harry )
Lexem 9 Current token='>' perl='eq' value='==' Tokenstr |c(f(",fa)>| translated: assert ( .join( ( '' , sorted harry ) ==
Lexem 10 Current token='"' perl='AbelCaincatdogx' value=''AbelCaincatdogx'' Tokenstr |c(f(",fa)>"| translated: assert ( .join( ( '' , sorted harry ) == 'AbelCaincatdogx'
Lexem 11 Current token=')' perl=')' value=')' Tokenstr |c(f(",fa)>")| translated: assert ( .join( ( '' , sorted harry ) == 'AbelCaincatdogx' )

Line:   52 TokenStr: =|c(f(",fa)>")|= @ValPy: assert ( .join( ( '' , sorted harry ) == 'AbelCaincatdogx' )
control(0) =|c(f(",fa)>")|= assert ( join (  , sort @harry ) eq AbelCaincatdogx )

control-parens removed, begin=0 start=1 =|cf(",fa)>"|= assert join (  , sort @harry ) eq AbelCaincatdogx

Generated partial line assert
expression(1, 9, 0) =|cf(",fa)>"|= assert join (  , sort @harry ) eq AbelCaincatdogx

function(1, 9) =|cf(",fa)>"|= assert join (  , sort @harry ) eq AbelCaincatdogx

function start=3, end_pos=6, bracketed=1
Generated partial line assert''
Generated partial line assert''.join(
Generated partial line assert''.join((
expression(5, 6, 0) =|cf(",fa)>"|= assert join (  , sort @harry ) eq AbelCaincatdogx

function(5, 6) =|cf(",fa)>"|= assert join (  , sort @harry ) eq AbelCaincatdogx

function start=6, end_pos=6, bracketed=0
Generated partial line assert''.join((sorted
Generated partial line assert''.join((sorted(
expression(6, 6, 0) =|cf(",fa)>"|= assert join (  , sort @harry ) eq AbelCaincatdogx

Generated partial line assert''.join((sorted(harry
expression returns 7
Generated partial line assert''.join((sorted(harry)
expression returns 7
Generated partial line assert''.join((sorted(harry))
Generated partial line assert''.join((sorted(harry)))
Generated partial line assert''.join((sorted(harry)))==
Generated partial line assert''.join((sorted(harry)))=='AbelCaincatdogx'
expression returns 10
  53 | 0 |   |
  54 | 0 |   |assert ''.join((sorted(harry))) == 'AbelCaincatdogx'                                    #PL: assert(join('', sort backwards @harry) eq 'xdogcatCainAbel');

Tokens: cf(",fa)>" ValPy: 
Main loop, line=assert(join('', sort backwards @harry) eq 'xdogcatCainAbel');


 === Line 54 Perl source:assert(join('', sort backwards @harry) eq 'xdogcatCainAbel');===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='join' value='.join(' Tokenstr |c(f| translated: assert ( .join(
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( .join( (
Lexem 4 Current token='"' perl='' value='''' Tokenstr |c(f("| translated: assert ( .join( ( ''
Lexem 5 Current token=',' perl=',' value=',' Tokenstr |c(f(",| translated: assert ( .join( ( '' ,
Lexem 6 Current token='f' perl='sort' value='sorted' Tokenstr |c(f(",f| translated: assert ( .join( ( '' , sorted
Lexem 7 Current token='i' perl='backwards' value='backwards' Tokenstr |c(f(",fi| translated: assert ( .join( ( '' , sorted backwards
Lexem 8 Current token='a' perl='@harry' value='harry' Tokenstr |c(f(",fia| translated: assert ( .join( ( '' , sorted backwards harry
Lexem 9 Current token=')' perl=')' value=')' Tokenstr |c(f(",fia)| translated: assert ( .join( ( '' , sorted backwards harry )
Lexem 10 Current token='>' perl='eq' value='==' Tokenstr |c(f(",fia)>| translated: assert ( .join( ( '' , sorted backwards harry ) ==
Lexem 11 Current token='"' perl='xdogcatCainAbel' value=''xdogcatCainAbel'' Tokenstr |c(f(",fia)>"| translated: assert ( .join( ( '' , sorted backwards harry ) == 'xdogcatCainAbel'
Lexem 12 Current token=')' perl=')' value=')' Tokenstr |c(f(",fia)>")| translated: assert ( .join( ( '' , sorted backwards harry ) == 'xdogcatCainAbel' )

Line:   54 TokenStr: =|c(f(",fia)>")|= @ValPy: assert ( .join( ( '' , sorted backwards harry ) == 'xdogcatCainAbel' )
control(0) =|c(f(",fia)>")|= assert ( join (  , sort backwards @harry ) eq xdogcatCainAbel )

control-parens removed, begin=0 start=1 =|cf(",fia)>"|= assert join (  , sort backwards @harry ) eq xdogcatCainAbel

Generated partial line assert
expression(1, 10, 0) =|cf(",fia)>"|= assert join (  , sort backwards @harry ) eq xdogcatCainAbel

function(1, 10) =|cf(",fia)>"|= assert join (  , sort backwards @harry ) eq xdogcatCainAbel

function start=3, end_pos=7, bracketed=1
Generated partial line assert''
Generated partial line assert''.join(
Generated partial line assert''.join((
expression(5, 7, 0) =|cf(",fia)>"|= assert join (  , sort backwards @harry ) eq xdogcatCainAbel

function(5, 7) =|cf(",fia)>"|= assert join (  , sort backwards @harry ) eq xdogcatCainAbel

function start=6, end_pos=7, bracketed=0
Generated partial line assert''.join((sorted
Generated partial line assert''.join((sorted(
expression(7, 7, 0) =|cf(",fia)>"|= assert join (  , sort backwards @harry ) eq xdogcatCainAbel

Generated partial line assert''.join((sorted(harry
expression returns 8
Generated partial line assert''.join((sorted(harry, key=functools.cmp_to_key(lambda a,b:
Generated partial line assert''.join((sorted(harry, key=functools.cmp_to_key(lambda a,b:_sortf(backwards, a, b)
Generated partial line assert''.join((sorted(harry, key=functools.cmp_to_key(lambda a,b:_sortf(backwards, a, b))
Generated partial line assert''.join((sorted(harry, key=functools.cmp_to_key(lambda a,b:_sortf(backwards, a, b)))
expression returns 8
Generated partial line assert''.join((sorted(harry, key=functools.cmp_to_key(lambda a,b:_sortf(backwards, a, b))))
Generated partial line assert''.join((sorted(harry, key=functools.cmp_to_key(lambda a,b:_sortf(backwards, a, b)))))
Generated partial line assert''.join((sorted(harry, key=functools.cmp_to_key(lambda a,b:_sortf(backwards, a, b)))))==
Generated partial line assert''.join((sorted(harry, key=functools.cmp_to_key(lambda a,b:_sortf(backwards, a, b)))))=='xdogcatCainAbel'
expression returns 11
  55 | 0 |   |
  56 | 0 |   |#We'll fix this some other day
  57 | 0 |   |#@sorted = sort @george, 'to', @harry;
  58 | 0 |   |#assert(join('', @sorted) eq 'AbelAxedCainPunishedcatchaseddoggonetoxyz');
  59 | 0 |   |#
  60 | 0 |   |
  61 | 0 |   |assert ''.join((sorted(harry, key=functools.cmp_to_key(lambda a,b:_sortf(backwards, a, b))))) == 'xdogcatCainAbel' #PL: %routespans = ();

Tokens: cf(",fia)>" ValPy: 
Main loop, line=%routespans = ();


 === Line 61 Perl source:%routespans = ();===

Lexem 0 Current token='h' perl='routespans' value='routespans' Tokenstr |h| translated: routespans
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |h=| translated: routespans =
Lexem 2 Current token='(' perl='(' value='(' Tokenstr |h=(| translated: routespans = (
Lexem 3 Current token=')' perl=')' value=')' Tokenstr |h=()| translated: routespans = ( )

Line:   61 TokenStr: =|h=()|= @ValPy: routespans = ( )
Generated partial line routespans = {
Generated partial line routespans = {}
  62 | 0 |   |routespans = {}                                                                         #PL: $routespans{rin} = {1=>'av', 3=>'cv', 2=>'bv'};

Tokens: h=() ValPy: 
Main loop, line=$routespans{rin} = {1=>'av', 3=>'cv', 2=>'bv'};


 === Line 62 Perl source:$routespans{rin} = {1=>'av', 3=>'cv', 2=>'bv'};===

Lexem 0 Current token='s' perl='$routespans' value='routespans' Tokenstr |s| translated: routespans
Lexem 1 Current token='(' perl='{' value='[' Tokenstr |s(| translated: routespans [
Lexem 2 Current token='i' perl='rin' value='rin' Tokenstr |s(i| translated: routespans [ rin
Lexem 3 Current token=')' perl='}' value=']' Tokenstr |s(")| translated: routespans [ 'rin' ]
Lexem 4 Current token='=' perl='=' value='=' Tokenstr |s(")=| translated: routespans [ 'rin' ] =
Lexem 5 Current token='(' perl='{' value='[' Tokenstr |s(")=(| translated: routespans [ 'rin' ] = [
Lexem 6 Current token='d' perl='1' value='1' Tokenstr |s(")=(d| translated: routespans [ 'rin' ] = [ 1
Lexem 7 Current token=':' perl='=>' value=': ' Tokenstr |s(")=(d:| translated: routespans [ 'rin' ] = [ 1 : 
Lexem 8 Current token='"' perl='av' value=''av'' Tokenstr |s(")=(d:"| translated: routespans [ 'rin' ] = [ 1 :  'av'
Lexem 9 Current token=',' perl=',' value=',' Tokenstr |s(")=(d:",| translated: routespans [ 'rin' ] = [ 1 :  'av' ,
Lexem 10 Current token='d' perl='3' value='3' Tokenstr |s(")=(d:",d| translated: routespans [ 'rin' ] = [ 1 :  'av' , 3
Lexem 11 Current token=':' perl='=>' value=': ' Tokenstr |s(")=(d:",d:| translated: routespans [ 'rin' ] = [ 1 :  'av' , 3 : 
Lexem 12 Current token='"' perl='cv' value=''cv'' Tokenstr |s(")=(d:",d:"| translated: routespans [ 'rin' ] = [ 1 :  'av' , 3 :  'cv'
Lexem 13 Current token=',' perl=',' value=',' Tokenstr |s(")=(d:",d:",| translated: routespans [ 'rin' ] = [ 1 :  'av' , 3 :  'cv' ,
Lexem 14 Current token='d' perl='2' value='2' Tokenstr |s(")=(d:",d:",d| translated: routespans [ 'rin' ] = [ 1 :  'av' , 3 :  'cv' , 2
Lexem 15 Current token=':' perl='=>' value=': ' Tokenstr |s(")=(d:",d:",d:| translated: routespans [ 'rin' ] = [ 1 :  'av' , 3 :  'cv' , 2 : 
Lexem 16 Current token='"' perl='bv' value=''bv'' Tokenstr |s(")=(d:",d:",d:"| translated: routespans [ 'rin' ] = [ 1 :  'av' , 3 :  'cv' , 2 :  'bv'
Lexem 17 Current token=')' perl='}' value=']' Tokenstr |s(")=(d:",d:",d:")| translated: routespans [ 'rin' ] = [ 1 :  'av' , 3 :  'cv' , 2 :  'bv' ]

Line:   62 TokenStr: =|s(")=(d:",d:",d:")|= @ValPy: routespans [ 'rin' ] = [ 1 :  'av' , 3 :  'cv' , 2 :  'bv' ]
assignment(0, 17) =|s(")=(d:",d:",d:")|= $routespans { rin } = { 1 => av , 3 => cv , 2 => bv }

expression(0, 3, 0) =|s(")=(d:",d:",d:")|= $routespans { rin } = { 1 => av , 3 => cv , 2 => bv }

Generated partial line routespans
Generated partial line routespans[
expression(2, 2, 0) =|s(")=(d:",d:",d:")|= $routespans { rin } = { 1 => av , 3 => cv , 2 => bv }

Generated partial line routespans['rin'
expression returns 3
Generated partial line routespans['rin']
expression returns 4
Generated partial line routespans['rin']=
expression(5, 17, 0) =|s(")=(d:",d:",d:")|= $routespans { rin } = { 1 => av , 3 => cv , 2 => bv }

Generated partial line routespans['rin']={
expression(6, 16, 0) =|s(")=(d:",d:",d:")|= $routespans { rin } = { 1 => av , 3 => cv , 2 => bv }

Generated partial line routespans['rin']={1
Generated partial line routespans['rin']={1: 
Generated partial line routespans['rin']={1: 'av'
Generated partial line routespans['rin']={1: 'av',
Generated partial line routespans['rin']={1: 'av',3
Generated partial line routespans['rin']={1: 'av',3: 
Generated partial line routespans['rin']={1: 'av',3: 'cv'
Generated partial line routespans['rin']={1: 'av',3: 'cv',
Generated partial line routespans['rin']={1: 'av',3: 'cv',2
Generated partial line routespans['rin']={1: 'av',3: 'cv',2: 
Generated partial line routespans['rin']={1: 'av',3: 'cv',2: 'bv'
expression returns 17
Generated partial line routespans['rin']={1: 'av',3: 'cv',2: 'bv'}
expression returns 18
  63 | 0 |   |routespans['rin'] = {1: 'av', 3: 'cv', 2: 'bv'}                                         #PL: $rin = 'rin';

Tokens: s(")=(d:",d:",d:") ValPy: 
Main loop, line=$rin = 'rin';


 === Line 63 Perl source:$rin = 'rin';===

Lexem 0 Current token='s' perl='$rin' value='rin' Tokenstr |s| translated: rin
Lexem 1 Current token='=' perl='=' value='=' Tokenstr |s=| translated: rin =
Lexem 2 Current token='"' perl='rin' value=''rin'' Tokenstr |s="| translated: rin = 'rin'

Line:   63 TokenStr: =|s="|= @ValPy: rin = 'rin'
assignment(0, 2) =|s="|= $rin = rin

Generated partial line rin
Generated partial line rin=
assign, ValClass[limit] = ", ValPy='rin', ValPerl=rin

Generated partial line rin='rin'
  64 | 0 |   |rin = 'rin'                                                                             #PL: sub bynum

Tokens: s=" ValPy: 
Main loop, line=sub bynum


 === Line 64 Perl source:sub bynum===

Lexem 0 Current token='k' perl='sub' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' perl='bynum' value='bynum' Tokenstr |ki| translated: def bynum

Line:   65 TokenStr: =|ki|= @ValPy: def bynum
Generated partial line defbynum(_args):
  65 | 0 |   |def bynum(_args):                                                                       #PL: 

Tokens: ki ValPy: 
Main loop, line={


 === Line 65 Perl source:{===


Line:   65 TokenStr: =|{|= @ValPy: {
Main loop, line=$a <=> $b;


 === Line 66 Perl source:$a <=> $b;===

Lexem 0 Current token='s' perl='$a' value='a' Tokenstr |s| translated: a
Lexem 1 Current token='>' perl='<=>' value='_spaceship' Tokenstr |s>| translated: a _spaceship
Lexem 2 Current token='s' perl='$b' value='b' Tokenstr |s>s| translated: a _spaceship b

Line:   66 TokenStr: =|s>s|= @ValPy: a _spaceship b
handle_cmp_spaceship(0, 1, 2): a[0:0], b[2:2] = 3 (=|f(s,s))|=)
function(0, 6) =|f(s,s))|= <=> ( $a , $b ) )

function start=2, end_pos=4, bracketed=1
Generated partial line _spaceship
Generated partial line _spaceship(
expression(2, 4, 0) =|f(s,s))|= <=> ( $a , $b ) )

Generated partial line _spaceship(a
Generated partial line _spaceship(a,
Generated partial line _spaceship(a,b
expression returns 5
Generated partial line _spaceship(a,b)
finish: prev_line=$a <=> $b;, PythonCode=_spaceship ( a , b )
finish: Resetting line to }
  67 | 1 |   |    return _spaceship(a, b)                                                             #PL: 

Tokens: f(s,s)) ValPy: 
Main loop, line=}


 === Line 67 Perl source:}===


Line:   67 TokenStr: =|}|= @ValPy: }
initialize_globals_for_state_vars: 
  67 | 0 |   |
Main loop, line=my @sequence = sort bynum keys %{$routespans{$rin}};


 === Line 68 Perl source:my @sequence = sort bynum keys %{$routespans{$rin}};===

Lexem 0 Current token='t' perl='my' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' perl='@sequence' value='sequence' Tokenstr |ta| translated:  sequence
Lexem 2 Current token='=' perl='=' value='=' Tokenstr |ta=| translated:  sequence =
Lexem 3 Current token='f' perl='sort' value='sorted' Tokenstr |ta=f| translated:  sequence = sorted
Lexem 4 Current token='i' perl='bynum' value='bynum' Tokenstr |ta=fi| translated:  sequence = sorted bynum
Lexem 5 Current token='f' perl='keys' value='.keys()' Tokenstr |ta=fif| translated:  sequence = sorted bynum .keys()
Lexem 6 Current token='%' perl='%' value='%' Tokenstr |ta=fif%| translated:  sequence = sorted bynum .keys() %
Lexem 7 Current token='(' perl='{' value='[' Tokenstr |ta=fif%(| translated:  sequence = sorted bynum .keys() % [
Lexem 8 Current token='s' perl='$routespans' value='routespans' Tokenstr |ta=fif%(s| translated:  sequence = sorted bynum .keys() % [ routespans
Lexem 9 Current token='(' perl='{' value='[' Tokenstr |ta=fif%(s(| translated:  sequence = sorted bynum .keys() % [ routespans [
Lexem 10 Current token='s' perl='$rin' value='rin' Tokenstr |ta=fif%(s(s| translated:  sequence = sorted bynum .keys() % [ routespans [ rin
Lexem 11 Current token=')' perl='}' value=']' Tokenstr |ta=fif%(s(s)| translated:  sequence = sorted bynum .keys() % [ routespans [ rin ]
Lexem 12 Current token=')' perl='}' value=']' Tokenstr |ta=fif%(s(s))| translated:  sequence = sorted bynum .keys() % [ routespans [ rin ] ]

Line:   68 TokenStr: =|ta=fif%(s(s))|= @ValPy:  sequence = sorted bynum .keys() % [ routespans [ rin ] ]
assignment(0, 8) =|a=fifs(s)|= @sequence = sort bynum keys $routespans { $rin }

Generated partial line sequence
Generated partial line sequence=
expression(2, 8, 0) =|a=fifs(s)|= @sequence = sort bynum keys $routespans { $rin }

function(2, 8) =|a=fifs(s)|= @sequence = sort bynum keys $routespans { $rin }

function start=3, end_pos=8, bracketed=0
Generated partial line sequence=sorted
Generated partial line sequence=sorted(
expression(4, 8, 0) =|a=fifs(s)|= @sequence = sort bynum keys $routespans { $rin }

function(4, 8) =|a=fifs(s)|= @sequence = sort bynum keys $routespans { $rin }

function start=5, end_pos=8, bracketed=0
expression(5, 8, 0) =|a=fifs(s)|= @sequence = sort bynum keys $routespans { $rin }

Generated partial line sequence=sorted(routespans
Generated partial line sequence=sorted(routespans.get(
expression(7, 7, 0) =|a=fifs(s)|= @sequence = sort bynum keys $routespans { $rin }

Generated partial line sequence=sorted(routespans.get(rin
expression returns 8
Generated partial line sequence=sorted(routespans.get(rin)
expression returns 9
Generated partial line sequence=sorted(routespans.get(rin).keys()
expression returns 9
Generated partial line sequence=sorted(routespans.get(rin).keys(), key=functools.cmp_to_key(lambda a,b:
Generated partial line sequence=sorted(routespans.get(rin).keys(), key=functools.cmp_to_key(lambda a,b:_sortf(bynum, a, b)
Generated partial line sequence=sorted(routespans.get(rin).keys(), key=functools.cmp_to_key(lambda a,b:_sortf(bynum, a, b))
Generated partial line sequence=sorted(routespans.get(rin).keys(), key=functools.cmp_to_key(lambda a,b:_sortf(bynum, a, b)))
expression returns 9
  69 | 0 |   |sequence = sorted(routespans.get(rin).keys(), key=functools.cmp_to_key(lambda a,b:_sortf(bynum, a, b)))
                                                                                                      #PL: assert(scalar(@sequence)==3 && $sequence[0] == 1 && $sequence[1] == 2 && $sequence[2] =
                                                                                                      #+ : = 3);

Tokens: a=fifs(s) ValPy: 
Main loop, line=assert(scalar(@sequence)==3 && $sequence[0] == 1 && $sequence[1] == 2 && $sequence[2] == 3);


 === Line 69 Perl source:assert(scalar(@sequence)==3 && $sequence[0] == 1 && $sequence[1] == 2 && $sequence[2] == 3);===

Lexem 0 Current token='c' perl='assert' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' perl='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' perl='scalar' value='len' Tokenstr |c(f| translated: assert ( len
Lexem 3 Current token='(' perl='(' value='(' Tokenstr |c(f(| translated: assert ( len (
Lexem 4 Current token='a' perl='@sequence' value='sequence' Tokenstr |c(f(a| translated: assert ( len ( sequence
Lexem 5 Current token=')' perl=')' value=')' Tokenstr |c(f(a)| translated: assert ( len ( sequence )
Lexem 6 Current token='>' perl='==' value='==' Tokenstr |c(f(a)>| translated: assert ( len ( sequence ) ==
Lexem 7 Current token='d' perl='3' value='3' Tokenstr |c(f(a)>d| translated: assert ( len ( sequence ) == 3
Lexem 8 Current token='0' perl='&&' value=' and ' Tokenstr |c(f(a)>d0| translated: assert ( len ( sequence ) == 3  and 
Lexem 9 Current token='s' perl='$sequence' value='sequence' Tokenstr |c(f(a)>d0s| translated: assert ( len ( sequence ) == 3  and  sequence
Lexem 10 Current token='(' perl='[' value='[' Tokenstr |c(f(a)>d0s(| translated: assert ( len ( sequence ) == 3  and  sequence [
Lexem 11 Current token='d' perl='0' value='0' Tokenstr |c(f(a)>d0s(d| translated: assert ( len ( sequence ) == 3  and  sequence [ 0
Lexem 12 Current token=')' perl=']' value=']' Tokenstr |c(f(a)>d0s(d)| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ]
Lexem 13 Current token='>' perl='==' value='==' Tokenstr |c(f(a)>d0s(d)>| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] ==
Lexem 14 Current token='d' perl='1' value='1' Tokenstr |c(f(a)>d0s(d)>d| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1
Lexem 15 Current token='0' perl='&&' value=' and ' Tokenstr |c(f(a)>d0s(d)>d0| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1  and 
Lexem 16 Current token='s' perl='$sequence' value='sequence' Tokenstr |c(f(a)>d0s(d)>d0s| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1  and  sequence
Lexem 17 Current token='(' perl='[' value='[' Tokenstr |c(f(a)>d0s(d)>d0s(| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1  and  sequence [
Lexem 18 Current token='d' perl='1' value='1' Tokenstr |c(f(a)>d0s(d)>d0s(d| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1  and  sequence [ 1
Lexem 19 Current token=')' perl=']' value=']' Tokenstr |c(f(a)>d0s(d)>d0s(d)| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1  and  sequence [ 1 ]
Lexem 20 Current token='>' perl='==' value='==' Tokenstr |c(f(a)>d0s(d)>d0s(d)>| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1  and  sequence [ 1 ] ==
Lexem 21 Current token='d' perl='2' value='2' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1  and  sequence [ 1 ] == 2
Lexem 22 Current token='0' perl='&&' value=' and ' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1  and  sequence [ 1 ] == 2  and 
Lexem 23 Current token='s' perl='$sequence' value='sequence' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0s| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1  and  sequence [ 1 ] == 2  and  sequence
Lexem 24 Current token='(' perl='[' value='[' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0s(| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1  and  sequence [ 1 ] == 2  and  sequence [
Lexem 25 Current token='d' perl='2' value='2' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0s(d| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1  and  sequence [ 1 ] == 2  and  sequence [ 2
Lexem 26 Current token=')' perl=']' value=']' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0s(d)| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1  and  sequence [ 1 ] == 2  and  sequence [ 2 ]
Lexem 27 Current token='>' perl='==' value='==' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0s(d)>| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1  and  sequence [ 1 ] == 2  and  sequence [ 2 ] ==
Lexem 28 Current token='d' perl='3' value='3' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0s(d)>d| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1  and  sequence [ 1 ] == 2  and  sequence [ 2 ] == 3
Lexem 29 Current token=')' perl=')' value=')' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0s(d)>d)| translated: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1  and  sequence [ 1 ] == 2  and  sequence [ 2 ] == 3 )

Line:   69 TokenStr: =|c(f(a)>d0s(d)>d0s(d)>d0s(d)>d)|= @ValPy: assert ( len ( sequence ) == 3  and  sequence [ 0 ] == 1  and  sequence [ 1 ] == 2  and  sequence [ 2 ] == 3 )
control(0) =|c(f(a)>d0s(d)>d0s(d)>d0s(d)>d)|= assert ( scalar ( @sequence ) == 3 && $sequence [ 0 ] == 1 && $sequence [ 1 ] == 2 && $sequence [ 2 ] == 3 )

control-parens removed, begin=0 start=1 =|cf(a)>d0s(d)>d0s(d)>d0s(d)>d|= assert scalar ( @sequence ) == 3 && $sequence [ 0 ] == 1 && $sequence [ 1 ] == 2 && $sequence [ 2 ] == 3

Generated partial line assert
expression(1, 27, 0) =|cf(a)>d0s(d)>d0s(d)>d0s(d)>d|= assert scalar ( @sequence ) == 3 && $sequence [ 0 ] == 1 && $sequence [ 1 ] == 2 && $sequence [ 2 ] == 3

function(1, 7) =|cf(a)>d0s(d)>d0s(d)>d0s(d)>d|= assert scalar ( @sequence ) == 3 && $sequence [ 0 ] == 1 && $sequence [ 1 ] == 2 && $sequence [ 2 ] == 3

function start=3, end_pos=3, bracketed=1
Generated partial line assertlen
Generated partial line assertlen(
expression(3, 3, 0) =|cf(a)>d0s(d)>d0s(d)>d0s(d)>d|= assert scalar ( @sequence ) == 3 && $sequence [ 0 ] == 1 && $sequence [ 1 ] == 2 && $sequence [ 2 ] == 3

Generated partial line assertlen(sequence
expression returns 4
Generated partial line assertlen(sequence)
Generated partial line assertlen(sequence)==
Generated partial line assertlen(sequence)==3
Generated partial line assertlen(sequence)==3 and 
Generated partial line assertlen(sequence)==3 and sequence
Generated partial line assertlen(sequence)==3 and sequence[
expression(10, 10, 0) =|cf(a)>d0s(d)>d0s(d)>d0s(d)>d|= assert scalar ( @sequence ) == 3 && $sequence [ 0 ] == 1 && $sequence [ 1 ] == 2 && $sequence [ 2 ] == 3

Generated partial line assertlen(sequence)==3 and sequence[0
expression returns 11
Generated partial line assertlen(sequence)==3 and sequence[0]
Generated partial line assertlen(sequence)==3 and sequence[0]==
Generated partial line assertlen(sequence)==3 and sequence[0]==1
Generated partial line assertlen(sequence)==3 and sequence[0]==1 and 
Generated partial line assertlen(sequence)==3 and sequence[0]==1 and sequence
Generated partial line assertlen(sequence)==3 and sequence[0]==1 and sequence[
expression(17, 17, 0) =|cf(a)>d0s(d)>d0s(d)>d0s(d)>d|= assert scalar ( @sequence ) == 3 && $sequence [ 0 ] == 1 && $sequence [ 1 ] == 2 && $sequence [ 2 ] == 3

Generated partial line assertlen(sequence)==3 and sequence[0]==1 and sequence[1
expression returns 18
Generated partial line assertlen(sequence)==3 and sequence[0]==1 and sequence[1]
Generated partial line assertlen(sequence)==3 and sequence[0]==1 and sequence[1]==
Generated partial line assertlen(sequence)==3 and sequence[0]==1 and sequence[1]==2
Generated partial line assertlen(sequence)==3 and sequence[0]==1 and sequence[1]==2 and 
Generated partial line assertlen(sequence)==3 and sequence[0]==1 and sequence[1]==2 and sequence
Generated partial line assertlen(sequence)==3 and sequence[0]==1 and sequence[1]==2 and sequence[
expression(24, 24, 0) =|cf(a)>d0s(d)>d0s(d)>d0s(d)>d|= assert scalar ( @sequence ) == 3 && $sequence [ 0 ] == 1 && $sequence [ 1 ] == 2 && $sequence [ 2 ] == 3

Generated partial line assertlen(sequence)==3 and sequence[0]==1 and sequence[1]==2 and sequence[2
expression returns 25
Generated partial line assertlen(sequence)==3 and sequence[0]==1 and sequence[1]==2 and sequence[2]
Generated partial line assertlen(sequence)==3 and sequence[0]==1 and sequence[1]==2 and sequence[2]==
Generated partial line assertlen(sequence)==3 and sequence[0]==1 and sequence[1]==2 and sequence[2]==3
expression returns 28
  70 | 0 |   |
  71 | 0 |   |assert len(sequence) == 3 and sequence[0] == 1 and sequence[1] == 2 and sequence[2] == 3 #PL: print "$0 - test passed!\n";

Tokens: cf(a)>d0s(d)>d0s(d)>d0s(d)>d ValPy: 
Main loop, line=print "$0 - test passed!\n";


 === Line 71 Perl source:print "$0 - test passed!\n";===

Lexem 0 Current token='f' perl='print' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='"' perl='$0 - test passed!\n' value='f"{__file__} - test passed!\n"' Tokenstr |f"| translated: print f"{__file__} - test passed!\n"

Line:   71 TokenStr: =|f"|= @ValPy: print f"{__file__} - test passed!\n"
Generated partial line print(
print3(0) start=0, handle=, k=1, end_pos=1

expression(1, 1, 0) =|f"|= print $0 - test passed!\n

Generated partial line print(f"{__file__} - test passed!\n"
expression returns 2
Generated partial line print(f"{__file__} - test passed!")
  71 | 0 |   |print(f"{__file__} - test passed!")                                                     #PL: print "$0 - test passed!\n";

Tokens: f" ValPy: 
initialize_globals_for_state_vars: 
ERROR STATISTICS:  W: 1


 [Softpano-W317]:  Debug flag is set to 5


