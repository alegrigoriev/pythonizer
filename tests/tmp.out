 [Softpano-W317]:  Debug flag is set to 5


PYTHONIZER: Fuzzy translator of Python to Perl. Version 0.916 (mtime 211203_0018) Started at 21/12/03 00:26

Logs are at /tmp/Pythonizer/pythonizer.211203_0026.log. Type -h for help.
=============================================================================================================
Results of transcription are written to the file  issue_32.py
=========================================================================================================================

Lexem 0 Current token='c' value='NoTrans!' Tokenstr |c| translated: NoTrans!
Lexem 1 Current token='i' value='Carp.Assert' Tokenstr |ci| translated: NoTrans! Carp.Assert
Lexem 0 Current token='s' value='python' Tokenstr |s| translated: python
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: python =
Lexem 2 Current token='s' value='__file__' Tokenstr |s=s| translated: python = __file__
Lexem 3 Current token='~' value='' Tokenstr |s=s~| translated: python = __file__ 
Lexem 4 Current token='q' value='re.search(r'\.py$',' Tokenstr |s=s~q| translated: python = __file__  re.search(r'\.py$',
Lexem 0 Current token='s' value='a' Tokenstr |s| translated: a
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: a =
Lexem 2 Current token='d' value='1' Tokenstr |s=d| translated: a = 1
Lexem 0 Current token='s' value='b' Tokenstr |s| translated: b
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: b =
Lexem 2 Current token='d' value='2' Tokenstr |s=d| translated: b = 2
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='a' Tokenstr |c(s| translated: assert ( a
Lexem 3 Current token='+' value='+' Tokenstr |c(s+| translated: assert ( a +
Lexem 4 Current token='d' value='1' Tokenstr |c(s+d| translated: assert ( a + 1
Lexem 5 Current token='>' value='==' Tokenstr |c(s+d>| translated: assert ( a + 1 ==
Lexem 6 Current token='s' value='b' Tokenstr |c(s+d>s| translated: assert ( a + 1 == b
Lexem 7 Current token=')' value=')' Tokenstr |c(s+d>s)| translated: assert ( a + 1 == b )
Lexem 0 Current token='s' value='_d' Tokenstr |s| translated: _d
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: _d =
Lexem 2 Current token='"' value=''abc'' Tokenstr |s="| translated: _d = 'abc'
Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' value='fields' Tokenstr |ta| translated:  fields
Lexem 2 Current token='=' value='=' Tokenstr |ta=| translated:  fields =
Lexem 3 Current token='f' value='re.split' Tokenstr |ta=f| translated:  fields = re.split
Lexem 4 Current token='q' value='r'b'' Tokenstr |ta=fq| translated:  fields = re.split r'b'
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='len' Tokenstr |c(f| translated: assert ( len
Lexem 3 Current token='(' value='(' Tokenstr |c(f(| translated: assert ( len (
Lexem 4 Current token='a' value='fields' Tokenstr |c(f(a| translated: assert ( len ( fields
Lexem 5 Current token=')' value=')' Tokenstr |c(f(a)| translated: assert ( len ( fields )
Lexem 6 Current token='>' value='==' Tokenstr |c(f(a)>| translated: assert ( len ( fields ) ==
Lexem 7 Current token='d' value='2' Tokenstr |c(f(a)>d| translated: assert ( len ( fields ) == 2
Lexem 8 Current token='0' value=' and ' Tokenstr |c(f(a)>d0| translated: assert ( len ( fields ) == 2  and 
Lexem 9 Current token='s' value='fields' Tokenstr |c(f(a)>d0s| translated: assert ( len ( fields ) == 2  and  fields
Lexem 10 Current token='(' value='[' Tokenstr |c(f(a)>d0s(| translated: assert ( len ( fields ) == 2  and  fields [
Lexem 11 Current token='d' value='0' Tokenstr |c(f(a)>d0s(d| translated: assert ( len ( fields ) == 2  and  fields [ 0
Lexem 12 Current token=')' value=']' Tokenstr |c(f(a)>d0s(d)| translated: assert ( len ( fields ) == 2  and  fields [ 0 ]
Lexem 13 Current token='>' value='==' Tokenstr |c(f(a)>d0s(d)>| translated: assert ( len ( fields ) == 2  and  fields [ 0 ] ==
Lexem 14 Current token='"' value=''a'' Tokenstr |c(f(a)>d0s(d)>"| translated: assert ( len ( fields ) == 2  and  fields [ 0 ] == 'a'
Lexem 15 Current token='0' value=' and ' Tokenstr |c(f(a)>d0s(d)>"0| translated: assert ( len ( fields ) == 2  and  fields [ 0 ] == 'a'  and 
Lexem 16 Current token='s' value='fields' Tokenstr |c(f(a)>d0s(d)>"0s| translated: assert ( len ( fields ) == 2  and  fields [ 0 ] == 'a'  and  fields
Lexem 17 Current token='(' value='[' Tokenstr |c(f(a)>d0s(d)>"0s(| translated: assert ( len ( fields ) == 2  and  fields [ 0 ] == 'a'  and  fields [
Lexem 18 Current token='d' value='1' Tokenstr |c(f(a)>d0s(d)>"0s(d| translated: assert ( len ( fields ) == 2  and  fields [ 0 ] == 'a'  and  fields [ 1
Lexem 19 Current token=')' value=']' Tokenstr |c(f(a)>d0s(d)>"0s(d)| translated: assert ( len ( fields ) == 2  and  fields [ 0 ] == 'a'  and  fields [ 1 ]
Lexem 20 Current token='>' value='==' Tokenstr |c(f(a)>d0s(d)>"0s(d)>| translated: assert ( len ( fields ) == 2  and  fields [ 0 ] == 'a'  and  fields [ 1 ] ==
Lexem 21 Current token='"' value=''c'' Tokenstr |c(f(a)>d0s(d)>"0s(d)>"| translated: assert ( len ( fields ) == 2  and  fields [ 0 ] == 'a'  and  fields [ 1 ] == 'c'
Lexem 22 Current token=')' value=')' Tokenstr |c(f(a)>d0s(d)>"0s(d)>")| translated: assert ( len ( fields ) == 2  and  fields [ 0 ] == 'a'  and  fields [ 1 ] == 'c' )
Lexem 0 Current token='c' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='a' value='fields' Tokenstr |c(a| translated: for  ( fields
Lexem 3 Current token=')' value=')' Tokenstr |c(a)| translated: for  ( fields )
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='_d' Tokenstr |c(s| translated: assert ( _d
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( _d ==
Lexem 4 Current token='"' value=''a'' Tokenstr |c(s>"| translated: assert ( _d == 'a'
Lexem 5 Current token='0' value=' or ' Tokenstr |c(s>"0| translated: assert ( _d == 'a'  or 
Lexem 6 Current token='s' value='_d' Tokenstr |c(s>"0s| translated: assert ( _d == 'a'  or  _d
Lexem 7 Current token='>' value='==' Tokenstr |c(s>"0s>| translated: assert ( _d == 'a'  or  _d ==
Lexem 8 Current token='"' value=''c'' Tokenstr |c(s>"0s>"| translated: assert ( _d == 'a'  or  _d == 'c'
Lexem 9 Current token=')' value=')' Tokenstr |c(s>"0s>")| translated: assert ( _d == 'a'  or  _d == 'c' )
Lexem 0 Current token='s' value='_d' Tokenstr |s| translated: _d
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: _d =
Lexem 2 Current token='"' value=''abc\n'' Tokenstr |s="| translated: _d = 'abc\n'
Lexem 0 Current token='f' value='.rstrip("\n")' Tokenstr |f| translated: .rstrip("\n")
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='_d' Tokenstr |c(s| translated: assert ( _d
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( _d ==
Lexem 4 Current token='"' value=''abc'' Tokenstr |c(s>"| translated: assert ( _d == 'abc'
Lexem 5 Current token=')' value=')' Tokenstr |c(s>")| translated: assert ( _d == 'abc' )
Lexem 0 Current token='f' value='[0:-1]' Tokenstr |f| translated: [0:-1]
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='_d' Tokenstr |c(s| translated: assert ( _d
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( _d ==
Lexem 4 Current token='"' value=''ab'' Tokenstr |c(s>"| translated: assert ( _d == 'ab'
Lexem 5 Current token=')' value=')' Tokenstr |c(s>")| translated: assert ( _d == 'ab' )
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='line' Tokenstr |c(s| translated: assert ( line
Lexem 3 Current token='=' value=':=' Tokenstr |c(s=| translated: assert ( line :=
Lexem 4 Current token='q' value='re.search(r'b',_d)' Tokenstr |c(s=q| translated: assert ( line := re.search(r'b',_d)
Lexem 5 Current token=')' value=')' Tokenstr |c(s=q)| translated: assert ( line := re.search(r'b',_d) )
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='line' Tokenstr |c(s| translated: assert ( line
Lexem 3 Current token=')' value=')' Tokenstr |c(s)| translated: assert ( line )
Lexem 0 Current token='s' value='_d' Tokenstr |s| translated: _d
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: _d =
Lexem 2 Current token='"' value=''a'' Tokenstr |s="| translated: _d = 'a'
Lexem 0 Current token='s' value='i' Tokenstr |s| translated: i
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: i =
Lexem 2 Current token='f' value='ord' Tokenstr |s=f| translated: i = ord
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='i' Tokenstr |c(s| translated: assert ( i
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( i ==
Lexem 4 Current token='d' value='97' Tokenstr |c(s>d| translated: assert ( i == 97
Lexem 5 Current token=')' value=')' Tokenstr |c(s>d)| translated: assert ( i == 97 )
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='ord' Tokenstr |c(f| translated: assert ( ord
Lexem 3 Current token='>' value='==' Tokenstr |c(f>| translated: assert ( ord ==
Lexem 4 Current token='d' value='97' Tokenstr |c(f>d| translated: assert ( ord == 97
Lexem 5 Current token=')' value=')' Tokenstr |c(f>d)| translated: assert ( ord == 97 )
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='ord' Tokenstr |c(f| translated: assert ( ord
Lexem 3 Current token='s' value='_d' Tokenstr |c(fs| translated: assert ( ord _d
Lexem 4 Current token='>' value='==' Tokenstr |c(fs>| translated: assert ( ord _d ==
Lexem 5 Current token='d' value='97' Tokenstr |c(fs>d| translated: assert ( ord _d == 97
Lexem 6 Current token=')' value=')' Tokenstr |c(fs>d)| translated: assert ( ord _d == 97 )
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='ord' Tokenstr |c(f| translated: assert ( ord
Lexem 3 Current token='(' value='(' Tokenstr |c(f(| translated: assert ( ord (
Lexem 4 Current token='s' value='_d' Tokenstr |c(f(s| translated: assert ( ord ( _d
Lexem 5 Current token=')' value=')' Tokenstr |c(f(s)| translated: assert ( ord ( _d )
Lexem 6 Current token='>' value='==' Tokenstr |c(f(s)>| translated: assert ( ord ( _d ) ==
Lexem 7 Current token='d' value='97' Tokenstr |c(f(s)>d| translated: assert ( ord ( _d ) == 97
Lexem 8 Current token=')' value=')' Tokenstr |c(f(s)>d)| translated: assert ( ord ( _d ) == 97 )
Lexem 0 Current token='s' value='_d' Tokenstr |s| translated: _d
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: _d =
Lexem 2 Current token='d' value='97' Tokenstr |s=d| translated: _d = 97
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='ord' Tokenstr |c(f| translated: assert ( ord
Lexem 3 Current token='f' value='chr' Tokenstr |c(ff| translated: assert ( ord chr
Lexem 4 Current token='>' value='==' Tokenstr |c(ff>| translated: assert ( ord chr ==
Lexem 5 Current token='d' value='97' Tokenstr |c(ff>d| translated: assert ( ord chr == 97
Lexem 6 Current token=')' value=')' Tokenstr |c(ff>d)| translated: assert ( ord chr == 97 )
Lexem 0 Current token='f' value='open' Tokenstr |f| translated: open
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: open (
Lexem 2 Current token='i' value='FH' Tokenstr |f(i| translated: open ( FH
Lexem 3 Current token=',' value=',' Tokenstr |f(i,| translated: open ( FH ,
Lexem 4 Current token='"' value=''>_test.tmp'' Tokenstr |f(i,"| translated: open ( FH , '>_test.tmp'
Lexem 5 Current token=')' value=')' Tokenstr |f(i,")| translated: open ( FH , '>_test.tmp' )
Lexem 0 Current token='s' value='_d' Tokenstr |s| translated: _d
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: _d =
Lexem 2 Current token='"' value=''i'' Tokenstr |s="| translated: _d = 'i'
Lexem 0 Current token='f' value='print' Tokenstr |f| translated: print
Lexem 0 Current token='s' value='_d' Tokenstr |s| translated: _d
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: _d =
Lexem 2 Current token='"' value=''a'' Tokenstr |s="| translated: _d = 'a'
Lexem 0 Current token='f' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='i' value='FH' Tokenstr |fi| translated: print FH
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='_d' Tokenstr |c(s| translated: assert ( _d
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( _d ==
Lexem 4 Current token='"' value=''a'' Tokenstr |c(s>"| translated: assert ( _d == 'a'
Lexem 5 Current token=')' value=')' Tokenstr |c(s>")| translated: assert ( _d == 'a' )
Lexem 0 Current token='f' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='i' value='FH' Tokenstr |fi| translated: print FH
Lexem 0 Current token='f' value='.close()' Tokenstr |f| translated: .close()
Lexem 1 Current token='i' value='FH' Tokenstr |fi| translated: .close() FH
Lexem 0 Current token='f' value='open' Tokenstr |f| translated: open
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: open (
Lexem 2 Current token='i' value='FH' Tokenstr |f(i| translated: open ( FH
Lexem 3 Current token=',' value=',' Tokenstr |f(i,| translated: open ( FH ,
Lexem 4 Current token='"' value=''<_test.tmp'' Tokenstr |f(i,"| translated: open ( FH , '<_test.tmp'
Lexem 5 Current token=')' value=')' Tokenstr |f(i,")| translated: open ( FH , '<_test.tmp' )
Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' value='test' Tokenstr |ta| translated:  test
Lexem 2 Current token='=' value='=' Tokenstr |ta=| translated:  test =
Lexem 3 Current token='i' value='FH.readlines()' Tokenstr |ta=i| translated:  test = FH.readlines()
Lexem 0 Current token='f' value='.rstrip("\n")' Tokenstr |f| translated: .rstrip("\n")
Lexem 1 Current token='a' value='test' Tokenstr |fa| translated: .rstrip("\n") test
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='len' Tokenstr |c(f| translated: assert ( len
Lexem 3 Current token='(' value='(' Tokenstr |c(f(| translated: assert ( len (
Lexem 4 Current token='a' value='test' Tokenstr |c(f(a| translated: assert ( len ( test
Lexem 5 Current token=')' value=')' Tokenstr |c(f(a)| translated: assert ( len ( test )
Lexem 6 Current token='>' value='==' Tokenstr |c(f(a)>| translated: assert ( len ( test ) ==
Lexem 7 Current token='d' value='1' Tokenstr |c(f(a)>d| translated: assert ( len ( test ) == 1
Lexem 8 Current token=')' value=')' Tokenstr |c(f(a)>d)| translated: assert ( len ( test ) == 1 )
Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='s' value='a' Tokenstr |ts| translated:  a
Lexem 2 Current token='=' value='=' Tokenstr |ts=| translated:  a =
Lexem 3 Current token='s' value='b' Tokenstr |ts=s| translated:  a = b
Lexem 4 Current token='=' value='=' Tokenstr |ts=s=| translated:  a = b =
Lexem 5 Current token='s' value='c' Tokenstr |ts=s=s| translated:  a = b = c
Lexem 6 Current token='=' value='=' Tokenstr |ts=s=s=| translated:  a = b = c =
Lexem 7 Current token='"' value=''\n'' Tokenstr |ts=s=s="| translated:  a = b = c = '\n'
Lexem 0 Current token='f' value='.rstrip("\n")' Tokenstr |f| translated: .rstrip("\n")
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: .rstrip("\n") (
Lexem 2 Current token='s' value='a' Tokenstr |f(s| translated: .rstrip("\n") ( a
Lexem 3 Current token=',' value=',' Tokenstr |f(s,| translated: .rstrip("\n") ( a ,
Lexem 4 Current token='s' value='b' Tokenstr |f(s,s| translated: .rstrip("\n") ( a , b
Lexem 5 Current token=',' value=',' Tokenstr |f(s,s,| translated: .rstrip("\n") ( a , b ,
Lexem 6 Current token='s' value='c' Tokenstr |f(s,s,s| translated: .rstrip("\n") ( a , b , c
Lexem 7 Current token=')' value=')' Tokenstr |f(s,s,s)| translated: .rstrip("\n") ( a , b , c )
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='a' Tokenstr |c(s| translated: assert ( a
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( a ==
Lexem 4 Current token='"' value='''' Tokenstr |c(s>"| translated: assert ( a == ''
Lexem 5 Current token='0' value=' and ' Tokenstr |c(s>"0| translated: assert ( a == ''  and 
Lexem 6 Current token='s' value='b' Tokenstr |c(s>"0s| translated: assert ( a == ''  and  b
Lexem 7 Current token='>' value='==' Tokenstr |c(s>"0s>| translated: assert ( a == ''  and  b ==
Lexem 8 Current token='"' value='''' Tokenstr |c(s>"0s>"| translated: assert ( a == ''  and  b == ''
Lexem 9 Current token='0' value=' and ' Tokenstr |c(s>"0s>"0| translated: assert ( a == ''  and  b == ''  and 
Lexem 10 Current token='s' value='c' Tokenstr |c(s>"0s>"0s| translated: assert ( a == ''  and  b == ''  and  c
Lexem 11 Current token='>' value='==' Tokenstr |c(s>"0s>"0s>| translated: assert ( a == ''  and  b == ''  and  c ==
Lexem 12 Current token='"' value='''' Tokenstr |c(s>"0s>"0s>"| translated: assert ( a == ''  and  b == ''  and  c == ''
Lexem 13 Current token=')' value=')' Tokenstr |c(s>"0s>"0s>")| translated: assert ( a == ''  and  b == ''  and  c == '' )
Lexem 0 Current token='f' value='.rstrip("\n")' Tokenstr |f| translated: .rstrip("\n")
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: .rstrip("\n") (
Lexem 2 Current token='a' value='tester' Tokenstr |f(a| translated: .rstrip("\n") ( tester
Lexem 3 Current token='=' value='=' Tokenstr |f(a=| translated: .rstrip("\n") ( tester =
Lexem 4 Current token='i' value='FH.readlines()' Tokenstr |f(a=i| translated: .rstrip("\n") ( tester = FH.readlines()
Lexem 5 Current token=')' value=')' Tokenstr |f(a=i)| translated: .rstrip("\n") ( tester = FH.readlines() )
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='len' Tokenstr |c(f| translated: assert ( len
Lexem 3 Current token='(' value='(' Tokenstr |c(f(| translated: assert ( len (
Lexem 4 Current token='a' value='tester' Tokenstr |c(f(a| translated: assert ( len ( tester
Lexem 5 Current token=')' value=')' Tokenstr |c(f(a)| translated: assert ( len ( tester )
Lexem 6 Current token='>' value='==' Tokenstr |c(f(a)>| translated: assert ( len ( tester ) ==
Lexem 7 Current token='d' value='0' Tokenstr |c(f(a)>d| translated: assert ( len ( tester ) == 0
Lexem 8 Current token=')' value=')' Tokenstr |c(f(a)>d)| translated: assert ( len ( tester ) == 0 )
Lexem 0 Current token='f' value='.close()' Tokenstr |f| translated: .close()
Lexem 1 Current token='i' value='FH' Tokenstr |fi| translated: .close() FH
Lexem 0 Current token='f' value='os.unlink' Tokenstr |f| translated: os.unlink
Lexem 1 Current token='"' value=''_test.tmp'' Tokenstr |f"| translated: os.unlink '_test.tmp'
Lexem 0 Current token='s' value='_d' Tokenstr |s| translated: _d
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: _d =
Lexem 2 Current token='d' value='65' Tokenstr |s=d| translated: _d = 65
Lexem 0 Current token='s' value='c' Tokenstr |s| translated: c
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: c =
Lexem 2 Current token='f' value='chr' Tokenstr |s=f| translated: c = chr
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='c' Tokenstr |c(s| translated: assert ( c
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( c ==
Lexem 4 Current token='"' value=''A'' Tokenstr |c(s>"| translated: assert ( c == 'A'
Lexem 5 Current token=')' value=')' Tokenstr |c(s>")| translated: assert ( c == 'A' )
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='chr' Tokenstr |c(f| translated: assert ( chr
Lexem 3 Current token='>' value='==' Tokenstr |c(f>| translated: assert ( chr ==
Lexem 4 Current token='"' value=''A'' Tokenstr |c(f>"| translated: assert ( chr == 'A'
Lexem 5 Current token=')' value=')' Tokenstr |c(f>")| translated: assert ( chr == 'A' )
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='chr' Tokenstr |c(f| translated: assert ( chr
Lexem 3 Current token='s' value='_d' Tokenstr |c(fs| translated: assert ( chr _d
Lexem 4 Current token='>' value='==' Tokenstr |c(fs>| translated: assert ( chr _d ==
Lexem 5 Current token='"' value=''A'' Tokenstr |c(fs>"| translated: assert ( chr _d == 'A'
Lexem 6 Current token=')' value=')' Tokenstr |c(fs>")| translated: assert ( chr _d == 'A' )
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='chr' Tokenstr |c(f| translated: assert ( chr
Lexem 3 Current token='s' value='_d' Tokenstr |c(fs| translated: assert ( chr _d
Lexem 4 Current token='+' value='+' Tokenstr |c(fs+| translated: assert ( chr _d +
Lexem 5 Current token='d' value='1' Tokenstr |c(fs+d| translated: assert ( chr _d + 1
Lexem 6 Current token='>' value='==' Tokenstr |c(fs+d>| translated: assert ( chr _d + 1 ==
Lexem 7 Current token='"' value=''B'' Tokenstr |c(fs+d>"| translated: assert ( chr _d + 1 == 'B'
Lexem 8 Current token=')' value=')' Tokenstr |c(fs+d>")| translated: assert ( chr _d + 1 == 'B' )
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='chr' Tokenstr |c(f| translated: assert ( chr
Lexem 3 Current token='(' value='(' Tokenstr |c(f(| translated: assert ( chr (
Lexem 4 Current token='s' value='_d' Tokenstr |c(f(s| translated: assert ( chr ( _d
Lexem 5 Current token=')' value=')' Tokenstr |c(f(s)| translated: assert ( chr ( _d )
Lexem 6 Current token='>' value='==' Tokenstr |c(f(s)>| translated: assert ( chr ( _d ) ==
Lexem 7 Current token='"' value=''A'' Tokenstr |c(f(s)>"| translated: assert ( chr ( _d ) == 'A'
Lexem 8 Current token=')' value=')' Tokenstr |c(f(s)>")| translated: assert ( chr ( _d ) == 'A' )
Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' value='numbers' Tokenstr |ta| translated:  numbers
Lexem 2 Current token='=' value='=' Tokenstr |ta=| translated:  numbers =
Lexem 3 Current token='(' value='(' Tokenstr |ta=(| translated:  numbers = (
Lexem 4 Current token='d' value='1' Tokenstr |ta=(d| translated:  numbers = ( 1
Lexem 5 Current token=',' value=',' Tokenstr |ta=(d,| translated:  numbers = ( 1 ,
Lexem 6 Current token='d' value='2' Tokenstr |ta=(d,d| translated:  numbers = ( 1 , 2
Lexem 7 Current token=',' value=',' Tokenstr |ta=(d,d,| translated:  numbers = ( 1 , 2 ,
Lexem 8 Current token='d' value='3' Tokenstr |ta=(d,d,d| translated:  numbers = ( 1 , 2 , 3
Lexem 9 Current token=')' value=')' Tokenstr |ta=(d,d,d)| translated:  numbers = ( 1 , 2 , 3 )
Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' value='doubles' Tokenstr |ta| translated:  doubles
Lexem 2 Current token='=' value='=' Tokenstr |ta=| translated:  doubles =
Lexem 3 Current token='f' value='map' Tokenstr |ta=f| translated:  doubles = map
Lexem 4 Current token='(' value='[' Tokenstr |ta=f(| translated:  doubles = map [
Lexem 5 Current token='s' value='_d' Tokenstr |ta=f(s| translated:  doubles = map [ _d
Lexem 6 Current token='*' value='*' Tokenstr |ta=f(s*| translated:  doubles = map [ _d *
Lexem 7 Current token='d' value='2' Tokenstr |ta=f(s*d| translated:  doubles = map [ _d * 2
Lexem 8 Current token=')' value=']' Tokenstr |ta=f(s*d)| translated:  doubles = map [ _d * 2 ]
Lexem 9 Current token='a' value='numbers' Tokenstr |ta=f(s*d)a| translated:  doubles = map [ _d * 2 ] numbers
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='len' Tokenstr |c(f| translated: assert ( len
Lexem 3 Current token='(' value='(' Tokenstr |c(f(| translated: assert ( len (
Lexem 4 Current token='a' value='doubles' Tokenstr |c(f(a| translated: assert ( len ( doubles
Lexem 5 Current token=')' value=')' Tokenstr |c(f(a)| translated: assert ( len ( doubles )
Lexem 6 Current token='>' value='==' Tokenstr |c(f(a)>| translated: assert ( len ( doubles ) ==
Lexem 7 Current token='d' value='3' Tokenstr |c(f(a)>d| translated: assert ( len ( doubles ) == 3
Lexem 8 Current token='0' value=' and ' Tokenstr |c(f(a)>d0| translated: assert ( len ( doubles ) == 3  and 
Lexem 9 Current token='s' value='doubles' Tokenstr |c(f(a)>d0s| translated: assert ( len ( doubles ) == 3  and  doubles
Lexem 10 Current token='(' value='[' Tokenstr |c(f(a)>d0s(| translated: assert ( len ( doubles ) == 3  and  doubles [
Lexem 11 Current token='d' value='0' Tokenstr |c(f(a)>d0s(d| translated: assert ( len ( doubles ) == 3  and  doubles [ 0
Lexem 12 Current token=')' value=']' Tokenstr |c(f(a)>d0s(d)| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ]
Lexem 13 Current token='>' value='==' Tokenstr |c(f(a)>d0s(d)>| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] ==
Lexem 14 Current token='d' value='2' Tokenstr |c(f(a)>d0s(d)>d| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2
Lexem 15 Current token='0' value=' and ' Tokenstr |c(f(a)>d0s(d)>d0| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2  and 
Lexem 16 Current token='s' value='doubles' Tokenstr |c(f(a)>d0s(d)>d0s| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2  and  doubles
Lexem 17 Current token='(' value='[' Tokenstr |c(f(a)>d0s(d)>d0s(| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2  and  doubles [
Lexem 18 Current token='d' value='1' Tokenstr |c(f(a)>d0s(d)>d0s(d| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2  and  doubles [ 1
Lexem 19 Current token=')' value=']' Tokenstr |c(f(a)>d0s(d)>d0s(d)| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2  and  doubles [ 1 ]
Lexem 20 Current token='>' value='==' Tokenstr |c(f(a)>d0s(d)>d0s(d)>| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2  and  doubles [ 1 ] ==
Lexem 21 Current token='d' value='4' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2  and  doubles [ 1 ] == 4
Lexem 22 Current token='0' value=' and ' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2  and  doubles [ 1 ] == 4  and 
Lexem 23 Current token='s' value='doubles' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0s| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2  and  doubles [ 1 ] == 4  and  doubles
Lexem 24 Current token='(' value='[' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0s(| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2  and  doubles [ 1 ] == 4  and  doubles [
Lexem 25 Current token='d' value='2' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0s(d| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2  and  doubles [ 1 ] == 4  and  doubles [ 2
Lexem 26 Current token=')' value=']' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0s(d)| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2  and  doubles [ 1 ] == 4  and  doubles [ 2 ]
Lexem 27 Current token='>' value='==' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0s(d)>| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2  and  doubles [ 1 ] == 4  and  doubles [ 2 ] ==
Lexem 28 Current token='d' value='6' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0s(d)>d| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2  and  doubles [ 1 ] == 4  and  doubles [ 2 ] == 6
Lexem 29 Current token=')' value=')' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0s(d)>d)| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2  and  doubles [ 1 ] == 4  and  doubles [ 2 ] == 6 )
Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' value='numbers' Tokenstr |ta| translated:  numbers
Lexem 2 Current token='=' value='=' Tokenstr |ta=| translated:  numbers =
Lexem 3 Current token='(' value='(' Tokenstr |ta=(| translated:  numbers = (
Lexem 4 Current token='d' value='65' Tokenstr |ta=(d| translated:  numbers = ( 65
Lexem 5 Current token=',' value=',' Tokenstr |ta=(d,| translated:  numbers = ( 65 ,
Lexem 6 Current token='d' value='66' Tokenstr |ta=(d,d| translated:  numbers = ( 65 , 66
Lexem 7 Current token=')' value=')' Tokenstr |ta=(d,d)| translated:  numbers = ( 65 , 66 )
Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' value='chars' Tokenstr |ta| translated:  chars
Lexem 2 Current token='=' value='=' Tokenstr |ta=| translated:  chars =
Lexem 3 Current token='f' value='map' Tokenstr |ta=f| translated:  chars = map
Lexem 4 Current token='(' value='(' Tokenstr |ta=f(| translated:  chars = map (
Lexem 5 Current token='f' value='chr' Tokenstr |ta=f(f| translated:  chars = map ( chr
Lexem 6 Current token=',' value=',' Tokenstr |ta=f(f,| translated:  chars = map ( chr ,
Lexem 7 Current token='a' value='numbers' Tokenstr |ta=f(f,a| translated:  chars = map ( chr , numbers
Lexem 8 Current token=')' value=')' Tokenstr |ta=f(f,a)| translated:  chars = map ( chr , numbers )
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='chars' Tokenstr |c(s| translated: assert ( chars
Lexem 3 Current token='(' value='[' Tokenstr |c(s(| translated: assert ( chars [
Lexem 4 Current token='d' value='0' Tokenstr |c(s(d| translated: assert ( chars [ 0
Lexem 5 Current token=')' value=']' Tokenstr |c(s(d)| translated: assert ( chars [ 0 ]
Lexem 6 Current token='>' value='==' Tokenstr |c(s(d)>| translated: assert ( chars [ 0 ] ==
Lexem 7 Current token='"' value=''A'' Tokenstr |c(s(d)>"| translated: assert ( chars [ 0 ] == 'A'
Lexem 8 Current token='0' value=' and ' Tokenstr |c(s(d)>"0| translated: assert ( chars [ 0 ] == 'A'  and 
Lexem 9 Current token='s' value='chars' Tokenstr |c(s(d)>"0s| translated: assert ( chars [ 0 ] == 'A'  and  chars
Lexem 10 Current token='(' value='[' Tokenstr |c(s(d)>"0s(| translated: assert ( chars [ 0 ] == 'A'  and  chars [
Lexem 11 Current token='d' value='1' Tokenstr |c(s(d)>"0s(d| translated: assert ( chars [ 0 ] == 'A'  and  chars [ 1
Lexem 12 Current token=')' value=']' Tokenstr |c(s(d)>"0s(d)| translated: assert ( chars [ 0 ] == 'A'  and  chars [ 1 ]
Lexem 13 Current token='>' value='==' Tokenstr |c(s(d)>"0s(d)>| translated: assert ( chars [ 0 ] == 'A'  and  chars [ 1 ] ==
Lexem 14 Current token='"' value=''B'' Tokenstr |c(s(d)>"0s(d)>"| translated: assert ( chars [ 0 ] == 'A'  and  chars [ 1 ] == 'B'
Lexem 15 Current token=')' value=')' Tokenstr |c(s(d)>"0s(d)>")| translated: assert ( chars [ 0 ] == 'A'  and  chars [ 1 ] == 'B' )
Lexem 0 Current token='k' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' value='myF' Tokenstr |ki| translated: def myF
Lexem 0 Current token='k' value='return' Tokenstr |k| translated: return
Lexem 1 Current token='(' value='(' Tokenstr |k(| translated: return (
Lexem 2 Current token='f' value='.lower()' Tokenstr |k(f| translated: return ( .lower()
Lexem 3 Current token='f' value='.pop(0)' Tokenstr |k(ff| translated: return ( .lower() .pop(0)
Lexem 4 Current token=')' value=')' Tokenstr |k(ff)| translated: return ( .lower() .pop(0) )
Lexem 5 Current token='c' value='if ' Tokenstr |k(ff)c| translated: return ( .lower() .pop(0) ) if 
Lexem 6 Current token='(' value='(' Tokenstr |k(ff)c(| translated: return ( .lower() .pop(0) ) if  (
Lexem 7 Current token='s' value='python' Tokenstr |k(ff)c(s| translated: return ( .lower() .pop(0) ) if  ( python
Lexem 8 Current token=')' value=')' Tokenstr |k(ff)c(s)| translated: return ( .lower() .pop(0) ) if  ( python )
Lexem 0 Current token='k' value='return' Tokenstr |k| translated: return
Lexem 1 Current token='(' value='(' Tokenstr |k(| translated: return (
Lexem 2 Current token='f' value='.lower()' Tokenstr |k(f| translated: return ( .lower()
Lexem 3 Current token='s' value='_d' Tokenstr |k(fs| translated: return ( .lower() _d
Lexem 4 Current token=')' value=')' Tokenstr |k(fs)| translated: return ( .lower() _d )
Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' value='lc' Tokenstr |ta| translated:  lc
Lexem 2 Current token='=' value='=' Tokenstr |ta=| translated:  lc =
Lexem 3 Current token='f' value='map' Tokenstr |ta=f| translated:  lc = map
Lexem 4 Current token='(' value='(' Tokenstr |ta=f(| translated:  lc = map (
Lexem 5 Current token='i' value='myF' Tokenstr |ta=f(i| translated:  lc = map ( myF
Lexem 6 Current token=',' value=',' Tokenstr |ta=f(i,| translated:  lc = map ( myF ,
Lexem 7 Current token='a' value='chars' Tokenstr |ta=f(i,a| translated:  lc = map ( myF , chars
Lexem 8 Current token=')' value=')' Tokenstr |ta=f(i,a)| translated:  lc = map ( myF , chars )
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='lc' Tokenstr |c(s| translated: assert ( lc
Lexem 3 Current token='(' value='[' Tokenstr |c(s(| translated: assert ( lc [
Lexem 4 Current token='d' value='0' Tokenstr |c(s(d| translated: assert ( lc [ 0
Lexem 5 Current token=')' value=']' Tokenstr |c(s(d)| translated: assert ( lc [ 0 ]
Lexem 6 Current token='>' value='==' Tokenstr |c(s(d)>| translated: assert ( lc [ 0 ] ==
Lexem 7 Current token='"' value=''a'' Tokenstr |c(s(d)>"| translated: assert ( lc [ 0 ] == 'a'
Lexem 8 Current token='0' value=' and ' Tokenstr |c(s(d)>"0| translated: assert ( lc [ 0 ] == 'a'  and 
Lexem 9 Current token='s' value='lc' Tokenstr |c(s(d)>"0s| translated: assert ( lc [ 0 ] == 'a'  and  lc
Lexem 10 Current token='(' value='[' Tokenstr |c(s(d)>"0s(| translated: assert ( lc [ 0 ] == 'a'  and  lc [
Lexem 11 Current token='d' value='1' Tokenstr |c(s(d)>"0s(d| translated: assert ( lc [ 0 ] == 'a'  and  lc [ 1
Lexem 12 Current token=')' value=']' Tokenstr |c(s(d)>"0s(d)| translated: assert ( lc [ 0 ] == 'a'  and  lc [ 1 ]
Lexem 13 Current token='>' value='==' Tokenstr |c(s(d)>"0s(d)>| translated: assert ( lc [ 0 ] == 'a'  and  lc [ 1 ] ==
Lexem 14 Current token='"' value=''b'' Tokenstr |c(s(d)>"0s(d)>"| translated: assert ( lc [ 0 ] == 'a'  and  lc [ 1 ] == 'b'
Lexem 15 Current token=')' value=')' Tokenstr |c(s(d)>"0s(d)>")| translated: assert ( lc [ 0 ] == 'a'  and  lc [ 1 ] == 'b' )
Lexem 0 Current token='a' value='lc2' Tokenstr |a| translated: lc2
Lexem 1 Current token='=' value='=' Tokenstr |a=| translated: lc2 =
Lexem 2 Current token='f' value='map' Tokenstr |a=f| translated: lc2 = map
Lexem 3 Current token='(' value='(' Tokenstr |a=f(| translated: lc2 = map (
Lexem 4 Current token='f' value='.lower()' Tokenstr |a=f(f| translated: lc2 = map ( .lower()
Lexem 5 Current token=',' value=',' Tokenstr |a=f(f,| translated: lc2 = map ( .lower() ,
Lexem 6 Current token='a' value='chars' Tokenstr |a=f(f,a| translated: lc2 = map ( .lower() , chars
Lexem 7 Current token=')' value=')' Tokenstr |a=f(f,a)| translated: lc2 = map ( .lower() , chars )
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='lc2' Tokenstr |c(s| translated: assert ( lc2
Lexem 3 Current token='(' value='[' Tokenstr |c(s(| translated: assert ( lc2 [
Lexem 4 Current token='d' value='0' Tokenstr |c(s(d| translated: assert ( lc2 [ 0
Lexem 5 Current token=')' value=']' Tokenstr |c(s(d)| translated: assert ( lc2 [ 0 ]
Lexem 6 Current token='>' value='==' Tokenstr |c(s(d)>| translated: assert ( lc2 [ 0 ] ==
Lexem 7 Current token='"' value=''a'' Tokenstr |c(s(d)>"| translated: assert ( lc2 [ 0 ] == 'a'
Lexem 8 Current token='0' value=' and ' Tokenstr |c(s(d)>"0| translated: assert ( lc2 [ 0 ] == 'a'  and 
Lexem 9 Current token='s' value='lc2' Tokenstr |c(s(d)>"0s| translated: assert ( lc2 [ 0 ] == 'a'  and  lc2
Lexem 10 Current token='(' value='[' Tokenstr |c(s(d)>"0s(| translated: assert ( lc2 [ 0 ] == 'a'  and  lc2 [
Lexem 11 Current token='d' value='1' Tokenstr |c(s(d)>"0s(d| translated: assert ( lc2 [ 0 ] == 'a'  and  lc2 [ 1
Lexem 12 Current token=')' value=']' Tokenstr |c(s(d)>"0s(d)| translated: assert ( lc2 [ 0 ] == 'a'  and  lc2 [ 1 ]
Lexem 13 Current token='>' value='==' Tokenstr |c(s(d)>"0s(d)>| translated: assert ( lc2 [ 0 ] == 'a'  and  lc2 [ 1 ] ==
Lexem 14 Current token='"' value=''b'' Tokenstr |c(s(d)>"0s(d)>"| translated: assert ( lc2 [ 0 ] == 'a'  and  lc2 [ 1 ] == 'b'
Lexem 15 Current token=')' value=')' Tokenstr |c(s(d)>"0s(d)>")| translated: assert ( lc2 [ 0 ] == 'a'  and  lc2 [ 1 ] == 'b' )
Lexem 0 Current token='a' value='numbers' Tokenstr |a| translated: numbers
Lexem 1 Current token='=' value='=' Tokenstr |a=| translated: numbers =
Lexem 2 Current token='(' value='(' Tokenstr |a=(| translated: numbers = (
Lexem 3 Current token='d' value='8' Tokenstr |a=(d| translated: numbers = ( 8
Lexem 4 Current token=',' value=',' Tokenstr |a=(d,| translated: numbers = ( 8 ,
Lexem 5 Current token='d' value='2' Tokenstr |a=(d,d| translated: numbers = ( 8 , 2
Lexem 6 Current token=',' value=',' Tokenstr |a=(d,d,| translated: numbers = ( 8 , 2 ,
Lexem 7 Current token='d' value='5' Tokenstr |a=(d,d,d| translated: numbers = ( 8 , 2 , 5
Lexem 8 Current token=',' value=',' Tokenstr |a=(d,d,d,| translated: numbers = ( 8 , 2 , 5 ,
Lexem 9 Current token='d' value='3' Tokenstr |a=(d,d,d,d| translated: numbers = ( 8 , 2 , 5 , 3
Lexem 10 Current token=',' value=',' Tokenstr |a=(d,d,d,d,| translated: numbers = ( 8 , 2 , 5 , 3 ,
Lexem 11 Current token='d' value='1' Tokenstr |a=(d,d,d,d,d| translated: numbers = ( 8 , 2 , 5 , 3 , 1
Lexem 12 Current token=',' value=',' Tokenstr |a=(d,d,d,d,d,| translated: numbers = ( 8 , 2 , 5 , 3 , 1 ,
Lexem 13 Current token='d' value='7' Tokenstr |a=(d,d,d,d,d,d| translated: numbers = ( 8 , 2 , 5 , 3 , 1 , 7
Lexem 14 Current token=')' value=')' Tokenstr |a=(d,d,d,d,d,d)| translated: numbers = ( 8 , 2 , 5 , 3 , 1 , 7 )
Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' value='big_numbers' Tokenstr |ta| translated:  big_numbers
Lexem 2 Current token='=' value='=' Tokenstr |ta=| translated:  big_numbers =
Lexem 3 Current token='f' value='filter' Tokenstr |ta=f| translated:  big_numbers = filter
Lexem 4 Current token='(' value='[' Tokenstr |ta=f(| translated:  big_numbers = filter [
Lexem 5 Current token='s' value='_d' Tokenstr |ta=f(s| translated:  big_numbers = filter [ _d
Lexem 6 Current token='>' value='>' Tokenstr |ta=f(s>| translated:  big_numbers = filter [ _d >
Lexem 7 Current token='d' value='4' Tokenstr |ta=f(s>d| translated:  big_numbers = filter [ _d > 4
Lexem 8 Current token=')' value=']' Tokenstr |ta=f(s>d)| translated:  big_numbers = filter [ _d > 4 ]
Lexem 9 Current token='a' value='numbers' Tokenstr |ta=f(s>d)a| translated:  big_numbers = filter [ _d > 4 ] numbers
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='len' Tokenstr |c(f| translated: assert ( len
Lexem 3 Current token='(' value='(' Tokenstr |c(f(| translated: assert ( len (
Lexem 4 Current token='a' value='big_numbers' Tokenstr |c(f(a| translated: assert ( len ( big_numbers
Lexem 5 Current token=')' value=')' Tokenstr |c(f(a)| translated: assert ( len ( big_numbers )
Lexem 6 Current token='>' value='==' Tokenstr |c(f(a)>| translated: assert ( len ( big_numbers ) ==
Lexem 7 Current token='d' value='3' Tokenstr |c(f(a)>d| translated: assert ( len ( big_numbers ) == 3
Lexem 8 Current token=')' value=')' Tokenstr |c(f(a)>d)| translated: assert ( len ( big_numbers ) == 3 )
Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' value='names' Tokenstr |ta| translated:  names
Lexem 2 Current token='=' value='=' Tokenstr |ta=| translated:  names =
Lexem 3 Current token='q' value='"Foo Bar Baz".split()' Tokenstr |ta=q| translated:  names = "Foo Bar Baz".split()
Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='s' value='visitor' Tokenstr |ts| translated:  visitor
Lexem 2 Current token='=' value='=' Tokenstr |ts=| translated:  visitor =
Lexem 3 Current token='"' value=''Bar'' Tokenstr |ts="| translated:  visitor = 'Bar'
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='filter' Tokenstr |c(f| translated: assert ( filter
Lexem 3 Current token='(' value='[' Tokenstr |c(f(| translated: assert ( filter [
Lexem 4 Current token='s' value='visitor' Tokenstr |c(f(s| translated: assert ( filter [ visitor
Lexem 5 Current token='>' value='==' Tokenstr |c(f(s>| translated: assert ( filter [ visitor ==
Lexem 6 Current token='s' value='_d' Tokenstr |c(f(s>s| translated: assert ( filter [ visitor == _d
Lexem 7 Current token=')' value=']' Tokenstr |c(f(s>s)| translated: assert ( filter [ visitor == _d ]
Lexem 8 Current token='a' value='names' Tokenstr |c(f(s>s)a| translated: assert ( filter [ visitor == _d ] names
Lexem 9 Current token=')' value=')' Tokenstr |c(f(s>s)a)| translated: assert ( filter [ visitor == _d ] names )
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='!' value='not' Tokenstr |c(!| translated: assert ( not
Lexem 3 Current token='f' value='filter' Tokenstr |c(!f| translated: assert ( not filter
Lexem 4 Current token='(' value='[' Tokenstr |c(!f(| translated: assert ( not filter [
Lexem 5 Current token='"' value=''Fred'' Tokenstr |c(!f("| translated: assert ( not filter [ 'Fred'
Lexem 6 Current token='>' value='==' Tokenstr |c(!f(">| translated: assert ( not filter [ 'Fred' ==
Lexem 7 Current token='s' value='_d' Tokenstr |c(!f(">s| translated: assert ( not filter [ 'Fred' == _d
Lexem 8 Current token=')' value=']' Tokenstr |c(!f(">s)| translated: assert ( not filter [ 'Fred' == _d ]
Lexem 9 Current token='a' value='names' Tokenstr |c(!f(">s)a| translated: assert ( not filter [ 'Fred' == _d ] names
Lexem 10 Current token=')' value=')' Tokenstr |c(!f(">s)a)| translated: assert ( not filter [ 'Fred' == _d ] names )
Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' value='foo' Tokenstr |ta| translated:  foo
Lexem 2 Current token='=' value='=' Tokenstr |ta=| translated:  foo =
Lexem 3 Current token='f' value='filter' Tokenstr |ta=f| translated:  foo = filter
Lexem 4 Current token='(' value='(' Tokenstr |ta=f(| translated:  foo = filter (
Lexem 5 Current token='s' value='_d' Tokenstr |ta=f(s| translated:  foo = filter ( _d
Lexem 6 Current token='>' value='==' Tokenstr |ta=f(s>| translated:  foo = filter ( _d ==
Lexem 7 Current token='"' value=''Foo'' Tokenstr |ta=f(s>"| translated:  foo = filter ( _d == 'Foo'
Lexem 8 Current token=',' value=',' Tokenstr |ta=f(s>",| translated:  foo = filter ( _d == 'Foo' ,
Lexem 9 Current token='a' value='names' Tokenstr |ta=f(s>",a| translated:  foo = filter ( _d == 'Foo' , names
Lexem 10 Current token=')' value=')' Tokenstr |ta=f(s>",a)| translated:  foo = filter ( _d == 'Foo' , names )
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='len' Tokenstr |c(f| translated: assert ( len
Lexem 3 Current token='(' value='(' Tokenstr |c(f(| translated: assert ( len (
Lexem 4 Current token='a' value='foo' Tokenstr |c(f(a| translated: assert ( len ( foo
Lexem 5 Current token=')' value=')' Tokenstr |c(f(a)| translated: assert ( len ( foo )
Lexem 6 Current token='>' value='==' Tokenstr |c(f(a)>| translated: assert ( len ( foo ) ==
Lexem 7 Current token='d' value='1' Tokenstr |c(f(a)>d| translated: assert ( len ( foo ) == 1
Lexem 8 Current token='0' value=' and ' Tokenstr |c(f(a)>d0| translated: assert ( len ( foo ) == 1  and 
Lexem 9 Current token='s' value='foo' Tokenstr |c(f(a)>d0s| translated: assert ( len ( foo ) == 1  and  foo
Lexem 10 Current token='(' value='[' Tokenstr |c(f(a)>d0s(| translated: assert ( len ( foo ) == 1  and  foo [
Lexem 11 Current token='d' value='0' Tokenstr |c(f(a)>d0s(d| translated: assert ( len ( foo ) == 1  and  foo [ 0
Lexem 12 Current token=')' value=']' Tokenstr |c(f(a)>d0s(d)| translated: assert ( len ( foo ) == 1  and  foo [ 0 ]
Lexem 13 Current token='>' value='==' Tokenstr |c(f(a)>d0s(d)>| translated: assert ( len ( foo ) == 1  and  foo [ 0 ] ==
Lexem 14 Current token='"' value=''Foo'' Tokenstr |c(f(a)>d0s(d)>"| translated: assert ( len ( foo ) == 1  and  foo [ 0 ] == 'Foo'
Lexem 15 Current token=')' value=')' Tokenstr |c(f(a)>d0s(d)>")| translated: assert ( len ( foo ) == 1  and  foo [ 0 ] == 'Foo' )
Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' value='bs' Tokenstr |ta| translated:  bs
Lexem 2 Current token='=' value='=' Tokenstr |ta=| translated:  bs =
Lexem 3 Current token='f' value='filter' Tokenstr |ta=f| translated:  bs = filter
Lexem 4 Current token='(' value='(' Tokenstr |ta=f(| translated:  bs = filter (
Lexem 5 Current token='q' value='r'B'' Tokenstr |ta=f(q| translated:  bs = filter ( r'B'
Lexem 6 Current token=',' value=',' Tokenstr |ta=f(q,| translated:  bs = filter ( r'B' ,
Lexem 7 Current token='a' value='names' Tokenstr |ta=f(q,a| translated:  bs = filter ( r'B' , names
Lexem 8 Current token=')' value=')' Tokenstr |ta=f(q,a)| translated:  bs = filter ( r'B' , names )
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='len' Tokenstr |c(f| translated: assert ( len
Lexem 3 Current token='(' value='(' Tokenstr |c(f(| translated: assert ( len (
Lexem 4 Current token='a' value='bs' Tokenstr |c(f(a| translated: assert ( len ( bs
Lexem 5 Current token=')' value=')' Tokenstr |c(f(a)| translated: assert ( len ( bs )
Lexem 6 Current token='>' value='==' Tokenstr |c(f(a)>| translated: assert ( len ( bs ) ==
Lexem 7 Current token='d' value='2' Tokenstr |c(f(a)>d| translated: assert ( len ( bs ) == 2
Lexem 8 Current token=')' value=')' Tokenstr |c(f(a)>d)| translated: assert ( len ( bs ) == 2 )
Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' value='bs' Tokenstr |ta| translated:  bs
Lexem 2 Current token='=' value='=' Tokenstr |ta=| translated:  bs =
Lexem 3 Current token='f' value='filter' Tokenstr |ta=f| translated:  bs = filter
Lexem 4 Current token='q' value='re.search(re.compile(r'b',re.I),_d)' Tokenstr |ta=fq| translated:  bs = filter re.search(re.compile(r'b',re.I),_d)
Lexem 5 Current token=',' value=',' Tokenstr |ta=fq,| translated:  bs = filter re.search(re.compile(r'b',re.I),_d) ,
Lexem 6 Current token='a' value='names' Tokenstr |ta=fq,a| translated:  bs = filter re.search(re.compile(r'b',re.I),_d) , names
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='len' Tokenstr |c(f| translated: assert ( len
Lexem 3 Current token='(' value='(' Tokenstr |c(f(| translated: assert ( len (
Lexem 4 Current token='a' value='bs' Tokenstr |c(f(a| translated: assert ( len ( bs
Lexem 5 Current token=')' value=')' Tokenstr |c(f(a)| translated: assert ( len ( bs )
Lexem 6 Current token='>' value='==' Tokenstr |c(f(a)>| translated: assert ( len ( bs ) ==
Lexem 7 Current token='d' value='2' Tokenstr |c(f(a)>d| translated: assert ( len ( bs ) == 2
Lexem 8 Current token=')' value=')' Tokenstr |c(f(a)>d)| translated: assert ( len ( bs ) == 2 )
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='filter' Tokenstr |c(f| translated: assert ( filter
Lexem 3 Current token='(' value='(' Tokenstr |c(f(| translated: assert ( filter (
Lexem 4 Current token='"' value=''Baz'' Tokenstr |c(f("| translated: assert ( filter ( 'Baz'
Lexem 5 Current token=',' value=',' Tokenstr |c(f(",| translated: assert ( filter ( 'Baz' ,
Lexem 6 Current token='a' value='names' Tokenstr |c(f(",a| translated: assert ( filter ( 'Baz' , names
Lexem 7 Current token=')' value=')' Tokenstr |c(f(",a)| translated: assert ( filter ( 'Baz' , names )
Lexem 8 Current token=')' value=')' Tokenstr |c(f(",a))| translated: assert ( filter ( 'Baz' , names ) )
Lexem 0 Current token='a' value='bz' Tokenstr |a| translated: bz
Lexem 1 Current token='=' value='=' Tokenstr |a=| translated: bz =
Lexem 2 Current token='q' value='"Baz".split()' Tokenstr |a=q| translated: bz = "Baz".split()
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='filter' Tokenstr |c(f| translated: assert ( filter
Lexem 3 Current token='(' value='(' Tokenstr |c(f(| translated: assert ( filter (
Lexem 4 Current token='s' value='bz' Tokenstr |c(f(s| translated: assert ( filter ( bz
Lexem 5 Current token='(' value='[' Tokenstr |c(f(s(| translated: assert ( filter ( bz [
Lexem 6 Current token='d' value='0' Tokenstr |c(f(s(d| translated: assert ( filter ( bz [ 0
Lexem 7 Current token=')' value=']' Tokenstr |c(f(s(d)| translated: assert ( filter ( bz [ 0 ]
Lexem 8 Current token=',' value=',' Tokenstr |c(f(s(d),| translated: assert ( filter ( bz [ 0 ] ,
Lexem 9 Current token='a' value='names' Tokenstr |c(f(s(d),a| translated: assert ( filter ( bz [ 0 ] , names
Lexem 10 Current token=')' value=')' Tokenstr |c(f(s(d),a)| translated: assert ( filter ( bz [ 0 ] , names )
Lexem 11 Current token=')' value=')' Tokenstr |c(f(s(d),a))| translated: assert ( filter ( bz [ 0 ] , names ) )
Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='s' value='string' Tokenstr |ts| translated:  string
Lexem 2 Current token='=' value='=' Tokenstr |ts=| translated:  string =
Lexem 3 Current token='"' value=''the quick brown fox jumped over the lazy dog'' Tokenstr |ts="| translated:  string = 'the quick brown fox jumped over the lazy dog'
Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='s' value='count_the_fox' Tokenstr |ts| translated:  count_the_fox
Lexem 2 Current token='=' value='=' Tokenstr |ts=| translated:  count_the_fox =
Lexem 3 Current token='s' value='string' Tokenstr |ts=s| translated:  count_the_fox = string
Lexem 4 Current token='~' value='' Tokenstr |ts=s~| translated:  count_the_fox = string 
Lexem 5 Current token='q' value='(_m:=re.search(r'\s+([a-z][a-z]x)\s+',' Tokenstr |ts=s~q| translated:  count_the_fox = string  (_m:=re.search(r'\s+([a-z][a-z]x)\s+',
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='count_the_fox' Tokenstr |c(s| translated: assert ( count_the_fox
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( count_the_fox ==
Lexem 4 Current token='d' value='1' Tokenstr |c(s>d| translated: assert ( count_the_fox == 1
Lexem 5 Current token=')' value=')' Tokenstr |c(s>d)| translated: assert ( count_the_fox == 1 )
Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='(' value='(' Tokenstr |t(| translated:  (
Lexem 2 Current token='s' value='find_the_fox' Tokenstr |t(s| translated:  ( find_the_fox
Lexem 3 Current token=')' value=')' Tokenstr |t(s)| translated:  ( find_the_fox )
Lexem 4 Current token='=' value='=' Tokenstr |t(s)=| translated:  ( find_the_fox ) =
Lexem 5 Current token='s' value='string' Tokenstr |t(s)=s| translated:  ( find_the_fox ) = string
Lexem 6 Current token='~' value='' Tokenstr |t(s)=s~| translated:  ( find_the_fox ) = string 
Lexem 7 Current token='q' value='(_m:=re.search(r'\s+([a-z][a-z]x)\s+',' Tokenstr |t(s)=s~q| translated:  ( find_the_fox ) = string  (_m:=re.search(r'\s+([a-z][a-z]x)\s+',
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='find_the_fox' Tokenstr |c(s| translated: assert ( find_the_fox
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( find_the_fox ==
Lexem 4 Current token='"' value=''fox'' Tokenstr |c(s>"| translated: assert ( find_the_fox == 'fox'
Lexem 5 Current token=')' value=')' Tokenstr |c(s>")| translated: assert ( find_the_fox == 'fox' )
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='i' value='my_add' Tokenstr |c(i| translated: assert ( my_add
Lexem 3 Current token='(' value='(' Tokenstr |c(i(| translated: assert ( my_add (
Lexem 4 Current token='d' value='1' Tokenstr |c(i(d| translated: assert ( my_add ( 1
Lexem 5 Current token=',' value=',' Tokenstr |c(i(d,| translated: assert ( my_add ( 1 ,
Lexem 6 Current token='d' value='2' Tokenstr |c(i(d,d| translated: assert ( my_add ( 1 , 2
Lexem 7 Current token=')' value=')' Tokenstr |c(i(d,d)| translated: assert ( my_add ( 1 , 2 )
Lexem 8 Current token='>' value='==' Tokenstr |c(i(d,d)>| translated: assert ( my_add ( 1 , 2 ) ==
Lexem 9 Current token='d' value='3' Tokenstr |c(i(d,d)>d| translated: assert ( my_add ( 1 , 2 ) == 3
Lexem 10 Current token=')' value=')' Tokenstr |c(i(d,d)>d)| translated: assert ( my_add ( 1 , 2 ) == 3 )
Lexem 0 Current token='k' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' value='my_add' Tokenstr |ki| translated: def my_add
Lexem 0 Current token='s' value='op1' Tokenstr |s| translated: op1
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: op1 =
Lexem 2 Current token='f' value='.pop(0)' Tokenstr |s=f| translated: op1 = .pop(0)
Lexem 0 Current token='s' value='op2' Tokenstr |s| translated: op2
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: op2 =
Lexem 2 Current token='f' value='.pop(0)' Tokenstr |s=f| translated: op2 = .pop(0)
Lexem 0 Current token='k' value='return' Tokenstr |k| translated: return
Lexem 1 Current token='c' value='if ' Tokenstr |kc| translated: return if 
Lexem 2 Current token='(' value='(' Tokenstr |kc(| translated: return if  (
Lexem 3 Current token='!' value='not' Tokenstr |kc(!| translated: return if  ( not
Lexem 4 Current token='f' value='perl_defined' Tokenstr |kc(!f| translated: return if  ( not perl_defined
Lexem 5 Current token='s' value='op1' Tokenstr |kc(!fs| translated: return if  ( not perl_defined op1
Lexem 6 Current token=')' value=')' Tokenstr |kc(!fs)| translated: return if  ( not perl_defined op1 )
Lexem 0 Current token='k' value='return' Tokenstr |k| translated: return
Lexem 1 Current token='c' value='if ' Tokenstr |kc| translated: return if 
Lexem 2 Current token='(' value='(' Tokenstr |kc(| translated: return if  (
Lexem 3 Current token='!' value='not' Tokenstr |kc(!| translated: return if  ( not
Lexem 4 Current token='f' value='perl_defined' Tokenstr |kc(!f| translated: return if  ( not perl_defined
Lexem 5 Current token='s' value='op2' Tokenstr |kc(!fs| translated: return if  ( not perl_defined op2
Lexem 6 Current token=')' value=')' Tokenstr |kc(!fs)| translated: return if  ( not perl_defined op2 )
Lexem 0 Current token='s' value='op1' Tokenstr |s| translated: op1
Lexem 1 Current token='+' value='+' Tokenstr |s+| translated: op1 +
Lexem 2 Current token='s' value='op2' Tokenstr |s+s| translated: op1 + op2
Lexem 0 Current token='f' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='f' value='' Tokenstr |ff| translated: print 
Lexem 2 Current token='(' value='(' Tokenstr |ff(| translated: print  (
Lexem 3 Current token='s' value='__file__' Tokenstr |ff(s| translated: print  ( __file__
Lexem 4 Current token=',' value=',' Tokenstr |ff(s,| translated: print  ( __file__ ,
Lexem 5 Current token='d' value='1' Tokenstr |ff(s,d| translated: print  ( __file__ , 1
Lexem 6 Current token=')' value=')' Tokenstr |ff(s,d)| translated: print  ( __file__ , 1 )
Lexem 7 Current token='.' value=' + ' Tokenstr |ff(s,d).| translated: print  ( __file__ , 1 )  + 
Lexem 8 Current token='"' value='' - test passed!\n'' Tokenstr |ff(s,d)."| translated: print  ( __file__ , 1 )  +  ' - test passed!\n'
VarSubMap = $VAR1 = {
  'op1' => {
    'my_add' => '+'
  },
  'i' => {
    'main' => '+'
  },
  'numbers' => {
    'main' => '+'
  },
  'op2' => {
    'my_add' => '+'
  },
  'lc2' => {
    'main' => '+'
  },
  'c' => {
    'main' => '+'
  },
  'python' => {
    'myF' => '+',
    'main' => '+'
  },
  'tester' => {
    'main' => '+'
  },
  'bz' => {
    'main' => '+'
  },
  'OS_ERROR' => {
    'main' => '+'
  },
  'chars' => {
    'main' => '+'
  },
  'line' => {
    'main' => '+'
  },
  'AUTODIE' => {
    'main' => '+'
  },
  'TRACEBACK' => {
    'main' => '+'
  },
  'LIST_SEPARATOR' => {
    'main' => '+'
  },
  '_script_start' => {
    'main' => '+'
  }
};


DETECTED GLOBAL VARIABLES:
	main: global python
	myF: global python

List of local subroutines:
myF my_add main
mkdir: cannot create directory ‘/c/Users/Joe’: File exists
cp: target 'Orost/Archive/pythonizer' is not a directory
cp: target 'Orost/Archive/Softpano.pm' is not a directory
cp: target 'Orost/Archive/Perlscan.pm' is not a directory
cp: target 'Orost/Archive/Pythonizer.pm' is not a directory
   1 | 0 |   |#!/usr/bin/python3 -u
   1 | 0 |   |# Generated by pythonizer 0.916 run by Joe Orost on Fri Dec  3 00:26:23 2021
   1 | 0 |   |# issue 32 - let user define the variable translations
   2 | 0 |   |import sys,os,re,fcntl,math,fileinput,subprocess,inspect,collections.abc,argparse,glob,warnings,inspect,functools,signal,traceback
   2 | 0 |   |import time as tm_py
   2 | 0 |   |AUTODIE = 1
   2 | 0 |   |LIST_SEPARATOR = ' '
   2 | 0 |   |_script_start = tm_py.time()
   2 | 0 |   |TRACEBACK = 1
   2 | 0 |   |OS_ERROR = ''
   2 | 0 |   |class Die(Exception):
    def __init(self, arg):
        traceback.print_stack()
   2 | 0 |   |class EvalReturn(Exception):
    pass
   2 | 0 |   |_args = sys.argv[1:]
Main loop, line=use Carp::Assert;


 === Line 2 Perl source:use Carp::Assert;===

Lexem 0 Current token='c' value='NoTrans!' Tokenstr |c| translated: NoTrans!
Lexem 1 Current token='i' value='Carp.Assert' Tokenstr |ci| translated: NoTrans! Carp.Assert

Line:    2 TokenStr: =|ci|= @ValPy: NoTrans! Carp.Assert
   2 | 0 |   |#SKIPPED: use Carp::Assert;
Main loop, line=$python = $0 =~ /\.py$/;


 === Line 3 Perl source:$python = $0 =~ /\.py$/;===

Lexem 0 Current token='s' value='python' Tokenstr |s| translated: python
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: python =
Lexem 2 Current token='s' value='__file__' Tokenstr |s=s| translated: python = __file__
Lexem 3 Current token='~' value='' Tokenstr |s=s~| translated: python = __file__ 
Lexem 4 Current token='q' value='re.search(r'\.py$',' Tokenstr |s=s~q| translated: python = __file__  re.search(r'\.py$',

Line:    3 TokenStr: =|s=s~q|= @ValPy: python = __file__  re.search(r'\.py$',
assignment(0, 4) =|s=s~q|= $python = 0 =~ \.py$

Generated partial line python
Generated partial line python=
expression(2, 4, 0) =|s=s~q|= $python = 0 =~ \.py$

Generated partial line python=re.search(r'\.py$',
expression(2, 2, 0) =|s=s~q|= $python = 0 =~ \.py$

Generated partial line python=re.search(r'\.py$',__file__
expression returns 3
Generated partial line python=re.search(r'\.py$',__file__)
expression returns 5
   3 | 0 |   |python = re.search(r'\.py$',__file__)                                                   #PL: $python = $0 =~ /\.py$/;

Tokens: s=s~q ValPy: 
Main loop, line=$a = 1;


 === Line 4 Perl source:$a = 1;===

Lexem 0 Current token='s' value='a' Tokenstr |s| translated: a
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: a =
Lexem 2 Current token='d' value='1' Tokenstr |s=d| translated: a = 1

Line:    4 TokenStr: =|s=d|= @ValPy: a = 1
assignment(0, 2) =|s=d|= $a = 1

Generated partial line a
Generated partial line a=
assign, ValClass[limit] = d, ValPy=1, ValPerl=1

Generated partial line a=1
   4 | 0 |   |a = 1                                                                                   #PL: $a = 1;

Tokens: s=d ValPy: 
Main loop, line=$b = 2;


 === Line 5 Perl source:$b = 2;===

Lexem 0 Current token='s' value='b' Tokenstr |s| translated: b
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: b =
Lexem 2 Current token='d' value='2' Tokenstr |s=d| translated: b = 2

Line:    5 TokenStr: =|s=d|= @ValPy: b = 2
assignment(0, 2) =|s=d|= $b = 2

Generated partial line b
Generated partial line b=
assign, ValClass[limit] = d, ValPy=2, ValPerl=2

Generated partial line b=2
   5 | 0 |   |b = 2                                                                                   #PL: $b = 2;

Tokens: s=d ValPy: 
Main loop, line=assert($a+1 == $b);


 === Line 6 Perl source:assert($a+1 == $b);===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='a' Tokenstr |c(s| translated: assert ( a
Lexem 3 Current token='+' value='+' Tokenstr |c(s+| translated: assert ( a +
Lexem 4 Current token='d' value='1' Tokenstr |c(s+d| translated: assert ( a + 1
Lexem 5 Current token='>' value='==' Tokenstr |c(s+d>| translated: assert ( a + 1 ==
Lexem 6 Current token='s' value='b' Tokenstr |c(s+d>s| translated: assert ( a + 1 == b
Lexem 7 Current token=')' value=')' Tokenstr |c(s+d>s)| translated: assert ( a + 1 == b )

Line:    6 TokenStr: =|c(s+d>s)|= @ValPy: assert ( a + 1 == b )
control(0) =|c(s+d>s)|= assert ( $a + 1 == $b )

control-parens removed, begin=0 start=1 =|cs+d>s|= assert $a + 1 == $b

Generated partial line assert
expression(1, 5, 0) =|cs+d>s|= assert $a + 1 == $b

Generated partial line asserta
Generated partial line asserta+
Generated partial line asserta+1
Generated partial line asserta+1==
Generated partial line asserta+1==b
expression returns 6
   6 | 0 |   |assert a+1==b                                                                           #PL: assert($a+1 == $b);

Tokens: cs+d>s ValPy: 
Main loop, line=$_ = 'abc';


 === Line 7 Perl source:$_ = 'abc';===

Lexem 0 Current token='s' value='_d' Tokenstr |s| translated: _d
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: _d =
Lexem 2 Current token='"' value=''abc'' Tokenstr |s="| translated: _d = 'abc'

Line:    7 TokenStr: =|s="|= @ValPy: _d = 'abc'
assignment(0, 2) =|s="|= $_ = abc

Generated partial line _d
Generated partial line _d=
assign, ValClass[limit] = ", ValPy='abc', ValPerl=abc

Generated partial line _d='abc'
   7 | 0 |   |_d = 'abc'                                                                              #PL: $_ = 'abc';

Tokens: s=" ValPy: 
Main loop, line=my @fields = split /b/;


 === Line 8 Perl source:my @fields = split /b/;===

Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' value='fields' Tokenstr |ta| translated:  fields
Lexem 2 Current token='=' value='=' Tokenstr |ta=| translated:  fields =
Lexem 3 Current token='f' value='re.split' Tokenstr |ta=f| translated:  fields = re.split
Lexem 4 Current token='q' value='r'b'' Tokenstr |ta=fq| translated:  fields = re.split r'b'

Line:    8 TokenStr: =|ta=fq|= @ValPy:  fields = re.split r'b'
assignment(0, 3) =|a=fq|=  = split /b/; = split b

Generated partial line fields
Generated partial line fields=
expression(2, 3, 0) =|a=fq|=  = split /b/; = split b

function(2, 3) =|a=fq|=  = split /b/; = split b

function start=3, end_pos=3, bracketed=0
Generated partial line fields=re.split(r'b',_d)
expression returns 4
   8 | 0 |   |fields = re.split(r'b',_d)                                                              #PL: my @fields = split /b/;

Tokens: a=fq ValPy: 
Main loop, line=assert(scalar(@fields) == 2 && $fields[0] eq 'a' && $fields[1] eq 'c');


 === Line 9 Perl source:assert(scalar(@fields) == 2 && $fields[0] eq 'a' && $fields[1] eq 'c');===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='len' Tokenstr |c(f| translated: assert ( len
Lexem 3 Current token='(' value='(' Tokenstr |c(f(| translated: assert ( len (
Lexem 4 Current token='a' value='fields' Tokenstr |c(f(a| translated: assert ( len ( fields
Lexem 5 Current token=')' value=')' Tokenstr |c(f(a)| translated: assert ( len ( fields )
Lexem 6 Current token='>' value='==' Tokenstr |c(f(a)>| translated: assert ( len ( fields ) ==
Lexem 7 Current token='d' value='2' Tokenstr |c(f(a)>d| translated: assert ( len ( fields ) == 2
Lexem 8 Current token='0' value=' and ' Tokenstr |c(f(a)>d0| translated: assert ( len ( fields ) == 2  and 
Lexem 9 Current token='s' value='fields' Tokenstr |c(f(a)>d0s| translated: assert ( len ( fields ) == 2  and  fields
Lexem 10 Current token='(' value='[' Tokenstr |c(f(a)>d0s(| translated: assert ( len ( fields ) == 2  and  fields [
Lexem 11 Current token='d' value='0' Tokenstr |c(f(a)>d0s(d| translated: assert ( len ( fields ) == 2  and  fields [ 0
Lexem 12 Current token=')' value=']' Tokenstr |c(f(a)>d0s(d)| translated: assert ( len ( fields ) == 2  and  fields [ 0 ]
Lexem 13 Current token='>' value='==' Tokenstr |c(f(a)>d0s(d)>| translated: assert ( len ( fields ) == 2  and  fields [ 0 ] ==
Lexem 14 Current token='"' value=''a'' Tokenstr |c(f(a)>d0s(d)>"| translated: assert ( len ( fields ) == 2  and  fields [ 0 ] == 'a'
Lexem 15 Current token='0' value=' and ' Tokenstr |c(f(a)>d0s(d)>"0| translated: assert ( len ( fields ) == 2  and  fields [ 0 ] == 'a'  and 
Lexem 16 Current token='s' value='fields' Tokenstr |c(f(a)>d0s(d)>"0s| translated: assert ( len ( fields ) == 2  and  fields [ 0 ] == 'a'  and  fields
Lexem 17 Current token='(' value='[' Tokenstr |c(f(a)>d0s(d)>"0s(| translated: assert ( len ( fields ) == 2  and  fields [ 0 ] == 'a'  and  fields [
Lexem 18 Current token='d' value='1' Tokenstr |c(f(a)>d0s(d)>"0s(d| translated: assert ( len ( fields ) == 2  and  fields [ 0 ] == 'a'  and  fields [ 1
Lexem 19 Current token=')' value=']' Tokenstr |c(f(a)>d0s(d)>"0s(d)| translated: assert ( len ( fields ) == 2  and  fields [ 0 ] == 'a'  and  fields [ 1 ]
Lexem 20 Current token='>' value='==' Tokenstr |c(f(a)>d0s(d)>"0s(d)>| translated: assert ( len ( fields ) == 2  and  fields [ 0 ] == 'a'  and  fields [ 1 ] ==
Lexem 21 Current token='"' value=''c'' Tokenstr |c(f(a)>d0s(d)>"0s(d)>"| translated: assert ( len ( fields ) == 2  and  fields [ 0 ] == 'a'  and  fields [ 1 ] == 'c'
Lexem 22 Current token=')' value=')' Tokenstr |c(f(a)>d0s(d)>"0s(d)>")| translated: assert ( len ( fields ) == 2  and  fields [ 0 ] == 'a'  and  fields [ 1 ] == 'c' )

Line:    9 TokenStr: =|c(f(a)>d0s(d)>"0s(d)>")|= @ValPy: assert ( len ( fields ) == 2  and  fields [ 0 ] == 'a'  and  fields [ 1 ] == 'c' )
control(0) =|c(f(a)>d0s(d)>"0s(d)>")|= assert ( scalar ( ) == 2 && $fields[0] eq 'a' && $fields[1] eq 'c'); ) == 2 && $fields [ 0 ] eq a && $fields [ 1 ] eq c )

control-parens removed, begin=0 start=1 =|cf(a)>d0s(d)>"0s(d)>"|= assert scalar ( ) == 2 && $fields[0] eq 'a' && $fields[1] eq 'c'); ) == 2 && $fields [ 0 ] eq a && $fields [ 1 ] eq c

Generated partial line assert
expression(1, 20, 0) =|cf(a)>d0s(d)>"0s(d)>"|= assert scalar ( ) == 2 && $fields[0] eq 'a' && $fields[1] eq 'c'); ) == 2 && $fields [ 0 ] eq a && $fields [ 1 ] eq c

function(1, 7) =|cf(a)>d0s(d)>"0s(d)>"|= assert scalar ( ) == 2 && $fields[0] eq 'a' && $fields[1] eq 'c'); ) == 2 && $fields [ 0 ] eq a && $fields [ 1 ] eq c

function start=3, end_pos=3, bracketed=1
Generated partial line assertlen
Generated partial line assertlen(
expression(3, 3, 0) =|cf(a)>d0s(d)>"0s(d)>"|= assert scalar ( ) == 2 && $fields[0] eq 'a' && $fields[1] eq 'c'); ) == 2 && $fields [ 0 ] eq a && $fields [ 1 ] eq c

Generated partial line assertlen(fields
expression returns 4
Generated partial line assertlen(fields)
Generated partial line assertlen(fields)==
Generated partial line assertlen(fields)==2
Generated partial line assertlen(fields)==2 and 
Generated partial line assertlen(fields)==2 and fields
Generated partial line assertlen(fields)==2 and fields[
expression(10, 10, 0) =|cf(a)>d0s(d)>"0s(d)>"|= assert scalar ( ) == 2 && $fields[0] eq 'a' && $fields[1] eq 'c'); ) == 2 && $fields [ 0 ] eq a && $fields [ 1 ] eq c

Generated partial line assertlen(fields)==2 and fields[0
expression returns 11
Generated partial line assertlen(fields)==2 and fields[0]
Generated partial line assertlen(fields)==2 and fields[0]==
Generated partial line assertlen(fields)==2 and fields[0]=='a'
Generated partial line assertlen(fields)==2 and fields[0]=='a' and 
Generated partial line assertlen(fields)==2 and fields[0]=='a' and fields
Generated partial line assertlen(fields)==2 and fields[0]=='a' and fields[
expression(17, 17, 0) =|cf(a)>d0s(d)>"0s(d)>"|= assert scalar ( ) == 2 && $fields[0] eq 'a' && $fields[1] eq 'c'); ) == 2 && $fields [ 0 ] eq a && $fields [ 1 ] eq c

Generated partial line assertlen(fields)==2 and fields[0]=='a' and fields[1
expression returns 18
Generated partial line assertlen(fields)==2 and fields[0]=='a' and fields[1]
Generated partial line assertlen(fields)==2 and fields[0]=='a' and fields[1]==
Generated partial line assertlen(fields)==2 and fields[0]=='a' and fields[1]=='c'
expression returns 21
   9 | 0 |   |assert len(fields)==2 and fields[0]=='a' and fields[1]=='c'                             #PL: assert(scalar(@fields) == 2 && $fields[0] eq 'a' && $fields[1] eq 'c');

Tokens: cf(a)>d0s(d)>"0s(d)>" ValPy: 
Main loop, line=foreach (@fields) {


 === Line 10 Perl source:foreach (@fields) {===

Lexem 0 Current token='c' value='for ' Tokenstr |c| translated: for 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: for  (
Lexem 2 Current token='a' value='fields' Tokenstr |c(a| translated: for  ( fields
Lexem 3 Current token=')' value=')' Tokenstr |c(a)| translated: for  ( fields )

Line:   10 TokenStr: =|c(a)|= @ValPy: for  ( fields )
control(0) =|c(a)|= foreach ( ) { )

control-parens removed, begin=0 start=1 =|ca|= foreach ) {

Generated partial line for 
Generated partial line for _d in 
Generated partial line for _d in fields
Generated partial line for _d in fields:
  10 | 0 |   |for _d in fields:                                                                       #PL: foreach (@fields) {

Tokens: c(a) ValPy: 
Main loop, line={


 === Line 10 Perl source:{===


Line:   10 TokenStr: =|{|= @ValPy: {
Main loop, line=assert($_ eq 'a' || $_ eq 'c');


 === Line 11 Perl source:assert($_ eq 'a' || $_ eq 'c');===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='_d' Tokenstr |c(s| translated: assert ( _d
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( _d ==
Lexem 4 Current token='"' value=''a'' Tokenstr |c(s>"| translated: assert ( _d == 'a'
Lexem 5 Current token='0' value=' or ' Tokenstr |c(s>"0| translated: assert ( _d == 'a'  or 
Lexem 6 Current token='s' value='_d' Tokenstr |c(s>"0s| translated: assert ( _d == 'a'  or  _d
Lexem 7 Current token='>' value='==' Tokenstr |c(s>"0s>| translated: assert ( _d == 'a'  or  _d ==
Lexem 8 Current token='"' value=''c'' Tokenstr |c(s>"0s>"| translated: assert ( _d == 'a'  or  _d == 'c'
Lexem 9 Current token=')' value=')' Tokenstr |c(s>"0s>")| translated: assert ( _d == 'a'  or  _d == 'c' )

Line:   11 TokenStr: =|c(s>"0s>")|= @ValPy: assert ( _d == 'a'  or  _d == 'c' )
control(0) =|c(s>"0s>")|= assert ( $_ eq a || $_ eq c )

control-parens removed, begin=0 start=1 =|cs>"0s>"|= assert $_ eq a || $_ eq c

Generated partial line assert
expression(1, 7, 0) =|cs>"0s>"|= assert $_ eq a || $_ eq c

Generated partial line assert_d
Generated partial line assert_d==
Generated partial line assert_d=='a'
Generated partial line assert_d=='a' or 
Generated partial line assert_d=='a' or _d
Generated partial line assert_d=='a' or _d==
Generated partial line assert_d=='a' or _d=='c'
expression returns 8
  11 | 1 |   |    assert _d=='a' or _d=='c'                                                           #PL: assert($_ eq 'a' || $_ eq 'c');

Tokens: cs>"0s>" ValPy: 
Main loop, line=}


 === Line 12 Perl source:}===


Line:   12 TokenStr: =|}|= @ValPy: }
Main loop, line=$_ = "abc\n";


 === Line 13 Perl source:$_ = "abc\n";===

Lexem 0 Current token='s' value='_d' Tokenstr |s| translated: _d
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: _d =
Lexem 2 Current token='"' value=''abc\n'' Tokenstr |s="| translated: _d = 'abc\n'

Line:   13 TokenStr: =|s="|= @ValPy: _d = 'abc\n'
assignment(0, 2) =|s="|= $_ = abc\n

Generated partial line _d
Generated partial line _d=
assign, ValClass[limit] = ", ValPy='abc\n', ValPerl=abc\n

Generated partial line _d='abc\n'
  13 | 0 |   |_d = 'abc\n'                                                                            #PL: $_ = "abc\n";

Tokens: s=" ValPy: 
Main loop, line=chomp;


 === Line 14 Perl source:chomp;===

Lexem 0 Current token='f' value='.rstrip("\n")' Tokenstr |f| translated: .rstrip("\n")

Line:   14 TokenStr: =|f|= @ValPy: .rstrip("\n")
Generated partial line _d=_d.rstrip("\n")
  14 | 0 |   |_d=_d.rstrip("\n")                                                                      #PL: chomp;

Tokens: f ValPy: 
Main loop, line=assert($_ eq 'abc');


 === Line 15 Perl source:assert($_ eq 'abc');===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='_d' Tokenstr |c(s| translated: assert ( _d
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( _d ==
Lexem 4 Current token='"' value=''abc'' Tokenstr |c(s>"| translated: assert ( _d == 'abc'
Lexem 5 Current token=')' value=')' Tokenstr |c(s>")| translated: assert ( _d == 'abc' )

Line:   15 TokenStr: =|c(s>")|= @ValPy: assert ( _d == 'abc' )
control(0) =|c(s>")|= assert ( $_ eq abc )

control-parens removed, begin=0 start=1 =|cs>"|= assert $_ eq abc

Generated partial line assert
expression(1, 3, 0) =|cs>"|= assert $_ eq abc

Generated partial line assert_d
Generated partial line assert_d==
Generated partial line assert_d=='abc'
expression returns 4
  15 | 0 |   |assert _d=='abc'                                                                        #PL: assert($_ eq 'abc');

Tokens: cs>" ValPy: 
Main loop, line=chop;


 === Line 16 Perl source:chop;===

Lexem 0 Current token='f' value='[0:-1]' Tokenstr |f| translated: [0:-1]

Line:   16 TokenStr: =|f|= @ValPy: [0:-1]
Generated partial line _d = _d[0:-1]
  16 | 0 |   |_d = _d[0:-1]                                                                           #PL: chop;

Tokens: f ValPy: 
Main loop, line=assert($_ eq 'ab');


 === Line 17 Perl source:assert($_ eq 'ab');===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='_d' Tokenstr |c(s| translated: assert ( _d
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( _d ==
Lexem 4 Current token='"' value=''ab'' Tokenstr |c(s>"| translated: assert ( _d == 'ab'
Lexem 5 Current token=')' value=')' Tokenstr |c(s>")| translated: assert ( _d == 'ab' )

Line:   17 TokenStr: =|c(s>")|= @ValPy: assert ( _d == 'ab' )
control(0) =|c(s>")|= assert ( $_ eq ab )

control-parens removed, begin=0 start=1 =|cs>"|= assert $_ eq ab

Generated partial line assert
expression(1, 3, 0) =|cs>"|= assert $_ eq ab

Generated partial line assert_d
Generated partial line assert_d==
Generated partial line assert_d=='ab'
expression returns 4
  17 | 0 |   |assert _d=='ab'                                                                         #PL: assert($_ eq 'ab');

Tokens: cs>" ValPy: 
Main loop, line=assert($line = /b/);


 === Line 18 Perl source:assert($line = /b/);===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='line' Tokenstr |c(s| translated: assert ( line
Lexem 3 Current token='=' value=':=' Tokenstr |c(s=| translated: assert ( line :=
Lexem 4 Current token='q' value='re.search(r'b',_d)' Tokenstr |c(s=q| translated: assert ( line := re.search(r'b',_d)
Lexem 5 Current token=')' value=')' Tokenstr |c(s=q)| translated: assert ( line := re.search(r'b',_d) )

Line:   18 TokenStr: =|c(s=q)|= @ValPy: assert ( line := re.search(r'b',_d) )
control(0) =|c(s=q)|= assert ( $line = b )

Generated partial line assert
expression(1, 5, 0) =|c(s=q)|= assert ( $line = b )

Generated partial line assert(
expression(2, 4, 0) =|c(s=q)|= assert ( $line = b )

Generated partial line assert(line
Generated partial line assert(line:=
Generated partial line assert(line:=re.search(r'b',_d)
expression returns 5
Generated partial line assert(line:=re.search(r'b',_d))
expression returns 6
  18 | 0 |   |assert (line:=re.search(r'b',_d))                                                       #PL: assert($line = /b/);

Tokens: c(s=q) ValPy: 
Main loop, line=assert($line);


 === Line 19 Perl source:assert($line);===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='line' Tokenstr |c(s| translated: assert ( line
Lexem 3 Current token=')' value=')' Tokenstr |c(s)| translated: assert ( line )

Line:   19 TokenStr: =|c(s)|= @ValPy: assert ( line )
control(0) =|c(s)|= assert ( $line )

control-parens removed, begin=0 start=1 =|cs|= assert $line

Generated partial line assert
expression(1, 1, 0) =|cs|= assert $line

Generated partial line assertline
expression returns 2
  19 | 0 |   |assert line                                                                             #PL: assert($line);

Tokens: cs ValPy: 
Main loop, line=$_ = 'a';


 === Line 20 Perl source:$_ = 'a';===

Lexem 0 Current token='s' value='_d' Tokenstr |s| translated: _d
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: _d =
Lexem 2 Current token='"' value=''a'' Tokenstr |s="| translated: _d = 'a'

Line:   20 TokenStr: =|s="|= @ValPy: _d = 'a'
assignment(0, 2) =|s="|= $_ = a

Generated partial line _d
Generated partial line _d=
assign, ValClass[limit] = ", ValPy='a', ValPerl=a

Generated partial line _d='a'
  20 | 0 |   |_d = 'a'                                                                                #PL: $_ = 'a';

Tokens: s=" ValPy: 
Main loop, line=$i = ord;


 === Line 21 Perl source:$i = ord;===

Lexem 0 Current token='s' value='i' Tokenstr |s| translated: i
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: i =
Lexem 2 Current token='f' value='ord' Tokenstr |s=f| translated: i = ord

Line:   21 TokenStr: =|s=f|= @ValPy: i = ord
assignment(0, 2) =|s=f|= $i = ord

Generated partial line i
Generated partial line i=
assign, ValClass[limit] = f, ValPy=ord, ValPerl=ord

function(2, 2) =|s=f|= $i = ord

function start=3, end_pos=2, bracketed=-1
Generated partial line i=ord(_d)
  21 | 0 |   |i = ord(_d)                                                                             #PL: $i = ord;

Tokens: s=f ValPy: 
Main loop, line=assert($i == 97);


 === Line 22 Perl source:assert($i == 97);===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='i' Tokenstr |c(s| translated: assert ( i
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( i ==
Lexem 4 Current token='d' value='97' Tokenstr |c(s>d| translated: assert ( i == 97
Lexem 5 Current token=')' value=')' Tokenstr |c(s>d)| translated: assert ( i == 97 )

Line:   22 TokenStr: =|c(s>d)|= @ValPy: assert ( i == 97 )
control(0) =|c(s>d)|= assert ( $i == 97 )

control-parens removed, begin=0 start=1 =|cs>d|= assert $i == 97

Generated partial line assert
expression(1, 3, 0) =|cs>d|= assert $i == 97

Generated partial line asserti
Generated partial line asserti==
Generated partial line asserti==97
expression returns 4
  22 | 0 |   |assert i==97                                                                            #PL: assert($i == 97);

Tokens: cs>d ValPy: 
Main loop, line=assert(ord == 97);


 === Line 23 Perl source:assert(ord == 97);===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='ord' Tokenstr |c(f| translated: assert ( ord
Lexem 3 Current token='>' value='==' Tokenstr |c(f>| translated: assert ( ord ==
Lexem 4 Current token='d' value='97' Tokenstr |c(f>d| translated: assert ( ord == 97
Lexem 5 Current token=')' value=')' Tokenstr |c(f>d)| translated: assert ( ord == 97 )

Line:   23 TokenStr: =|c(f>d)|= @ValPy: assert ( ord == 97 )
control(0) =|c(f>d)|= assert ( ord == 97 )

control-parens removed, begin=0 start=1 =|cf>d|= assert ord == 97

Generated partial line assert
expression(1, 3, 0) =|cf>d|= assert ord == 97

function(1, 3) =|cf>d|= assert ord == 97

function start=2, end_pos=1, bracketed=-1
Generated partial line assertord(_d)
Generated partial line assertord(_d)==
Generated partial line assertord(_d)==97
expression returns 4
  23 | 0 |   |assert ord(_d)==97                                                                      #PL: assert(ord == 97);

Tokens: cf>d ValPy: 
Main loop, line=assert(ord $_ == 97);


 === Line 24 Perl source:assert(ord $_ == 97);===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='ord' Tokenstr |c(f| translated: assert ( ord
Lexem 3 Current token='s' value='_d' Tokenstr |c(fs| translated: assert ( ord _d
Lexem 4 Current token='>' value='==' Tokenstr |c(fs>| translated: assert ( ord _d ==
Lexem 5 Current token='d' value='97' Tokenstr |c(fs>d| translated: assert ( ord _d == 97
Lexem 6 Current token=')' value=')' Tokenstr |c(fs>d)| translated: assert ( ord _d == 97 )

Line:   24 TokenStr: =|c(fs>d)|= @ValPy: assert ( ord _d == 97 )
control(0) =|c(fs>d)|= assert ( ord $_ == 97 )

control-parens removed, begin=0 start=1 =|cfs>d|= assert ord $_ == 97

Generated partial line assert
expression(1, 4, 0) =|cfs>d|= assert ord $_ == 97

function(1, 4) =|cfs>d|= assert ord $_ == 97

function start=2, end_pos=2, bracketed=0
Generated partial line assertord(
expression(2, 2, 0) =|cfs>d|= assert ord $_ == 97

Generated partial line assertord(_d
expression returns 3
Generated partial line assertord(_d)
Generated partial line assertord(_d)==
Generated partial line assertord(_d)==97
expression returns 5
  24 | 0 |   |assert ord(_d)==97                                                                      #PL: assert(ord $_ == 97);

Tokens: cfs>d ValPy: 
Main loop, line=assert(ord($_) == 97);


 === Line 25 Perl source:assert(ord($_) == 97);===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='ord' Tokenstr |c(f| translated: assert ( ord
Lexem 3 Current token='(' value='(' Tokenstr |c(f(| translated: assert ( ord (
Lexem 4 Current token='s' value='_d' Tokenstr |c(f(s| translated: assert ( ord ( _d
Lexem 5 Current token=')' value=')' Tokenstr |c(f(s)| translated: assert ( ord ( _d )
Lexem 6 Current token='>' value='==' Tokenstr |c(f(s)>| translated: assert ( ord ( _d ) ==
Lexem 7 Current token='d' value='97' Tokenstr |c(f(s)>d| translated: assert ( ord ( _d ) == 97
Lexem 8 Current token=')' value=')' Tokenstr |c(f(s)>d)| translated: assert ( ord ( _d ) == 97 )

Line:   25 TokenStr: =|c(f(s)>d)|= @ValPy: assert ( ord ( _d ) == 97 )
control(0) =|c(f(s)>d)|= assert ( ord ( $_ ) == 97 )

control-parens removed, begin=0 start=1 =|cf(s)>d|= assert ord ( $_ ) == 97

Generated partial line assert
expression(1, 6, 0) =|cf(s)>d|= assert ord ( $_ ) == 97

function(1, 6) =|cf(s)>d|= assert ord ( $_ ) == 97

function start=3, end_pos=3, bracketed=1
Generated partial line assertord(
expression(3, 3, 0) =|cf(s)>d|= assert ord ( $_ ) == 97

Generated partial line assertord(_d
expression returns 4
Generated partial line assertord(_d)
Generated partial line assertord(_d)==
Generated partial line assertord(_d)==97
expression returns 7
  25 | 0 |   |assert ord(_d)==97                                                                      #PL: assert(ord($_) == 97);

Tokens: cf(s)>d ValPy: 
Main loop, line=$_ = 97;


 === Line 26 Perl source:$_ = 97;===

Lexem 0 Current token='s' value='_d' Tokenstr |s| translated: _d
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: _d =
Lexem 2 Current token='d' value='97' Tokenstr |s=d| translated: _d = 97

Line:   26 TokenStr: =|s=d|= @ValPy: _d = 97
assignment(0, 2) =|s=d|= $_ = 97

Generated partial line _d
Generated partial line _d=
assign, ValClass[limit] = d, ValPy=97, ValPerl=97

Generated partial line _d=97
  26 | 0 |   |_d = 97                                                                                 #PL: $_ = 97;

Tokens: s=d ValPy: 
Main loop, line=assert(ord chr == 97);


 === Line 27 Perl source:assert(ord chr == 97);===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='ord' Tokenstr |c(f| translated: assert ( ord
Lexem 3 Current token='f' value='chr' Tokenstr |c(ff| translated: assert ( ord chr
Lexem 4 Current token='>' value='==' Tokenstr |c(ff>| translated: assert ( ord chr ==
Lexem 5 Current token='d' value='97' Tokenstr |c(ff>d| translated: assert ( ord chr == 97
Lexem 6 Current token=')' value=')' Tokenstr |c(ff>d)| translated: assert ( ord chr == 97 )

Line:   27 TokenStr: =|c(ff>d)|= @ValPy: assert ( ord chr == 97 )
control(0) =|c(ff>d)|= assert ( ord chr == 97 )

control-parens removed, begin=0 start=1 =|cff>d|= assert ord chr == 97

Generated partial line assert
expression(1, 4, 0) =|cff>d|= assert ord chr == 97

function(1, 4) =|cff>d|= assert ord chr == 97

function start=2, end_pos=2, bracketed=0
Generated partial line assertord(
expression(2, 2, 0) =|cff>d|= assert ord chr == 97

function(2, 2) =|cff>d|= assert ord chr == 97

function start=3, end_pos=2, bracketed=-1
Generated partial line assertord(chr(_d)
expression returns 3
Generated partial line assertord(chr(_d))
Generated partial line assertord(chr(_d))==
Generated partial line assertord(chr(_d))==97
expression returns 5
  27 | 0 |   |assert ord(chr(_d))==97                                                                 #PL: assert(ord chr == 97);

Tokens: cff>d ValPy: 
Main loop, line=open(FH,'>_test.tmp');


 === Line 28 Perl source:open(FH,'>_test.tmp');===

Lexem 0 Current token='f' value='open' Tokenstr |f| translated: open
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: open (
Lexem 2 Current token='i' value='FH' Tokenstr |f(i| translated: open ( FH
Lexem 3 Current token=',' value=',' Tokenstr |f(i,| translated: open ( FH ,
Lexem 4 Current token='"' value=''>_test.tmp'' Tokenstr |f(i,"| translated: open ( FH , '>_test.tmp'
Lexem 5 Current token=')' value=')' Tokenstr |f(i,")| translated: open ( FH , '>_test.tmp' )

Line:   28 TokenStr: =|f(i,")|= @ValPy: open ( FH , '>_test.tmp' )
  28 | 0 |   |try:                                                                                    #PL: open(FH,'>_test.tmp');
  28 | 1 |   |    FH=open('_test.tmp', 'w')                                                           #PL: open(FH,'>_test.tmp');
  28 | 0 |   |except OSError as _e:                                                                   #PL: open(FH,'>_test.tmp');
  28 | 1 |   |    OS_ERROR = str(_e)                                                                  #PL: open(FH,'>_test.tmp');
  28 | 1 |   |    traceback.print_exc()                                                               #PL: open(FH,'>_test.tmp');
  28 | 1 |   |    raise                                                                               #PL: open(FH,'>_test.tmp');
Main loop, line=$_ = 'i';


 === Line 29 Perl source:$_ = 'i';===

Lexem 0 Current token='s' value='_d' Tokenstr |s| translated: _d
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: _d =
Lexem 2 Current token='"' value=''i'' Tokenstr |s="| translated: _d = 'i'

Line:   29 TokenStr: =|s="|= @ValPy: _d = 'i'
assignment(0, 2) =|s="|= $_ = i

Generated partial line _d
Generated partial line _d=
assign, ValClass[limit] = ", ValPy='i', ValPerl=i

Generated partial line _d='i'
  29 | 0 |   |_d = 'i'                                                                                #PL: $_ = 'i';

Tokens: s=" ValPy: 
Main loop, line=print;


 === Line 30 Perl source:print;===

Lexem 0 Current token='f' value='print' Tokenstr |f| translated: print

Line:   30 TokenStr: =|f|= @ValPy: print
Generated partial line print(
print3(0) handle=, k=1, end_pos=0

Generated partial line print(_d, end="")
  30 | 0 |   |print(_d, end="")                                                                       #PL: print;

Tokens: f ValPy: 
Main loop, line=$_ = 'a';


 === Line 31 Perl source:$_ = 'a';===

Lexem 0 Current token='s' value='_d' Tokenstr |s| translated: _d
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: _d =
Lexem 2 Current token='"' value=''a'' Tokenstr |s="| translated: _d = 'a'

Line:   31 TokenStr: =|s="|= @ValPy: _d = 'a'
assignment(0, 2) =|s="|= $_ = a

Generated partial line _d
Generated partial line _d=
assign, ValClass[limit] = ", ValPy='a', ValPerl=a

Generated partial line _d='a'
  31 | 0 |   |_d = 'a'                                                                                #PL: $_ = 'a';

Tokens: s=" ValPy: 
Main loop, line=print FH;


 === Line 32 Perl source:print FH;===

Lexem 0 Current token='f' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='i' value='FH' Tokenstr |fi| translated: print FH

Line:   32 TokenStr: =|fi|= @ValPy: print FH
Generated partial line print(
print3(0) handle=FH, k=2, end_pos=1

Generated partial line print(_d, file=FH, end="")
  32 | 0 |   |print(_d, file=FH, end="")                                                              #PL: print FH;

Tokens: fi ValPy: 
Use of uninitialized value $TrStatus in numeric lt (<) at /d/pythonizer/pythonizer/Pythonizer.pm line 425, <> line 33.
  33 | 0 |   |#say;           # Doesn't say anything in perl
Main loop, line=assert($_ eq 'a');


 === Line 34 Perl source:assert($_ eq 'a');===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='_d' Tokenstr |c(s| translated: assert ( _d
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( _d ==
Lexem 4 Current token='"' value=''a'' Tokenstr |c(s>"| translated: assert ( _d == 'a'
Lexem 5 Current token=')' value=')' Tokenstr |c(s>")| translated: assert ( _d == 'a' )

Line:   34 TokenStr: =|c(s>")|= @ValPy: assert ( _d == 'a' )
control(0) =|c(s>")|= assert ( $_ eq a )

control-parens removed, begin=0 start=1 =|cs>"|= assert $_ eq a

Generated partial line assert
expression(1, 3, 0) =|cs>"|= assert $_ eq a

Generated partial line assert_d
Generated partial line assert_d==
Generated partial line assert_d=='a'
expression returns 4
  34 | 0 |   |assert _d=='a'                                                                          #PL: assert($_ eq 'a');

Tokens: cs>" ValPy: 
Main loop, line=say FH;


 === Line 35 Perl source:say FH;===

Lexem 0 Current token='f' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='i' value='FH' Tokenstr |fi| translated: print FH

Line:   35 TokenStr: =|fi|= @ValPy: print FH
Generated partial line print(
print3(0) handle=FH, k=2, end_pos=1

Generated partial line print(_d, file=FH)
  35 | 0 |   |print(_d, file=FH)                                                                      #PL: say FH;

Tokens: fi ValPy: 
Main loop, line=close FH;


 === Line 36 Perl source:close FH;===

Lexem 0 Current token='f' value='.close()' Tokenstr |f| translated: .close()
Lexem 1 Current token='i' value='FH' Tokenstr |fi| translated: .close() FH

Line:   36 TokenStr: =|fi|= @ValPy: .close() FH
Generated partial line FH.close()
  36 | 0 |   |FH.close()                                                                              #PL: close FH;

Tokens: fi ValPy: 
Main loop, line=open(FH,'<_test.tmp');


 === Line 37 Perl source:open(FH,'<_test.tmp');===

Lexem 0 Current token='f' value='open' Tokenstr |f| translated: open
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: open (
Lexem 2 Current token='i' value='FH' Tokenstr |f(i| translated: open ( FH
Lexem 3 Current token=',' value=',' Tokenstr |f(i,| translated: open ( FH ,
Lexem 4 Current token='"' value=''<_test.tmp'' Tokenstr |f(i,"| translated: open ( FH , '<_test.tmp'
Lexem 5 Current token=')' value=')' Tokenstr |f(i,")| translated: open ( FH , '<_test.tmp' )

Line:   37 TokenStr: =|f(i,")|= @ValPy: open ( FH , '<_test.tmp' )
  37 | 0 |   |try:                                                                                    #PL: open(FH,'<_test.tmp');
  37 | 1 |   |    FH=open('_test.tmp', 'r')                                                           #PL: open(FH,'<_test.tmp');
  37 | 0 |   |except OSError as _e:                                                                   #PL: open(FH,'<_test.tmp');
  37 | 1 |   |    OS_ERROR = str(_e)                                                                  #PL: open(FH,'<_test.tmp');
  37 | 1 |   |    traceback.print_exc()                                                               #PL: open(FH,'<_test.tmp');
  37 | 1 |   |    raise                                                                               #PL: open(FH,'<_test.tmp');
Main loop, line=my @test = <FH>;


 === Line 38 Perl source:my @test = <FH>;===

Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' value='test' Tokenstr |ta| translated:  test
Lexem 2 Current token='=' value='=' Tokenstr |ta=| translated:  test =
Lexem 3 Current token='i' value='FH.readlines()' Tokenstr |ta=i| translated:  test = FH.readlines()

Line:   38 TokenStr: =|ta=i|= @ValPy:  test = FH.readlines()
Generated partial line test = FH.readlines().copy()
  38 | 0 |   |test = FH.readlines().copy()                                                            #PL: my @test = <FH>;

Tokens: a=i ValPy: 
Main loop, line=chomp @test;


 === Line 39 Perl source:chomp @test;===

Lexem 0 Current token='f' value='.rstrip("\n")' Tokenstr |f| translated: .rstrip("\n")
Lexem 1 Current token='a' value='test' Tokenstr |fa| translated: .rstrip("\n") test

Line:   39 TokenStr: =|fa|= @ValPy: .rstrip("\n") test
function(0, 1) =|fa|= chomp ;

function start=1, end_pos=1, bracketed=0
  39 | 0 |   |for _ in range(len(test)):                                                              #PL: chomp @test;

Tokens: fa ValPy: 
Generated partial line test[_] = test[_].rstrip("\n")
  39 | 1 |   |    test[_] = test[_].rstrip("\n")                                                      #PL: chomp @test;

Tokens: fa ValPy: 
  40 | 0 |   |#assert(scalar(@test) == 1 && $test[0] eq 'aa');  Why doesn't this work?
Main loop, line=assert(scalar(@test) == 1);


 === Line 41 Perl source:assert(scalar(@test) == 1);===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='len' Tokenstr |c(f| translated: assert ( len
Lexem 3 Current token='(' value='(' Tokenstr |c(f(| translated: assert ( len (
Lexem 4 Current token='a' value='test' Tokenstr |c(f(a| translated: assert ( len ( test
Lexem 5 Current token=')' value=')' Tokenstr |c(f(a)| translated: assert ( len ( test )
Lexem 6 Current token='>' value='==' Tokenstr |c(f(a)>| translated: assert ( len ( test ) ==
Lexem 7 Current token='d' value='1' Tokenstr |c(f(a)>d| translated: assert ( len ( test ) == 1
Lexem 8 Current token=')' value=')' Tokenstr |c(f(a)>d)| translated: assert ( len ( test ) == 1 )

Line:   41 TokenStr: =|c(f(a)>d)|= @ValPy: assert ( len ( test ) == 1 )
control(0) =|c(f(a)>d)|= assert ( scalar ( ) == 1); ) == 1 )

control-parens removed, begin=0 start=1 =|cf(a)>d|= assert scalar ( ) == 1); ) == 1

Generated partial line assert
expression(1, 6, 0) =|cf(a)>d|= assert scalar ( ) == 1); ) == 1

function(1, 6) =|cf(a)>d|= assert scalar ( ) == 1); ) == 1

function start=3, end_pos=3, bracketed=1
Generated partial line assertlen
Generated partial line assertlen(
expression(3, 3, 0) =|cf(a)>d|= assert scalar ( ) == 1); ) == 1

Generated partial line assertlen(test
expression returns 4
Generated partial line assertlen(test)
Generated partial line assertlen(test)==
Generated partial line assertlen(test)==1
expression returns 7
  41 | 0 |   |assert len(test)==1                                                                     #PL: assert(scalar(@test) == 1);

Tokens: cf(a)>d ValPy: 
Main loop, line=my $a=$b=$c="\n";


 === Line 42 Perl source:my $a=$b=$c="\n";===

Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='s' value='a' Tokenstr |ts| translated:  a
Lexem 2 Current token='=' value='=' Tokenstr |ts=| translated:  a =
Lexem 3 Current token='s' value='b' Tokenstr |ts=s| translated:  a = b
Lexem 4 Current token='=' value='=' Tokenstr |ts=s=| translated:  a = b =
Lexem 5 Current token='s' value='c' Tokenstr |ts=s=s| translated:  a = b = c
Lexem 6 Current token='=' value='=' Tokenstr |ts=s=s=| translated:  a = b = c =
Lexem 7 Current token='"' value=''\n'' Tokenstr |ts=s=s="| translated:  a = b = c = '\n'

Line:   42 TokenStr: =|ts=s=s="|= @ValPy:  a = b = c = '\n'
assignment(1, 7) =|ts=s=s="|= my $a = $b = $c = \n

Generated partial line a
Generated partial line a=
expression(3, 7, 0) =|ts=s=s="|= my $a = $b = $c = \n

Generated partial line a=b
Generated partial line a=b=
Generated partial line a=b=c
Generated partial line a=b=c=
Generated partial line a=b=c='\n'
expression returns 8
  42 | 0 |   |a = b = c = '\n'                                                                        #PL: my $a=$b=$c="\n";

Tokens: ts=s=s=" ValPy: 
Main loop, line=chomp ($a, $b, $c);


 === Line 43 Perl source:chomp ($a, $b, $c);===

Lexem 0 Current token='f' value='.rstrip("\n")' Tokenstr |f| translated: .rstrip("\n")
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: .rstrip("\n") (
Lexem 2 Current token='s' value='a' Tokenstr |f(s| translated: .rstrip("\n") ( a
Lexem 3 Current token=',' value=',' Tokenstr |f(s,| translated: .rstrip("\n") ( a ,
Lexem 4 Current token='s' value='b' Tokenstr |f(s,s| translated: .rstrip("\n") ( a , b
Lexem 5 Current token=',' value=',' Tokenstr |f(s,s,| translated: .rstrip("\n") ( a , b ,
Lexem 6 Current token='s' value='c' Tokenstr |f(s,s,s| translated: .rstrip("\n") ( a , b , c
Lexem 7 Current token=')' value=')' Tokenstr |f(s,s,s)| translated: .rstrip("\n") ( a , b , c )

Line:   43 TokenStr: =|f(s,s,s)|= @ValPy: .rstrip("\n") ( a , b , c )
function(0, 7) =|f(s,s,s)|= chomp ( $a , $b , $c )

function start=2, end_pos=6, bracketed=1
Generated partial line a = a.rstrip("\n")
  43 | 0 |   |a = a.rstrip("\n")                                                                      #PL: chomp ($a, $b, $c);

Tokens: f(s,s,s) ValPy: 
Generated partial line b = b.rstrip("\n")
  43 | 0 |   |b = b.rstrip("\n")                                                                      #PL: chomp ($a, $b, $c);

Tokens: f(s,s,s) ValPy: 
Generated partial line c = c.rstrip("\n")
  43 | 0 |   |c = c.rstrip("\n")                                                                      #PL: chomp ($a, $b, $c);

Tokens: f(s,s,s) ValPy: 
Main loop, line=assert($a eq '' && $b eq '' && $c eq '');


 === Line 44 Perl source:assert($a eq '' && $b eq '' && $c eq '');===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='a' Tokenstr |c(s| translated: assert ( a
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( a ==
Lexem 4 Current token='"' value='''' Tokenstr |c(s>"| translated: assert ( a == ''
Lexem 5 Current token='0' value=' and ' Tokenstr |c(s>"0| translated: assert ( a == ''  and 
Lexem 6 Current token='s' value='b' Tokenstr |c(s>"0s| translated: assert ( a == ''  and  b
Lexem 7 Current token='>' value='==' Tokenstr |c(s>"0s>| translated: assert ( a == ''  and  b ==
Lexem 8 Current token='"' value='''' Tokenstr |c(s>"0s>"| translated: assert ( a == ''  and  b == ''
Lexem 9 Current token='0' value=' and ' Tokenstr |c(s>"0s>"0| translated: assert ( a == ''  and  b == ''  and 
Lexem 10 Current token='s' value='c' Tokenstr |c(s>"0s>"0s| translated: assert ( a == ''  and  b == ''  and  c
Lexem 11 Current token='>' value='==' Tokenstr |c(s>"0s>"0s>| translated: assert ( a == ''  and  b == ''  and  c ==
Lexem 12 Current token='"' value='''' Tokenstr |c(s>"0s>"0s>"| translated: assert ( a == ''  and  b == ''  and  c == ''
Lexem 13 Current token=')' value=')' Tokenstr |c(s>"0s>"0s>")| translated: assert ( a == ''  and  b == ''  and  c == '' )

Line:   44 TokenStr: =|c(s>"0s>"0s>")|= @ValPy: assert ( a == ''  and  b == ''  and  c == '' )
control(0) =|c(s>"0s>"0s>")|= assert ( $a eq  && $b eq  && $c eq  )

control-parens removed, begin=0 start=1 =|cs>"0s>"0s>"|= assert $a eq  && $b eq  && $c eq 

Generated partial line assert
expression(1, 11, 0) =|cs>"0s>"0s>"|= assert $a eq  && $b eq  && $c eq 

Generated partial line asserta
Generated partial line asserta==
Generated partial line asserta==''
Generated partial line asserta=='' and 
Generated partial line asserta=='' and b
Generated partial line asserta=='' and b==
Generated partial line asserta=='' and b==''
Generated partial line asserta=='' and b=='' and 
Generated partial line asserta=='' and b=='' and c
Generated partial line asserta=='' and b=='' and c==
Generated partial line asserta=='' and b=='' and c==''
expression returns 12
  44 | 0 |   |assert a=='' and b=='' and c==''                                                        #PL: assert($a eq '' && $b eq '' && $c eq '');

Tokens: cs>"0s>"0s>" ValPy: 
Main loop, line=chomp(my @tester = <FH>);


 === Line 45 Perl source:chomp(my @tester = <FH>);===

Lexem 0 Current token='f' value='.rstrip("\n")' Tokenstr |f| translated: .rstrip("\n")
Lexem 1 Current token='(' value='(' Tokenstr |f(| translated: .rstrip("\n") (
Lexem 2 Current token='a' value='tester' Tokenstr |f(a| translated: .rstrip("\n") ( tester
Lexem 3 Current token='=' value='=' Tokenstr |f(a=| translated: .rstrip("\n") ( tester =
Lexem 4 Current token='i' value='FH.readlines()' Tokenstr |f(a=i| translated: .rstrip("\n") ( tester = FH.readlines()
Lexem 5 Current token=')' value=')' Tokenstr |f(a=i)| translated: .rstrip("\n") ( tester = FH.readlines() )

Line:   45 TokenStr: =|f(a=i)|= @ValPy: .rstrip("\n") ( tester = FH.readlines() )
function(0, 5) =|f(a=i)|= chomp (  = <FH>); = <FH> )

function start=2, end_pos=4, bracketed=1
pre_assign(1, 1), assign_end=5, =|f(a=i)|= chomp (  = <FH>); = <FH> )

assignment(2, 4) =|f(a=i)|= chomp (  = <FH>); = <FH> )

Generated partial line tester
Generated partial line tester=
assign, ValClass[limit] = i, ValPy=FH.readlines(), ValPerl=<FH>

Generated partial line tester=FH.readlines()
  45 | 0 |   |tester = FH.readlines()                                                                 #PL: chomp(my @tester = <FH>);

Tokens: f(a=i) ValPy: 
after pre_assign: start=2, end_pos=2, =|f(a)|= chomp (  = <FH>); )

  45 | 0 |   |for _ in range(len(tester)):                                                            #PL: chomp(my @tester = <FH>);

Tokens: f(a) ValPy: 
Generated partial line tester[_] = tester[_].rstrip("\n")
  45 | 1 |   |    tester[_] = tester[_].rstrip("\n")                                                  #PL: chomp(my @tester = <FH>);

Tokens: f(a) ValPy: 
Main loop, line=assert(scalar(@tester) == 0);


 === Line 46 Perl source:assert(scalar(@tester) == 0);===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='len' Tokenstr |c(f| translated: assert ( len
Lexem 3 Current token='(' value='(' Tokenstr |c(f(| translated: assert ( len (
Lexem 4 Current token='a' value='tester' Tokenstr |c(f(a| translated: assert ( len ( tester
Lexem 5 Current token=')' value=')' Tokenstr |c(f(a)| translated: assert ( len ( tester )
Lexem 6 Current token='>' value='==' Tokenstr |c(f(a)>| translated: assert ( len ( tester ) ==
Lexem 7 Current token='d' value='0' Tokenstr |c(f(a)>d| translated: assert ( len ( tester ) == 0
Lexem 8 Current token=')' value=')' Tokenstr |c(f(a)>d)| translated: assert ( len ( tester ) == 0 )

Line:   46 TokenStr: =|c(f(a)>d)|= @ValPy: assert ( len ( tester ) == 0 )
control(0) =|c(f(a)>d)|= assert ( scalar ( ) == 0); ) == 0 )

control-parens removed, begin=0 start=1 =|cf(a)>d|= assert scalar ( ) == 0); ) == 0

Generated partial line assert
expression(1, 6, 0) =|cf(a)>d|= assert scalar ( ) == 0); ) == 0

function(1, 6) =|cf(a)>d|= assert scalar ( ) == 0); ) == 0

function start=3, end_pos=3, bracketed=1
Generated partial line assertlen
Generated partial line assertlen(
expression(3, 3, 0) =|cf(a)>d|= assert scalar ( ) == 0); ) == 0

Generated partial line assertlen(tester
expression returns 4
Generated partial line assertlen(tester)
Generated partial line assertlen(tester)==
Generated partial line assertlen(tester)==0
expression returns 7
  46 | 0 |   |assert len(tester)==0                                                                   #PL: assert(scalar(@tester) == 0);

Tokens: cf(a)>d ValPy: 
Main loop, line=close FH;


 === Line 47 Perl source:close FH;===

Lexem 0 Current token='f' value='.close()' Tokenstr |f| translated: .close()
Lexem 1 Current token='i' value='FH' Tokenstr |fi| translated: .close() FH

Line:   47 TokenStr: =|fi|= @ValPy: .close() FH
Generated partial line FH.close()
  47 | 0 |   |FH.close()                                                                              #PL: close FH;

Tokens: fi ValPy: 
Main loop, line=unlink '_test.tmp';


 === Line 48 Perl source:unlink '_test.tmp';===

Lexem 0 Current token='f' value='os.unlink' Tokenstr |f| translated: os.unlink
Lexem 1 Current token='"' value=''_test.tmp'' Tokenstr |f"| translated: os.unlink '_test.tmp'

Line:   48 TokenStr: =|f"|= @ValPy: os.unlink '_test.tmp'
function(0, 1) =|f"|= unlink _test.tmp

function start=1, end_pos=1, bracketed=0
Generated partial line os.unlink
Generated partial line os.unlink(
expression(1, 1, 0) =|f"|= unlink _test.tmp

Generated partial line os.unlink('_test.tmp'
expression returns 2
Generated partial line os.unlink('_test.tmp')
  48 | 0 |   |os.unlink('_test.tmp')                                                                  #PL: unlink '_test.tmp';

Tokens: f" ValPy: 
Main loop, line=$_ = 65;


 === Line 49 Perl source:$_ = 65;===

Lexem 0 Current token='s' value='_d' Tokenstr |s| translated: _d
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: _d =
Lexem 2 Current token='d' value='65' Tokenstr |s=d| translated: _d = 65

Line:   49 TokenStr: =|s=d|= @ValPy: _d = 65
assignment(0, 2) =|s=d|= $_ = 65

Generated partial line _d
Generated partial line _d=
assign, ValClass[limit] = d, ValPy=65, ValPerl=65

Generated partial line _d=65
  49 | 0 |   |_d = 65                                                                                 #PL: $_ = 65;

Tokens: s=d ValPy: 
Main loop, line=$c = chr;


 === Line 50 Perl source:$c = chr;===

Lexem 0 Current token='s' value='c' Tokenstr |s| translated: c
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: c =
Lexem 2 Current token='f' value='chr' Tokenstr |s=f| translated: c = chr

Line:   50 TokenStr: =|s=f|= @ValPy: c = chr
assignment(0, 2) =|s=f|= $c = chr

Generated partial line c
Generated partial line c=
assign, ValClass[limit] = f, ValPy=chr, ValPerl=chr

function(2, 2) =|s=f|= $c = chr

function start=3, end_pos=2, bracketed=-1
Generated partial line c=chr(_d)
  50 | 0 |   |c = chr(_d)                                                                             #PL: $c = chr;

Tokens: s=f ValPy: 
Main loop, line=assert($c == 'A');


 === Line 51 Perl source:assert($c == 'A');===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='c' Tokenstr |c(s| translated: assert ( c
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( c ==
Lexem 4 Current token='"' value=''A'' Tokenstr |c(s>"| translated: assert ( c == 'A'
Lexem 5 Current token=')' value=')' Tokenstr |c(s>")| translated: assert ( c == 'A' )

Line:   51 TokenStr: =|c(s>")|= @ValPy: assert ( c == 'A' )
control(0) =|c(s>")|= assert ( $c == A )

control-parens removed, begin=0 start=1 =|cs>"|= assert $c == A

Generated partial line assert
expression(1, 3, 0) =|cs>"|= assert $c == A

Generated partial line assertc
Generated partial line assertc==
Generated partial line assertc=='A'
expression returns 4
  51 | 0 |   |assert c=='A'                                                                           #PL: assert($c == 'A');

Tokens: cs>" ValPy: 
Main loop, line=assert(chr == 'A');


 === Line 52 Perl source:assert(chr == 'A');===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='chr' Tokenstr |c(f| translated: assert ( chr
Lexem 3 Current token='>' value='==' Tokenstr |c(f>| translated: assert ( chr ==
Lexem 4 Current token='"' value=''A'' Tokenstr |c(f>"| translated: assert ( chr == 'A'
Lexem 5 Current token=')' value=')' Tokenstr |c(f>")| translated: assert ( chr == 'A' )

Line:   52 TokenStr: =|c(f>")|= @ValPy: assert ( chr == 'A' )
control(0) =|c(f>")|= assert ( chr == A )

control-parens removed, begin=0 start=1 =|cf>"|= assert chr == A

Generated partial line assert
expression(1, 3, 0) =|cf>"|= assert chr == A

function(1, 3) =|cf>"|= assert chr == A

function start=2, end_pos=1, bracketed=-1
Generated partial line assertchr(_d)
Generated partial line assertchr(_d)==
Generated partial line assertchr(_d)=='A'
expression returns 4
  52 | 0 |   |assert chr(_d)=='A'                                                                     #PL: assert(chr == 'A');

Tokens: cf>" ValPy: 
Main loop, line=assert(chr $_ == 'A');


 === Line 53 Perl source:assert(chr $_ == 'A');===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='chr' Tokenstr |c(f| translated: assert ( chr
Lexem 3 Current token='s' value='_d' Tokenstr |c(fs| translated: assert ( chr _d
Lexem 4 Current token='>' value='==' Tokenstr |c(fs>| translated: assert ( chr _d ==
Lexem 5 Current token='"' value=''A'' Tokenstr |c(fs>"| translated: assert ( chr _d == 'A'
Lexem 6 Current token=')' value=')' Tokenstr |c(fs>")| translated: assert ( chr _d == 'A' )

Line:   53 TokenStr: =|c(fs>")|= @ValPy: assert ( chr _d == 'A' )
control(0) =|c(fs>")|= assert ( chr $_ == A )

control-parens removed, begin=0 start=1 =|cfs>"|= assert chr $_ == A

Generated partial line assert
expression(1, 4, 0) =|cfs>"|= assert chr $_ == A

function(1, 4) =|cfs>"|= assert chr $_ == A

function start=2, end_pos=2, bracketed=0
Generated partial line assertchr(
expression(2, 2, 0) =|cfs>"|= assert chr $_ == A

Generated partial line assertchr(_d
expression returns 3
Generated partial line assertchr(_d)
Generated partial line assertchr(_d)==
Generated partial line assertchr(_d)=='A'
expression returns 5
  53 | 0 |   |assert chr(_d)=='A'                                                                     #PL: assert(chr $_ == 'A');

Tokens: cfs>" ValPy: 
Main loop, line=assert(chr $_+1 == 'B');


 === Line 54 Perl source:assert(chr $_+1 == 'B');===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='chr' Tokenstr |c(f| translated: assert ( chr
Lexem 3 Current token='s' value='_d' Tokenstr |c(fs| translated: assert ( chr _d
Lexem 4 Current token='+' value='+' Tokenstr |c(fs+| translated: assert ( chr _d +
Lexem 5 Current token='d' value='1' Tokenstr |c(fs+d| translated: assert ( chr _d + 1
Lexem 6 Current token='>' value='==' Tokenstr |c(fs+d>| translated: assert ( chr _d + 1 ==
Lexem 7 Current token='"' value=''B'' Tokenstr |c(fs+d>"| translated: assert ( chr _d + 1 == 'B'
Lexem 8 Current token=')' value=')' Tokenstr |c(fs+d>")| translated: assert ( chr _d + 1 == 'B' )

Line:   54 TokenStr: =|c(fs+d>")|= @ValPy: assert ( chr _d + 1 == 'B' )
control(0) =|c(fs+d>")|= assert ( chr $_ + 1 == B )

control-parens removed, begin=0 start=1 =|cfs+d>"|= assert chr $_ + 1 == B

Generated partial line assert
expression(1, 6, 0) =|cfs+d>"|= assert chr $_ + 1 == B

function(1, 6) =|cfs+d>"|= assert chr $_ + 1 == B

function start=2, end_pos=4, bracketed=0
Generated partial line assertchr(
expression(2, 4, 0) =|cfs+d>"|= assert chr $_ + 1 == B

Generated partial line assertchr(_d
Generated partial line assertchr(_d+
Generated partial line assertchr(_d+1
expression returns 5
Generated partial line assertchr(_d+1)
Generated partial line assertchr(_d+1)==
Generated partial line assertchr(_d+1)=='B'
expression returns 7
  54 | 0 |   |assert chr(_d+1)=='B'                                                                   #PL: assert(chr $_+1 == 'B');

Tokens: cfs+d>" ValPy: 
Main loop, line=assert(chr($_) == 'A');


 === Line 55 Perl source:assert(chr($_) == 'A');===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='chr' Tokenstr |c(f| translated: assert ( chr
Lexem 3 Current token='(' value='(' Tokenstr |c(f(| translated: assert ( chr (
Lexem 4 Current token='s' value='_d' Tokenstr |c(f(s| translated: assert ( chr ( _d
Lexem 5 Current token=')' value=')' Tokenstr |c(f(s)| translated: assert ( chr ( _d )
Lexem 6 Current token='>' value='==' Tokenstr |c(f(s)>| translated: assert ( chr ( _d ) ==
Lexem 7 Current token='"' value=''A'' Tokenstr |c(f(s)>"| translated: assert ( chr ( _d ) == 'A'
Lexem 8 Current token=')' value=')' Tokenstr |c(f(s)>")| translated: assert ( chr ( _d ) == 'A' )

Line:   55 TokenStr: =|c(f(s)>")|= @ValPy: assert ( chr ( _d ) == 'A' )
control(0) =|c(f(s)>")|= assert ( chr ( $_ ) == A )

control-parens removed, begin=0 start=1 =|cf(s)>"|= assert chr ( $_ ) == A

Generated partial line assert
expression(1, 6, 0) =|cf(s)>"|= assert chr ( $_ ) == A

function(1, 6) =|cf(s)>"|= assert chr ( $_ ) == A

function start=3, end_pos=3, bracketed=1
Generated partial line assertchr(
expression(3, 3, 0) =|cf(s)>"|= assert chr ( $_ ) == A

Generated partial line assertchr(_d
expression returns 4
Generated partial line assertchr(_d)
Generated partial line assertchr(_d)==
Generated partial line assertchr(_d)=='A'
expression returns 7
  55 | 0 |   |assert chr(_d)=='A'                                                                     #PL: assert(chr($_) == 'A');

Tokens: cf(s)>" ValPy: 
Main loop, line=my @numbers = (1,2,3);


 === Line 56 Perl source:my @numbers = (1,2,3);===

Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' value='numbers' Tokenstr |ta| translated:  numbers
Lexem 2 Current token='=' value='=' Tokenstr |ta=| translated:  numbers =
Lexem 3 Current token='(' value='(' Tokenstr |ta=(| translated:  numbers = (
Lexem 4 Current token='d' value='1' Tokenstr |ta=(d| translated:  numbers = ( 1
Lexem 5 Current token=',' value=',' Tokenstr |ta=(d,| translated:  numbers = ( 1 ,
Lexem 6 Current token='d' value='2' Tokenstr |ta=(d,d| translated:  numbers = ( 1 , 2
Lexem 7 Current token=',' value=',' Tokenstr |ta=(d,d,| translated:  numbers = ( 1 , 2 ,
Lexem 8 Current token='d' value='3' Tokenstr |ta=(d,d,d| translated:  numbers = ( 1 , 2 , 3
Lexem 9 Current token=')' value=')' Tokenstr |ta=(d,d,d)| translated:  numbers = ( 1 , 2 , 3 )

Line:   56 TokenStr: =|ta=(d,d,d)|= @ValPy:  numbers = ( 1 , 2 , 3 )
Generated partial line numbers = [
Generated partial line numbers = [1
Generated partial line numbers = [1,
Generated partial line numbers = [1,2
Generated partial line numbers = [1,2,
Generated partial line numbers = [1,2,3
Generated partial line numbers = [1,2,3]
  56 | 0 |   |numbers = [1, 2, 3]                                                                     #PL: my @numbers = (1,2,3);

Tokens: a=(d,d,d) ValPy: 
Main loop, line=my @doubles = map {$_ * 2} @numbers;


 === Line 57 Perl source:my @doubles = map {$_ * 2} @numbers;===

Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' value='doubles' Tokenstr |ta| translated:  doubles
Lexem 2 Current token='=' value='=' Tokenstr |ta=| translated:  doubles =
Lexem 3 Current token='f' value='map' Tokenstr |ta=f| translated:  doubles = map
Lexem 4 Current token='(' value='[' Tokenstr |ta=f(| translated:  doubles = map [
Lexem 5 Current token='s' value='_d' Tokenstr |ta=f(s| translated:  doubles = map [ _d
Lexem 6 Current token='*' value='*' Tokenstr |ta=f(s*| translated:  doubles = map [ _d *
Lexem 7 Current token='d' value='2' Tokenstr |ta=f(s*d| translated:  doubles = map [ _d * 2
Lexem 8 Current token=')' value=']' Tokenstr |ta=f(s*d)| translated:  doubles = map [ _d * 2 ]
Lexem 9 Current token='a' value='numbers' Tokenstr |ta=f(s*d)a| translated:  doubles = map [ _d * 2 ] numbers

Line:   57 TokenStr: =|ta=f(s*d)a|= @ValPy:  doubles = map [ _d * 2 ] numbers
assignment(0, 8) =|a=f(s*d)a|=  = map {$_ * 2} @numbers; = map { $_ * 2 } ;

Generated partial line doubles
Generated partial line doubles=
expression(2, 8, 0) =|a=f(s*d)a|=  = map {$_ * 2} @numbers; = map { $_ * 2 } ;

function(2, 8) =|a=f(s*d)a|=  = map {$_ * 2} @numbers; = map { $_ * 2 } ;

function start=4, end_pos=6, bracketed=1
Generated partial line doubles=list(map
Generated partial line doubles=list(map(lambda _d:
expression(4, 6, 0) =|a=f(s*d)a|=  = map {$_ * 2} @numbers; = map { $_ * 2 } ;

Generated partial line doubles=list(map(lambda _d:_d
Generated partial line doubles=list(map(lambda _d:_d*
Generated partial line doubles=list(map(lambda _d:_d*2
expression returns 7
Generated partial line doubles=list(map(lambda _d:_d*2,
expression(8, 8, 0) =|a=f(s*d)a|=  = map {$_ * 2} @numbers; = map { $_ * 2 } ;

Generated partial line doubles=list(map(lambda _d:_d*2,numbers
expression returns 9
Generated partial line doubles=list(map(lambda _d:_d*2,numbers)
Generated partial line doubles=list(map(lambda _d:_d*2,numbers))
expression returns 9
  57 | 0 |   |doubles = list(map(lambda _d:_d*2, numbers))                                            #PL: my @doubles = map {$_ * 2} @numbers;

Tokens: a=f(s*d)a ValPy: 
Main loop, line=assert(scalar(@doubles) == 3 && $doubles[0] == 2 && $doubles[1] == 4 && $doubles[2] == 6);


 === Line 58 Perl source:assert(scalar(@doubles) == 3 && $doubles[0] == 2 && $doubles[1] == 4 && $doubles[2] == 6);===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='len' Tokenstr |c(f| translated: assert ( len
Lexem 3 Current token='(' value='(' Tokenstr |c(f(| translated: assert ( len (
Lexem 4 Current token='a' value='doubles' Tokenstr |c(f(a| translated: assert ( len ( doubles
Lexem 5 Current token=')' value=')' Tokenstr |c(f(a)| translated: assert ( len ( doubles )
Lexem 6 Current token='>' value='==' Tokenstr |c(f(a)>| translated: assert ( len ( doubles ) ==
Lexem 7 Current token='d' value='3' Tokenstr |c(f(a)>d| translated: assert ( len ( doubles ) == 3
Lexem 8 Current token='0' value=' and ' Tokenstr |c(f(a)>d0| translated: assert ( len ( doubles ) == 3  and 
Lexem 9 Current token='s' value='doubles' Tokenstr |c(f(a)>d0s| translated: assert ( len ( doubles ) == 3  and  doubles
Lexem 10 Current token='(' value='[' Tokenstr |c(f(a)>d0s(| translated: assert ( len ( doubles ) == 3  and  doubles [
Lexem 11 Current token='d' value='0' Tokenstr |c(f(a)>d0s(d| translated: assert ( len ( doubles ) == 3  and  doubles [ 0
Lexem 12 Current token=')' value=']' Tokenstr |c(f(a)>d0s(d)| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ]
Lexem 13 Current token='>' value='==' Tokenstr |c(f(a)>d0s(d)>| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] ==
Lexem 14 Current token='d' value='2' Tokenstr |c(f(a)>d0s(d)>d| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2
Lexem 15 Current token='0' value=' and ' Tokenstr |c(f(a)>d0s(d)>d0| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2  and 
Lexem 16 Current token='s' value='doubles' Tokenstr |c(f(a)>d0s(d)>d0s| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2  and  doubles
Lexem 17 Current token='(' value='[' Tokenstr |c(f(a)>d0s(d)>d0s(| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2  and  doubles [
Lexem 18 Current token='d' value='1' Tokenstr |c(f(a)>d0s(d)>d0s(d| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2  and  doubles [ 1
Lexem 19 Current token=')' value=']' Tokenstr |c(f(a)>d0s(d)>d0s(d)| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2  and  doubles [ 1 ]
Lexem 20 Current token='>' value='==' Tokenstr |c(f(a)>d0s(d)>d0s(d)>| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2  and  doubles [ 1 ] ==
Lexem 21 Current token='d' value='4' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2  and  doubles [ 1 ] == 4
Lexem 22 Current token='0' value=' and ' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2  and  doubles [ 1 ] == 4  and 
Lexem 23 Current token='s' value='doubles' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0s| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2  and  doubles [ 1 ] == 4  and  doubles
Lexem 24 Current token='(' value='[' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0s(| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2  and  doubles [ 1 ] == 4  and  doubles [
Lexem 25 Current token='d' value='2' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0s(d| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2  and  doubles [ 1 ] == 4  and  doubles [ 2
Lexem 26 Current token=')' value=']' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0s(d)| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2  and  doubles [ 1 ] == 4  and  doubles [ 2 ]
Lexem 27 Current token='>' value='==' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0s(d)>| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2  and  doubles [ 1 ] == 4  and  doubles [ 2 ] ==
Lexem 28 Current token='d' value='6' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0s(d)>d| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2  and  doubles [ 1 ] == 4  and  doubles [ 2 ] == 6
Lexem 29 Current token=')' value=')' Tokenstr |c(f(a)>d0s(d)>d0s(d)>d0s(d)>d)| translated: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2  and  doubles [ 1 ] == 4  and  doubles [ 2 ] == 6 )

Line:   58 TokenStr: =|c(f(a)>d0s(d)>d0s(d)>d0s(d)>d)|= @ValPy: assert ( len ( doubles ) == 3  and  doubles [ 0 ] == 2  and  doubles [ 1 ] == 4  and  doubles [ 2 ] == 6 )
control(0) =|c(f(a)>d0s(d)>d0s(d)>d0s(d)>d)|= assert ( scalar ( ) == 3 && $doubles[0] == 2 && $doubles[1] == 4 && $doubles[2] == 6); ) == 3 && $doubles [ 0 ] == 2 && $doubles [ 1 ] == 4 && $doubles [ 2 ] == 6 )

control-parens removed, begin=0 start=1 =|cf(a)>d0s(d)>d0s(d)>d0s(d)>d|= assert scalar ( ) == 3 && $doubles[0] == 2 && $doubles[1] == 4 && $doubles[2] == 6); ) == 3 && $doubles [ 0 ] == 2 && $doubles [ 1 ] == 4 && $doubles [ 2 ] == 6

Generated partial line assert
expression(1, 27, 0) =|cf(a)>d0s(d)>d0s(d)>d0s(d)>d|= assert scalar ( ) == 3 && $doubles[0] == 2 && $doubles[1] == 4 && $doubles[2] == 6); ) == 3 && $doubles [ 0 ] == 2 && $doubles [ 1 ] == 4 && $doubles [ 2 ] == 6

function(1, 7) =|cf(a)>d0s(d)>d0s(d)>d0s(d)>d|= assert scalar ( ) == 3 && $doubles[0] == 2 && $doubles[1] == 4 && $doubles[2] == 6); ) == 3 && $doubles [ 0 ] == 2 && $doubles [ 1 ] == 4 && $doubles [ 2 ] == 6

function start=3, end_pos=3, bracketed=1
Generated partial line assertlen
Generated partial line assertlen(
expression(3, 3, 0) =|cf(a)>d0s(d)>d0s(d)>d0s(d)>d|= assert scalar ( ) == 3 && $doubles[0] == 2 && $doubles[1] == 4 && $doubles[2] == 6); ) == 3 && $doubles [ 0 ] == 2 && $doubles [ 1 ] == 4 && $doubles [ 2 ] == 6

Generated partial line assertlen(doubles
expression returns 4
Generated partial line assertlen(doubles)
Generated partial line assertlen(doubles)==
Generated partial line assertlen(doubles)==3
Generated partial line assertlen(doubles)==3 and 
Generated partial line assertlen(doubles)==3 and doubles
Generated partial line assertlen(doubles)==3 and doubles[
expression(10, 10, 0) =|cf(a)>d0s(d)>d0s(d)>d0s(d)>d|= assert scalar ( ) == 3 && $doubles[0] == 2 && $doubles[1] == 4 && $doubles[2] == 6); ) == 3 && $doubles [ 0 ] == 2 && $doubles [ 1 ] == 4 && $doubles [ 2 ] == 6

Generated partial line assertlen(doubles)==3 and doubles[0
expression returns 11
Generated partial line assertlen(doubles)==3 and doubles[0]
Generated partial line assertlen(doubles)==3 and doubles[0]==
Generated partial line assertlen(doubles)==3 and doubles[0]==2
Generated partial line assertlen(doubles)==3 and doubles[0]==2 and 
Generated partial line assertlen(doubles)==3 and doubles[0]==2 and doubles
Generated partial line assertlen(doubles)==3 and doubles[0]==2 and doubles[
expression(17, 17, 0) =|cf(a)>d0s(d)>d0s(d)>d0s(d)>d|= assert scalar ( ) == 3 && $doubles[0] == 2 && $doubles[1] == 4 && $doubles[2] == 6); ) == 3 && $doubles [ 0 ] == 2 && $doubles [ 1 ] == 4 && $doubles [ 2 ] == 6

Generated partial line assertlen(doubles)==3 and doubles[0]==2 and doubles[1
expression returns 18
Generated partial line assertlen(doubles)==3 and doubles[0]==2 and doubles[1]
Generated partial line assertlen(doubles)==3 and doubles[0]==2 and doubles[1]==
Generated partial line assertlen(doubles)==3 and doubles[0]==2 and doubles[1]==4
Generated partial line assertlen(doubles)==3 and doubles[0]==2 and doubles[1]==4 and 
Generated partial line assertlen(doubles)==3 and doubles[0]==2 and doubles[1]==4 and doubles
Generated partial line assertlen(doubles)==3 and doubles[0]==2 and doubles[1]==4 and doubles[
expression(24, 24, 0) =|cf(a)>d0s(d)>d0s(d)>d0s(d)>d|= assert scalar ( ) == 3 && $doubles[0] == 2 && $doubles[1] == 4 && $doubles[2] == 6); ) == 3 && $doubles [ 0 ] == 2 && $doubles [ 1 ] == 4 && $doubles [ 2 ] == 6

Generated partial line assertlen(doubles)==3 and doubles[0]==2 and doubles[1]==4 and doubles[2
expression returns 25
Generated partial line assertlen(doubles)==3 and doubles[0]==2 and doubles[1]==4 and doubles[2]
Generated partial line assertlen(doubles)==3 and doubles[0]==2 and doubles[1]==4 and doubles[2]==
Generated partial line assertlen(doubles)==3 and doubles[0]==2 and doubles[1]==4 and doubles[2]==6
expression returns 28
  58 | 0 |   |assert len(doubles)==3 and doubles[0]==2 and doubles[1]==4 and doubles[2]==6            #PL: assert(scalar(@doubles) == 3 && $doubles[0] == 2 && $doubles[1] == 4 && $doubles[2] == 6);

Tokens: cf(a)>d0s(d)>d0s(d)>d0s(d)>d ValPy: 
Main loop, line=my @numbers = (65, 66);


 === Line 59 Perl source:my @numbers = (65, 66);===

Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' value='numbers' Tokenstr |ta| translated:  numbers
Lexem 2 Current token='=' value='=' Tokenstr |ta=| translated:  numbers =
Lexem 3 Current token='(' value='(' Tokenstr |ta=(| translated:  numbers = (
Lexem 4 Current token='d' value='65' Tokenstr |ta=(d| translated:  numbers = ( 65
Lexem 5 Current token=',' value=',' Tokenstr |ta=(d,| translated:  numbers = ( 65 ,
Lexem 6 Current token='d' value='66' Tokenstr |ta=(d,d| translated:  numbers = ( 65 , 66
Lexem 7 Current token=')' value=')' Tokenstr |ta=(d,d)| translated:  numbers = ( 65 , 66 )

Line:   59 TokenStr: =|ta=(d,d)|= @ValPy:  numbers = ( 65 , 66 )
Generated partial line numbers = [
Generated partial line numbers = [65
Generated partial line numbers = [65,
Generated partial line numbers = [65,66
Generated partial line numbers = [65,66]
  59 | 0 |   |numbers = [65, 66]                                                                      #PL: my @numbers = (65, 66);

Tokens: a=(d,d) ValPy: 
Main loop, line=my @chars = map(chr, @numbers);


 === Line 60 Perl source:my @chars = map(chr, @numbers);===

Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' value='chars' Tokenstr |ta| translated:  chars
Lexem 2 Current token='=' value='=' Tokenstr |ta=| translated:  chars =
Lexem 3 Current token='f' value='map' Tokenstr |ta=f| translated:  chars = map
Lexem 4 Current token='(' value='(' Tokenstr |ta=f(| translated:  chars = map (
Lexem 5 Current token='f' value='chr' Tokenstr |ta=f(f| translated:  chars = map ( chr
Lexem 6 Current token=',' value=',' Tokenstr |ta=f(f,| translated:  chars = map ( chr ,
Lexem 7 Current token='a' value='numbers' Tokenstr |ta=f(f,a| translated:  chars = map ( chr , numbers
Lexem 8 Current token=')' value=')' Tokenstr |ta=f(f,a)| translated:  chars = map ( chr , numbers )

Line:   60 TokenStr: =|ta=f(f,a)|= @ValPy:  chars = map ( chr , numbers )
assignment(0, 7) =|a=f(f,a)|=  = map(chr, @numbers); = map ( chr , ); )

Generated partial line chars
Generated partial line chars=
expression(2, 7, 0) =|a=f(f,a)|=  = map(chr, @numbers); = map ( chr , ); )

function(2, 7) =|a=f(f,a)|=  = map(chr, @numbers); = map ( chr , ); )

function start=4, end_pos=6, bracketed=1
Generated partial line chars=list(map
Generated partial line chars=list(map(chr
Generated partial line chars=list(map(chr,
expression(6, 7, 0) =|a=f(f,a)|=  = map(chr, @numbers); = map ( chr , ); )

Generated partial line chars=list(map(chr,numbers
Generated partial line chars=list(map(chr,numbers)
expression returns 8
Generated partial line chars=list(map(chr,numbers))
expression returns 8
  60 | 0 |   |chars = list(map(chr, numbers))                                                         #PL: my @chars = map(chr, @numbers);

Tokens: a=f(f,a) ValPy: 
Main loop, line=assert($chars[0] eq 'A' && $chars[1] eq 'B');


 === Line 61 Perl source:assert($chars[0] eq 'A' && $chars[1] eq 'B');===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='chars' Tokenstr |c(s| translated: assert ( chars
Lexem 3 Current token='(' value='[' Tokenstr |c(s(| translated: assert ( chars [
Lexem 4 Current token='d' value='0' Tokenstr |c(s(d| translated: assert ( chars [ 0
Lexem 5 Current token=')' value=']' Tokenstr |c(s(d)| translated: assert ( chars [ 0 ]
Lexem 6 Current token='>' value='==' Tokenstr |c(s(d)>| translated: assert ( chars [ 0 ] ==
Lexem 7 Current token='"' value=''A'' Tokenstr |c(s(d)>"| translated: assert ( chars [ 0 ] == 'A'
Lexem 8 Current token='0' value=' and ' Tokenstr |c(s(d)>"0| translated: assert ( chars [ 0 ] == 'A'  and 
Lexem 9 Current token='s' value='chars' Tokenstr |c(s(d)>"0s| translated: assert ( chars [ 0 ] == 'A'  and  chars
Lexem 10 Current token='(' value='[' Tokenstr |c(s(d)>"0s(| translated: assert ( chars [ 0 ] == 'A'  and  chars [
Lexem 11 Current token='d' value='1' Tokenstr |c(s(d)>"0s(d| translated: assert ( chars [ 0 ] == 'A'  and  chars [ 1
Lexem 12 Current token=')' value=']' Tokenstr |c(s(d)>"0s(d)| translated: assert ( chars [ 0 ] == 'A'  and  chars [ 1 ]
Lexem 13 Current token='>' value='==' Tokenstr |c(s(d)>"0s(d)>| translated: assert ( chars [ 0 ] == 'A'  and  chars [ 1 ] ==
Lexem 14 Current token='"' value=''B'' Tokenstr |c(s(d)>"0s(d)>"| translated: assert ( chars [ 0 ] == 'A'  and  chars [ 1 ] == 'B'
Lexem 15 Current token=')' value=')' Tokenstr |c(s(d)>"0s(d)>")| translated: assert ( chars [ 0 ] == 'A'  and  chars [ 1 ] == 'B' )

Line:   61 TokenStr: =|c(s(d)>"0s(d)>")|= @ValPy: assert ( chars [ 0 ] == 'A'  and  chars [ 1 ] == 'B' )
control(0) =|c(s(d)>"0s(d)>")|= assert ( $chars [ 0 ] eq A && $chars [ 1 ] eq B )

control-parens removed, begin=0 start=1 =|cs(d)>"0s(d)>"|= assert $chars [ 0 ] eq A && $chars [ 1 ] eq B

Generated partial line assert
expression(1, 13, 0) =|cs(d)>"0s(d)>"|= assert $chars [ 0 ] eq A && $chars [ 1 ] eq B

Generated partial line assertchars
Generated partial line assertchars[
expression(3, 3, 0) =|cs(d)>"0s(d)>"|= assert $chars [ 0 ] eq A && $chars [ 1 ] eq B

Generated partial line assertchars[0
expression returns 4
Generated partial line assertchars[0]
Generated partial line assertchars[0]==
Generated partial line assertchars[0]=='A'
Generated partial line assertchars[0]=='A' and 
Generated partial line assertchars[0]=='A' and chars
Generated partial line assertchars[0]=='A' and chars[
expression(10, 10, 0) =|cs(d)>"0s(d)>"|= assert $chars [ 0 ] eq A && $chars [ 1 ] eq B

Generated partial line assertchars[0]=='A' and chars[1
expression returns 11
Generated partial line assertchars[0]=='A' and chars[1]
Generated partial line assertchars[0]=='A' and chars[1]==
Generated partial line assertchars[0]=='A' and chars[1]=='B'
expression returns 14
  61 | 0 |   |assert chars[0]=='A' and chars[1]=='B'                                                  #PL: assert($chars[0] eq 'A' && $chars[1] eq 'B');

Tokens: cs(d)>"0s(d)>" ValPy: 
Main loop, line=sub myF {


 === Line 62 Perl source:sub myF {===

Lexem 0 Current token='k' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' value='myF' Tokenstr |ki| translated: def myF

Line:   62 TokenStr: =|ki|= @ValPy: def myF
Generated partial line defmyF(_args):
  62 | 0 |   |def myF(_args):                                                                         #PL: sub myF {

Tokens: ki ValPy: 
  62 | 1 |   |    global python                                                                       #PL: sub myF {
Main loop, line={


 === Line 62 Perl source:{===


Line:   62 TokenStr: =|{|= @ValPy: {
Main loop, line=return(lc shift) if($python);       # in perl it doesn't pass the arg!


 === Line 63 Perl source:return(lc shift) if($python);       # in perl it doesn't pass the arg!===

Lexem 0 Current token='k' value='return' Tokenstr |k| translated: return
Lexem 1 Current token='(' value='(' Tokenstr |k(| translated: return (
Lexem 2 Current token='f' value='.lower()' Tokenstr |k(f| translated: return ( .lower()
Lexem 3 Current token='f' value='.pop(0)' Tokenstr |k(ff| translated: return ( .lower() .pop(0)
Lexem 4 Current token=')' value=')' Tokenstr |k(ff)| translated: return ( .lower() .pop(0) )
Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='s' value='python' Tokenstr |c(s| translated: if  ( python
Lexem 3 Current token=')' value=')' Tokenstr |c(s)| translated: if  ( python )

Line:   63 TokenStr: =|c(s)|= @ValPy: if  ( python )
control(0) =|c(s)|= if ( $python )

control-parens removed, begin=0 start=1 =|cs|= if $python

Generated partial line if 
expression(1, 1, 0) =|cs|= if $python

Generated partial line if python
expression returns 2
Generated partial line if python:
  63 | 1 |   |    if python:     # in perl it doesn't pass the arg!
                                                                                                      #PL: return(lc shift) if($python);

Tokens: cs ValPy: 
Main loop, line=return(lc shift) if($python);       # in perl it doesn't pass the arg!
Main loop, line=return(lc shift) if($python);       # in perl it doesn't pass the arg!
expression(0, 4, 0) =|k(ff)|= return ( lc shift )

Generated partial line return
Generated partial line return(
expression(2, 3, 0) =|k(ff)|= return ( lc shift )

function(2, 3) =|k(ff)|= return ( lc shift )

function start=3, end_pos=3, bracketed=0
expression(3, 3, 0) =|k(ff)|= return ( lc shift )

function(3, 3) =|k(ff)|= return ( lc shift )

function start=4, end_pos=3, bracketed=-1
Generated partial line return((_args.pop(0) if _args else None)
expression returns 4
Generated partial line return((_args.pop(0) if _args else None).lower()
expression returns 4
Generated partial line return((_args.pop(0) if _args else None).lower())
expression returns 5
  63 | 2 |   |        return((_args.pop(0) if _args else None).lower())                               #PL: return(lc shift) if($python);       # in perl it doesn't pass the arg!

Tokens: k(ff) ValPy: 
Main loop, line=return(lc shift) if($python);       # in perl it doesn't pass the arg!
Main loop, line=return(lc $_);


 === Line 64 Perl source:return(lc $_);===

Lexem 0 Current token='k' value='return' Tokenstr |k| translated: return
Lexem 1 Current token='(' value='(' Tokenstr |k(| translated: return (
Lexem 2 Current token='f' value='.lower()' Tokenstr |k(f| translated: return ( .lower()
Lexem 3 Current token='s' value='_d' Tokenstr |k(fs| translated: return ( .lower() _d
Lexem 4 Current token=')' value=')' Tokenstr |k(fs)| translated: return ( .lower() _d )

Line:   64 TokenStr: =|k(fs)|= @ValPy: return ( .lower() _d )
expression(0, 4, 0) =|k(fs)|= return ( lc $_ )

Generated partial line return
Generated partial line return(
expression(2, 3, 0) =|k(fs)|= return ( lc $_ )

function(2, 3) =|k(fs)|= return ( lc $_ )

function start=3, end_pos=3, bracketed=0
expression(3, 3, 0) =|k(fs)|= return ( lc $_ )

Generated partial line return(_d
expression returns 4
Generated partial line return(_d.lower()
expression returns 4
Generated partial line return(_d.lower())
expression returns 5
  64 | 1 |   |    return(_d.lower())                                                                  #PL: return(lc $_);

Tokens: k(fs) ValPy: 
Main loop, line=}


 === Line 65 Perl source:}===


Line:   65 TokenStr: =|}|= @ValPy: }
Main loop, line=my @lc = map(myF, @chars);


 === Line 66 Perl source:my @lc = map(myF, @chars);===

Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' value='lc' Tokenstr |ta| translated:  lc
Lexem 2 Current token='=' value='=' Tokenstr |ta=| translated:  lc =
Lexem 3 Current token='f' value='map' Tokenstr |ta=f| translated:  lc = map
Lexem 4 Current token='(' value='(' Tokenstr |ta=f(| translated:  lc = map (
Lexem 5 Current token='i' value='myF' Tokenstr |ta=f(i| translated:  lc = map ( myF
Lexem 6 Current token=',' value=',' Tokenstr |ta=f(i,| translated:  lc = map ( myF ,
Lexem 7 Current token='a' value='chars' Tokenstr |ta=f(i,a| translated:  lc = map ( myF , chars
Lexem 8 Current token=')' value=')' Tokenstr |ta=f(i,a)| translated:  lc = map ( myF , chars )

Line:   66 TokenStr: =|ta=f(i,a)|= @ValPy:  lc = map ( myF , chars )
assignment(0, 7) =|a=f(i,a)|=  = map(myF, @chars); = map ( myF , ); )

Generated partial line lc
Generated partial line lc=
expression(2, 7, 0) =|a=f(i,a)|=  = map(myF, @chars); = map ( myF , ); )

function(2, 7) =|a=f(i,a)|=  = map(myF, @chars); = map ( myF , ); )

function start=4, end_pos=6, bracketed=1
Generated partial line lc=list(map
Generated partial line lc=list(map(lambda _d:
Generated partial line lc=list(map(lambda _d:myF([_d])
Generated partial line lc=list(map(lambda _d:myF([_d]),
expression(6, 7, 0) =|a=f(i,a)|=  = map(myF, @chars); = map ( myF , ); )

Generated partial line lc=list(map(lambda _d:myF([_d]),chars
Generated partial line lc=list(map(lambda _d:myF([_d]),chars)
expression returns 8
Generated partial line lc=list(map(lambda _d:myF([_d]),chars))
expression returns 8
  66 | 0 |   |lc = list(map(lambda _d:myF([_d]), chars))                                              #PL: my @lc = map(myF, @chars);

Tokens: a=f(i,a) ValPy: 
Main loop, line=assert($lc[0] eq 'a' && $lc[1] eq 'b');


 === Line 67 Perl source:assert($lc[0] eq 'a' && $lc[1] eq 'b');===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='lc' Tokenstr |c(s| translated: assert ( lc
Lexem 3 Current token='(' value='[' Tokenstr |c(s(| translated: assert ( lc [
Lexem 4 Current token='d' value='0' Tokenstr |c(s(d| translated: assert ( lc [ 0
Lexem 5 Current token=')' value=']' Tokenstr |c(s(d)| translated: assert ( lc [ 0 ]
Lexem 6 Current token='>' value='==' Tokenstr |c(s(d)>| translated: assert ( lc [ 0 ] ==
Lexem 7 Current token='"' value=''a'' Tokenstr |c(s(d)>"| translated: assert ( lc [ 0 ] == 'a'
Lexem 8 Current token='0' value=' and ' Tokenstr |c(s(d)>"0| translated: assert ( lc [ 0 ] == 'a'  and 
Lexem 9 Current token='s' value='lc' Tokenstr |c(s(d)>"0s| translated: assert ( lc [ 0 ] == 'a'  and  lc
Lexem 10 Current token='(' value='[' Tokenstr |c(s(d)>"0s(| translated: assert ( lc [ 0 ] == 'a'  and  lc [
Lexem 11 Current token='d' value='1' Tokenstr |c(s(d)>"0s(d| translated: assert ( lc [ 0 ] == 'a'  and  lc [ 1
Lexem 12 Current token=')' value=']' Tokenstr |c(s(d)>"0s(d)| translated: assert ( lc [ 0 ] == 'a'  and  lc [ 1 ]
Lexem 13 Current token='>' value='==' Tokenstr |c(s(d)>"0s(d)>| translated: assert ( lc [ 0 ] == 'a'  and  lc [ 1 ] ==
Lexem 14 Current token='"' value=''b'' Tokenstr |c(s(d)>"0s(d)>"| translated: assert ( lc [ 0 ] == 'a'  and  lc [ 1 ] == 'b'
Lexem 15 Current token=')' value=')' Tokenstr |c(s(d)>"0s(d)>")| translated: assert ( lc [ 0 ] == 'a'  and  lc [ 1 ] == 'b' )

Line:   67 TokenStr: =|c(s(d)>"0s(d)>")|= @ValPy: assert ( lc [ 0 ] == 'a'  and  lc [ 1 ] == 'b' )
control(0) =|c(s(d)>"0s(d)>")|= assert ( $lc [ 0 ] eq a && $lc [ 1 ] eq b )

control-parens removed, begin=0 start=1 =|cs(d)>"0s(d)>"|= assert $lc [ 0 ] eq a && $lc [ 1 ] eq b

Generated partial line assert
expression(1, 13, 0) =|cs(d)>"0s(d)>"|= assert $lc [ 0 ] eq a && $lc [ 1 ] eq b

Generated partial line assertlc
Generated partial line assertlc[
expression(3, 3, 0) =|cs(d)>"0s(d)>"|= assert $lc [ 0 ] eq a && $lc [ 1 ] eq b

Generated partial line assertlc[0
expression returns 4
Generated partial line assertlc[0]
Generated partial line assertlc[0]==
Generated partial line assertlc[0]=='a'
Generated partial line assertlc[0]=='a' and 
Generated partial line assertlc[0]=='a' and lc
Generated partial line assertlc[0]=='a' and lc[
expression(10, 10, 0) =|cs(d)>"0s(d)>"|= assert $lc [ 0 ] eq a && $lc [ 1 ] eq b

Generated partial line assertlc[0]=='a' and lc[1
expression returns 11
Generated partial line assertlc[0]=='a' and lc[1]
Generated partial line assertlc[0]=='a' and lc[1]==
Generated partial line assertlc[0]=='a' and lc[1]=='b'
expression returns 14
  67 | 0 |   |assert lc[0]=='a' and lc[1]=='b'                                                        #PL: assert($lc[0] eq 'a' && $lc[1] eq 'b');

Tokens: cs(d)>"0s(d)>" ValPy: 
Main loop, line=@lc2 = map(lc, @chars);


 === Line 68 Perl source:@lc2 = map(lc, @chars);===

Lexem 0 Current token='a' value='lc2' Tokenstr |a| translated: lc2
Lexem 1 Current token='=' value='=' Tokenstr |a=| translated: lc2 =
Lexem 2 Current token='f' value='map' Tokenstr |a=f| translated: lc2 = map
Lexem 3 Current token='(' value='(' Tokenstr |a=f(| translated: lc2 = map (
Lexem 4 Current token='f' value='.lower()' Tokenstr |a=f(f| translated: lc2 = map ( .lower()
Lexem 5 Current token=',' value=',' Tokenstr |a=f(f,| translated: lc2 = map ( .lower() ,
Lexem 6 Current token='a' value='chars' Tokenstr |a=f(f,a| translated: lc2 = map ( .lower() , chars
Lexem 7 Current token=')' value=')' Tokenstr |a=f(f,a)| translated: lc2 = map ( .lower() , chars )

Line:   68 TokenStr: =|a=f(f,a)|= @ValPy: lc2 = map ( .lower() , chars )
assignment(0, 7) =|a=f(f,a)|=  = map(lc, @chars); = map ( lc , ); )

Generated partial line lc2
Generated partial line lc2=
expression(2, 7, 0) =|a=f(f,a)|=  = map(lc, @chars); = map ( lc , ); )

function(2, 7) =|a=f(f,a)|=  = map(lc, @chars); = map ( lc , ); )

function start=4, end_pos=6, bracketed=1
Generated partial line lc2=list(map
Generated partial line lc2=list(map(lambda _d:
Generated partial line lc2=list(map(lambda _d:_d.lower()
Generated partial line lc2=list(map(lambda _d:_d.lower(),
expression(6, 7, 0) =|a=f(f,a)|=  = map(lc, @chars); = map ( lc , ); )

Generated partial line lc2=list(map(lambda _d:_d.lower(),chars
Generated partial line lc2=list(map(lambda _d:_d.lower(),chars)
expression returns 8
Generated partial line lc2=list(map(lambda _d:_d.lower(),chars))
expression returns 8
  68 | 0 |   |lc2 = list(map(lambda _d:_d.lower(), chars))                                            #PL: @lc2 = map(lc, @chars);

Tokens: a=f(f,a) ValPy: 
Main loop, line=assert($lc2[0] eq 'a' && $lc2[1] eq 'b');


 === Line 69 Perl source:assert($lc2[0] eq 'a' && $lc2[1] eq 'b');===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='lc2' Tokenstr |c(s| translated: assert ( lc2
Lexem 3 Current token='(' value='[' Tokenstr |c(s(| translated: assert ( lc2 [
Lexem 4 Current token='d' value='0' Tokenstr |c(s(d| translated: assert ( lc2 [ 0
Lexem 5 Current token=')' value=']' Tokenstr |c(s(d)| translated: assert ( lc2 [ 0 ]
Lexem 6 Current token='>' value='==' Tokenstr |c(s(d)>| translated: assert ( lc2 [ 0 ] ==
Lexem 7 Current token='"' value=''a'' Tokenstr |c(s(d)>"| translated: assert ( lc2 [ 0 ] == 'a'
Lexem 8 Current token='0' value=' and ' Tokenstr |c(s(d)>"0| translated: assert ( lc2 [ 0 ] == 'a'  and 
Lexem 9 Current token='s' value='lc2' Tokenstr |c(s(d)>"0s| translated: assert ( lc2 [ 0 ] == 'a'  and  lc2
Lexem 10 Current token='(' value='[' Tokenstr |c(s(d)>"0s(| translated: assert ( lc2 [ 0 ] == 'a'  and  lc2 [
Lexem 11 Current token='d' value='1' Tokenstr |c(s(d)>"0s(d| translated: assert ( lc2 [ 0 ] == 'a'  and  lc2 [ 1
Lexem 12 Current token=')' value=']' Tokenstr |c(s(d)>"0s(d)| translated: assert ( lc2 [ 0 ] == 'a'  and  lc2 [ 1 ]
Lexem 13 Current token='>' value='==' Tokenstr |c(s(d)>"0s(d)>| translated: assert ( lc2 [ 0 ] == 'a'  and  lc2 [ 1 ] ==
Lexem 14 Current token='"' value=''b'' Tokenstr |c(s(d)>"0s(d)>"| translated: assert ( lc2 [ 0 ] == 'a'  and  lc2 [ 1 ] == 'b'
Lexem 15 Current token=')' value=')' Tokenstr |c(s(d)>"0s(d)>")| translated: assert ( lc2 [ 0 ] == 'a'  and  lc2 [ 1 ] == 'b' )

Line:   69 TokenStr: =|c(s(d)>"0s(d)>")|= @ValPy: assert ( lc2 [ 0 ] == 'a'  and  lc2 [ 1 ] == 'b' )
control(0) =|c(s(d)>"0s(d)>")|= assert ( $lc2 [ 0 ] eq a && $lc2 [ 1 ] eq b )

control-parens removed, begin=0 start=1 =|cs(d)>"0s(d)>"|= assert $lc2 [ 0 ] eq a && $lc2 [ 1 ] eq b

Generated partial line assert
expression(1, 13, 0) =|cs(d)>"0s(d)>"|= assert $lc2 [ 0 ] eq a && $lc2 [ 1 ] eq b

Generated partial line assertlc2
Generated partial line assertlc2[
expression(3, 3, 0) =|cs(d)>"0s(d)>"|= assert $lc2 [ 0 ] eq a && $lc2 [ 1 ] eq b

Generated partial line assertlc2[0
expression returns 4
Generated partial line assertlc2[0]
Generated partial line assertlc2[0]==
Generated partial line assertlc2[0]=='a'
Generated partial line assertlc2[0]=='a' and 
Generated partial line assertlc2[0]=='a' and lc2
Generated partial line assertlc2[0]=='a' and lc2[
expression(10, 10, 0) =|cs(d)>"0s(d)>"|= assert $lc2 [ 0 ] eq a && $lc2 [ 1 ] eq b

Generated partial line assertlc2[0]=='a' and lc2[1
expression returns 11
Generated partial line assertlc2[0]=='a' and lc2[1]
Generated partial line assertlc2[0]=='a' and lc2[1]==
Generated partial line assertlc2[0]=='a' and lc2[1]=='b'
expression returns 14
  69 | 0 |   |assert lc2[0]=='a' and lc2[1]=='b'                                                      #PL: assert($lc2[0] eq 'a' && $lc2[1] eq 'b');

Tokens: cs(d)>"0s(d)>" ValPy: 
  70 | 0 |   |
Main loop, line=@numbers = (8, 2, 5, 3, 1, 7);


 === Line 71 Perl source:@numbers = (8, 2, 5, 3, 1, 7);===

Lexem 0 Current token='a' value='numbers' Tokenstr |a| translated: numbers
Lexem 1 Current token='=' value='=' Tokenstr |a=| translated: numbers =
Lexem 2 Current token='(' value='(' Tokenstr |a=(| translated: numbers = (
Lexem 3 Current token='d' value='8' Tokenstr |a=(d| translated: numbers = ( 8
Lexem 4 Current token=',' value=',' Tokenstr |a=(d,| translated: numbers = ( 8 ,
Lexem 5 Current token='d' value='2' Tokenstr |a=(d,d| translated: numbers = ( 8 , 2
Lexem 6 Current token=',' value=',' Tokenstr |a=(d,d,| translated: numbers = ( 8 , 2 ,
Lexem 7 Current token='d' value='5' Tokenstr |a=(d,d,d| translated: numbers = ( 8 , 2 , 5
Lexem 8 Current token=',' value=',' Tokenstr |a=(d,d,d,| translated: numbers = ( 8 , 2 , 5 ,
Lexem 9 Current token='d' value='3' Tokenstr |a=(d,d,d,d| translated: numbers = ( 8 , 2 , 5 , 3
Lexem 10 Current token=',' value=',' Tokenstr |a=(d,d,d,d,| translated: numbers = ( 8 , 2 , 5 , 3 ,
Lexem 11 Current token='d' value='1' Tokenstr |a=(d,d,d,d,d| translated: numbers = ( 8 , 2 , 5 , 3 , 1
Lexem 12 Current token=',' value=',' Tokenstr |a=(d,d,d,d,d,| translated: numbers = ( 8 , 2 , 5 , 3 , 1 ,
Lexem 13 Current token='d' value='7' Tokenstr |a=(d,d,d,d,d,d| translated: numbers = ( 8 , 2 , 5 , 3 , 1 , 7
Lexem 14 Current token=')' value=')' Tokenstr |a=(d,d,d,d,d,d)| translated: numbers = ( 8 , 2 , 5 , 3 , 1 , 7 )

Line:   71 TokenStr: =|a=(d,d,d,d,d,d)|= @ValPy: numbers = ( 8 , 2 , 5 , 3 , 1 , 7 )
Generated partial line numbers = [
Generated partial line numbers = [8
Generated partial line numbers = [8,
Generated partial line numbers = [8,2
Generated partial line numbers = [8,2,
Generated partial line numbers = [8,2,5
Generated partial line numbers = [8,2,5,
Generated partial line numbers = [8,2,5,3
Generated partial line numbers = [8,2,5,3,
Generated partial line numbers = [8,2,5,3,1
Generated partial line numbers = [8,2,5,3,1,
Generated partial line numbers = [8,2,5,3,1,7
Generated partial line numbers = [8,2,5,3,1,7]
  71 | 0 |   |numbers = [8, 2, 5, 3, 1, 7]                                                            #PL: @numbers = (8, 2, 5, 3, 1, 7);

Tokens: a=(d,d,d,d,d,d) ValPy: 
Main loop, line=my @big_numbers = grep { $_ > 4 } @numbers;


 === Line 72 Perl source:my @big_numbers = grep { $_ > 4 } @numbers;===

Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' value='big_numbers' Tokenstr |ta| translated:  big_numbers
Lexem 2 Current token='=' value='=' Tokenstr |ta=| translated:  big_numbers =
Lexem 3 Current token='f' value='filter' Tokenstr |ta=f| translated:  big_numbers = filter
Lexem 4 Current token='(' value='[' Tokenstr |ta=f(| translated:  big_numbers = filter [
Lexem 5 Current token='s' value='_d' Tokenstr |ta=f(s| translated:  big_numbers = filter [ _d
Lexem 6 Current token='>' value='>' Tokenstr |ta=f(s>| translated:  big_numbers = filter [ _d >
Lexem 7 Current token='d' value='4' Tokenstr |ta=f(s>d| translated:  big_numbers = filter [ _d > 4
Lexem 8 Current token=')' value=']' Tokenstr |ta=f(s>d)| translated:  big_numbers = filter [ _d > 4 ]
Lexem 9 Current token='a' value='numbers' Tokenstr |ta=f(s>d)a| translated:  big_numbers = filter [ _d > 4 ] numbers

Line:   72 TokenStr: =|ta=f(s>d)a|= @ValPy:  big_numbers = filter [ _d > 4 ] numbers
assignment(0, 8) =|a=f(s>d)a|=  = grep { $_ > 4 } @numbers; = grep { $_ > 4 } ;

Generated partial line big_numbers
Generated partial line big_numbers=
expression(2, 8, 0) =|a=f(s>d)a|=  = grep { $_ > 4 } @numbers; = grep { $_ > 4 } ;

function(2, 8) =|a=f(s>d)a|=  = grep { $_ > 4 } @numbers; = grep { $_ > 4 } ;

function start=4, end_pos=6, bracketed=1
Generated partial line big_numbers=list(filter
Generated partial line big_numbers=list(filter(lambda _d:
expression(4, 6, 0) =|a=f(s>d)a|=  = grep { $_ > 4 } @numbers; = grep { $_ > 4 } ;

Generated partial line big_numbers=list(filter(lambda _d:_d
Generated partial line big_numbers=list(filter(lambda _d:_d>
Generated partial line big_numbers=list(filter(lambda _d:_d>4
expression returns 7
Generated partial line big_numbers=list(filter(lambda _d:_d>4,
expression(8, 8, 0) =|a=f(s>d)a|=  = grep { $_ > 4 } @numbers; = grep { $_ > 4 } ;

Generated partial line big_numbers=list(filter(lambda _d:_d>4,numbers
expression returns 9
Generated partial line big_numbers=list(filter(lambda _d:_d>4,numbers)
Generated partial line big_numbers=list(filter(lambda _d:_d>4,numbers))
expression returns 9
  72 | 0 |   |big_numbers = list(filter(lambda _d:_d>4, numbers))                                     #PL: my @big_numbers = grep { $_ > 4 } @numbers;

Tokens: a=f(s>d)a ValPy: 
Main loop, line=assert(scalar(@big_numbers) == 3);


 === Line 73 Perl source:assert(scalar(@big_numbers) == 3);===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='len' Tokenstr |c(f| translated: assert ( len
Lexem 3 Current token='(' value='(' Tokenstr |c(f(| translated: assert ( len (
Lexem 4 Current token='a' value='big_numbers' Tokenstr |c(f(a| translated: assert ( len ( big_numbers
Lexem 5 Current token=')' value=')' Tokenstr |c(f(a)| translated: assert ( len ( big_numbers )
Lexem 6 Current token='>' value='==' Tokenstr |c(f(a)>| translated: assert ( len ( big_numbers ) ==
Lexem 7 Current token='d' value='3' Tokenstr |c(f(a)>d| translated: assert ( len ( big_numbers ) == 3
Lexem 8 Current token=')' value=')' Tokenstr |c(f(a)>d)| translated: assert ( len ( big_numbers ) == 3 )

Line:   73 TokenStr: =|c(f(a)>d)|= @ValPy: assert ( len ( big_numbers ) == 3 )
control(0) =|c(f(a)>d)|= assert ( scalar ( ) == 3); ) == 3 )

control-parens removed, begin=0 start=1 =|cf(a)>d|= assert scalar ( ) == 3); ) == 3

Generated partial line assert
expression(1, 6, 0) =|cf(a)>d|= assert scalar ( ) == 3); ) == 3

function(1, 6) =|cf(a)>d|= assert scalar ( ) == 3); ) == 3

function start=3, end_pos=3, bracketed=1
Generated partial line assertlen
Generated partial line assertlen(
expression(3, 3, 0) =|cf(a)>d|= assert scalar ( ) == 3); ) == 3

Generated partial line assertlen(big_numbers
expression returns 4
Generated partial line assertlen(big_numbers)
Generated partial line assertlen(big_numbers)==
Generated partial line assertlen(big_numbers)==3
expression returns 7
  73 | 0 |   |assert len(big_numbers)==3                                                              #PL: assert(scalar(@big_numbers) == 3);

Tokens: cf(a)>d ValPy: 
  74 | 0 |   |
Main loop, line=my @names = qw(Foo Bar Baz);


 === Line 75 Perl source:my @names = qw(Foo Bar Baz);===

Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' value='names' Tokenstr |ta| translated:  names
Lexem 2 Current token='=' value='=' Tokenstr |ta=| translated:  names =
Lexem 3 Current token='q' value='"Foo Bar Baz".split()' Tokenstr |ta=q| translated:  names = "Foo Bar Baz".split()

Line:   75 TokenStr: =|ta=q|= @ValPy:  names = "Foo Bar Baz".split()
assignment(0, 2) =|a=q|=  = qw(Foo Bar Baz); = Foo Bar Baz

Generated partial line names
Generated partial line names=
assign, ValClass[limit] = q, ValPy="Foo Bar Baz".split(), ValPerl=Foo Bar Baz

Generated partial line names="Foo Bar Baz".split()
  75 | 0 |   |names = "Foo Bar Baz".split()                                                           #PL: my @names = qw(Foo Bar Baz);

Tokens: a=q ValPy: 
Main loop, line=my $visitor = 'Bar';


 === Line 76 Perl source:my $visitor = 'Bar';===

Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='s' value='visitor' Tokenstr |ts| translated:  visitor
Lexem 2 Current token='=' value='=' Tokenstr |ts=| translated:  visitor =
Lexem 3 Current token='"' value=''Bar'' Tokenstr |ts="| translated:  visitor = 'Bar'

Line:   76 TokenStr: =|ts="|= @ValPy:  visitor = 'Bar'
  76 | 0 |   |visitor='Bar'                                                                           #PL: my $visitor = 'Bar';
Main loop, line=assert(grep { $visitor eq $_ } @names);


 === Line 77 Perl source:assert(grep { $visitor eq $_ } @names);===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='filter' Tokenstr |c(f| translated: assert ( filter
Lexem 3 Current token='(' value='[' Tokenstr |c(f(| translated: assert ( filter [
Lexem 4 Current token='s' value='visitor' Tokenstr |c(f(s| translated: assert ( filter [ visitor
Lexem 5 Current token='>' value='==' Tokenstr |c(f(s>| translated: assert ( filter [ visitor ==
Lexem 6 Current token='s' value='_d' Tokenstr |c(f(s>s| translated: assert ( filter [ visitor == _d
Lexem 7 Current token=')' value=']' Tokenstr |c(f(s>s)| translated: assert ( filter [ visitor == _d ]
Lexem 8 Current token='a' value='names' Tokenstr |c(f(s>s)a| translated: assert ( filter [ visitor == _d ] names
Lexem 9 Current token=')' value=')' Tokenstr |c(f(s>s)a)| translated: assert ( filter [ visitor == _d ] names )

Line:   77 TokenStr: =|c(f(s>s)a)|= @ValPy: assert ( filter [ visitor == _d ] names )
control(0) =|c(f(s>s)a)|= assert ( grep { $visitor eq $_ } ); )

control-parens removed, begin=0 start=1 =|cf(s>s)a|= assert grep { $visitor eq $_ } );

Generated partial line assert
expression(1, 7, 0) =|cf(s>s)a|= assert grep { $visitor eq $_ } );

function(1, 7) =|cf(s>s)a|= assert grep { $visitor eq $_ } );

function start=3, end_pos=5, bracketed=1
Generated partial line assertlist(filter
Generated partial line assertlist(filter(lambda _d:
expression(3, 5, 0) =|cf(s>s)a|= assert grep { $visitor eq $_ } );

Generated partial line assertlist(filter(lambda _d:visitor
Generated partial line assertlist(filter(lambda _d:visitor==
Generated partial line assertlist(filter(lambda _d:visitor==_d
expression returns 6
Generated partial line assertlist(filter(lambda _d:visitor==_d,
expression(7, 7, 0) =|cf(s>s)a|= assert grep { $visitor eq $_ } );

Generated partial line assertlist(filter(lambda _d:visitor==_d,names
expression returns 8
Generated partial line assertlist(filter(lambda _d:visitor==_d,names)
Generated partial line assertlist(filter(lambda _d:visitor==_d,names))
expression returns 8
  77 | 0 |   |assert list(filter(lambda _d:visitor==_d, names))                                       #PL: assert(grep { $visitor eq $_ } @names);

Tokens: cf(s>s)a ValPy: 
Main loop, line=assert(!grep { 'Fred' eq $_ } @names);


 === Line 78 Perl source:assert(!grep { 'Fred' eq $_ } @names);===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='!' value='not' Tokenstr |c(!| translated: assert ( not
Lexem 3 Current token='f' value='filter' Tokenstr |c(!f| translated: assert ( not filter
Lexem 4 Current token='(' value='[' Tokenstr |c(!f(| translated: assert ( not filter [
Lexem 5 Current token='"' value=''Fred'' Tokenstr |c(!f("| translated: assert ( not filter [ 'Fred'
Lexem 6 Current token='>' value='==' Tokenstr |c(!f(">| translated: assert ( not filter [ 'Fred' ==
Lexem 7 Current token='s' value='_d' Tokenstr |c(!f(">s| translated: assert ( not filter [ 'Fred' == _d
Lexem 8 Current token=')' value=']' Tokenstr |c(!f(">s)| translated: assert ( not filter [ 'Fred' == _d ]
Lexem 9 Current token='a' value='names' Tokenstr |c(!f(">s)a| translated: assert ( not filter [ 'Fred' == _d ] names
Lexem 10 Current token=')' value=')' Tokenstr |c(!f(">s)a)| translated: assert ( not filter [ 'Fred' == _d ] names )

Line:   78 TokenStr: =|c(!f(">s)a)|= @ValPy: assert ( not filter [ 'Fred' == _d ] names )
control(0) =|c(!f(">s)a)|= assert ( ! grep { Fred eq $_ } ); )

control-parens removed, begin=0 start=1 =|c!f(">s)a|= assert ! grep { Fred eq $_ } );

Generated partial line assert
expression(1, 8, 0) =|c!f(">s)a|= assert ! grep { Fred eq $_ } );

Generated partial line assertnot
function(2, 8) =|c!f(">s)a|= assert ! grep { Fred eq $_ } );

function start=4, end_pos=6, bracketed=1
Generated partial line assertnotlist(filter
Generated partial line assertnotlist(filter(lambda _d:
expression(4, 6, 0) =|c!f(">s)a|= assert ! grep { Fred eq $_ } );

Generated partial line assertnotlist(filter(lambda _d:'Fred'
Generated partial line assertnotlist(filter(lambda _d:'Fred'==
Generated partial line assertnotlist(filter(lambda _d:'Fred'==_d
expression returns 7
Generated partial line assertnotlist(filter(lambda _d:'Fred'==_d,
expression(8, 8, 0) =|c!f(">s)a|= assert ! grep { Fred eq $_ } );

Generated partial line assertnotlist(filter(lambda _d:'Fred'==_d,names
expression returns 9
Generated partial line assertnotlist(filter(lambda _d:'Fred'==_d,names)
Generated partial line assertnotlist(filter(lambda _d:'Fred'==_d,names))
expression returns 9
  78 | 0 |   |assert not list(filter(lambda _d:'Fred'==_d, names))                                    #PL: assert(!grep { 'Fred' eq $_ } @names);

Tokens: c!f(">s)a ValPy: 
Main loop, line=my @foo = grep($_ eq 'Foo', @names);


 === Line 79 Perl source:my @foo = grep($_ eq 'Foo', @names);===

Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' value='foo' Tokenstr |ta| translated:  foo
Lexem 2 Current token='=' value='=' Tokenstr |ta=| translated:  foo =
Lexem 3 Current token='f' value='filter' Tokenstr |ta=f| translated:  foo = filter
Lexem 4 Current token='(' value='(' Tokenstr |ta=f(| translated:  foo = filter (
Lexem 5 Current token='s' value='_d' Tokenstr |ta=f(s| translated:  foo = filter ( _d
Lexem 6 Current token='>' value='==' Tokenstr |ta=f(s>| translated:  foo = filter ( _d ==
Lexem 7 Current token='"' value=''Foo'' Tokenstr |ta=f(s>"| translated:  foo = filter ( _d == 'Foo'
Lexem 8 Current token=',' value=',' Tokenstr |ta=f(s>",| translated:  foo = filter ( _d == 'Foo' ,
Lexem 9 Current token='a' value='names' Tokenstr |ta=f(s>",a| translated:  foo = filter ( _d == 'Foo' , names
Lexem 10 Current token=')' value=')' Tokenstr |ta=f(s>",a)| translated:  foo = filter ( _d == 'Foo' , names )

Line:   79 TokenStr: =|ta=f(s>",a)|= @ValPy:  foo = filter ( _d == 'Foo' , names )
assignment(0, 9) =|a=f(s>",a)|=  = grep($_ eq 'Foo', @names); = grep ( $_ eq Foo , ); )

Generated partial line foo
Generated partial line foo=
expression(2, 9, 0) =|a=f(s>",a)|=  = grep($_ eq 'Foo', @names); = grep ( $_ eq Foo , ); )

function(2, 9) =|a=f(s>",a)|=  = grep($_ eq 'Foo', @names); = grep ( $_ eq Foo , ); )

function start=4, end_pos=8, bracketed=1
Generated partial line foo=list(filter
Generated partial line foo=list(filter(lambda _d:
expression(4, 6, 0) =|a=f(s>",a)|=  = grep($_ eq 'Foo', @names); = grep ( $_ eq Foo , ); )

Generated partial line foo=list(filter(lambda _d:_d
Generated partial line foo=list(filter(lambda _d:_d==
Generated partial line foo=list(filter(lambda _d:_d=='Foo'
expression returns 7
Generated partial line foo=list(filter(lambda _d:_d=='Foo',
expression(8, 9, 0) =|a=f(s>",a)|=  = grep($_ eq 'Foo', @names); = grep ( $_ eq Foo , ); )

Generated partial line foo=list(filter(lambda _d:_d=='Foo',names
Generated partial line foo=list(filter(lambda _d:_d=='Foo',names)
expression returns 10
Generated partial line foo=list(filter(lambda _d:_d=='Foo',names))
expression returns 10
  79 | 0 |   |foo = list(filter(lambda _d:_d=='Foo', names))                                          #PL: my @foo = grep($_ eq 'Foo', @names);

Tokens: a=f(s>",a) ValPy: 
Main loop, line=assert(scalar(@foo) == 1 && $foo[0] eq 'Foo');


 === Line 80 Perl source:assert(scalar(@foo) == 1 && $foo[0] eq 'Foo');===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='len' Tokenstr |c(f| translated: assert ( len
Lexem 3 Current token='(' value='(' Tokenstr |c(f(| translated: assert ( len (
Lexem 4 Current token='a' value='foo' Tokenstr |c(f(a| translated: assert ( len ( foo
Lexem 5 Current token=')' value=')' Tokenstr |c(f(a)| translated: assert ( len ( foo )
Lexem 6 Current token='>' value='==' Tokenstr |c(f(a)>| translated: assert ( len ( foo ) ==
Lexem 7 Current token='d' value='1' Tokenstr |c(f(a)>d| translated: assert ( len ( foo ) == 1
Lexem 8 Current token='0' value=' and ' Tokenstr |c(f(a)>d0| translated: assert ( len ( foo ) == 1  and 
Lexem 9 Current token='s' value='foo' Tokenstr |c(f(a)>d0s| translated: assert ( len ( foo ) == 1  and  foo
Lexem 10 Current token='(' value='[' Tokenstr |c(f(a)>d0s(| translated: assert ( len ( foo ) == 1  and  foo [
Lexem 11 Current token='d' value='0' Tokenstr |c(f(a)>d0s(d| translated: assert ( len ( foo ) == 1  and  foo [ 0
Lexem 12 Current token=')' value=']' Tokenstr |c(f(a)>d0s(d)| translated: assert ( len ( foo ) == 1  and  foo [ 0 ]
Lexem 13 Current token='>' value='==' Tokenstr |c(f(a)>d0s(d)>| translated: assert ( len ( foo ) == 1  and  foo [ 0 ] ==
Lexem 14 Current token='"' value=''Foo'' Tokenstr |c(f(a)>d0s(d)>"| translated: assert ( len ( foo ) == 1  and  foo [ 0 ] == 'Foo'
Lexem 15 Current token=')' value=')' Tokenstr |c(f(a)>d0s(d)>")| translated: assert ( len ( foo ) == 1  and  foo [ 0 ] == 'Foo' )

Line:   80 TokenStr: =|c(f(a)>d0s(d)>")|= @ValPy: assert ( len ( foo ) == 1  and  foo [ 0 ] == 'Foo' )
control(0) =|c(f(a)>d0s(d)>")|= assert ( scalar ( ) == 1 && $foo[0] eq 'Foo'); ) == 1 && $foo [ 0 ] eq Foo )

control-parens removed, begin=0 start=1 =|cf(a)>d0s(d)>"|= assert scalar ( ) == 1 && $foo[0] eq 'Foo'); ) == 1 && $foo [ 0 ] eq Foo

Generated partial line assert
expression(1, 13, 0) =|cf(a)>d0s(d)>"|= assert scalar ( ) == 1 && $foo[0] eq 'Foo'); ) == 1 && $foo [ 0 ] eq Foo

function(1, 7) =|cf(a)>d0s(d)>"|= assert scalar ( ) == 1 && $foo[0] eq 'Foo'); ) == 1 && $foo [ 0 ] eq Foo

function start=3, end_pos=3, bracketed=1
Generated partial line assertlen
Generated partial line assertlen(
expression(3, 3, 0) =|cf(a)>d0s(d)>"|= assert scalar ( ) == 1 && $foo[0] eq 'Foo'); ) == 1 && $foo [ 0 ] eq Foo

Generated partial line assertlen(foo
expression returns 4
Generated partial line assertlen(foo)
Generated partial line assertlen(foo)==
Generated partial line assertlen(foo)==1
Generated partial line assertlen(foo)==1 and 
Generated partial line assertlen(foo)==1 and foo
Generated partial line assertlen(foo)==1 and foo[
expression(10, 10, 0) =|cf(a)>d0s(d)>"|= assert scalar ( ) == 1 && $foo[0] eq 'Foo'); ) == 1 && $foo [ 0 ] eq Foo

Generated partial line assertlen(foo)==1 and foo[0
expression returns 11
Generated partial line assertlen(foo)==1 and foo[0]
Generated partial line assertlen(foo)==1 and foo[0]==
Generated partial line assertlen(foo)==1 and foo[0]=='Foo'
expression returns 14
  80 | 0 |   |assert len(foo)==1 and foo[0]=='Foo'                                                    #PL: assert(scalar(@foo) == 1 && $foo[0] eq 'Foo');

Tokens: cf(a)>d0s(d)>" ValPy: 
Main loop, line=my @bs = grep(/B/, @names);


 === Line 81 Perl source:my @bs = grep(/B/, @names);===

Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' value='bs' Tokenstr |ta| translated:  bs
Lexem 2 Current token='=' value='=' Tokenstr |ta=| translated:  bs =
Lexem 3 Current token='f' value='filter' Tokenstr |ta=f| translated:  bs = filter
Lexem 4 Current token='(' value='(' Tokenstr |ta=f(| translated:  bs = filter (
Lexem 5 Current token='q' value='r'B'' Tokenstr |ta=f(q| translated:  bs = filter ( r'B'
Lexem 6 Current token=',' value=',' Tokenstr |ta=f(q,| translated:  bs = filter ( r'B' ,
Lexem 7 Current token='a' value='names' Tokenstr |ta=f(q,a| translated:  bs = filter ( r'B' , names
Lexem 8 Current token=')' value=')' Tokenstr |ta=f(q,a)| translated:  bs = filter ( r'B' , names )

Line:   81 TokenStr: =|ta=f(q,a)|= @ValPy:  bs = filter ( r'B' , names )
assignment(0, 7) =|a=f(q,a)|=  = grep(/B/, @names); = grep ( B , ); )

Generated partial line bs
Generated partial line bs=
expression(2, 7, 0) =|a=f(q,a)|=  = grep(/B/, @names); = grep ( B , ); )

function(2, 7) =|a=f(q,a)|=  = grep(/B/, @names); = grep ( B , ); )

function start=4, end_pos=6, bracketed=1
Generated partial line bs=list(filter
Generated partial line bs=list(filter(lambda _d:
Generated partial line bs=list(filter(lambda _d:re.search(r'B',_d)
Generated partial line bs=list(filter(lambda _d:re.search(r'B',_d),
expression(6, 7, 0) =|a=f(q,a)|=  = grep(/B/, @names); = grep ( B , ); )

Generated partial line bs=list(filter(lambda _d:re.search(r'B',_d),names
Generated partial line bs=list(filter(lambda _d:re.search(r'B',_d),names)
expression returns 8
Generated partial line bs=list(filter(lambda _d:re.search(r'B',_d),names))
expression returns 8
  81 | 0 |   |bs = list(filter(lambda _d:re.search(r'B', _d), names))                                 #PL: my @bs = grep(/B/, @names);

Tokens: a=f(q,a) ValPy: 
Main loop, line=assert(scalar(@bs) == 2);


 === Line 82 Perl source:assert(scalar(@bs) == 2);===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='len' Tokenstr |c(f| translated: assert ( len
Lexem 3 Current token='(' value='(' Tokenstr |c(f(| translated: assert ( len (
Lexem 4 Current token='a' value='bs' Tokenstr |c(f(a| translated: assert ( len ( bs
Lexem 5 Current token=')' value=')' Tokenstr |c(f(a)| translated: assert ( len ( bs )
Lexem 6 Current token='>' value='==' Tokenstr |c(f(a)>| translated: assert ( len ( bs ) ==
Lexem 7 Current token='d' value='2' Tokenstr |c(f(a)>d| translated: assert ( len ( bs ) == 2
Lexem 8 Current token=')' value=')' Tokenstr |c(f(a)>d)| translated: assert ( len ( bs ) == 2 )

Line:   82 TokenStr: =|c(f(a)>d)|= @ValPy: assert ( len ( bs ) == 2 )
control(0) =|c(f(a)>d)|= assert ( scalar ( ) == 2); ) == 2 )

control-parens removed, begin=0 start=1 =|cf(a)>d|= assert scalar ( ) == 2); ) == 2

Generated partial line assert
expression(1, 6, 0) =|cf(a)>d|= assert scalar ( ) == 2); ) == 2

function(1, 6) =|cf(a)>d|= assert scalar ( ) == 2); ) == 2

function start=3, end_pos=3, bracketed=1
Generated partial line assertlen
Generated partial line assertlen(
expression(3, 3, 0) =|cf(a)>d|= assert scalar ( ) == 2); ) == 2

Generated partial line assertlen(bs
expression returns 4
Generated partial line assertlen(bs)
Generated partial line assertlen(bs)==
Generated partial line assertlen(bs)==2
expression returns 7
  82 | 0 |   |assert len(bs)==2                                                                       #PL: assert(scalar(@bs) == 2);

Tokens: cf(a)>d ValPy: 
Main loop, line=my @bs = grep /b/i, @names;


 === Line 83 Perl source:my @bs = grep /b/i, @names;===

Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='a' value='bs' Tokenstr |ta| translated:  bs
Lexem 2 Current token='=' value='=' Tokenstr |ta=| translated:  bs =
Lexem 3 Current token='f' value='filter' Tokenstr |ta=f| translated:  bs = filter
Lexem 4 Current token='q' value='re.search(re.compile(r'b',re.I),_d)' Tokenstr |ta=fq| translated:  bs = filter re.search(re.compile(r'b',re.I),_d)
Lexem 5 Current token=',' value=',' Tokenstr |ta=fq,| translated:  bs = filter re.search(re.compile(r'b',re.I),_d) ,
Lexem 6 Current token='a' value='names' Tokenstr |ta=fq,a| translated:  bs = filter re.search(re.compile(r'b',re.I),_d) , names

Line:   83 TokenStr: =|ta=fq,a|= @ValPy:  bs = filter re.search(re.compile(r'b',re.I),_d) , names
assignment(0, 5) =|a=fq,a|=  = grep /b/i, @names; = grep b , ;

Generated partial line bs
Generated partial line bs=
expression(2, 5, 0) =|a=fq,a|=  = grep /b/i, @names; = grep b , ;

function(2, 5) =|a=fq,a|=  = grep /b/i, @names; = grep b , ;

function start=3, end_pos=5, bracketed=0
Generated partial line bs=list(filter
Generated partial line bs=list(filter(lambda _d:
Generated partial line bs=list(filter(lambda _d:re.search(re.compile(r'b',re.I),_d)
Generated partial line bs=list(filter(lambda _d:re.search(re.compile(r'b',re.I),_d),
expression(5, 5, 0) =|a=fq,a|=  = grep /b/i, @names; = grep b , ;

Generated partial line bs=list(filter(lambda _d:re.search(re.compile(r'b',re.I),_d),names
expression returns 6
Generated partial line bs=list(filter(lambda _d:re.search(re.compile(r'b',re.I),_d),names)
Generated partial line bs=list(filter(lambda _d:re.search(re.compile(r'b',re.I),_d),names))
expression returns 6
  83 | 0 |   |bs = list(filter(lambda _d:re.search(re.compile(r'b',re.I),_d), names))                 #PL: my @bs = grep /b/i, @names;

Tokens: a=fq,a ValPy: 
Main loop, line=assert(scalar(@bs) == 2);


 === Line 84 Perl source:assert(scalar(@bs) == 2);===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='len' Tokenstr |c(f| translated: assert ( len
Lexem 3 Current token='(' value='(' Tokenstr |c(f(| translated: assert ( len (
Lexem 4 Current token='a' value='bs' Tokenstr |c(f(a| translated: assert ( len ( bs
Lexem 5 Current token=')' value=')' Tokenstr |c(f(a)| translated: assert ( len ( bs )
Lexem 6 Current token='>' value='==' Tokenstr |c(f(a)>| translated: assert ( len ( bs ) ==
Lexem 7 Current token='d' value='2' Tokenstr |c(f(a)>d| translated: assert ( len ( bs ) == 2
Lexem 8 Current token=')' value=')' Tokenstr |c(f(a)>d)| translated: assert ( len ( bs ) == 2 )

Line:   84 TokenStr: =|c(f(a)>d)|= @ValPy: assert ( len ( bs ) == 2 )
control(0) =|c(f(a)>d)|= assert ( scalar ( ) == 2); ) == 2 )

control-parens removed, begin=0 start=1 =|cf(a)>d|= assert scalar ( ) == 2); ) == 2

Generated partial line assert
expression(1, 6, 0) =|cf(a)>d|= assert scalar ( ) == 2); ) == 2

function(1, 6) =|cf(a)>d|= assert scalar ( ) == 2); ) == 2

function start=3, end_pos=3, bracketed=1
Generated partial line assertlen
Generated partial line assertlen(
expression(3, 3, 0) =|cf(a)>d|= assert scalar ( ) == 2); ) == 2

Generated partial line assertlen(bs
expression returns 4
Generated partial line assertlen(bs)
Generated partial line assertlen(bs)==
Generated partial line assertlen(bs)==2
expression returns 7
  84 | 0 |   |assert len(bs)==2                                                                       #PL: assert(scalar(@bs) == 2);

Tokens: cf(a)>d ValPy: 
Main loop, line=assert(grep('Baz', @names));


 === Line 85 Perl source:assert(grep('Baz', @names));===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='filter' Tokenstr |c(f| translated: assert ( filter
Lexem 3 Current token='(' value='(' Tokenstr |c(f(| translated: assert ( filter (
Lexem 4 Current token='"' value=''Baz'' Tokenstr |c(f("| translated: assert ( filter ( 'Baz'
Lexem 5 Current token=',' value=',' Tokenstr |c(f(",| translated: assert ( filter ( 'Baz' ,
Lexem 6 Current token='a' value='names' Tokenstr |c(f(",a| translated: assert ( filter ( 'Baz' , names
Lexem 7 Current token=')' value=')' Tokenstr |c(f(",a)| translated: assert ( filter ( 'Baz' , names )
Lexem 8 Current token=')' value=')' Tokenstr |c(f(",a))| translated: assert ( filter ( 'Baz' , names ) )

Line:   85 TokenStr: =|c(f(",a))|= @ValPy: assert ( filter ( 'Baz' , names ) )
control(0) =|c(f(",a))|= assert ( grep ( Baz , )); ) )

control-parens removed, begin=0 start=1 =|cf(",a)|= assert grep ( Baz , )); )

Generated partial line assert
expression(1, 6, 0) =|cf(",a)|= assert grep ( Baz , )); )

function(1, 6) =|cf(",a)|= assert grep ( Baz , )); )

function start=3, end_pos=5, bracketed=1
Generated partial line assertlist(filter
Generated partial line assertlist(filter(lambda _d:
Generated partial line assertlist(filter(lambda _d:_d=='Baz'
Generated partial line assertlist(filter(lambda _d:_d=='Baz',
expression(5, 6, 0) =|cf(",a)|= assert grep ( Baz , )); )

Generated partial line assertlist(filter(lambda _d:_d=='Baz',names
Generated partial line assertlist(filter(lambda _d:_d=='Baz',names)
expression returns 7
Generated partial line assertlist(filter(lambda _d:_d=='Baz',names))
expression returns 7
  85 | 0 |   |assert list(filter(lambda _d:_d=='Baz', names))                                         #PL: assert(grep('Baz', @names));

Tokens: cf(",a) ValPy: 
Main loop, line=@bz = qw/Baz/;


 === Line 86 Perl source:@bz = qw/Baz/;===

Lexem 0 Current token='a' value='bz' Tokenstr |a| translated: bz
Lexem 1 Current token='=' value='=' Tokenstr |a=| translated: bz =
Lexem 2 Current token='q' value='"Baz".split()' Tokenstr |a=q| translated: bz = "Baz".split()

Line:   86 TokenStr: =|a=q|= @ValPy: bz = "Baz".split()
assignment(0, 2) =|a=q|=  = qw/Baz/; = Baz

Generated partial line bz
Generated partial line bz=
assign, ValClass[limit] = q, ValPy="Baz".split(), ValPerl=Baz

Generated partial line bz="Baz".split()
  86 | 0 |   |bz = "Baz".split()                                                                      #PL: @bz = qw/Baz/;

Tokens: a=q ValPy: 
Main loop, line=assert(grep($bz[0], @names));


 === Line 87 Perl source:assert(grep($bz[0], @names));===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='f' value='filter' Tokenstr |c(f| translated: assert ( filter
Lexem 3 Current token='(' value='(' Tokenstr |c(f(| translated: assert ( filter (
Lexem 4 Current token='s' value='bz' Tokenstr |c(f(s| translated: assert ( filter ( bz
Lexem 5 Current token='(' value='[' Tokenstr |c(f(s(| translated: assert ( filter ( bz [
Lexem 6 Current token='d' value='0' Tokenstr |c(f(s(d| translated: assert ( filter ( bz [ 0
Lexem 7 Current token=')' value=']' Tokenstr |c(f(s(d)| translated: assert ( filter ( bz [ 0 ]
Lexem 8 Current token=',' value=',' Tokenstr |c(f(s(d),| translated: assert ( filter ( bz [ 0 ] ,
Lexem 9 Current token='a' value='names' Tokenstr |c(f(s(d),a| translated: assert ( filter ( bz [ 0 ] , names
Lexem 10 Current token=')' value=')' Tokenstr |c(f(s(d),a)| translated: assert ( filter ( bz [ 0 ] , names )
Lexem 11 Current token=')' value=')' Tokenstr |c(f(s(d),a))| translated: assert ( filter ( bz [ 0 ] , names ) )

Line:   87 TokenStr: =|c(f(s(d),a))|= @ValPy: assert ( filter ( bz [ 0 ] , names ) )
control(0) =|c(f(s(d),a))|= assert ( grep ( $bz [ 0 ] , )); ) )

control-parens removed, begin=0 start=1 =|cf(s(d),a)|= assert grep ( $bz [ 0 ] , )); )

Generated partial line assert
expression(1, 9, 0) =|cf(s(d),a)|= assert grep ( $bz [ 0 ] , )); )

function(1, 9) =|cf(s(d),a)|= assert grep ( $bz [ 0 ] , )); )

function start=3, end_pos=8, bracketed=1
Generated partial line assertlist(filter
Generated partial line assertlist(filter(lambda _d:
expression(3, 6, 0) =|cf(s(d),a)|= assert grep ( $bz [ 0 ] , )); )

Generated partial line assertlist(filter(lambda _d:bz
Generated partial line assertlist(filter(lambda _d:bz[
expression(5, 5, 0) =|cf(s(d),a)|= assert grep ( $bz [ 0 ] , )); )

Generated partial line assertlist(filter(lambda _d:bz[0
expression returns 6
Generated partial line assertlist(filter(lambda _d:bz[0]
expression returns 7
Generated partial line assertlist(filter(lambda _d:bz[0],
expression(8, 9, 0) =|cf(s(d),a)|= assert grep ( $bz [ 0 ] , )); )

Generated partial line assertlist(filter(lambda _d:bz[0],names
Generated partial line assertlist(filter(lambda _d:bz[0],names)
expression returns 10
Generated partial line assertlist(filter(lambda _d:bz[0],names))
expression returns 10
  87 | 0 |   |assert list(filter(lambda _d:bz[0], names))                                             #PL: assert(grep($bz[0], @names));

Tokens: cf(s(d),a) ValPy: 
  88 | 0 |   |
Main loop, line=my $string = "the quick brown fox jumped over the lazy dog";


 === Line 89 Perl source:my $string = "the quick brown fox jumped over the lazy dog";===

Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='s' value='string' Tokenstr |ts| translated:  string
Lexem 2 Current token='=' value='=' Tokenstr |ts=| translated:  string =
Lexem 3 Current token='"' value=''the quick brown fox jumped over the lazy dog'' Tokenstr |ts="| translated:  string = 'the quick brown fox jumped over the lazy dog'

Line:   89 TokenStr: =|ts="|= @ValPy:  string = 'the quick brown fox jumped over the lazy dog'
  89 | 0 |   |string='the quick brown fox jumped over the lazy dog'                                   #PL: my $string = "the quick brown fox jumped over the lazy dog";
Main loop, line=my $count_the_fox = $string =~ /\s+([a-z][a-z]x)\s+/;	# 1


 === Line 90 Perl source:my $count_the_fox = $string =~ /\s+([a-z][a-z]x)\s+/;	# 1===

Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='s' value='count_the_fox' Tokenstr |ts| translated:  count_the_fox
Lexem 2 Current token='=' value='=' Tokenstr |ts=| translated:  count_the_fox =
Lexem 3 Current token='s' value='string' Tokenstr |ts=s| translated:  count_the_fox = string
Lexem 4 Current token='~' value='' Tokenstr |ts=s~| translated:  count_the_fox = string 
Lexem 5 Current token='q' value='(_m:=re.search(r'\s+([a-z][a-z]x)\s+',' Tokenstr |ts=s~q| translated:  count_the_fox = string  (_m:=re.search(r'\s+([a-z][a-z]x)\s+',

Line:   90 TokenStr: =|ts=s~q|= @ValPy:  count_the_fox = string  (_m:=re.search(r'\s+([a-z][a-z]x)\s+',
assignment(1, 5) =|ts=s~q|= my $count_the_fox = $string =~ \s+([a-z][a-z]x)\s+

Generated partial line count_the_fox
Generated partial line count_the_fox=
expression(3, 5, 0) =|ts=s~q|= my $count_the_fox = $string =~ \s+([a-z][a-z]x)\s+

Generated partial line count_the_fox=(_m:=re.search(r'\s+([a-z][a-z]x)\s+',
expression(3, 3, 0) =|ts=s~q|= my $count_the_fox = $string =~ \s+([a-z][a-z]x)\s+

Generated partial line count_the_fox=(_m:=re.search(r'\s+([a-z][a-z]x)\s+',string
expression returns 4
Generated partial line count_the_fox=(_m:=re.search(r'\s+([a-z][a-z]x)\s+',string),len(_m.groups()) if _m else 0)[1]
expression returns 6
  90 | 0 |   |count_the_fox = (_m:=re.search(r'\s+([a-z][a-z]x)\s+',string),len(_m.groups()) if _m else 0)[1] # 1
                                                                                                      #PL: my $count_the_fox = $string =~ /\s+([a-z][a-z]x)\s+/;

Tokens: ts=s~q ValPy: 
Main loop, line=assert($count_the_fox == 1);


 === Line 91 Perl source:assert($count_the_fox == 1);===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='count_the_fox' Tokenstr |c(s| translated: assert ( count_the_fox
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( count_the_fox ==
Lexem 4 Current token='d' value='1' Tokenstr |c(s>d| translated: assert ( count_the_fox == 1
Lexem 5 Current token=')' value=')' Tokenstr |c(s>d)| translated: assert ( count_the_fox == 1 )

Line:   91 TokenStr: =|c(s>d)|= @ValPy: assert ( count_the_fox == 1 )
control(0) =|c(s>d)|= assert ( $count_the_fox == 1 )

control-parens removed, begin=0 start=1 =|cs>d|= assert $count_the_fox == 1

Generated partial line assert
expression(1, 3, 0) =|cs>d|= assert $count_the_fox == 1

Generated partial line assertcount_the_fox
Generated partial line assertcount_the_fox==
Generated partial line assertcount_the_fox==1
expression returns 4
  91 | 0 |   |assert count_the_fox==1                                                                 #PL: assert($count_the_fox == 1);

Tokens: cs>d ValPy: 
Main loop, line=my ($find_the_fox) = $string =~ /\s+([a-z][a-z]x)\s+/;	# "fox"


 === Line 92 Perl source:my ($find_the_fox) = $string =~ /\s+([a-z][a-z]x)\s+/;	# "fox"===

Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='(' value='(' Tokenstr |t(| translated:  (
Lexem 2 Current token='s' value='find_the_fox' Tokenstr |t(s| translated:  ( find_the_fox
Lexem 3 Current token=')' value=')' Tokenstr |t(s)| translated:  ( find_the_fox )
Lexem 4 Current token='=' value='=' Tokenstr |t(s)=| translated:  ( find_the_fox ) =
Lexem 5 Current token='s' value='string' Tokenstr |t(s)=s| translated:  ( find_the_fox ) = string
Lexem 6 Current token='~' value='' Tokenstr |t(s)=s~| translated:  ( find_the_fox ) = string 
Lexem 7 Current token='q' value='(_m:=re.search(r'\s+([a-z][a-z]x)\s+',' Tokenstr |t(s)=s~q| translated:  ( find_the_fox ) = string  (_m:=re.search(r'\s+([a-z][a-z]x)\s+',

Line:   92 TokenStr: =|t(s)=s~q|= @ValPy:  ( find_the_fox ) = string  (_m:=re.search(r'\s+([a-z][a-z]x)\s+',
assignment(1, 7) =|t(s)=s~q|= my ( $find_the_fox ) = $string =~ \s+([a-z][a-z]x)\s+

Generated partial line [
Generated partial line [find_the_fox
Generated partial line [find_the_fox]
Generated partial line [find_the_fox]=
Generated partial line [find_the_fox]=_list_of_n(
expression(5, 7, 0) =|t(s)=s~q|= my ( $find_the_fox ) = $string =~ \s+([a-z][a-z]x)\s+

Generated partial line [find_the_fox]=_list_of_n((_m:=re.search(r'\s+([a-z][a-z]x)\s+',
expression(5, 5, 0) =|t(s)=s~q|= my ( $find_the_fox ) = $string =~ \s+([a-z][a-z]x)\s+

Generated partial line [find_the_fox]=_list_of_n((_m:=re.search(r'\s+([a-z][a-z]x)\s+',string
expression returns 6
Generated partial line [find_the_fox]=_list_of_n((_m:=re.search(r'\s+([a-z][a-z]x)\s+',string),_m.groups() if _m else [])[1]
expression returns 8
Generated partial line [find_the_fox]=_list_of_n((_m:=re.search(r'\s+([a-z][a-z]x)\s+',string),_m.groups() if _m else [])[1], 1)
  92 | 0 |   |[find_the_fox] = _list_of_n((_m:=re.search(r'\s+([a-z][a-z]x)\s+',string),_m.groups() if _m else [])[1], 1) # "fox"
                                                                                                      #PL: my ($find_the_fox) = $string =~ /\s+([a-z][a-z]x)\s+/;

Tokens: t(s)=s~q ValPy: 
Main loop, line=assert($find_the_fox == 'fox');


 === Line 93 Perl source:assert($find_the_fox == 'fox');===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='find_the_fox' Tokenstr |c(s| translated: assert ( find_the_fox
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( find_the_fox ==
Lexem 4 Current token='"' value=''fox'' Tokenstr |c(s>"| translated: assert ( find_the_fox == 'fox'
Lexem 5 Current token=')' value=')' Tokenstr |c(s>")| translated: assert ( find_the_fox == 'fox' )

Line:   93 TokenStr: =|c(s>")|= @ValPy: assert ( find_the_fox == 'fox' )
control(0) =|c(s>")|= assert ( $find_the_fox == fox )

control-parens removed, begin=0 start=1 =|cs>"|= assert $find_the_fox == fox

Generated partial line assert
expression(1, 3, 0) =|cs>"|= assert $find_the_fox == fox

Generated partial line assertfind_the_fox
Generated partial line assertfind_the_fox==
Generated partial line assertfind_the_fox=='fox'
expression returns 4
  93 | 0 |   |assert find_the_fox=='fox'                                                              #PL: assert($find_the_fox == 'fox');

Tokens: cs>" ValPy: 
  94 | 0 |   |
Main loop, line=assert(my_add(1, 2) == 3);


 === Line 95 Perl source:assert(my_add(1, 2) == 3);===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='i' value='my_add' Tokenstr |c(i| translated: assert ( my_add
Lexem 3 Current token='(' value='(' Tokenstr |c(i(| translated: assert ( my_add (
Lexem 4 Current token='d' value='1' Tokenstr |c(i(d| translated: assert ( my_add ( 1
Lexem 5 Current token=',' value=',' Tokenstr |c(i(d,| translated: assert ( my_add ( 1 ,
Lexem 6 Current token='d' value='2' Tokenstr |c(i(d,d| translated: assert ( my_add ( 1 , 2
Lexem 7 Current token=')' value=')' Tokenstr |c(i(d,d)| translated: assert ( my_add ( 1 , 2 )
Lexem 8 Current token='>' value='==' Tokenstr |c(i(d,d)>| translated: assert ( my_add ( 1 , 2 ) ==
Lexem 9 Current token='d' value='3' Tokenstr |c(i(d,d)>d| translated: assert ( my_add ( 1 , 2 ) == 3
Lexem 10 Current token=')' value=')' Tokenstr |c(i(d,d)>d)| translated: assert ( my_add ( 1 , 2 ) == 3 )

Line:   95 TokenStr: =|c(i(d,d)>d)|= @ValPy: assert ( my_add ( 1 , 2 ) == 3 )
control(0) =|c(i(d,d)>d)|= assert ( my_add ( 1 , 2 ) == 3 )

control-parens removed, begin=0 start=1 =|ci(d,d)>d|= assert my_add ( 1 , 2 ) == 3

Generated partial line assert
expression(1, 8, 0) =|ci(d,d)>d|= assert my_add ( 1 , 2 ) == 3

Generated partial line assertmy_add
Generated partial line assertmy_add([
expression(3, 5, 0) =|ci(d,d)>d|= assert my_add ( 1 , 2 ) == 3

Generated partial line assertmy_add([1
Generated partial line assertmy_add([1,
Generated partial line assertmy_add([1,2
expression returns 6
Generated partial line assertmy_add([1,2])
Generated partial line assertmy_add([1,2])==
Generated partial line assertmy_add([1,2])==3
expression returns 9
  95 | 0 |   |assert my_add([1, 2])==3                                                                #PL: assert(my_add(1, 2) == 3);

Tokens: ci(d,d)>d ValPy: 
  96 | 0 |   |
Main loop, line=sub my_add {


 === Line 97 Perl source:sub my_add {===

Lexem 0 Current token='k' value='def' Tokenstr |k| translated: def
Lexem 1 Current token='i' value='my_add' Tokenstr |ki| translated: def my_add

Line:   97 TokenStr: =|ki|= @ValPy: def my_add
Generated partial line defmy_add(_args):
  97 | 0 |   |def my_add(_args):                                                                      #PL: sub my_add {

Tokens: ki ValPy: 
Main loop, line={


 === Line 97 Perl source:{===


Line:   97 TokenStr: =|{|= @ValPy: {
  98 | 1 |   |    # Add op1 to op2 giving result
Main loop, line=$op1 = shift;


 === Line 99 Perl source:$op1 = shift;===

Lexem 0 Current token='s' value='op1' Tokenstr |s| translated: op1
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: op1 =
Lexem 2 Current token='f' value='.pop(0)' Tokenstr |s=f| translated: op1 = .pop(0)

Line:   99 TokenStr: =|s=f|= @ValPy: op1 = .pop(0)
assignment(0, 2) =|s=f|= $op1 = shift

Generated partial line op1
Generated partial line op1=
assign, ValClass[limit] = f, ValPy=.pop(0), ValPerl=shift

function(2, 2) =|s=f|= $op1 = shift

function start=3, end_pos=2, bracketed=-1
Generated partial line op1=(_args.pop(0) if _args else None)
  99 | 1 |   |    op1 = (_args.pop(0) if _args else None)                                             #PL: $op1 = shift;

Tokens: s=f ValPy: 
Main loop, line=$op2 = shift;


 === Line 100 Perl source:$op2 = shift;===

Lexem 0 Current token='s' value='op2' Tokenstr |s| translated: op2
Lexem 1 Current token='=' value='=' Tokenstr |s=| translated: op2 =
Lexem 2 Current token='f' value='.pop(0)' Tokenstr |s=f| translated: op2 = .pop(0)

Line:  100 TokenStr: =|s=f|= @ValPy: op2 = .pop(0)
assignment(0, 2) =|s=f|= $op2 = shift

Generated partial line op2
Generated partial line op2=
assign, ValClass[limit] = f, ValPy=.pop(0), ValPerl=shift

function(2, 2) =|s=f|= $op2 = shift

function start=3, end_pos=2, bracketed=-1
Generated partial line op2=(_args.pop(0) if _args else None)
 100 | 1 |   |    op2 = (_args.pop(0) if _args else None)                                             #PL: $op2 = shift;

Tokens: s=f ValPy: 
Main loop, line=return if(!defined $op1);	# Make sure they gave both args


 === Line 101 Perl source:return if(!defined $op1);	# Make sure they gave both args===

Lexem 0 Current token='k' value='return' Tokenstr |k| translated: return
Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='!' value='not' Tokenstr |c(!| translated: if  ( not
Lexem 3 Current token='f' value='perl_defined' Tokenstr |c(!f| translated: if  ( not perl_defined
Lexem 4 Current token='s' value='op1' Tokenstr |c(!fs| translated: if  ( not perl_defined op1
Lexem 5 Current token=')' value=')' Tokenstr |c(!fs)| translated: if  ( not perl_defined op1 )

Line:  101 TokenStr: =|c(!fs)|= @ValPy: if  ( not perl_defined op1 )
control(0) =|c(!fs)|= if ( ! defined $op1 )

control-parens removed, begin=0 start=1 =|c!fs|= if ! defined $op1

Generated partial line if 
expression(1, 3, 0) =|c!fs|= if ! defined $op1

Generated partial line if not
function(2, 3) =|c!fs|= if ! defined $op1

function start=3, end_pos=3, bracketed=0
Generated partial line if notop1 is not None
expression returns 4
Generated partial line if notop1 is not None:
 101 | 1 |   |    if not op1 is not None:     # Make sure they gave both args
                                                                                                      #PL: return if(!defined $op1);

Tokens: c!fs ValPy: 
Main loop, line=return if(!defined $op1);	# Make sure they gave both args
Main loop, line=return if(!defined $op1);	# Make sure they gave both args
Generated partial line return
 101 | 2 |   |        return                                                                          #PL: return if(!defined $op1);	# Make sure they gave both args

Tokens: k ValPy: 
Main loop, line=return if(!defined $op1);	# Make sure they gave both args
Main loop, line=return if(!defined $op2);	# Make sure they gave both args


 === Line 102 Perl source:return if(!defined $op2);	# Make sure they gave both args===

Lexem 0 Current token='k' value='return' Tokenstr |k| translated: return
Lexem 0 Current token='c' value='if ' Tokenstr |c| translated: if 
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: if  (
Lexem 2 Current token='!' value='not' Tokenstr |c(!| translated: if  ( not
Lexem 3 Current token='f' value='perl_defined' Tokenstr |c(!f| translated: if  ( not perl_defined
Lexem 4 Current token='s' value='op2' Tokenstr |c(!fs| translated: if  ( not perl_defined op2
Lexem 5 Current token=')' value=')' Tokenstr |c(!fs)| translated: if  ( not perl_defined op2 )

Line:  102 TokenStr: =|c(!fs)|= @ValPy: if  ( not perl_defined op2 )
control(0) =|c(!fs)|= if ( ! defined $op2 )

control-parens removed, begin=0 start=1 =|c!fs|= if ! defined $op2

Generated partial line if 
expression(1, 3, 0) =|c!fs|= if ! defined $op2

Generated partial line if not
function(2, 3) =|c!fs|= if ! defined $op2

function start=3, end_pos=3, bracketed=0
Generated partial line if notop2 is not None
expression returns 4
Generated partial line if notop2 is not None:
 102 | 1 |   |    if not op2 is not None:     # Make sure they gave both args
                                                                                                      #PL: return if(!defined $op2);

Tokens: c!fs ValPy: 
Main loop, line=return if(!defined $op2);	# Make sure they gave both args
Main loop, line=return if(!defined $op2);	# Make sure they gave both args
Generated partial line return
 102 | 2 |   |        return                                                                          #PL: return if(!defined $op2);	# Make sure they gave both args

Tokens: k ValPy: 
Main loop, line=return if(!defined $op2);	# Make sure they gave both args
Main loop, line=$op1 + $op2;		# implicitly return the sum


 === Line 103 Perl source:$op1 + $op2;		# implicitly return the sum===

Lexem 0 Current token='s' value='op1' Tokenstr |s| translated: op1
Lexem 1 Current token='+' value='+' Tokenstr |s+| translated: op1 +
Lexem 2 Current token='s' value='op2' Tokenstr |s+s| translated: op1 + op2

Line:  103 TokenStr: =|s+s|= @ValPy: op1 + op2
assignment(0, 2) =|s+s|= $op1 + $op2

finish: prev_line=$op1 + $op2;		# implicitly return the sum, PythonCode=
finish: Resetting line to return $op1 + $op2;		# implicitly return the sum;
Main loop, line=return $op1 + $op2;		# implicitly return the sum;


 === Line 104 Perl source:return $op1 + $op2;		# implicitly return the sum;===

Lexem 0 Current token='k' value='return' Tokenstr |k| translated: return
Lexem 1 Current token='s' value='op1' Tokenstr |ks| translated: return op1
Lexem 2 Current token='+' value='+' Tokenstr |ks+| translated: return op1 +
Lexem 3 Current token='s' value='op2' Tokenstr |ks+s| translated: return op1 + op2

Line:  104 TokenStr: =|ks+s|= @ValPy: return op1 + op2
Generated partial line return
expression(1, 3, 0) =|ks+s|= return $op1 + $op2

Generated partial line returnop1
Generated partial line returnop1+
Generated partial line returnop1+op2
expression returns 4
 104 | 1 |   |    return op1+op2     # implicitly return the sum;
                                                                                                      #PL: 

Tokens: ks+s ValPy: 
Main loop, line=}


 === Line 104 Perl source:}===


Line:  104 TokenStr: =|}|= @ValPy: }
 105 | 0 |   |
Main loop, line=print substr($0,1)." - test passed!\n";


 === Line 106 Perl source:print substr($0,1)." - test passed!\n";===

Lexem 0 Current token='f' value='print' Tokenstr |f| translated: print
Lexem 1 Current token='f' value='' Tokenstr |ff| translated: print 
Lexem 2 Current token='(' value='(' Tokenstr |ff(| translated: print  (
Lexem 3 Current token='s' value='__file__' Tokenstr |ff(s| translated: print  ( __file__
Lexem 4 Current token=',' value=',' Tokenstr |ff(s,| translated: print  ( __file__ ,
Lexem 5 Current token='d' value='1' Tokenstr |ff(s,d| translated: print  ( __file__ , 1
Lexem 6 Current token=')' value=')' Tokenstr |ff(s,d)| translated: print  ( __file__ , 1 )
Lexem 7 Current token='.' value=' + ' Tokenstr |ff(s,d).| translated: print  ( __file__ , 1 )  + 
Lexem 8 Current token='"' value='' - test passed!\n'' Tokenstr |ff(s,d)."| translated: print  ( __file__ , 1 )  +  ' - test passed!\n'

Line:  106 TokenStr: =|ff(s,d)."|= @ValPy: print  ( __file__ , 1 )  +  ' - test passed!\n'
Generated partial line print(
print3(0) handle=, k=1, end_pos=8

expression(1, 8, 0) =|ff(s,d)."|= print substr ( 0 , 1 ) .  - test passed!\n

function(1, 8) =|ff(s,d)."|= print substr ( 0 , 1 ) .  - test passed!\n

function start=3, end_pos=5, bracketed=1
Generated partial line print(__file__
Generated partial line print(__file__[
expression(5, 5, 0) =|ff(s,d)."|= print substr ( 0 , 1 ) .  - test passed!\n

Generated partial line print(__file__[1
expression returns 6
Generated partial line print(__file__[1:]
Generated partial line print(__file__[1:] + 
Generated partial line print(__file__[1:] + ' - test passed!\n'
expression returns 9
Generated partial line print(__file__[1:] + ' - test passed!')
 106 | 0 |   |print(__file__[1:] + ' - test passed!')                                                 #PL: print substr($0,1)." - test passed!\n";

Tokens: ff(s,d)." ValPy: 
ERROR STATISTICS:  W: 1


 [Softpano-W317]:  Debug flag is set to 5


