 [Softpano-W317]:  Debug flag is set to 5


PYTHONIZER: Fuzzy translator of Python to Perl. Version 0.917 (mtime 211206_0308) Started at 21/12/06 03:16

Logs are at /tmp/Pythonizer/pythonizer.211206_0316.log. Type -h for help.
=============================================================================================================
Results of transcription are written to the file  issue_39.py
=========================================================================================================================

Lexem 0 Current token='c' value='NoTrans!' Tokenstr |c| translated: NoTrans!
Lexem 1 Current token='i' value='Carp.Assert' Tokenstr |ci| translated: NoTrans! Carp.Assert
Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='s' value='f' Tokenstr |ts| translated:  f
Lexem 2 Current token='=' value='=' Tokenstr |ts=| translated:  f =
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 3.
single_quoted_literal('line1, ', 1), opening_delim=, nest=0
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 4.
single_quoted_literal('line1
line2, ', 7), opening_delim=, nest=0
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 5.
single_quoted_literal('line1
line2
line3, ', 13), opening_delim=, nest=0
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 6.
single_quoted_literal('line1
line2
line3
';, ', 19), opening_delim=, nest=0
Lexem 3 Current token='"' value=''''line1
line2
line3
'''' Tokenstr |ts="| translated:  f = '''line1
line2
line3
'''
check_ref(main, f) at 1
expr_type(3, 3, main)
merge_types(f, main, S)
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='f' Tokenstr |c(s| translated: assert ( f
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( f ==
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 7.
single_quoted_literal("line1\nline2\nline3\n");, ", 1), opening_delim=, nest=0
Lexem 4 Current token='"' value=''line1\nline2\nline3\n'' Tokenstr |c(s>"| translated: assert ( f == 'line1\nline2\nline3\n'
Lexem 5 Current token=')' value=')' Tokenstr |c(s>")| translated: assert ( f == 'line1\nline2\nline3\n' )
check_ref(main, f) at 2
Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='s' value='g' Tokenstr |ts| translated:  g
Lexem 2 Current token='=' value='=' Tokenstr |ts=| translated:  g =
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 10.
single_quoted_literal("line1, ", 1), opening_delim=, nest=0
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 11.
single_quoted_literal("line1
$f, ", 7), opening_delim=, nest=0
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 12.
single_quoted_literal("line1
$f
line3, ", 10), opening_delim=, nest=0
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 13.
single_quoted_literal("line1
$f
line3
";, ", 16), opening_delim=, nest=0
Lexem 3 Current token='"' value='f"""""line1
{f}
line3
"""""' Tokenstr |ts="| translated:  g = f"""""line1
{f}
line3
"""""
check_ref(main, g) at 1
expr_type(3, 3, main)
merge_types(g, main, S)
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='g' Tokenstr |c(s| translated: assert ( g
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( g ==
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 14.
single_quoted_literal("line1\nline1\nline2\nline3\n\nline3\n");, ", 1), opening_delim=, nest=0
Lexem 4 Current token='"' value=''line1\nline1\nline2\nline3\n\nline3\n'' Tokenstr |c(s>"| translated: assert ( g == 'line1\nline1\nline2\nline3\n\nline3\n'
Lexem 5 Current token=')' value=')' Tokenstr |c(s>")| translated: assert ( g == 'line1\nline1\nline2\nline3\n\nline3\n' )
check_ref(main, g) at 2
Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='s' value='h' Tokenstr |ts| translated:  h
Lexem 2 Current token='=' value='=' Tokenstr |ts=| translated:  h =
Lexem 3 Current token='H' value='<<' Tokenstr |ts=H| translated:  h = <<
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 19.
single_quoted_literal('END_TXT';, ', 1), opening_delim=, nest=0
get_here(END_TXT, ): line=line1, lno=20
get_here:line=line2, lno=21, len_eof=7, length(line)=5, spaces=0, defined line=1
get_here:line=line3, lno=22, len_eof=7, length(line)=5, spaces=0, defined line=1
get_here:line=END_TXT, lno=23, len_eof=7, length(line)=7, spaces=0, defined line=1
get_here:here_str=line1
line2
line3

Lexem 3 Current token='"' value='"""line1
line2
line3
"""' Tokenstr |ts="| translated:  h = """line1
line2
line3
"""
check_ref(main, h) at 1
expr_type(3, 3, main)
merge_types(h, main, S)
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='h' Tokenstr |c(s| translated: assert ( h
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( h ==
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 24.
single_quoted_literal("line1\nline2\nline3\n");, ", 1), opening_delim=, nest=0
Lexem 4 Current token='"' value=''line1\nline2\nline3\n'' Tokenstr |c(s>"| translated: assert ( h == 'line1\nline2\nline3\n'
Lexem 5 Current token=')' value=')' Tokenstr |c(s>")| translated: assert ( h == 'line1\nline2\nline3\n' )
check_ref(main, h) at 2
Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='s' value='i' Tokenstr |ts| translated:  i
Lexem 2 Current token='=' value='=' Tokenstr |ts=| translated:  i =
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 29.
single_quoted_literal(q/line1, /, 2), opening_delim=, nest=0
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 30.
single_quoted_literal(q/line1
line2, /, 8), opening_delim=, nest=0
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 31.
single_quoted_literal(q/line1
line2
line3, /, 14), opening_delim=, nest=0
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 32.
single_quoted_literal(q/line1
line2
line3
/;, /, 20), opening_delim=, nest=0
Lexem 3 Current token='"' value='"""line1
line2
line3
"""' Tokenstr |ts="| translated:  i = """line1
line2
line3
"""
check_ref(main, i) at 1
expr_type(3, 3, main)
merge_types(i, main, S)
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='i' Tokenstr |c(s| translated: assert ( i
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( i ==
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 33.
single_quoted_literal("line1\nline2\nline3\n");, ", 1), opening_delim=, nest=0
Lexem 4 Current token='"' value=''line1\nline2\nline3\n'' Tokenstr |c(s>"| translated: assert ( i == 'line1\nline2\nline3\n'
Lexem 5 Current token=')' value=')' Tokenstr |c(s>")| translated: assert ( i == 'line1\nline2\nline3\n' )
check_ref(main, i) at 2
Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='s' value='i' Tokenstr |ts| translated:  i
Lexem 2 Current token='=' value='=' Tokenstr |ts=| translated:  i =
single_quoted_literal(qq{line1, }, 3), opening_delim={, nest=0
single_quoted_literal(qq{line1
$f, }, 9), opening_delim={, nest=0
single_quoted_literal(qq{line1
$f
line3, }, 12), opening_delim={, nest=0
single_quoted_literal(qq{line1
$f
line3
};, }, 18), opening_delim={, nest=0
Lexem 3 Current token='"' value='f"""""line1
{f}
line3
"""""' Tokenstr |ts="| translated:  i = f"""""line1
{f}
line3
"""""
check_ref(main, i) at 1
expr_type(3, 3, main)
merge_types(i, main, S)
merge_types: otype=S
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='i' Tokenstr |c(s| translated: assert ( i
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( i ==
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 40.
single_quoted_literal("line1\nline1\nline2\nline3\n\nline3\n");, ", 1), opening_delim=, nest=0
Lexem 4 Current token='"' value=''line1\nline1\nline2\nline3\n\nline3\n'' Tokenstr |c(s>"| translated: assert ( i == 'line1\nline1\nline2\nline3\n\nline3\n'
Lexem 5 Current token=')' value=')' Tokenstr |c(s>")| translated: assert ( i == 'line1\nline1\nline2\nline3\n\nline3\n' )
check_ref(main, i) at 2
Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='s' value='j' Tokenstr |ts| translated:  j
Lexem 2 Current token='=' value='=' Tokenstr |ts=| translated:  j =
Lexem 3 Current token='H' value='<<' Tokenstr |ts=H| translated:  j = <<
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 43.
single_quoted_literal("END_TXT";, ", 1), opening_delim=, nest=0
get_here(END_TXT, ): line=line1, lno=44
get_here:line=$f, lno=45, len_eof=7, length(line)=2, spaces=0, defined line=1
get_here:line=line3, lno=46, len_eof=7, length(line)=5, spaces=0, defined line=1
get_here:line=END_TXT, lno=47, len_eof=7, length(line)=7, spaces=0, defined line=1
get_here:here_str=line1
$f
line3

Lexem 3 Current token='"' value='"""line1
$f
line3
"""' Tokenstr |ts="| translated:  j = """line1
$f
line3
"""
check_ref(main, j) at 1
expr_type(3, 3, main)
merge_types(j, main, S)
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='j' Tokenstr |c(s| translated: assert ( j
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( j ==
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 48.
single_quoted_literal("line1\nline1\nline2\nline3\n\nline3\n");, ", 1), opening_delim=, nest=0
Lexem 4 Current token='"' value=''line1\nline1\nline2\nline3\n\nline3\n'' Tokenstr |c(s>"| translated: assert ( j == 'line1\nline1\nline2\nline3\n\nline3\n'
Lexem 5 Current token=')' value=')' Tokenstr |c(s>")| translated: assert ( j == 'line1\nline1\nline2\nline3\n\nline3\n' )
check_ref(main, j) at 2
Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='s' value='j' Tokenstr |ts| translated:  j
Lexem 2 Current token='=' value='=' Tokenstr |ts=| translated:  j =
Lexem 3 Current token='H' value='<<' Tokenstr |ts=H| translated:  j = <<
get_here(END_TXT, ): line=line1, lno=52
get_here:line=$f, lno=53, len_eof=7, length(line)=2, spaces=0, defined line=1
get_here:line=line3, lno=54, len_eof=7, length(line)=5, spaces=0, defined line=1
get_here:line=END_TXT, lno=55, len_eof=7, length(line)=7, spaces=0, defined line=1
get_here:here_str=line1
$f
line3

Lexem 3 Current token='"' value='"""line1
$f
line3
"""' Tokenstr |ts="| translated:  j = """line1
$f
line3
"""
check_ref(main, j) at 1
expr_type(3, 3, main)
merge_types(j, main, S)
merge_types: otype=S
Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='j' Tokenstr |c(s| translated: assert ( j
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( j ==
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 56.
single_quoted_literal("line1\nline1\nline2\nline3\n\nline3\n");, ", 1), opening_delim=, nest=0
Lexem 4 Current token='"' value=''line1\nline1\nline2\nline3\n\nline3\n'' Tokenstr |c(s>"| translated: assert ( j == 'line1\nline1\nline2\nline3\n\nline3\n'
Lexem 5 Current token=')' value=')' Tokenstr |c(s>")| translated: assert ( j == 'line1\nline1\nline2\nline3\n\nline3\n' )
check_ref(main, j) at 2
Lexem 0 Current token='f' value='print' Tokenstr |f| translated: print
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 62.
single_quoted_literal("$0: Test passed\n";, ", 1), opening_delim=, nest=0
Lexem 1 Current token='"' value='f"{__file__}: Test passed\n"' Tokenstr |f"| translated: print f"{__file__}: Test passed\n"
VarSubMap = $VAR1 = {
  'TRACEBACK' => {
    'main' => '+'
  },
  '_OPEN_MODE_MAP' => {
    'main' => '+'
  },
  'AUTODIE' => {
    'main' => '+'
  },
  '_script_start' => {
    'main' => '+'
  },
  '_DUP_MAP' => {
    'main' => '+'
  },
  'LIST_SEPARATOR' => {
    'main' => '+'
  },
  'OS_ERROR' => {
    'main' => '+'
  }
};

VarType = $VAR1 = {
  '_script_start' => {
    'main' => 'I'
  },
  'h' => {
    'main' => 'S'
  },
  'LIST_SEPARATOR' => {
    'main' => 'S'
  },
  'sys.argv' => {
    'main' => 'a of S'
  },
  'f' => {
    'main' => 'S'
  },
  'os.environ' => {
    'main' => 'h of S'
  },
  'OS_ERROR' => {
    'main' => 'S'
  },
  'os.name' => {
    'main' => 'S'
  },
  'j' => {
    'main' => 'S'
  },
  'EVAL_ERROR' => {
    'main' => 'S'
  },
  'g' => {
    'main' => 'S'
  },
  'i' => {
    'main' => 'S'
  }
};

initialized = $VAR1 = {
  'main' => {
    'OS_ERROR' => 'S',
    'os.name' => 'S',
    'j' => 'S',
    'EVAL_ERROR' => 'S',
    'g' => 'S',
    'i' => 'S',
    'sys.argv' => 'a of S',
    'f' => 'S',
    'os.environ' => 'h of S',
    'h' => 'S',
    'LIST_SEPARATOR' => 'S',
    '_script_start' => 'I'
  }
};

NeedsInitializing = $VAR1 = {};


DETECTED GLOBAL VARIABLES:

AUTO-INITIALIZED VARIABLES:

List of local subroutines:
main
mkdir: cannot create directory ‘/c/Users/Joe’: File exists
cp: target 'Orost/Archive/pythonizer' is not a directory
cp: target 'Orost/Archive/Softpano.pm' is not a directory
cp: target 'Orost/Archive/Perlscan.pm' is not a directory
cp: target 'Orost/Archive/Pythonizer.pm' is not a directory
   1 | 0 |   |#!/usr/bin/python3 -u
   1 | 0 |   |# Generated by pythonizer 0.917 run by Joe Orost on Mon Dec  6 03:16:33 2021
   1 | 0 |   |import sys,os,re,fcntl,math,fileinput,subprocess,inspect,collections.abc,argparse,glob,warnings,inspect,functools,signal,traceback,io,tempfile,atexit
   1 | 0 |   |import time as tm_py
   1 | 0 |   |TRACEBACK = 0
   1 | 0 |   |_script_start = tm_py.time()
   1 | 0 |   |_DUP_MAP = dict(STDIN=0, STDOUT=1, STDERR=2)
   1 | 0 |   |_OPEN_MODE_MAP = {'<': 'r', '>': 'w', '+<': 'r+', '+>': 'w+', '>>': 'a', '+>>': 'a+'}
   1 | 0 |   |AUTODIE = 0
   1 | 0 |   |LIST_SEPARATOR = ' '
   1 | 0 |   |OS_ERROR = ''
   1 | 0 |   |class Die(Exception):
    pass
   1 | 0 |   |class EvalReturn(Exception):
    pass
   1 | 0 |   |_args = sys.argv[1:]
Main loop, line=use Carp::Assert;


 === Line 1 Perl source:use Carp::Assert;===

Lexem 0 Current token='c' value='NoTrans!' Tokenstr |c| translated: NoTrans!
Lexem 1 Current token='i' value='Carp.Assert' Tokenstr |ci| translated: NoTrans! Carp.Assert

Line:    1 TokenStr: =|ci|= @ValPy: NoTrans! Carp.Assert
   1 | 0 |   |#SKIPPED: use Carp::Assert;
   2 | 0 |   |# Non-interpolative
Main loop, line=my $f = 'line1


 === Line 3 Perl source:my $f = 'line1===

Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='s' value='f' Tokenstr |ts| translated:  f
Lexem 2 Current token='=' value='=' Tokenstr |ts=| translated:  f =
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 3.
single_quoted_literal('line1, ', 1), opening_delim=, nest=0
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 4.
single_quoted_literal('line1
line2, ', 7), opening_delim=, nest=0
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 5.
single_quoted_literal('line1
line2
line3, ', 13), opening_delim=, nest=0
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 6.
single_quoted_literal('line1
line2
line3
';, ', 19), opening_delim=, nest=0
Lexem 3 Current token='"' value=''''line1
line2
line3
'''' Tokenstr |ts="| translated:  f = '''line1
line2
line3
'''

Line:    6 TokenStr: =|ts="|= @ValPy:  f = '''line1
line2
line3
'''
   6 | 0 |   |f='''line1
line2
line3
'''                                                              #PL: ';
Main loop, line=assert($f eq "line1\nline2\nline3\n");


 === Line 7 Perl source:assert($f eq "line1\nline2\nline3\n");===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='f' Tokenstr |c(s| translated: assert ( f
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( f ==
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 7.
single_quoted_literal("line1\nline2\nline3\n");, ", 1), opening_delim=, nest=0
Lexem 4 Current token='"' value=''line1\nline2\nline3\n'' Tokenstr |c(s>"| translated: assert ( f == 'line1\nline2\nline3\n'
Lexem 5 Current token=')' value=')' Tokenstr |c(s>")| translated: assert ( f == 'line1\nline2\nline3\n' )

Line:    7 TokenStr: =|c(s>")|= @ValPy: assert ( f == 'line1\nline2\nline3\n' )
control(0) =|c(s>")|= assert ( $f eq line1\nline2\nline3\n )

control-parens removed, begin=0 start=1 =|cs>"|= assert $f eq line1\nline2\nline3\n

Generated partial line assert
expression(1, 3, 0) =|cs>"|= assert $f eq line1\nline2\nline3\n

Generated partial line assertf
Generated partial line assertf==
Generated partial line assertf=='line1\nline2\nline3\n'
expression returns 4
   7 | 0 |   |assert f=='line1\nline2\nline3\n'                                                       #PL: assert($f eq "line1\nline2\nline3\n");

Tokens: cs>" ValPy: 
   8 | 0 |   |
   9 | 0 |   |# Interpolative
Main loop, line=my $g = "line1


 === Line 10 Perl source:my $g = "line1===

Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='s' value='g' Tokenstr |ts| translated:  g
Lexem 2 Current token='=' value='=' Tokenstr |ts=| translated:  g =
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 10.
single_quoted_literal("line1, ", 1), opening_delim=, nest=0
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 11.
single_quoted_literal("line1
$f, ", 7), opening_delim=, nest=0
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 12.
single_quoted_literal("line1
$f
line3, ", 10), opening_delim=, nest=0
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 13.
single_quoted_literal("line1
$f
line3
";, ", 16), opening_delim=, nest=0
Lexem 3 Current token='"' value='f"""""line1
{f}
line3
"""""' Tokenstr |ts="| translated:  g = f"""""line1
{f}
line3
"""""

Line:   13 TokenStr: =|ts="|= @ValPy:  g = f"""""line1
{f}
line3
"""""
  13 | 0 |   |g=f"""""line1
{f}
line3
"""""                                                           #PL: ";
Main loop, line=assert($g eq "line1\nline1\nline2\nline3\n\nline3\n");


 === Line 14 Perl source:assert($g eq "line1\nline1\nline2\nline3\n\nline3\n");===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='g' Tokenstr |c(s| translated: assert ( g
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( g ==
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 14.
single_quoted_literal("line1\nline1\nline2\nline3\n\nline3\n");, ", 1), opening_delim=, nest=0
Lexem 4 Current token='"' value=''line1\nline1\nline2\nline3\n\nline3\n'' Tokenstr |c(s>"| translated: assert ( g == 'line1\nline1\nline2\nline3\n\nline3\n'
Lexem 5 Current token=')' value=')' Tokenstr |c(s>")| translated: assert ( g == 'line1\nline1\nline2\nline3\n\nline3\n' )

Line:   14 TokenStr: =|c(s>")|= @ValPy: assert ( g == 'line1\nline1\nline2\nline3\n\nline3\n' )
control(0) =|c(s>")|= assert ( $g eq line1\nline1\nline2\nline3\n\nline3\n )

control-parens removed, begin=0 start=1 =|cs>"|= assert $g eq line1\nline1\nline2\nline3\n\nline3\n

Generated partial line assert
expression(1, 3, 0) =|cs>"|= assert $g eq line1\nline1\nline2\nline3\n\nline3\n

Generated partial line assertg
Generated partial line assertg==
Generated partial line assertg=='line1\nline1\nline2\nline3\n\nline3\n'
expression returns 4
  14 | 0 |   |assert g=='line1\nline1\nline2\nline3\n\nline3\n'                                       #PL: assert($g eq "line1\nline1\nline2\nline3\n\nline3\n");

Tokens: cs>" ValPy: 
  15 | 0 |   |
  16 | 0 |   |#Here-docs allow you to define any token as the end of a block of quoted text:
  17 | 0 |   |
  18 | 0 |   |# Non-interpolative
Main loop, line=my $h = <<'END_TXT';


 === Line 19 Perl source:my $h = <<'END_TXT';===

Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='s' value='h' Tokenstr |ts| translated:  h
Lexem 2 Current token='=' value='=' Tokenstr |ts=| translated:  h =
Lexem 3 Current token='H' value='<<' Tokenstr |ts=H| translated:  h = <<
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 19.
single_quoted_literal('END_TXT';, ', 1), opening_delim=, nest=0
get_here(END_TXT, ): line=line1, lno=20
get_here:line=line2, lno=21, len_eof=7, length(line)=5, spaces=0, defined line=1
get_here:line=line3, lno=22, len_eof=7, length(line)=5, spaces=0, defined line=1
get_here:line=END_TXT, lno=23, len_eof=7, length(line)=7, spaces=0, defined line=1
get_here:here_str=line1
line2
line3

Lexem 3 Current token='"' value='"""line1
line2
line3
"""' Tokenstr |ts="| translated:  h = """line1
line2
line3
"""

Line:   23 TokenStr: =|ts="|= @ValPy:  h = """line1
line2
line3
"""
  23 | 0 |   |h="""line1
line2
line3
"""                                                              #PL: my $h = <<'END_TXT';
Main loop, line=assert($h eq "line1\nline2\nline3\n");


 === Line 24 Perl source:assert($h eq "line1\nline2\nline3\n");===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='h' Tokenstr |c(s| translated: assert ( h
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( h ==
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 24.
single_quoted_literal("line1\nline2\nline3\n");, ", 1), opening_delim=, nest=0
Lexem 4 Current token='"' value=''line1\nline2\nline3\n'' Tokenstr |c(s>"| translated: assert ( h == 'line1\nline2\nline3\n'
Lexem 5 Current token=')' value=')' Tokenstr |c(s>")| translated: assert ( h == 'line1\nline2\nline3\n' )

Line:   24 TokenStr: =|c(s>")|= @ValPy: assert ( h == 'line1\nline2\nline3\n' )
control(0) =|c(s>")|= assert ( $h eq line1\nline2\nline3\n )

control-parens removed, begin=0 start=1 =|cs>"|= assert $h eq line1\nline2\nline3\n

Generated partial line assert
expression(1, 3, 0) =|cs>"|= assert $h eq line1\nline2\nline3\n

Generated partial line asserth
Generated partial line asserth==
Generated partial line asserth=='line1\nline2\nline3\n'
expression returns 4
  24 | 0 |   |assert h=='line1\nline2\nline3\n'                                                       #PL: assert($h eq "line1\nline2\nline3\n");

Tokens: cs>" ValPy: 
  25 | 0 |   |
  26 | 0 |   |#Regex style quote operators let you use pretty much any character as the delimiter--in the same way a regex allows you to change delimiters.
  27 | 0 |   |
  28 | 0 |   |# Non-interpolative
Main loop, line=my $i = q/line1


 === Line 29 Perl source:my $i = q/line1===

Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='s' value='i' Tokenstr |ts| translated:  i
Lexem 2 Current token='=' value='=' Tokenstr |ts=| translated:  i =
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 29.
single_quoted_literal(q/line1, /, 2), opening_delim=, nest=0
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 30.
single_quoted_literal(q/line1
line2, /, 8), opening_delim=, nest=0
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 31.
single_quoted_literal(q/line1
line2
line3, /, 14), opening_delim=, nest=0
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 32.
single_quoted_literal(q/line1
line2
line3
/;, /, 20), opening_delim=, nest=0
Lexem 3 Current token='"' value='"""line1
line2
line3
"""' Tokenstr |ts="| translated:  i = """line1
line2
line3
"""

Line:   32 TokenStr: =|ts="|= @ValPy:  i = """line1
line2
line3
"""
  32 | 0 |   |i="""line1
line2
line3
"""                                                              #PL: /;
Main loop, line=assert($i eq "line1\nline2\nline3\n");


 === Line 33 Perl source:assert($i eq "line1\nline2\nline3\n");===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='i' Tokenstr |c(s| translated: assert ( i
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( i ==
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 33.
single_quoted_literal("line1\nline2\nline3\n");, ", 1), opening_delim=, nest=0
Lexem 4 Current token='"' value=''line1\nline2\nline3\n'' Tokenstr |c(s>"| translated: assert ( i == 'line1\nline2\nline3\n'
Lexem 5 Current token=')' value=')' Tokenstr |c(s>")| translated: assert ( i == 'line1\nline2\nline3\n' )

Line:   33 TokenStr: =|c(s>")|= @ValPy: assert ( i == 'line1\nline2\nline3\n' )
control(0) =|c(s>")|= assert ( $i eq line1\nline2\nline3\n )

control-parens removed, begin=0 start=1 =|cs>"|= assert $i eq line1\nline2\nline3\n

Generated partial line assert
expression(1, 3, 0) =|cs>"|= assert $i eq line1\nline2\nline3\n

Generated partial line asserti
Generated partial line asserti==
Generated partial line asserti=='line1\nline2\nline3\n'
expression returns 4
  33 | 0 |   |assert i=='line1\nline2\nline3\n'                                                       #PL: assert($i eq "line1\nline2\nline3\n");

Tokens: cs>" ValPy: 
  34 | 0 |   |
  35 | 0 |   |# Interpolative
Main loop, line=my $i = qq{line1


 === Line 36 Perl source:my $i = qq{line1===

Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='s' value='i' Tokenstr |ts| translated:  i
Lexem 2 Current token='=' value='=' Tokenstr |ts=| translated:  i =
single_quoted_literal(qq{line1, }, 3), opening_delim={, nest=0
single_quoted_literal(qq{line1
$f, }, 9), opening_delim={, nest=0
single_quoted_literal(qq{line1
$f
line3, }, 12), opening_delim={, nest=0
single_quoted_literal(qq{line1
$f
line3
};, }, 18), opening_delim={, nest=0
Lexem 3 Current token='"' value='f"""""line1
{f}
line3
"""""' Tokenstr |ts="| translated:  i = f"""""line1
{f}
line3
"""""

Line:   39 TokenStr: =|ts="|= @ValPy:  i = f"""""line1
{f}
line3
"""""
  39 | 0 |   |i=f"""""line1
{f}
line3
"""""                                                           #PL: };
Main loop, line=assert($i eq "line1\nline1\nline2\nline3\n\nline3\n");


 === Line 40 Perl source:assert($i eq "line1\nline1\nline2\nline3\n\nline3\n");===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='i' Tokenstr |c(s| translated: assert ( i
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( i ==
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 40.
single_quoted_literal("line1\nline1\nline2\nline3\n\nline3\n");, ", 1), opening_delim=, nest=0
Lexem 4 Current token='"' value=''line1\nline1\nline2\nline3\n\nline3\n'' Tokenstr |c(s>"| translated: assert ( i == 'line1\nline1\nline2\nline3\n\nline3\n'
Lexem 5 Current token=')' value=')' Tokenstr |c(s>")| translated: assert ( i == 'line1\nline1\nline2\nline3\n\nline3\n' )

Line:   40 TokenStr: =|c(s>")|= @ValPy: assert ( i == 'line1\nline1\nline2\nline3\n\nline3\n' )
control(0) =|c(s>")|= assert ( $i eq line1\nline1\nline2\nline3\n\nline3\n )

control-parens removed, begin=0 start=1 =|cs>"|= assert $i eq line1\nline1\nline2\nline3\n\nline3\n

Generated partial line assert
expression(1, 3, 0) =|cs>"|= assert $i eq line1\nline1\nline2\nline3\n\nline3\n

Generated partial line asserti
Generated partial line asserti==
Generated partial line asserti=='line1\nline1\nline2\nline3\n\nline3\n'
expression returns 4
  40 | 0 |   |assert i=='line1\nline1\nline2\nline3\n\nline3\n'                                       #PL: assert($i eq "line1\nline1\nline2\nline3\n\nline3\n");

Tokens: cs>" ValPy: 
  41 | 0 |   |
  42 | 0 |   |# Interpolative (Not yet implemented!)
Main loop, line=my $j = <<"END_TXT";


 === Line 43 Perl source:my $j = <<"END_TXT";===

Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='s' value='j' Tokenstr |ts| translated:  j
Lexem 2 Current token='=' value='=' Tokenstr |ts=| translated:  j =
Lexem 3 Current token='H' value='<<' Tokenstr |ts=H| translated:  j = <<
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 43.
single_quoted_literal("END_TXT";, ", 1), opening_delim=, nest=0
get_here(END_TXT, ): line=line1, lno=44
get_here:line=$f, lno=45, len_eof=7, length(line)=2, spaces=0, defined line=1
get_here:line=line3, lno=46, len_eof=7, length(line)=5, spaces=0, defined line=1
get_here:line=END_TXT, lno=47, len_eof=7, length(line)=7, spaces=0, defined line=1
get_here:here_str=line1
$f
line3

Lexem 3 Current token='"' value='"""line1
$f
line3
"""' Tokenstr |ts="| translated:  j = """line1
$f
line3
"""

Line:   47 TokenStr: =|ts="|= @ValPy:  j = """line1
$f
line3
"""
  47 | 0 |   |j="""line1
$f
line3
"""                                                                 #PL: my $j = <<"END_TXT";
Main loop, line=assert($j eq "line1\nline1\nline2\nline3\n\nline3\n");


 === Line 48 Perl source:assert($j eq "line1\nline1\nline2\nline3\n\nline3\n");===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='j' Tokenstr |c(s| translated: assert ( j
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( j ==
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 48.
single_quoted_literal("line1\nline1\nline2\nline3\n\nline3\n");, ", 1), opening_delim=, nest=0
Lexem 4 Current token='"' value=''line1\nline1\nline2\nline3\n\nline3\n'' Tokenstr |c(s>"| translated: assert ( j == 'line1\nline1\nline2\nline3\n\nline3\n'
Lexem 5 Current token=')' value=')' Tokenstr |c(s>")| translated: assert ( j == 'line1\nline1\nline2\nline3\n\nline3\n' )

Line:   48 TokenStr: =|c(s>")|= @ValPy: assert ( j == 'line1\nline1\nline2\nline3\n\nline3\n' )
control(0) =|c(s>")|= assert ( $j eq line1\nline1\nline2\nline3\n\nline3\n )

control-parens removed, begin=0 start=1 =|cs>"|= assert $j eq line1\nline1\nline2\nline3\n\nline3\n

Generated partial line assert
expression(1, 3, 0) =|cs>"|= assert $j eq line1\nline1\nline2\nline3\n\nline3\n

Generated partial line assertj
Generated partial line assertj==
Generated partial line assertj=='line1\nline1\nline2\nline3\n\nline3\n'
expression returns 4
  48 | 0 |   |assert j=='line1\nline1\nline2\nline3\n\nline3\n'                                       #PL: assert($j eq "line1\nline1\nline2\nline3\n\nline3\n");

Tokens: cs>" ValPy: 
  49 | 0 |   |
  50 | 0 |   |# Old style interpolative (Not yet implemented!)
Main loop, line=my $j = <<END_TXT;


 === Line 51 Perl source:my $j = <<END_TXT;===

Lexem 0 Current token='t' value='' Tokenstr |t| translated: 
Lexem 1 Current token='s' value='j' Tokenstr |ts| translated:  j
Lexem 2 Current token='=' value='=' Tokenstr |ts=| translated:  j =
Lexem 3 Current token='H' value='<<' Tokenstr |ts=H| translated:  j = <<
get_here(END_TXT, ): line=line1, lno=52
get_here:line=$f, lno=53, len_eof=7, length(line)=2, spaces=0, defined line=1
get_here:line=line3, lno=54, len_eof=7, length(line)=5, spaces=0, defined line=1
get_here:line=END_TXT, lno=55, len_eof=7, length(line)=7, spaces=0, defined line=1
get_here:here_str=line1
$f
line3

Lexem 3 Current token='"' value='"""line1
$f
line3
"""' Tokenstr |ts="| translated:  j = """line1
$f
line3
"""

Line:   55 TokenStr: =|ts="|= @ValPy:  j = """line1
$f
line3
"""
  55 | 0 |   |j="""line1
$f
line3
"""                                                                 #PL: my $j = <<END_TXT;
Main loop, line=assert($j eq "line1\nline1\nline2\nline3\n\nline3\n");


 === Line 56 Perl source:assert($j eq "line1\nline1\nline2\nline3\n\nline3\n");===

Lexem 0 Current token='c' value='assert' Tokenstr |c| translated: assert
Lexem 1 Current token='(' value='(' Tokenstr |c(| translated: assert (
Lexem 2 Current token='s' value='j' Tokenstr |c(s| translated: assert ( j
Lexem 3 Current token='>' value='==' Tokenstr |c(s>| translated: assert ( j ==
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 56.
single_quoted_literal("line1\nline1\nline2\nline3\n\nline3\n");, ", 1), opening_delim=, nest=0
Lexem 4 Current token='"' value=''line1\nline1\nline2\nline3\n\nline3\n'' Tokenstr |c(s>"| translated: assert ( j == 'line1\nline1\nline2\nline3\n\nline3\n'
Lexem 5 Current token=')' value=')' Tokenstr |c(s>")| translated: assert ( j == 'line1\nline1\nline2\nline3\n\nline3\n' )

Line:   56 TokenStr: =|c(s>")|= @ValPy: assert ( j == 'line1\nline1\nline2\nline3\n\nline3\n' )
control(0) =|c(s>")|= assert ( $j eq line1\nline1\nline2\nline3\n\nline3\n )

control-parens removed, begin=0 start=1 =|cs>"|= assert $j eq line1\nline1\nline2\nline3\n\nline3\n

Generated partial line assert
expression(1, 3, 0) =|cs>"|= assert $j eq line1\nline1\nline2\nline3\n\nline3\n

Generated partial line assertj
Generated partial line assertj==
Generated partial line assertj=='line1\nline1\nline2\nline3\n\nline3\n'
expression returns 4
  56 | 0 |   |assert j=='line1\nline1\nline2\nline3\n\nline3\n'                                       #PL: assert($j eq "line1\nline1\nline2\nline3\n\nline3\n");

Tokens: cs>" ValPy: 
  57 | 0 |   |
  58 | 0 |   |#use constant END_T => 4;
  59 | 0 |   |#my $s = 1<<END_T;
  60 | 0 |   |#assert($s == (1<<4));
  61 | 0 |   |
Main loop, line=print "$0: Test passed\n";


 === Line 62 Perl source:print "$0: Test passed\n";===

Lexem 0 Current token='f' value='print' Tokenstr |f| translated: print
Use of uninitialized value $Perlscan::opening_delim in concatenation (.) or string at /d/pythonizer/pythonizer/Perlscan.pm line 1406, <> line 62.
single_quoted_literal("$0: Test passed\n";, ", 1), opening_delim=, nest=0
Lexem 1 Current token='"' value='f"{__file__}: Test passed\n"' Tokenstr |f"| translated: print f"{__file__}: Test passed\n"

Line:   62 TokenStr: =|f"|= @ValPy: print f"{__file__}: Test passed\n"
Generated partial line print(
print3(0) handle=, k=1, end_pos=1

expression(1, 1, 0) =|f"|= print $0: Test passed\n

Generated partial line print(f"{__file__}: Test passed\n"
expression returns 2
Generated partial line print(f"{__file__}: Test passed")
  62 | 0 |   |print(f"{__file__}: Test passed")                                                       #PL: print "$0: Test passed\n";

Tokens: f" ValPy: 
initialize_globals_for_state_vars: 
ERROR STATISTICS:  W: 1


 [Softpano-W317]:  Debug flag is set to 5


